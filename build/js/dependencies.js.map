{"version":3,"file":"js/dependencies.js","mappings":";;;;;;;;;AAAA,+BAA+B,cAAc,+BAA+B,+DAA+D,wCAAwC,MAAM,oCAAoC,yCAAyC,qFAAqF,KAAK,gCAAgC,2HAA2H,KAAK,wBAAwB,WAAW,uEAAuE,QAAQ,aAAa,qCAAqC,sDAAsD,2CAA2C,uBAAuB,UAAU,OAAO,KAAK,4CAA4C,yBAAyB,MAAM,wBAAwB,WAAW,uFAAuF,QAAQ,iBAAiB,wSAAwS,qEAAqE,mEAAmE,UAAU,+EAA+E,6EAA6E,UAAU,4EAA4E,0EAA0E,UAAU,OAAO,KAAK,gCAAgC,mCAAmC,uDAAuD,KAAK,sCAAsC,uDAAuD,MAAM,mCAAmC,yCAAyC,qCAAqC,qEAAqE,gBAAgB,gBAAgB,SAAS,yEAAyE,QAAQ,MAAM,yFAAyF,gBAAgB,gBAAgB,SAAS,6FAA6F,OAAO,eAAe,MAAM,mCAAmC,yCAAyC,qCAAqC,qEAAqE,gBAAgB,gBAAgB,SAAS,yEAAyE,QAAQ,MAAM,yFAAyF,gBAAgB,gBAAgB,SAAS,6FAA6F,OAAO,eAAe,MAAM,sCAAsC,4CAA4C,qCAAqC,qEAAqE,oBAAoB,gBAAgB,SAAS,2DAA2D,6BAA6B,6BAA6B,SAAS,QAAQ,MAAM,yFAAyF,oBAAoB,gBAAgB,SAAS,+EAA+E,6BAA6B,6BAA6B,SAAS,OAAO,sBAAsB,MAAM,6BAA6B,mCAAmC,KAAK,8BAA8B,yBAAyB,KAAK,mCAAmC,6CAA6C,qCAAqC,oEAAoE,QAAQ,MAAM,wFAAwF,OAAO,eAAe,MAAM,oCAAoC,oDAAoD,qCAAqC,iFAAiF,SAAS,QAAQ,MAAM,qGAAqG,SAAS,OAAO,4BAA4B,MAAM,yCAAyC,gGAAgG,+CAA+C,MAAM,sCAAsC,oDAAoD,qCAAqC,2FAA2F,QAAQ,MAAM,+GAA+G,OAAO,mFAAmF,MAAM,wCAAwC,8DAA8D,qCAAqC,2BAA2B,0DAA0D,sBAAsB,yBAAyB,+BAA+B,WAAW,SAAS,QAAQ,MAAM,2BAA2B,8EAA8E,sBAAsB,yBAAyB,+BAA+B,WAAW,SAAS,OAAO,wCAAwC,MAAM,+BAA+B,mDAAmD,oCAAoC,MAAM,qCAAqC,cAAc,wCAAwC,6CAA6C,oDAAoD,6BAA6B,oCAAoC,0DAA0D,cAAc,WAAW,oBAAoB,SAAS,0CAA0C,6CAA6C,oDAAoD,6BAA6B,oCAAoC,sDAAsD,kBAAkB,WAAW,oBAAoB,SAAS,QAAQ,KAAK,gDAAgD,mCAAmC,iDAAiD,iCAAiC,6DAA6D,yCAAyC,QAAQ,MAAM,MAAM,4CAA4C,2CAA2C,0BAA0B,4BAA4B,OAAO,4BAA4B,mBAAmB,oCAAoC,4EAA4E,OAAO,mBAAmB,MAAM,6CAA6C,wDAAwD,oDAAoD,sBAAsB,MAAM,kCAAkC,6FAA6F,8DAA8D,mBAAmB,MAAM,yBAAyB,iDAAiD,sFAAsF,SAAS,GAAG,6DAA6D,SAAS,GAAG,mCAAmC,SAAS,OAAO,kBAAkB,MAAM,gCAAgC,sBAAsB,KAAK,uCAAuC,wCAAwC,MAAM,+BAA+B,oBAAoB,8CAA8C,kBAAkB,MAAM,iCAAiC,sBAAsB,qDAAqD,oBAAoB,MAAM,kCAAkC,uBAAuB,4CAA4C,gDAAgD,EAAE,qBAAqB,MAAM,mCAAmC,6DAA6D,8CAA8C,8BAA8B,0BAA0B,0BAA0B,yBAAyB,4BAA4B,iCAAiC,SAAS,OAAO,oBAAoB,MAAM,uBAAuB,8CAA8C,mCAAmC,iBAAiB,qCAAqC,uBAAuB,oBAAoB,SAAS,OAAO,wFAAwF,0EAA0E,uCAAuC,uFAAuF,qEAAqE,mBAAmB,MAAM,yCAAyC,gBAAgB,kCAAkC,eAAe,KAAK,2CAA2C,qCAAqC,qDAAqD,sEAAsE,EAAE,OAAO,KAAK,oCAAoC,6BAA6B,uCAAuC,gDAAgD,gCAAgC,UAAU,EAAE,QAAQ,qCAAqC,yCAAyC,iFAAiF,wEAAwE,QAAQ,MAAM,8DAA8D,OAAO,iBAAiB,MAAM,uBAAuB,qCAAqC,KAAK,8DAA8D,uBAAuB,kDAAkD,4CAA4C,OAAO,oCAAoC,oDAAoD,OAAO,+EAA+E,wBAAwB,6DAA6D,sBAAsB,OAAO,4BAA4B,yBAAyB,iDAAiD,4EAA4E,EAAE,uBAAuB,OAAO,iFAAiF,sFAAsF,OAAO,MAAM,EAAE,mCAAmC,kGAAkG,KAAK,qCAAqC,uEAAuE,KAAK,gCAAgC,4CAA4C,KAAK,mCAAmC,4EAA4E,KAAK,4BAA4B,oBAAoB,oEAAoE,kBAAkB,KAAK,4BAA4B,mBAAmB,uCAAuC,kBAAkB,KAAK,6BAA6B,6CAA6C,kBAAkB,KAAK,0BAA0B,mBAAmB,+CAA+C,6CAA6C,+HAA+H,wHAAwH,2BAA2B,kFAAkF,kCAAkC,YAAY,MAAM,oDAAoD,WAAW,SAAS,wBAAwB,6BAA6B,iDAAiD,kEAAkE,YAAY,UAAU,MAAM,sBAAsB,iDAAiD,6DAA6D,YAAY,SAAS,sCAAsC,sBAAsB,OAAO,sCAAsC,+CAA+C,oDAAoD,8CAA8C,uBAAuB,6EAA6E,EAAE,UAAU,EAAE,uDAAuD,yCAAyC,UAAU,UAAU,OAAO,6CAA6C,wCAAwC,QAAQ,wCAAwC,qDAAqD,QAAQ,gCAAgC,uBAAuB,oBAAoB,QAAQ,yCAAyC,0CAA0C,oBAAoB,QAAQ,2CAA2C,2BAA2B,oBAAoB,QAAQ,mCAAmC,mBAAmB,oBAAoB,QAAQ,kBAAkB,MAAM,gCAAgC,6BAA6B,sDAAsD,OAAO,0BAA0B,iBAAiB,MAAM,uBAAuB,qCAAqC,KAAK,uBAAuB,kDAAkD,oDAAoD,mBAAmB,OAAO,uIAAuI,yEAAyE,OAAO,MAAM,EAAE,qBAAqB,+BAA+B,eAAe,KAAK,4CAA4C,8CAA8C,oGAAoG,oBAAoB,MAAM,kDAAkD,yBAAyB,sDAAsD,iDAAiD,QAAQ,KAAK,8CAA8C,wCAAwC,8DAA8D,qDAAqD,OAAO,OAAO,qDAAqD,sDAAsD,OAAO,KAAK,mFAAmF,yBAAyB,8BAA8B,qEAAqE,+EAA+E,sBAAsB,MAAM,6BAA6B,2DAA2D,iDAAiD,qBAAqB,mCAAmC,kCAAkC,OAAO,wGAAwG,qCAAqC,sDAAsD,yEAAyE,SAAS,oBAAoB,OAAO,MAAM,4CAA4C,wDAAwD,wBAAwB,mDAAmD,wEAAwE,wBAAwB,OAAO,6CAA6C,8CAA8C,qDAAqD,kBAAkB,sBAAsB,0GAA0G,wCAAwC,SAAS,mEAAmE,gCAAgC,IAAI,wBAAwB,QAAQ,mBAAmB,KAAK,oBAAoB,uCAAuC,gCAAgC,KAAK,+BAA+B,0BAA0B,wCAAwC,eAAe,KAAK,yCAAyC,oEAAoE,+EAA+E,iDAAiD,+BAA+B,eAAe,+CAA+C,+BAA+B,0BAA0B,uDAAuD,YAAY,SAAS,0BAA0B,WAAW,UAAU,QAAQ,sBAAsB,KAAK,gCAAgC,oDAAoD,MAAM,kEAAkE,GAAG,IAAI,wBAAwB,4CAA4C,mCAAmC,MAAM,iCAAiC,+EAA+E,MAAM,qCAAqC,mDAAmD,oBAAoB,KAAK,sCAAsC,oCAAoC,OAAO,mCAAmC,uCAAuC,OAAO,uCAAuC,yFAAyF,6CAA6C,+CAA+C,UAAU,wCAAwC,QAAQ,2CAA2C,oCAAoC,yCAAyC,QAAQ,4BAA4B,gDAAgD,KAAK,+BAA+B,sDAAsD,MAAM,4DAA4D,yDAAyD,yDAAyD,mDAAmD,yCAAyC,SAAS,GAAG,wCAAwC,6DAA6D,4CAA4C,SAAS,GAAG,kCAAkC,kFAAkF,oFAAoF,YAAY,MAAM,kCAAkC,WAAW,SAAS,OAAO,uCAAuC,MAAM,gDAAgD,uEAAuE,2CAA2C,QAAQ,KAAK,4DAA4D,yCAAyC,sDAAsD,yCAAyC,SAAS,GAAG,6DAA6D,SAAS,GAAG,kCAAkC,gGAAgG,uCAAuC,WAAW,SAAS,OAAO,uCAAuC,MAAM,mDAAmD,uEAAuE,8CAA8C,QAAQ,KAAK,uBAAuB,8OAA8O,aAAa,2DAA2D,qDAAqD,kGAAkG,uDAAuD,oEAAoE,OAAO,OAAO,MAAM,0DAA0D,mCAAmC,2CAA2C,iCAAiC,uCAAuC,wGAAwG,SAAS,mFAAmF,oBAAoB,OAAO,2DAA2D,MAAM,+CAA+C,mCAAmC,2BAA2B,qCAAqC,OAAO,6BAA6B,yDAAyD,OAAO,+BAA+B,yCAAyC,OAAO,iCAAiC,6DAA6D,OAAO,+BAA+B,+CAA+C,uDAAuD,kCAAkC,OAAO,iCAAiC,+CAA+C,2EAA2E,sDAAsD,OAAO,0LAA0L,KAAK,+BAA+B,gDAAgD,KAAK,6DAA6D,mCAAmC,2CAA2C,6FAA6F,yCAAyC,6EAA6E,YAAY,MAAM,mDAAmD,mGAAmG,WAAW,sBAAsB,SAAS,sFAAsF,oBAAoB,OAAO,8DAA8D,MAAM,6CAA6C,2FAA2F,KAAK,2CAA2C,sDAAsD,KAAK,kDAAkD,0EAA0E,0BAA0B,kCAAkC,mBAAmB,iDAAiD,OAAO,kCAAkC,uDAAuD,6CAA6C,OAAO,+EAA+E,KAAK,+CAA+C,8CAA8C,sCAAsC,kFAAkF,uDAAuD,sBAAsB,2BAA2B,+FAA+F,UAAU,MAAM,gFAAgF,SAAS,QAAQ,KAAK,qEAAqE,+BAA+B,oBAAoB,2CAA2C,oCAAoC,sGAAsG,sBAAsB,SAAS,sBAAsB,iCAAiC,2FAA2F,SAAS,wBAAwB,OAAO,sEAAsE,MAAM,0DAA0D,4BAA4B,0CAA0C,OAAO,gCAAgC,wDAAwD,OAAO,gCAAgC,+CAA+C,4DAA4D,iDAAiD,OAAO,uGAAuG,KAAK,8DAA8D,mCAAmC,mEAAmE,uFAAuF,oBAAoB,OAAO,+DAA+D,MAAM,mDAAmD,+BAA+B,0BAA0B,OAAO,mCAAmC,2BAA2B,OAAO,mCAAmC,+CAA+C,4CAA4C,oBAAoB,OAAO,gHAAgH,KAAK,oDAAoD,uFAAuF,+CAA+C,gDAAgD,QAAQ,8BAA8B,gCAAgC,QAAQ,cAAc,iCAAiC,QAAQ,4BAA4B,MAAM,oDAAoD,uFAAuF,+CAA+C,8CAA8C,QAAQ,8BAA8B,8BAA8B,QAAQ,cAAc,+BAA+B,QAAQ,0BAA0B,MAAM,qDAAqD,0CAA0C,sCAAsC,iEAAiE,QAAQ,EAAE,MAAM,2CAA2C,yBAAyB,yEAAyE,wGAAwG,OAAO,2BAA2B,4EAA4E,OAAO,8GAA8G,KAAK,6DAA6D,0CAA0C,+CAA+C,sCAAsC,2GAA2G,QAAQ,EAAE,MAAM,+CAA+C,6CAA6C,MAAM,mCAAmC,mCAAmC,+CAA+C,KAAK,yDAAyD,+CAA+C,gCAAgC,4DAA4D,2BAA2B,kCAAkC,qCAAqC,WAAW,SAAS,qBAAqB,OAAO,yCAAyC,oLAAoL,oBAAoB,kFAAkF,wBAAwB,SAAS,GAAG,oCAAoC,0FAA0F,oCAAoC,gBAAgB,MAAM,qDAAqD,eAAe,sCAAsC,aAAa,WAAW,wBAAwB,SAAS,GAAG,mHAAmH,gEAAgE,cAAc,2BAA2B,oCAAoC,uCAAuC,aAAa,iDAAiD,WAAW,wBAAwB,SAAS,GAAG,kFAAkF,sCAAsC,aAAa,WAAW,UAAU,MAAM,wBAAwB,UAAU,GAAG,4BAA4B,oCAAoC,yBAAyB,uCAAuC,oCAAoC,cAAc,MAAM,gEAAgE,aAAa,WAAW,iBAAiB,OAAO,OAAO,kEAAkE,WAAW,iBAAiB,OAAO,OAAO,oCAAoC,WAAW,SAAS,wCAAwC,iGAAiG,iCAAiC,mCAAmC,+BAA+B,OAAO,mGAAmG,4CAA4C,2BAA2B,qFAAqF,SAAS,QAAQ,MAAM,2BAA2B,yCAAyC,SAAS,OAAO,iCAAiC,qBAAqB,QAAQ,gCAAgC,oBAAoB,QAAQ,oBAAoB,MAAM,4CAA4C,cAAc,8BAA8B,KAAK,qDAAqD,qGAAqG,MAAM,uDAAuD,gDAAgD,mFAAmF,wCAAwC,OAAO,OAAO,wCAAwC,6DAA6D,2CAA2C,OAAO,OAAO,kFAAkF,kCAAkC,WAAW,SAAS,OAAO,uCAAuC,MAAM,8CAA8C,yBAAyB,kDAAkD,QAAQ,KAAK,8CAA8C,yCAAyC,SAAS,GAAG,gFAAgF,UAAU,GAAG,kCAAkC,gGAAgG,wBAAwB,WAAW,SAAS,OAAO,kBAAkB,MAAM,yDAAyD,wEAAwE,yCAAyC,SAAS,6BAA6B,0BAA0B,MAAM,wDAAwD,yDAAyD,+BAA+B,uEAAuE,QAAQ,KAAK,uDAAuD,8DAA8D,mDAAmD,QAAQ,EAAE,MAAM,oDAAoD,0CAA0C,OAAO,OAAO,oEAAoE,OAAO,OAAO,wDAAwD,SAAS,OAAO,oBAAoB,KAAK,uDAAuD,uCAAuC,6CAA6C,kBAAkB,MAAM,8CAA8C,0BAA0B,MAAM,6CAA6C,wCAAwC,OAAO,OAAO,4DAA4D,OAAO,OAAO,8BAA8B,kCAAkC,SAAS,OAAO,kBAAkB,MAAM,6CAA6C,gBAAgB,2CAA2C,YAAY,QAAQ,EAAE,eAAe,MAAM,8CAA8C,4DAA4D,uBAAuB,KAAK,yCAAyC,4CAA4C,+DAA+D,sEAAsE,oEAAoE,kEAAkE,kEAAkE,kEAAkE,+DAA+D,kEAAkE,yCAAyC,SAAS,GAAG,6CAA6C,wCAAwC,+CAA+C,4CAA4C,SAAS,GAAG,kCAAkC,2GAA2G,6CAA6C,YAAY,MAAM,kCAAkC,WAAW,SAAS,OAAO,uCAAuC,MAAM,mEAAmE,kFAAkF,qEAAqE,MAAM,sDAAsD,iBAAiB,kCAAkC,4DAA4D,sCAAsC,kCAAkC,qDAAqD,oBAAoB,QAAQ,KAAK,kCAAkC,gBAAgB,yCAAyC,mDAAmD,uDAAuD,QAAQ,MAAM,yBAAyB,sDAAsD,OAAO,uCAAuC,MAAM,sCAAsC,gBAAgB,0CAA0C,+DAA+D,uDAAuD,QAAQ,MAAM,kCAAkC,gCAAgC,OAAO,uCAAuC,MAAM,oEAAoE,+BAA+B,oBAAoB,2CAA2C,wCAAwC,mGAAmG,sBAAsB,SAAS,wEAAwE,wBAAwB,OAAO,qEAAqE,MAAM,yDAAyD,4FAA4F,6CAA6C,sDAAsD,gEAAgE,2BAA2B,2BAA2B,kBAAkB,mDAAmD,4BAA4B,SAAS,OAAO,wBAAwB,wDAAwD,8BAA8B,qEAAqE,uBAAuB,OAAO,4BAA4B,oFAAoF,kCAAkC,2CAA2C,+BAA+B,yDAAyD,8BAA8B,WAAW,SAAS,OAAO,8EAA8E,KAAK,0CAA0C,oEAAoE,EAAE,wBAAwB,qDAAqD,4EAA4E,QAAQ,EAAE,KAAK,6DAA6D,4BAA4B,yBAAyB,qBAAqB,qCAAqC,aAAa,4CAA4C,UAAU,SAAS,uBAAuB,SAAS,QAAQ,KAAK,2DAA2D,6DAA6D,4BAA4B,qDAAqD,qGAAqG,8BAA8B,SAAS,QAAQ,KAAK,iDAAiD,4CAA4C,iRAAiR,0CAA0C,gHAAgH,OAAO,kCAAkC,0FAA0F,8CAA8C,OAAO,wCAAwC,2BAA2B,uEAAuE,8BAA8B,gCAAgC,gCAAgC,YAAY,mCAAmC,qCAAqC,kBAAkB,WAAW,SAAS,+BAA+B,SAAS,QAAQ,KAAK,sCAAsC,0DAA0D,MAAM,iGAAiG,4CAA4C,sDAAsD,uDAAuD,iCAAiC,yCAAyC,sCAAsC,8CAA8C,mDAAmD,kEAAkE,4KAA4K,kBAAkB,+CAA+C,oDAAoD,yBAAyB,WAAW,SAAS,uEAAuE,qDAAqD,4EAA4E,oCAAoC,OAAO,mDAAmD,0GAA0G,KAAK,2DAA2D,kGAAkG,iEAAiE,OAAO,OAAO,iEAAiE,mDAAmD,SAAS,OAAO,MAAM,mCAAmC,0RAA0R,uBAAuB,uFAAuF,OAAO,8DAA8D,2BAA2B,+ZAA+Z,yBAAyB,yDAAyD,sFAAsF,YAAY,MAAM,kCAAkC,WAAW,qBAAqB,2CAA2C,EAAE,4BAA4B,+DAA+D,qCAAqC,6CAA6C,6CAA6C,+BAA+B,kCAAkC,uBAAuB,gLAAgL,EAAE,WAAW,4BAA4B,sDAAsD,+EAA+E,mCAAmC,uBAAuB,6CAA6C,EAAE,WAAW,UAAU,OAAO,mCAAmC,+CAA+C,mBAAmB,oBAAoB,QAAQ,8CAA8C,MAAM,wCAAwC,mDAAmD,KAAK,iDAAiD,qEAAqE,mEAAmE,sDAAsD,4CAA4C,qBAAqB,QAAQ,OAAO,MAAM,4HAA4H,0BAA0B,wCAAwC,KAAK,oCAAoC,mFAAmF,KAAK,2BAA2B,qDAAqD,KAAK,2BAA2B,8DAA8D,KAAK,2BAA2B,mDAAmD,KAAK,2BAA2B,mDAAmD,KAAK,2BAA2B,2DAA2D,KAAK,+BAA+B,2CAA2C,KAAK,uCAAuC,6CAA6C,mJAAmJ,sBAAsB,oCAAoC,2BAA2B,4EAA4E,UAAU,QAAQ,MAAM,2PAA2P,4BAA4B,2BAA2B,2HAA2H,qFAAqF,UAAU,OAAO,2BAA2B,eAAe,MAAM,mCAAmC,kBAAkB,qDAAqD,0WAA0W,qCAAqC,mGAAmG,qEAAqE,SAAS,wFAAwF,qCAAqC,SAAS,2DAA2D,kCAAkC,SAAS,4BAA4B,OAAO,0BAA0B,gKAAgK,OAAO,kCAAkC,4BAA4B,mEAAmE,yCAAyC,6EAA6E,wCAAwC,8EAA8E,sCAAsC,cAAc,oCAAoC,8RAA8R,oCAAoC,8CAA8C,yCAAyC,8GAA8G,mCAAmC,gBAAgB,cAAc,wCAAwC,oCAAoC,cAAc,kCAAkC,oCAAoC,cAAc,EAAE,YAAY,MAAM,kCAAkC,oCAAoC,+BAA+B,kCAAkC,WAAW,UAAU,EAAE,QAAQ,sCAAsC,2DAA2D,gBAAgB,mEAAmE,kBAAkB,oBAAoB,QAAQ,kCAAkC,+CAA+C,gBAAgB,mEAAmE,sBAAsB,kBAAkB,oBAAoB,QAAQ,wCAAwC,oDAAoD,8EAA8E,oBAAoB,QAAQ,mCAAmC,+CAA+C,uCAAuC,oBAAoB,QAAQ,iCAAiC,6CAA6C,qCAAqC,oBAAoB,QAAQ,qCAAqC,iDAAiD,sBAAsB,oBAAoB,QAAQ,8BAA8B,2CAA2C,eAAe,sBAAsB,gBAAgB,sDAAsD,oBAAoB,QAAQ,8BAA8B,2CAA2C,eAAe,sBAAsB,gBAAgB,sDAAsD,oBAAoB,QAAQ,8BAA8B,0EAA0E,OAAO,2BAA2B,kEAAkE,OAAO,6BAA6B,2EAA2E,OAAO,oCAAoC,uBAAuB,8BAA8B,8BAA8B,OAAO,wCAAwC,0BAA0B,qEAAqE,oCAAoC,sCAAsC,iCAAiC,0EAA0E,gCAAgC,OAAO,0BAA0B,4DAA4D,yCAAyC,UAAU,qBAAqB,4DAA4D,yCAAyC,UAAU,qBAAqB,OAAO,wCAAwC,qCAAqC,uCAAuC,EAAE,OAAO,mCAAmC,kBAAkB,mBAAmB,kGAAkG,EAAE,OAAO,sCAAsC,qCAAqC,qCAAqC,kBAAkB,OAAO,8BAA8B,0PAA0P,4CAA4C,gCAAgC,0BAA0B,sBAAsB,qDAAqD,6BAA6B,SAAS,0BAA0B,4DAA4D,iCAAiC,gCAAgC,SAAS,OAAO,+BAA+B,gFAAgF,yPAAyP,kBAAkB,gCAAgC,gEAAgE,6BAA6B,2CAA2C,0BAA0B,0CAA0C,uFAAuF,YAAY,EAAE,yBAAyB,SAAS,4BAA4B,uCAAuC,2EAA2E,iCAAiC,gDAAgD,+CAA+C,OAAO,OAAO,qDAAqD,WAAW,qDAAqD,uCAAuC,0CAA0C,iCAAiC,2GAA2G,uCAAuC,aAAa,4BAA4B,YAAY,gCAAgC,mFAAmF,0CAA0C,WAAW,SAAS,0BAA0B,2DAA2D,8CAA8C,+CAA+C,OAAO,kBAAkB,4BAA4B,mDAAmD,8BAA8B,+BAA+B,aAAa,WAAW,qBAAqB,4KAA4K,kEAAkE,kEAAkE,uCAAuC,WAAW,2BAA2B,gCAAgC,6BAA6B,SAAS,0BAA0B,0CAA0C,kDAAkD,iDAAiD,OAAO,OAAO,uDAAuD,aAAa,kDAAkD,qCAAqC,aAAa,WAAW,uDAAuD,8EAA8E,wBAAwB,gCAAgC,SAAS,OAAO,+BAA+B,mDAAmD,gEAAgE,wIAAwI,kDAAkD,iCAAiC,gCAAgC,SAAS,OAAO,iCAAiC,0EAA0E,2CAA2C,2BAA2B,OAAO,6BAA6B,oEAAoE,uGAAuG,OAAO,8CAA8C,MAAM,iGAAiG,wBAAwB,0BAA0B,8CAA8C,+BAA+B,MAAM,oBAAoB,gCAAgC,uOAAuO,KAAK,4DAA4D,8CAA8C,mDAAmD,sDAAsD,MAAM,4CAA4C,mDAAmD,sDAAsD,MAAM,sCAAsC,kDAAkD,MAAM,oCAAoC,iBAAiB,0DAA0D,qDAAqD,oCAAoC,mDAAmD,sBAAsB,uBAAuB,iCAAiC,2BAA2B,uDAAuD,iCAAiC,kEAAkE,kBAAkB,OAAO,wBAAwB,0CAA0C,OAAO,iEAAiE,KAAK,oBAAoB,gCAAgC,8TAA8T,KAAK,4DAA4D,8CAA8C,6GAA6G,MAAM,4CAA4C,2GAA2G,MAAM,sCAAsC,wDAAwD,MAAM,oCAAoC,8BAA8B,8BAA8B,iFAAiF,KAAK,oBAAoB,gCAAgC,4RAA4R,KAAK,sBAAsB,4DAA4D,4DAA4D,8CAA8C,6GAA6G,MAAM,4CAA4C,2GAA2G,MAAM,sCAAsC,kDAAkD,MAAM,oCAAoC,iEAAiE,qCAAqC,qCAAqC,qCAAqC,2MAA2M,KAAK,oCAAoC,8HAA8H,KAAK,8BAA8B,oEAAoE,KAAK,8BAA8B,wEAAwE,KAAK,8BAA8B,qGAAqG,KAAK,oBAAoB,gCAAgC,0OAA0O,KAAK,oCAAoC,sEAAsE,KAAK,oCAAoC,0CAA0C,KAAK,4DAA4D,8CAA8C,mDAAmD,qDAAqD,yDAAyD,8BAA8B,8BAA8B,8BAA8B,kGAAkG,MAAM,4CAA4C,mDAAmD,8DAA8D,MAAM,sCAAsC,kDAAkD,MAAM,2CAA2C,wFAAwF,MAAM,8BAA8B,kGAAkG,KAAK,+CAA+C,6CAA6C,sEAAsE,iBAAiB,kCAAkC,0BAA0B,8BAA8B,kGAAkG,SAAS,gCAAgC,8GAA8G,SAAS,SAAS,OAAO,iDAAiD,gDAAgD,OAAO,oHAAoH,oCAAoC,oCAAoC,yBAAyB,0BAA0B,yBAAyB,yBAAyB,yBAAyB,UAAU,iCAAiC,yCAAyC,qCAAqC,0BAA0B,SAAS,OAAO,4BAA4B,KAAK,oCAAoC,gIAAgI,gBAAgB,+DAA+D,+DAA+D,4CAA4C,2BAA2B,gBAAgB,QAAQ,MAAM,gBAAgB,mCAAmC,OAAO,mCAAmC,KAAK,oCAAoC,0BAA0B,0BAA0B,0BAA0B,8OAA8O,sEAAsE,KAAK,8BAA8B,wFAAwF,KAAK,sCAAsC,8BAA8B,6EAA6E,KAAK,gCAAgC,wpHAAwpH,EAAE,kDAAkD,qDAAqD,MAAM,EAAE,8BAA8B,yDAAyD,iBAAiB,QAAQ,KAAK,4BAA4B,uCAAuC,qCAAqC,kDAAkD,sHAAsH,2DAA2D,QAAQ,KAAK,0DAA0D,kBAAkB,2FAA2F,sDAAsD,4IAA4I,oHAAoH,4CAA4C,QAAQ,0BAA0B,4CAA4C,2GAA2G,eAAe,mDAAmD,YAAY,aAAa,0CAA0C,mBAAmB,WAAW,4CAA4C,UAAU,MAAM,8CAA8C,SAAS,OAAO,8CAA8C,yBAAyB,yBAAyB,aAAa,iDAAiD,UAAU,SAAS,uBAAuB,SAAS,QAAQ,4CAA4C,6CAA6C,yDAAyD,mDAAmD,kCAAkC,mBAAmB,QAAQ,wCAAwC,iDAAiD,uDAAuD,mBAAmB,QAAQ,4CAA4C,qDAAqD,6BAA6B,mBAAmB,QAAQ,wCAAwC,yBAAyB,mBAAmB,QAAQ,yDAAyD,kCAAkC,mFAAmF,UAAU,QAAQ,EAAE,qDAAqD,mGAAmG,0CAA0C,wGAAwG,oHAAoH,iGAAiG,wEAAwE,iGAAiG,oCAAoC,UAAU,EAAE,iDAAiD,mDAAmD,mBAAmB,QAAQ,8BAA8B,wBAAwB,mBAAmB,QAAQ,yCAAyC,gFAAgF,KAAK,6CAA6C,iEAAiE,mDAAmD,QAAQ,WAAW,KAAK,2CAA2C,sCAAsC,iFAAiF,KAAK,8CAA8C,2GAA2G,0CAA0C,+DAA+D,mGAAmG,iCAAiC,8GAA8G,UAAU,mBAAmB,OAAO,oCAAoC,iDAAiD,OAAO,mCAAmC,oCAAoC,sDAAsD,UAAU,OAAO,uCAAuC,cAAc,wDAAwD,0CAA0C,iDAAiD,mCAAmC,iEAAiE,YAAY,qBAAqB,KAAK,sCAAsC,oCAAoC,YAAY,IAAI,UAAU,EAAE,QAAQ,2CAA2C,oBAAoB,UAAU,mDAAmD,0BAA0B,mCAAmC,6CAA6C,oBAAoB,8CAA8C,sBAAsB,+BAA+B,kDAAkD,6DAA6D,oBAAoB,eAAe,aAAa,sBAAsB,6CAA6C,6BAA6B,yBAAyB,yDAAyD,cAAc,sBAAsB,yBAAyB,aAAa,mEAAmE,WAAW,2BAA2B,kDAAkD,wCAAwC,sBAAsB,yBAAyB,0DAA0D,cAAc,yCAAyC,0CAA0C,WAAW,iCAAiC,SAAS,2CAA2C,qBAAqB,4CAA4C,wBAAwB,wBAAwB,WAAW,2DAA2D,yBAAyB,SAAS,oBAAoB,QAAQ,qCAAqC,sEAAsE,iDAAiD,uCAAuC,oCAAoC,2CAA2C,mDAAmD,aAAa,WAAW,UAAU,EAAE,kGAAkG,gDAAgD,6CAA6C,YAAY,oBAAoB,UAAU,oBAAoB,QAAQ,yCAAyC,qDAAqD,QAAQ,iCAAiC,wDAAwD,OAAO,oCAAoC,4FAA4F,OAAO,iBAAiB,MAAM,2CAA2C,6DAA6D,wLAAwL,iCAAiC,MAAM,2BAA2B,wCAAwC,MAAM,gDAAgD,+BAA+B,6BAA6B,qCAAqC,wCAAwC,2DAA2D,8DAA8D,gCAAgC,iCAAiC,iCAAiC,4DAA4D,8BAA8B,wCAAwC,OAAO,mBAAmB,KAAK,8BAA8B,gEAAgE,yBAAyB,kCAAkC,2CAA2C,gEAAgE,SAAS,8BAA8B,QAAQ,MAAM,8BAA8B,wCAAwC,OAAO,KAAK,iCAAiC,sBAAsB,uBAAuB,MAAM,8BAA8B,uDAAuD,uBAAuB,yEAAyE,wBAAwB,OAAO,iBAAiB,KAAK,+BAA+B,uDAAuD,oBAAoB,qBAAqB,yCAAyC,6BAA6B,UAAU,MAAM,4DAA4D,SAAS,OAAO,8BAA8B,kBAAkB,KAAK,0CAA0C,oEAAoE,KAAK,iCAAiC,mFAAmF,MAAM,4KAA4K,oDAAoD,gBAAgB,6BAA6B,qCAAqC,4FAA4F,oEAAoE,6EAA6E,OAAO,0CAA0C,MAAM,sCAAsC,+CAA+C,cAAc,sCAAsC,uBAAuB,UAAU,iBAAiB,uBAAuB,SAAS,0BAA0B,KAAK,+CAA+C,oOAAoO,gFAAgF,kCAAkC,0EAA0E,qDAAqD,mDAAmD,sEAAsE,SAAS,oDAAoD,QAAQ,cAAc,oCAAoC,sUAAsU,+DAA+D,2DAA2D,+BAA+B,wBAAwB,SAAS,yBAAyB,0CAA0C,uBAAuB,gBAAgB,2CAA2C,yBAAyB,uBAAuB,gBAAgB,2CAA2C,yBAAyB,uBAAuB,gBAAgB,oJAAoJ,gDAAgD,8CAA8C,wBAAwB,gBAAgB,0CAA0C,uBAAuB,gBAAgB,SAAS,yFAAyF,wDAAwD,kCAAkC,qFAAqF,gGAAgG,SAAS,oEAAoE,oCAAoC,kCAAkC,kCAAkC,kDAAkD,8HAA8H,4BAA4B,2DAA2D,wCAAwC,8CAA8C,YAAY,MAAM,2BAA2B,WAAW,2CAA2C,4DAA4D,wBAAwB,+DAA+D,uDAAuD,oEAAoE,YAAY,MAAM,6CAA6C,8DAA8D,WAAW,0EAA0E,gMAAgM,mHAAmH,6BAA6B,iCAAiC,0RAA0R,UAAU,QAAQ,KAAK,+BAA+B,qEAAqE,mCAAmC,wBAAwB,+BAA+B,OAAO,yBAAyB,wCAAwC,OAAO,yBAAyB,+BAA+B,OAAO,yBAAyB,gCAAgC,OAAO,yBAAyB,8CAA8C,OAAO,4BAA4B,kCAAkC,OAAO,4BAA4B,oCAAoC,OAAO,4BAA4B,8BAA8B,OAAO,4BAA4B,wJAAwJ,OAAO,MAAM,EAAE,yCAAyC,sBAAsB,KAAK,8BAA8B,iBAAiB,4BAA4B,mGAAmG,KAAK,6BAA6B,2BAA2B,mCAAmC,OAAO,2BAA2B,kCAAkC,OAAO,gCAAgC,uCAAuC,OAAO,6BAA6B,oCAAoC,OAAO,oCAAoC,2CAA2C,OAAO,+BAA+B,sCAAsC,OAAO,6BAA6B,oCAAoC,OAAO,+BAA+B,sCAAsC,OAAO,4BAA4B,gCAAgC,OAAO,sCAAsC,iBAAiB,OAAO,4BAA4B,gCAAgC,OAAO,4BAA4B,gEAAgE,OAAO,2BAA2B,+DAA+D,OAAO,gCAAgC,oEAAoE,OAAO,6BAA6B,iEAAiE,OAAO,oCAAoC,wEAAwE,OAAO,+BAA+B,mEAAmE,OAAO,6BAA6B,iEAAiE,OAAO,+BAA+B,mEAAmE,OAAO,4BAA4B,6DAA6D,OAAO,MAAM,2CAA2C,sDAAsD,8BAA8B,qDAAqD,+CAA+C,OAAO,6BAA6B,2DAA2D,oBAAoB,OAAO,kCAAkC,+CAA+C,oBAAoB,OAAO,oCAAoC,0CAA0C,uBAAuB,+BAA+B,4EAA4E,4BAA4B,WAAW,UAAU,MAAM,+EAA+E,SAAS,qBAAqB,OAAO,wCAAwC,aAAa,gCAAgC,sCAAsC,qBAAqB,sCAAsC,UAAU,SAAS,yBAAyB,SAAS,OAAO,0BAA0B,0BAA0B,wBAAwB,4BAA4B,0BAA0B,0DAA0D,sBAAsB,gDAAgD,8CAA8C,kDAAkD,4BAA4B,mBAAmB,KAAK,6CAA6C,kCAAkC,aAAa,gCAAgC,sCAAsC,uBAAuB,oCAAoC,UAAU,SAAS,yBAAyB,SAAS,QAAQ,KAAK,uDAAuD,iCAAiC,4BAA4B,kBAAkB,KAAK,4BAA4B,sDAAsD,KAAK,oBAAoB,gCAAgC,MAAM,EAAE,uCAAuC,+CAA+C,sDAAsD,sCAAsC,6EAA6E,iBAAiB,KAAK,4BAA4B,8CAA8C,KAAK,oBAAoB,gCAAgC,MAAM,EAAE,qCAAqC,6CAA6C,0CAA0C,sCAAsC,mHAAmH,MAAM,gIAAgI,gBAAgB,wEAAwE,6FAA6F,oBAAoB,OAAO,4BAA4B,kEAAkE,OAAO,oBAAoB,gDAAgD,iGAAiG,QAAQ,EAAE,4CAA4C,oDAAoD,oDAAoD,gDAAgD,iFAAiF,QAAQ,MAAM,EAAE,kCAAkC,yCAAyC,iDAAiD,8CAA8C,6CAA6C,2QAA2Q,2CAA2C,gCAAgC,iCAAiC,kDAAkD,6BAA6B,oDAAoD,oDAAoD,+GAA+G,uGAAuG,+BAA+B,wBAAwB,aAAa,WAAW,gDAAgD,qCAAqC,SAAS,2CAA2C,mBAAmB,0KAA0K,8CAA8C,gDAAgD,sDAAsD,+GAA+G,6DAA6D,sCAAsC,4DAA4D,0CAA0C,uJAAuJ,YAAY,uCAAuC,8EAA8E,wCAAwC,UAAU,sCAAsC,0BAA0B,UAAU,sBAAsB,OAAO,2DAA2D,mEAAmE,yBAAyB,kCAAkC,yCAAyC,2BAA2B,uCAAuC,sFAAsF,oEAAoE,YAAY,2CAA2C,sBAAsB,WAAW,SAAS,iBAAiB,OAAO,iDAAiD,+CAA+C,iCAAiC,eAAe,kCAAkC,oCAAoC,yBAAyB,gCAAgC,YAAY,SAAS,2BAA2B,WAAW,SAAS,2CAA2C,eAAe,kCAAkC,6CAA6C,kCAAkC,YAAY,SAAS,2BAA2B,WAAW,UAAU,yCAAyC,sBAAsB,QAAQ,4EAA4E,8gBAA8gB,gDAAgD,uDAAuD,QAAQ,EAAE,6BAA6B,0BAA0B,8CAA8C,SAAS,2BAA2B,yCAAyC,SAAS,2BAA2B,kDAAkD,SAAS,2BAA2B,6CAA6C,SAAS,2EAA2E,wDAAwD,SAAS,8BAA8B,wDAAwD,SAAS,8BAA8B,yDAAyD,SAAS,8BAA8B,oEAAoE,SAAS,8BAA8B,uEAAuE,SAAS,8BAA8B,gEAAgE,SAAS,8BAA8B,6DAA6D,SAAS,8BAA8B,2DAA2D,SAAS,2BAA2B,yDAAyD,SAAS,8BAA8B,2DAA2D,SAAS,8BAA8B,sEAAsE,SAAS,2BAA2B,4BAA4B,SAAS,8BAA8B,sEAAsE,SAAS,gHAAgH,kEAAkE,SAAS,8BAA8B,kEAAkE,SAAS,oDAAoD,uBAAuB,SAAS,QAAQ,6BAA6B,ozBAAozB,8DAA8D,0CAA0C,8DAA8D,wGAAwG,OAAO,wDAAwD,oCAAoC,wDAAwD,kGAAkG,OAAO,4DAA4D,4CAA4C,gEAAgE,0GAA0G,OAAO,sDAAsD,sCAAsC,0DAA0D,oGAAoG,OAAO,2DAA2D,8EAA8E,OAAO,2DAA2D,8EAA8E,OAAO,2DAA2D,8EAA8E,OAAO,qDAAqD,oFAAoF,kDAAkD,OAAO,4BAA4B,KAAK,8BAA8B,gEAAgE,2DAA2D,sDAAsD,6GAA6G,wGAAwG,KAAK,wCAAwC,2FAA2F,KAAK,4CAA4C,uDAAuD,6DAA6D,iBAAiB,KAAK,4DAA4D,qCAAqC,gEAAgE,0DAA0D,KAAK,+DAA+D,qCAAqC,yDAAyD,0DAA0D,KAAK,+DAA+D,qCAAqC,yDAAyD,0DAA0D,KAAK,uDAAuD,qCAAqC,gEAAgE,0DAA0D,KAAK,mDAAmD,qCAAqC,gEAAgE,gFAAgF,KAAK,mDAAmD,uBAAuB,EAAE,qFAAqF,KAAK,sCAAsC,yCAAyC,KAAK,0DAA0D,qCAAqC,gEAAgE,6DAA6D,KAAK,kDAAkD,qCAAqC,gEAAgE,0DAA0D,KAAK,wDAAwD,qCAAqC,gEAAgE,0DAA0D,KAAK,qDAAqD,qCAAqC,gEAAgE,0DAA0D,KAAK,sDAAsD,qCAAqC,gEAAgE,0DAA0D,KAAK,sDAAsD,qCAAqC,gEAAgE,0DAA0D,KAAK,2DAA2D,qCAAqC,gEAAgE,0DAA0D,KAAK,gCAAgC,4GAA4G,wFAAwF,KAAK,6DAA6D,sCAAsC,iEAAiE,sCAAsC,KAAK,6CAA6C,qCAAqC,8DAA8D,+BAA+B,kCAAkC,iDAAiD,4BAA4B,QAAQ,KAAK,oCAAoC,cAAc,iHAAiH,MAAM,qCAAqC,isBAAisB,EAAE,4CAA4C,gBAAgB,0BAA0B,0BAA0B,gDAAgD,+CAA+C,oDAAoD,gDAAgD,6BAA6B,OAAO,0BAA0B,4BAA4B,OAAO,4BAA4B,sBAAsB,OAAO,MAAM,sCAAsC,qCAAqC,mDAAmD,gCAAgC,KAAK,kDAAkD,8EAA8E,iEAAiE,QAAQ,MAAM,kDAAkD,OAAO,MAAM,0DAA0D,oFAAoF,uEAAuE,OAAO,KAAK,mCAAmC,8CAA8C,4DAA4D,OAAO,wDAAwD,oEAAoE,kFAAkF,OAAO,MAAM,qCAAqC,4CAA4C,0BAA0B,OAAO,4CAA4C,oCAAoC,0DAA0D,OAAO,iDAAiD,6EAA6E,qGAAqG,OAAO,iDAAiD,6DAA6D,OAAO,sDAAsD,6EAA6E,2EAA2E,OAAO,8CAA8C,6DAA6D,OAAO,mDAAmD,6EAA6E,2EAA2E,OAAO,yDAAyD,0EAA0E,2EAA2E,OAAO,MAAM,iEAAiE,8DAA8D,2BAA2B,mHAAmH,yBAAyB,KAAK,4DAA4D,yCAAyC,8BAA8B,yEAAyE,4BAA4B,KAAK,sCAAsC,yBAAyB,2CAA2C,4BAA4B,MAAM,4DAA4D,uBAAuB,0BAA0B,gCAAgC,OAAO,sGAAsG,mCAAmC,qDAAqD,OAAO,+BAA+B,0CAA0C,yDAAyD,kFAAkF,OAAO,MAAM,qCAAqC,qCAAqC,4CAA4C,sCAAsC,kIAAkI,QAAQ,kCAAkC,wBAAwB,uCAAuC,qMAAqM,qDAAqD,2CAA2C,OAAO,wCAAwC,8BAA8B,QAAQ,KAAK,4CAA4C,mEAAmE,2EAA2E,KAAK,0CAA0C,qDAAqD,KAAK,4CAA4C,iGAAiG,KAAK,0CAA0C,mBAAmB,mBAAmB,mBAAmB,KAAK,iDAAiD,6DAA6D,KAAK,6CAA6C,mEAAmE,gBAAgB,gBAAgB,gBAAgB,KAAK,4CAA4C,mFAAmF,KAAK,4CAA4C,8DAA8D,KAAK,gCAAgC,iEAAiE,mBAAmB,6GAA6G,kCAAkC,sCAAsC,kCAAkC,oBAAoB,qCAAqC,SAAS,iCAAiC,mCAAmC,8BAA8B,sCAAsC,kCAAkC,+EAA+E,+BAA+B,gCAAgC,uCAAuC,SAAS,QAAQ,8BAA8B,kDAAkD,6BAA6B,6BAA6B,OAAO,kCAAkC,uEAAuE,mBAAmB,2JAA2J,kDAAkD,sDAAsD,oHAAoH,+DAA+D,gDAAgD,mCAAmC,YAAY,yFAAyF,iDAAiD,mCAAmC,YAAY,MAAM,iCAAiC,iCAAiC,WAAW,+BAA+B,2BAA2B,6DAA6D,cAAc,MAAM,6DAA6D,aAAa,YAAY,MAAM,6BAA6B,mCAAmC,mCAAmC,cAAc,MAAM,6BAA6B,+DAA+D,gBAAgB,MAAM,+DAA+D,eAAe,aAAa,WAAW,UAAU,MAAM,wBAAwB,SAAS,uBAAuB,OAAO,4BAA4B,gCAAgC,OAAO,0BAA0B,qCAAqC,4BAA4B,kBAAkB,OAAO,kCAAkC,mBAAmB,0BAA0B,uEAAuE,UAAU,sBAAsB,kCAAkC,0BAA0B,OAAO,4BAA4B,gCAAgC,OAAO,0BAA0B,8BAA8B,8BAA8B,mDAAmD,qCAAqC,kBAAkB,OAAO,gCAAgC,gDAAgD,OAAO,sCAAsC,2BAA2B,OAAO,wCAAwC,oGAAoG,OAAO,kCAAkC,0CAA0C,oBAAoB,wCAAwC,8BAA8B,kBAAkB,uCAAuC,6DAA6D,OAAO,OAAO,0BAA0B,qEAAqE,2EAA2E,2EAA2E,cAAc,MAAM,mCAAmC,aAAa,WAAW,mCAAmC,oEAAoE,QAAQ,cAAc,0BAA0B,uFAAuF,WAAW,SAAS,8BAA8B,gHAAgH,QAAQ,KAAK,GAAG,0CAA0C,oOAAoO,+CAA+C,yGAAyG,qBAAqB,4EAA4E,yGAAyG,kCAAkC,0CAA0C,OAAO,6FAA6F,MAAM,wNAAwN,2BAA2B,wKAAwK,6DAA6D,OAAO,+BAA+B,6DAA6D,OAAO,MAAM,2CAA2C,sBAAsB,6CAA6C,2FAA2F,KAAK,iDAAiD,0BAA0B,yEAAyE,yEAAyE,yEAAyE,KAAK,yCAAyC,qBAAqB,gDAAgD,wBAAwB,+CAA+C,kCAAkC,kCAAkC,2BAA2B,0CAA0C,8CAA8C,QAAQ,kCAAkC,wBAAwB,wQAAwQ,+BAA+B,qDAAqD,qDAAqD,qDAAqD,8CAA8C,OAAO,KAAK,uCAAuC,mDAAmD,KAAK,yCAAyC,+BAA+B,gDAAgD,yBAAyB,0CAA0C,wBAAwB,+CAA+C,kCAAkC,kCAAkC,2BAA2B,8CAA8C,QAAQ,4CAA4C,8BAA8B,yDAAyD,qDAAqD,QAAQ,kCAAkC,wBAAwB,wTAAwT,oCAAoC,oCAAoC,oCAAoC,+BAA+B,qDAAqD,qDAAqD,qDAAqD,8CAA8C,OAAO,KAAK,qCAAqC,gCAAgC,8CAA8C,OAAO,qEAAqE,iEAAiE,QAAQ,qBAAqB,KAAK,wBAAwB,kBAAkB,KAAK,8FAA8F,kCAAkC,6CAA6C,sDAAsD,gDAAgD,gDAAgD,+BAA+B,2BAA2B,OAAO,sDAAsD,6BAA6B,iBAAiB,SAAS,4IAA4I,gBAAgB,0BAA0B,uBAAuB,2EAA2E,oEAAoE,gBAAgB,0BAA0B,uBAAuB,QAAQ,EAAE,2BAA2B,gDAAgD,6CAA6C,oCAAoC,iEAAiE,OAAO,OAAO,mCAAmC,OAAO,4CAA4C,mBAAmB,8CAA8C,4EAA4E,2BAA2B,6BAA6B,YAAY,yCAAyC,4BAA4B,8BAA8B,kDAAkD,OAAO,2DAA2D,cAAc,MAAM,iEAAiE,aAAa,gCAAgC,YAAY,MAAM,8BAA8B,mCAAmC,+CAA+C,QAAQ,2DAA2D,cAAc,MAAM,kEAAkE,aAAa,gCAAgC,WAAW,8BAA8B,6BAA6B,iCAAiC,UAAU,qBAAqB,2BAA2B,OAAO,KAAK,sDAAsD,0CAA0C,oCAAoC,yBAAyB,2BAA2B,gBAAgB,cAAc,OAAO,yBAAyB,cAAc,KAAK,4EAA4E,qBAAqB,sBAAsB,qBAAqB,qBAAqB,qBAAqB,6BAA6B,KAAK,4EAA4E,2CAA2C,wGAAwG,oBAAoB,qHAAqH,mCAAmC,uCAAuC,mCAAmC,0BAA0B,yBAAyB,WAAW,mCAAmC,+BAA+B,uCAAuC,mCAAmC,4CAA4C,qFAAqF,oCAAoC,oFAAoF,sGAAsG,cAAc,6BAA6B,oFAAoF,mCAAmC,qDAAqD,iCAAiC,aAAa,gFAAgF,sCAAsC,WAAW,+BAA+B,oCAAoC,iCAAiC,mDAAmD,+BAA+B,kCAAkC,WAAW,UAAU,gCAAgC,qCAAqC,mFAAmF,SAAS,oCAAoC,qCAAqC,2CAA2C,SAAS,8BAA8B,iCAAiC,2BAA2B,SAAS,4BAA4B,6BAA6B,yBAAyB,SAAS,qBAAqB,2HAA2H,oCAAoC,gCAAgC,qCAAqC,mDAAmD,SAAS,8BAA8B,mCAAmC,oBAAoB,SAAS,4BAA4B,8CAA8C,iCAAiC,6GAA6G,qBAAqB,+BAA+B,sBAAsB,2BAA2B,4BAA4B,sCAAsC,sDAAsD,0BAA0B,oFAAoF,mCAAmC,sFAAsF,iCAAiC,aAAa,mBAAmB,WAAW,2GAA2G,4EAA4E,SAAS,oBAAoB,QAAQ,KAAK,mDAAmD,gCAAgC,KAAK,0CAA0C,2BAA2B,cAAc,+BAA+B,kCAAkC,SAAS,kCAAkC,gCAAgC,SAAS,sDAAsD,6BAA6B,qBAAqB,sBAAsB,wBAAwB,SAAS,6BAA6B,oFAAoF,SAAS,QAAQ,KAAK,sCAAsC,iIAAiI,KAAK,0IAA0I,sDAAsD,+CAA+C,cAAc,+BAA+B,+BAA+B,oBAAoB,SAAS,oCAAoC,yDAAyD,oCAAoC,4EAA4E,sCAAsC,+BAA+B,iCAAiC,sCAAsC,qCAAqC,sBAAsB,YAAY,oCAAoC,qDAAqD,qDAAqD,oEAAoE,sCAAsC,+BAA+B,iCAAiC,sCAAsC,sBAAsB,WAAW,6CAA6C,oBAAoB,SAAS,8BAA8B,6BAA6B,wBAAwB,SAAS,4BAA4B,2BAA2B,SAAS,QAAQ,KAAK,iEAAiE,uDAAuD,iOAAiO,KAAK,kFAAkF,YAAY,2BAA2B,8BAA8B,gCAAgC,+BAA+B,+BAA+B,+BAA+B,gCAAgC,gCAAgC,iCAAiC,gCAAgC,gCAAgC,QAAQ,wCAAwC,yCAAyC,8BAA8B,gCAAgC,+BAA+B,+BAA+B,QAAQ,MAAM,uCAAuC,OAAO,KAAK,sDAAsD,qJAAqJ,iCAAiC,2CAA2C,OAAO,OAAO,+CAA+C,2BAA2B,gIAAgI,wBAAwB,+BAA+B,0BAA0B,gMAAgM,gHAAgH,yDAAyD,gEAAgE,qGAAqG,6CAA6C,4EAA4E,sDAAsD,wFAAwF,iFAAiF,yDAAyD,aAAa,WAAW,4BAA4B,6DAA6D,SAAS,OAAO,2FAA2F,KAAK,0CAA0C,yJAAyJ,8GAA8G,gCAAgC,kDAAkD,OAAO,qCAAqC,uCAAuC,gBAAgB,iCAAiC,6BAA6B,sBAAsB,WAAW,oCAAoC,mJAAmJ,oEAAoE,6BAA6B,mDAAmD,yGAAyG,+BAA+B,+BAA+B,oDAAoD,eAAe,aAAa,6BAA6B,wBAAwB,wBAAwB,qCAAqC,qDAAqD,uDAAuD,gBAAgB,MAAM,qDAAqD,uDAAuD,mCAAmC,eAAe,8BAA8B,cAAc,wDAAwD,oBAAoB,+EAA+E,0BAA0B,oCAAoC,uCAAuC,qDAAqD,qDAAqD,qCAAqC,kBAAkB,MAAM,qDAAqD,qCAAqC,uCAAuC,qDAAqD,iBAAiB,eAAe,aAAa,iFAAiF,qDAAqD,aAAa,4CAA4C,WAAW,gCAAgC,yCAAyC,0BAA0B,WAAW,8BAA8B,8CAA8C,WAAW,UAAU,OAAO,uCAAuC,mEAAmE,yJAAyJ,6CAA6C,2LAA2L,oCAAoC,gJAAgJ,6BAA6B,iFAAiF,oCAAoC,kCAAkC,6BAA6B,0DAA0D,+CAA+C,gFAAgF,yDAAyD,8JAA8J,+DAA+D,uCAAuC,+CAA+C,SAAS,OAAO,6BAA6B,4DAA4D,iCAAiC,4BAA4B,iCAAiC,4BAA4B,oBAAoB,OAAO,KAAK,iDAAiD,+BAA+B,0HAA0H,oBAAoB,mCAAmC,gBAAgB,uBAAuB,+BAA+B,+BAA+B,UAAU,oBAAoB,+BAA+B,+BAA+B,SAAS,oBAAoB,mCAAmC,gBAAgB,uBAAuB,+BAA+B,+BAA+B,UAAU,oBAAoB,+BAA+B,+BAA+B,SAAS,oBAAoB,mCAAmC,gBAAgB,uBAAuB,+BAA+B,+BAA+B,UAAU,oBAAoB,+BAA+B,+BAA+B,SAAS,oBAAoB,mCAAmC,gBAAgB,uBAAuB,+BAA+B,+BAA+B,UAAU,oBAAoB,+BAA+B,+BAA+B,SAAS,gCAAgC,6DAA6D,gCAAgC,6DAA6D,oBAAoB,QAAQ,KAAK,mCAAmC,oCAAoC,sDAAsD,oCAAoC,6CAA6C,kCAAkC,8BAA8B,wBAAwB,SAAS,gCAAgC,qEAAqE,iGAAiG,4DAA4D,4BAA4B,SAAS,QAAQ,6DAA6D,MAAM,kDAAkD,mCAAmC,uJAAuJ,oBAAoB,qHAAqH,sCAAsC,0BAA0B,yBAAyB,yBAAyB,WAAW,mCAAmC,iCAAiC,4CAA4C,4HAA4H,sCAAsC,sCAAsC,6BAA6B,qCAAqC,uDAAuD,mCAAmC,eAAe,8BAA8B,gGAAgG,eAAe,oCAAoC,aAAa,6CAA6C,WAAW,UAAU,qCAAqC,mDAAmD,2BAA2B,OAAO,OAAO,wEAAwE,OAAO,OAAO,uBAAuB,gCAAgC,kEAAkE,gBAAgB,MAAM,mEAAmE,eAAe,oBAAoB,aAAa,WAAW,0BAA0B,SAAS,+DAA+D,4BAA4B,0JAA0J,gBAAgB,8EAA8E,cAAc,mDAAmD,YAAY,MAAM,2CAA2C,WAAW,SAAS,uCAAuC,0DAA0D,SAAS,gCAAgC,6DAA6D,SAAS,oDAAoD,8BAA8B,iCAAiC,mDAAmD,uBAAuB,qBAAqB,wBAAwB,SAAS,4BAA4B,2BAA2B,kCAAkC,qDAAqD,qDAAqD,WAAW,6BAA6B,uCAAuC,SAAS,oCAAoC,qFAAqF,qFAAqF,uCAAuC,+CAA+C,wBAAwB,sCAAsC,0BAA0B,sBAAsB,mCAAmC,qCAAqC,aAAa,YAAY,MAAM,mDAAmD,MAAM,uBAAuB,oBAAoB,gEAAgE,qBAAqB,8DAA8D,gBAAgB,oCAAoC,4BAA4B,uCAAuC,iDAAiD,iBAAiB,+CAA+C,6CAA6C,8BAA8B,gBAAgB,eAAe,qCAAqC,uCAAuC,8BAA8B,eAAe,aAAa,WAAW,iCAAiC,SAAS,oBAAoB,QAAQ,uCAAuC,kLAAkL,OAAO,gCAAgC,yCAAyC,OAAO,sCAAsC,qDAAqD,4HAA4H,OAAO,KAAK,wCAAwC,yFAAyF,mCAAmC,uEAAuE,6DAA6D,QAAQ,eAAe,KAAK,8CAA8C,iIAAiI,gCAAgC,2DAA2D,kEAAkE,OAAO,yCAAyC,0BAA0B,6GAA6G,QAAQ,qBAAqB,KAAK,0CAA0C,mDAAmD,MAAM,8BAA8B,gCAAgC,2HAA2H,MAAM,mCAAmC,oCAAoC,+GAA+G,8GAA8G,gCAAgC,mCAAmC,6BAA6B,WAAW,SAAS,yCAAyC,yCAAyC,mDAAmD,qBAAqB,iGAAiG,qBAAqB,OAAO,kDAAkD,+HAA+H,wKAAwK,QAAQ,6CAA6C,qIAAqI,gBAAgB,mCAAmC,wCAAwC,uCAAuC,uCAAuC,WAAW,+BAA+B,mCAAmC,kCAAkC,kCAAkC,WAAW,kCAAkC,sCAAsC,qCAAqC,qCAAqC,WAAW,gCAAgC,oCAAoC,mCAAmC,mCAAmC,WAAW,qCAAqC,yCAAyC,wCAAwC,wCAAwC,WAAW,mCAAmC,uCAAuC,sCAAsC,sCAAsC,WAAW,UAAU,QAAQ,2CAA2C,4DAA4D,+BAA+B,8BAA8B,8BAA8B,yBAAyB,QAAQ,uCAAuC,wDAAwD,2BAA2B,gCAAgC,0BAA0B,0DAA0D,QAAQ,2CAA2C,4DAA4D,sDAAsD,2JAA2J,qMAAqM,sMAAsM,yBAAyB,QAAQ,qCAAqC,MAAM,uEAAuE,qGAAqG,mCAAmC,6DAA6D,OAAO,+BAA+B,8FAA8F,gEAAgE,OAAO,MAAM,yCAAyC,2BAA2B,gDAAgD,0CAA0C,mCAAmC,QAAQ,kCAAkC,kDAAkD,uBAAuB,OAAO,4CAA4C,8BAA8B,QAAQ,KAAK,2FAA2F,6BAA6B,+IAA+I,6CAA6C,6DAA6D,6DAA6D,6DAA6D,6DAA6D,KAAK,kCAAkC,oEAAoE,oBAAoB,oDAAoD,wCAAwC,SAAS,4DAA4D,0CAA0C,SAAS,iCAAiC,mCAAmC,+BAA+B,SAAS,qCAAqC,qDAAqD,wBAAwB,SAAS,6BAA6B,gCAAgC,6CAA6C,wBAAwB,0BAA0B,WAAW,SAAS,QAAQ,8BAA8B,uDAAuD,OAAO,uCAAuC,0CAA0C,iCAAiC,OAAO,kCAAkC,0CAA0C,OAAO,0BAA0B,6BAA6B,OAAO,iCAAiC,6BAA6B,OAAO,oBAAoB,KAAK,gDAAgD,qKAAqK,KAAK,+BAA+B,8JAA8J,qEAAqE,OAAO,+BAA+B,6DAA6D,qEAAqE,iEAAiE,OAAO,MAAM,+CAA+C,6BAA6B,6BAA6B,0BAA0B,KAAK,6CAA6C,iBAAiB,oDAAoD,8CAA8C,mDAAmD,QAAQ,kCAAkC,yEAAyE,gDAAgD,gDAAgD,+BAA+B,mDAAmD,OAAO,KAAK,2CAA2C,2DAA2D,KAAK,6CAA6C,2BAA2B,oDAAoD,8CAA8C,+DAA+D,QAAQ,kCAAkC,yEAAyE,gDAAgD,gDAAgD,+BAA+B,4BAA4B,4CAA4C,4CAA4C,mCAAmC,mDAAmD,OAAO,gDAAgD,8BAA8B,QAAQ,KAAK,4CAA4C,4BAA4B,oBAAoB,oDAAoD,wCAAwC,SAAS,4DAA4D,0CAA0C,SAAS,iCAAiC,mCAAmC,+BAA+B,SAAS,qCAAqC,0BAA0B,wBAAwB,SAAS,gCAAgC,8BAA8B,6CAA6C,+CAA+C,OAAO,uCAAuC,+BAA+B,iCAAiC,OAAO,kCAAkC,+BAA+B,OAAO,0BAA0B,6BAA6B,OAAO,iCAAiC,4BAA4B,OAAO,oBAAoB,KAAK,yCAAyC,+EAA+E,mCAAmC,yEAAyE,OAAO,uCAAuC,gEAAgE,8BAA8B,qCAAqC,UAAU,EAAE,OAAO,4CAA4C,sEAAsE,wBAAwB,qHAAqH,kCAAkC,2CAA2C,WAAW,mCAAmC,gCAAgC,2CAA2C,WAAW,UAAU,gCAAgC,8BAA8B,qCAAqC,SAAS,8BAA8B,mBAAmB,qCAAqC,6BAA6B,SAAS,oCAAoC,oEAAoE,oIAAoI,iCAAiC,SAAS,4BAA4B,iCAAiC,2BAA2B,SAAS,8BAA8B,sBAAsB,qCAAqC,qCAAqC,SAAS,oCAAoC,0FAA0F,qCAAqC,SAAS,4BAA4B,mGAAmG,qCAAqC,oBAAoB,SAAS,wBAAwB,OAAO,gGAAgG,+DAA+D,uCAAuC,sTAAsT,qIAAqI,mGAAmG,mCAAmC,yFAAyF,WAAW,SAAS,OAAO,0CAA0C,wDAAwD,4CAA4C,wBAAwB,QAAQ,sBAAsB,KAAK,8BAA8B,4FAA4F,+BAA+B,uBAAuB,wHAAwH,iGAAiG,+CAA+C,SAAS,sCAAsC,OAAO,sCAAsC,+BAA+B,kEAAkE,kCAAkC,QAAQ,0CAA0C,8LAA8L,sEAAsE,iVAAiV,QAAQ,wCAAwC,8GAA8G,oEAAoE,8GAA8G,QAAQ,uCAAuC,mDAAmD,qGAAqG,uBAAuB,QAAQ,oCAAoC,gDAAgD,wGAAwG,4FAA4F,uBAAuB,QAAQ,wCAAwC,oDAAoD,8FAA8F,oBAAoB,QAAQ,wBAAwB,2BAA2B,oBAAoB,OAAO,mEAAmE,MAAM,kDAAkD,wDAAwD,6DAA6D,QAAQ,EAAE,iCAAiC,8DAA8D,QAAQ,KAAK,4CAA4C,cAAc,oCAAoC,yDAAyD,6DAA6D,2BAA2B,SAAS,QAAQ,MAAM,yCAAyC,2BAA2B,KAAK,kCAAkC,+BAA+B,kCAAkC,OAAO,2BAA2B,6BAA6B,OAAO,8BAA8B,gCAAgC,OAAO,4BAA4B,8BAA8B,OAAO,iCAAiC,mCAAmC,OAAO,+BAA+B,iCAAiC,OAAO,MAAM,qDAAqD,cAAc,iDAAiD,0BAA0B,SAAS,gCAAgC,6BAA6B,SAAS,8BAA8B,2BAA2B,SAAS,mCAAmC,gCAAgC,SAAS,iCAAiC,8BAA8B,SAAS,QAAQ,KAAK,0CAA0C,wDAAwD,2CAA2C,mDAAmD,uBAAuB,QAAQ,IAAI,KAAK,oDAAoD,+FAA+F,8BAA8B,kDAAkD,UAAU,mLAAmL,oCAAoC,8EAA8E,wDAAwD,OAAO,gCAAgC,qFAAqF,yEAAyE,OAAO,8CAA8C,2CAA2C,sGAAsG,4BAA4B,sBAAsB,QAAQ,4CAA4C,kDAAkD,gIAAgI,4BAA4B,QAAQ,6CAA6C,mDAAmD,uBAAuB,6FAA6F,4BAA4B,QAAQ,wCAAwC,0CAA0C,eAAe,uBAAuB,QAAQ,4CAA4C,iDAAiD,kBAAkB,kBAAkB,uBAAuB,QAAQ,yCAAyC,2EAA2E,oCAAoC,oCAAoC,uBAAuB,QAAQ,yCAAyC,8FAA8F,qCAAqC,qCAAqC,wDAAwD,uBAAuB,QAAQ,8DAA8D,wBAAwB,0FAA0F,qCAAqC,+BAA+B,+BAA+B,4BAA4B,OAAO,6BAA6B,0DAA0D,0BAA0B,OAAO,yBAAyB,qDAAqD,qDAAqD,uBAAuB,QAAQ,KAAK,iDAAiD,8DAA8D,uDAAuD,QAAQ,EAAE,KAAK,6CAA6C,sBAAsB,KAAK,2CAA2C,yDAAyD,MAAM,+DAA+D,0CAA0C,uIAAuI,uCAAuC,yFAAyF,uFAAuF,OAAO,gDAAgD,gGAAgG,uFAAuF,QAAQ,qBAAqB,MAAM,8CAA8C,uDAAuD,KAAK,4DAA4D,4CAA4C,+LAA+L,KAAK,4CAA4C,+BAA+B,kEAAkE,QAAQ,KAAK,qCAAqC,mDAAmD,uDAAuD,sBAAsB,KAAK,0CAA0C,yGAAyG,iCAAiC,mIAAmI,gHAAgH,OAAO,0CAA0C,mIAAmI,gHAAgH,QAAQ,sBAAsB,KAAK,gCAAgC,+DAA+D,yBAAyB,kMAAkM,qCAAqC,mCAAmC,4CAA4C,mDAAmD,WAAW,UAAU,EAAE,gBAAgB,qEAAqE,OAAO,qCAAqC,+CAA+C,mBAAmB,sBAAsB,QAAQ,oCAAoC,8CAA8C,sGAAsG,sBAAsB,QAAQ,wCAAwC,kDAAkD,sGAAsG,sBAAsB,QAAQ,gCAAgC,MAAM,4DAA4D,2DAA2D,wDAAwD,yCAAyC,6BAA6B,gDAAgD,4CAA4C,6EAA6E,UAAU,MAAM,wCAAwC,kCAAkC,SAAS,mCAAmC,iCAAiC,aAAa,0HAA0H,SAAS,QAAQ,KAAK,8CAA8C,wCAAwC,iBAAiB,qCAAqC,mCAAmC,oFAAoF,KAAK,wCAAwC,+OAA+O,6JAA6J,MAAM,mCAAmC,2GAA2G,4BAA4B,gBAAgB,4EAA4E,OAAO,wBAAwB,oNAAoN,mCAAmC,UAAU,0FAA0F,mCAAmC,UAAU,aAAa,OAAO,oCAAoC,qDAAqD,kBAAkB,iFAAiF,UAAU,EAAE,QAAQ,sCAAsC,gBAAgB,iKAAiK,QAAQ,wCAAwC,gEAAgE,2DAA2D,QAAQ,6CAA6C,mEAAmE,qCAAqC,qCAAqC,+CAA+C,+CAA+C,gDAAgD,QAAQ,6CAA6C,mEAAmE,qCAAqC,qCAAqC,+CAA+C,+CAA+C,gDAAgD,QAAQ,sCAAsC,8DAA8D,uDAAuD,QAAQ,2CAA2C,mDAAmD,+BAA+B,yBAAyB,QAAQ,2CAA2C,mDAAmD,+BAA+B,yBAAyB,QAAQ,2CAA2C,kDAAkD,uBAAuB,4CAA4C,mDAAmD,4CAA4C,mDAAmD,yBAAyB,QAAQ,mIAAmI,MAAM,8CAA8C,sDAAsD,4BAA4B,qCAAqC,0BAA0B,UAAU,EAAE,QAAQ,KAAK,8CAA8C,sDAAsD,4BAA4B,qCAAqC,0BAA0B,UAAU,EAAE,QAAQ,KAAK,6BAA6B,sBAAsB,KAAK,6BAA6B,sBAAsB,KAAK,kCAAkC,mEAAmE,2BAA2B,gBAAgB,0JAA0J,OAAO,sCAAsC,yHAAyH,QAAQ,uCAAuC,+CAA+C,mEAAmE,wBAAwB,QAAQ,uCAAuC,+CAA+C,mEAAmE,wBAAwB,QAAQ,uCAAuC,+CAA+C,QAAQ,sBAAsB,MAAM,qDAAqD,kIAAkI,MAAM,mDAAmD,uUAAuU,2CAA2C,uIAAuI,6GAA6G,QAAQ,cAAc,oDAAoD,QAAQ,+BAA+B,yBAAyB,KAAK,wCAAwC,2BAA2B,6CAA6C,8BAA8B,MAAM,yBAAyB,yBAAyB,qKAAqK,uCAAuC,2BAA2B,8CAA8C,wFAAwF,wCAAwC,QAAQ,0CAA0C,8DAA8D,QAAQ,kCAAkC,iIAAiI,+KAA+K,2CAA2C,OAAO,KAAK,+CAA+C,kCAAkC,iFAAiF,+DAA+D,OAAO,2CAA2C,uGAAuG,oFAAoF,QAAQ,uBAAuB,KAAK,4EAA4E,+CAA+C,KAAK,iBAAiB,oCAAoC,MAAM,EAAE,8CAA8C,4DAA4D,MAAM,kCAAkC,8EAA8E,oCAAoC,oCAAoC,KAAK,gBAAgB,gDAAgD,8DAA8D,MAAM,oCAAoC,8CAA8C,qDAAqD,2CAA2C,SAAS,8IAA8I,uCAAuC,gCAAgC,sBAAsB,+CAA+C,UAAU,MAAM,6CAA6C,SAAS,0CAA0C,oEAAoE,OAAO,yCAAyC,6EAA6E,gGAAgG,QAAQ,qBAAqB,KAAK,0CAA0C,mDAAmD,MAAM,8BAA8B,gDAAgD,gIAAgI,wDAAwD,gCAAgC,sBAAsB,oEAAoE,OAAO,yCAAyC,yBAAyB,iGAAiG,QAAQ,qBAAqB,KAAK,4CAA4C,qDAAqD,MAAM,gCAAgC,kEAAkE,0BAA0B,KAAK,cAAc,oCAAoC,kDAAkD,MAAM,wBAAwB,sCAAsC,0DAA0D,KAAK,+CAA+C,2DAA2D,MAAM,mDAAmD,0HAA0H,4BAA4B,4CAA4C,iEAAiE,QAAQ,gCAAgC,gDAAgD,iEAAiE,QAAQ,oCAAoC,iDAAiD,wBAAwB,uCAAuC,iDAAiD,6EAA6E,WAAW,UAAU,sBAAsB,mBAAmB,SAAS,iBAAiB,QAAQ,kCAAkC,KAAK,oCAAoC,0DAA0D,MAAM,wBAAwB,4DAA4D,eAAe,KAAK,cAAc,wCAAwC,sDAAsD,MAAM,4BAA4B,uEAAuE,kCAAkC,KAAK,iBAAiB,gCAAgC,MAAM,EAAE,yCAAyC,uDAAuD,MAAM,6BAA6B,gDAAgD,2DAA2D,KAAK,yDAAyD,4DAA4D,MAAM,8CAA8C,sIAAsI,yCAAyC,iFAAiF,QAAQ,yCAAyC,gIAAgI,QAAQ,oCAAoC,MAAM,kCAAkC,iBAAiB,kCAAkC,kBAAkB,KAAK,kCAAkC,kBAAkB,KAAK,yCAAyC,iDAAiD,sDAAsD,6BAA6B,yCAAyC,4GAA4G,qBAAqB,OAAO,OAAO,2FAA2F,SAAS,yCAAyC,qBAAqB,OAAO,4DAA4D,4FAA4F,4HAA4H,oCAAoC,QAAQ,gDAAgD,6BAA6B,8BAA8B,gDAAgD,uBAAuB,OAAO,8BAA8B,sDAAsD,QAAQ,8BAA8B,sDAAsD,QAAQ,kBAAkB,MAAM,0CAA0C,qDAAqD,uBAAuB,OAAO,OAAO,0GAA0G,uBAAuB,OAAO,iCAAiC,KAAK,wCAAwC,wCAAwC,KAAK,+CAA+C,2DAA2D,yBAAyB,MAAM,kEAAkE,gDAAgD,gEAAgE,yBAAyB,cAAc,oBAAoB,0CAA0C,OAAO,uBAAuB,MAAM,uDAAuD,uEAAuE,4DAA4D,yBAAyB,cAAc,oBAAoB,sCAAsC,iCAAiC,iCAAiC,OAAO,8BAA8B,MAAM,yDAAyD,oJAAoJ,yBAAyB,gCAAgC,2BAA2B,oBAAoB,qDAAqD,eAAe,2BAA2B,uBAAuB,mDAAmD,sDAAsD,qEAAqE,aAAa,8BAA8B,YAAY,8CAA8C,mEAAmE,WAAW,gBAAgB,SAAS,iDAAiD,cAAc,OAAO,qBAAqB,MAAM,+CAA+C,mFAAmF,KAAK,qDAAqD,qMAAqM,8CAA8C,KAAK,mDAAmD,sEAAsE,6CAA6C,KAAK,8LAA8L,qCAAqC,0CAA0C,iDAAiD,KAAK,iDAAiD,+EAA+E,wBAAwB,mBAAmB,KAAK,kDAAkD,2CAA2C,6CAA6C,6CAA6C,2CAA2C,KAAK,kDAAkD,wEAAwE,sCAAsC,+DAA+D,0CAA0C,0BAA0B,8FAA8F,0BAA0B,qCAAqC,2CAA2C,wBAAwB,OAAO,mCAAmC,0CAA0C,sBAAsB,8FAA8F,sBAAsB,kCAAkC,2CAA2C,oBAAoB,OAAO,gCAAgC,0CAA0C,4CAA4C,sBAAsB,cAAc,UAAU,kCAAkC,sCAAsC,6EAA6E,OAAO,6BAA6B,qCAAqC,kFAAkF,0CAA0C,0CAA0C,KAAK,8CAA8C,gGAAgG,sBAAsB,mEAAmE,sCAAsC,MAAM,sEAAsE,0BAA0B,4BAA4B,0BAA0B,oBAAoB,aAAa,0BAA0B,YAAY,MAAM,6BAA6B,4BAA4B,0BAA0B,cAAc,sBAAsB,0BAA0B,4BAA4B,cAAc,MAAM,iCAAiC,aAAa,kBAAkB,WAAW,SAAS,OAAO,sDAAsD,oDAAoD,mCAAmC,4BAA4B,4CAA4C,uDAAuD,sDAAsD,sFAAsF,4CAA4C,4CAA4C,eAAe,OAAO,oBAAoB,0EAA0E,eAAe,OAAO,0CAA0C,0CAA0C,+OAA+O,2FAA2F,mEAAmE,2EAA2E,yEAAyE,0CAA0C,0CAA0C,KAAK,8DAA8D,oFAAoF,gCAAgC,uBAAuB,oCAAoC,uBAAuB,oEAAoE,iCAAiC,0EAA0E,qJAAqJ,mCAAmC,KAAK,+DAA+D,uBAAuB,0EAA0E,0BAA0B,sDAAsD,KAAK,0CAA0C,uBAAuB,sBAAsB,KAAK,wDAAwD,qEAAqE,6BAA6B,yCAAyC,mEAAmE,OAAO,qDAAqD,8BAA8B,MAAM,kDAAkD,6MAA6M,yBAAyB,4BAA4B,iDAAiD,+BAA+B,sCAAsC,sBAAsB,0CAA0C,mEAAmE,0FAA0F,2DAA2D,+JAA+J,+EAA+E,uCAAuC,+EAA+E,uCAAuC,+EAA+E,uCAAuC,+EAA+E,8BAA8B,yBAAyB,WAAW,SAAS,OAAO,KAAK,mDAAmD,+BAA+B,KAAK,sCAAsC,0CAA0C,8DAA8D,KAAK,iDAAiD,qCAAqC,mCAAmC,iEAAiE,oCAAoC,iHAAiH,wCAAwC,6BAA6B,oIAAoI,kFAAkF,uBAAuB,0BAA0B,wBAAwB,iDAAiD,qBAAqB,0BAA0B,yDAAyD,sBAAsB,+EAA+E,uCAAuC,MAAM,4BAA4B,kBAAkB,WAAW,UAAU,MAAM,uCAAuC,MAAM,0BAA0B,kBAAkB,WAAW,SAAS,OAAO,sDAAsD,yDAAyD,KAAK,iDAAiD,8BAA8B,qBAAqB,+DAA+D,gDAAgD,iDAAiD,8CAA8C,0BAA0B,OAAO,KAAK,iDAAiD,+IAA+I,qBAAqB,qBAAqB,+HAA+H,2BAA2B,+BAA+B,SAAS,OAAO,KAAK,yDAAyD,sBAAsB,4BAA4B,8OAA8O,wBAAwB,0CAA0C,wBAAwB,2BAA2B,gDAAgD,8BAA8B,gBAAgB,+CAA+C,UAAU,MAAM,2BAA2B,gDAAgD,6BAA6B,gBAAgB,+CAA+C,SAAS,QAAQ,MAAM,uCAAuC,0BAA0B,kCAAkC,0BAA0B,6BAA6B,oEAAoE,8BAA8B,kBAAkB,mEAAmE,YAAY,MAAM,6BAA6B,oEAAoE,6BAA6B,kBAAkB,mEAAmE,WAAW,UAAU,MAAM,0BAA0B,6BAA6B,gEAAgE,8BAA8B,kBAAkB,+DAA+D,YAAY,MAAM,6BAA6B,gEAAgE,6BAA6B,kBAAkB,+DAA+D,WAAW,SAAS,OAAO,kBAAkB,kBAAkB,kBAAkB,KAAK,kDAAkD,qBAAqB,qBAAqB,6BAA6B,KAAK,gEAAgE,yDAAyD,wCAAwC,oEAAoE,oEAAoE,oGAAoG,oGAAoG,kBAAkB,KAAK,+DAA+D,wDAAwD,kBAAkB,kBAAkB,wCAAwC,kBAAkB,KAAK,sEAAsE,iCAAiC,wBAAwB,uBAAuB,uBAAuB,QAAQ,8BAA8B,wBAAwB,QAAQ,MAAM,wBAAwB,OAAO,KAAK,4DAA4D,mCAAmC,uBAAuB,wBAAwB,mLAAmL,KAAK,yCAAyC,yBAAyB,qEAAqE,OAAO,wBAAwB,qEAAqE,OAAO,MAAM,4CAA4C,oBAAoB,KAAK,kDAAkD,iEAAiE,KAAK,6CAA6C,uCAAuC,mCAAmC,sBAAsB,yBAAyB,2BAA2B,0CAA0C,yBAAyB,0BAA0B,4BAA4B,8CAA8C,2BAA2B,YAAY,MAAM,2BAA2B,WAAW,yBAAyB,UAAU,oBAAoB,yDAAyD,wBAAwB,yBAAyB,mCAAmC,yBAAyB,UAAU,MAAM,iCAAiC,wBAAwB,wBAAwB,SAAS,+BAA+B,wBAAwB,sBAAsB,qBAAqB,sCAAsC,6BAA6B,uCAAuC,8BAA8B,qCAAqC,yCAAyC,+BAA+B,8BAA8B,cAAc,MAAM,yCAAyC,kEAAkE,+BAA+B,iCAAiC,eAAe,+BAA+B,+BAA+B,kEAAkE,aAAa,YAAY,MAAM,8BAA8B,qCAAqC,yCAAyC,+BAA+B,8BAA8B,cAAc,MAAM,yCAAyC,mEAAmE,+BAA+B,iCAAiC,eAAe,+BAA+B,+BAA+B,iEAAiE,aAAa,WAAW,2BAA2B,SAAS,yBAAyB,OAAO,iCAAiC,wCAAwC,wCAAwC,+BAA+B,+EAA+E,mCAAmC,gCAAgC,kDAAkD,uBAAuB,oDAAoD,qBAAqB,UAAU,MAAM,wBAAwB,SAAS,8BAA8B,uBAAuB,0BAA0B,wBAAwB,wBAAwB,iCAAiC,4BAA4B,4BAA4B,0BAA0B,4BAA4B,2BAA2B,2BAA2B,YAAY,MAAM,4BAA4B,0BAA0B,0BAA0B,WAAW,UAAU,MAAM,uBAAuB,sBAAsB,SAAS,oCAAoC,0BAA0B,+BAA+B,yBAAyB,iBAAiB,SAAS,YAAY,uCAAuC,oCAAoC,+BAA+B,8BAA8B,gCAAgC,8BAA8B,gEAAgE,iCAAiC,aAAa,yEAAyE,iDAAiD,oCAAoC,iCAAiC,oEAAoE,mCAAmC,eAAe,mCAAmC,6CAA6C,gEAAgE,4BAA4B,oBAAoB,aAAa,YAAY,MAAM,+BAA+B,8BAA8B,gCAAgC,8BAA8B,iEAAiE,iCAAiC,aAAa,yEAAyE,iDAAiD,oCAAoC,iCAAiC,mEAAmE,mCAAmC,eAAe,mCAAmC,6CAA6C,iEAAiE,4BAA4B,oBAAoB,aAAa,WAAW,2BAA2B,wBAAwB,4BAA4B,UAAU,kBAAkB,mCAAmC,OAAO,MAAM,8DAA8D,6CAA6C,qBAAqB,4CAA4C,kBAAkB,QAAQ,MAAM,mBAAmB,OAAO,mBAAmB,cAAc,gBAAgB,2BAA2B,cAAc,KAAK,+DAA+D,6CAA6C,qBAAqB,4CAA4C,kBAAkB,QAAQ,MAAM,mBAAmB,OAAO,mBAAmB,cAAc,gBAAgB,2BAA2B,cAAc,KAAK,mDAAmD,qCAAqC,kBAAkB,KAAK,6CAA6C,gFAAgF,gCAAgC,uDAAuD,iEAAiE,iEAAiE,sBAAsB,4CAA4C,qGAAqG,iDAAiD,2EAA2E,4CAA4C,qCAAqC,WAAW,6BAA6B,UAAU,oBAAoB,mDAAmD,UAAU,MAAM,gBAAgB,SAAS,OAAO,sFAAsF,qBAAqB,+EAA+E,2GAA2G,qBAAqB,KAAK,iDAAiD,oCAAoC,KAAK,0CAA0C,yGAAyG,6CAA6C,gCAAgC,4IAA4I,yFAAyF,qHAAqH,8BAA8B,gCAAgC,YAAY,2HAA2H,kCAAkC,UAAU,EAAE,wBAAwB,OAAO,8BAA8B,2CAA2C,kBAAkB,4HAA4H,UAAU,EAAE,OAAO,wCAAwC,gFAAgF,kCAAkC,UAAU,yBAAyB,kBAAkB,iFAAiF,UAAU,EAAE,QAAQ,4CAA4C,2BAA2B,6EAA6E,oLAAoL,6BAA6B,oBAAoB,oBAAoB,+BAA+B,6CAA6C,4FAA4F,oEAAoE,aAAa,WAAW,UAAU,EAAE,yBAAyB,QAAQ,iCAAiC,4EAA4E,QAAQ,iCAAiC,4EAA4E,QAAQ,0CAA0C,qGAAqG,+DAA+D,uBAAuB,QAAQ,oCAAoC,sHAAsH,0DAA0D,QAAQ,qBAAqB,MAAM,qEAAqE,qDAAqD,2EAA2E,KAAK,6CAA6C,qDAAqD,MAAM,2DAA2D,yDAAyD,wCAAwC,oCAAoC,oCAAoC,6BAA6B,kBAAkB,kBAAkB,sBAAsB,SAAS,kCAAkC,OAAO,iCAAiC,4FAA4F,2BAA2B,iDAAiD,UAAU,MAAM,gDAAgD,2BAA2B,0BAA0B,qCAAqC,OAAO,OAAO,wBAAwB,uCAAuC,uCAAuC,uCAAuC,uCAAuC,2BAA2B,2BAA2B,YAAY,kBAAkB,OAAO,OAAO,6DAA6D,qCAAqC,qCAAqC,qCAAqC,qCAAqC,0BAA0B,0BAA0B,WAAW,SAAS,2CAA2C,uCAAuC,oBAAoB,uDAAuD,iDAAiD,yBAAyB,mCAAmC,+BAA+B,0DAA0D,0DAA0D,gBAAgB,MAAM,qCAAqC,2CAA2C,iEAAiE,0DAA0D,eAAe,cAAc,MAAM,4CAA4C,aAAa,YAAY,MAAM,sDAAsD,WAAW,SAAS,4DAA4D,qHAAqH,yBAAyB,oEAAoE,gCAAgC,aAAa,gCAAgC,aAAa,+CAA+C,SAAS,0CAA0C,kCAAkC,4EAA4E,UAAU,oCAAoC,+DAA+D,UAAU,uCAAuC,sFAAsF,UAAU,eAAe,2BAA2B,6BAA6B,sEAAsE,WAAW,cAAc,UAAU,8BAA8B,kCAAkC,oBAAoB,OAAO,kCAAkC,0DAA0D,QAAQ,kCAAkC,0DAA0D,QAAQ,uCAAuC,uFAAuF,mDAAmD,uEAAuE,wBAAwB,QAAQ,qCAAqC,iFAAiF,mDAAmD,yCAAyC,wBAAwB,QAAQ,sBAAsB,MAAM,2CAA2C,iBAAiB,KAAK,2CAA2C,iBAAiB,KAAK,qCAAqC,cAAc,gGAAgG,KAAK,+DAA+D,yCAAyC,gFAAgF,mFAAmF,mFAAmF,mFAAmF,mFAAmF,OAAO,KAAK,iEAAiE,gDAAgD,+CAA+C,+DAA+D,mCAAmC,qFAAqF,2CAA2C,iEAAiE,iDAAiD,iDAAiD,iCAAiC,WAAW,SAAS,kHAAkH,qDAAqD,OAAO,OAAO,0DAA0D,0DAA0D,kBAAkB,4DAA4D,kBAAkB,4DAA4D,kBAAkB,4DAA4D,kBAAkB,WAAW,SAAS,QAAQ,0BAA0B,0BAA0B,KAAK,0CAA0C,wCAAwC,sBAAsB,sBAAsB,oFAAoF,4BAA4B,mJAAmJ,QAAQ,KAAK,gDAAgD,2CAA2C,gBAAgB,QAAQ,IAAI,sBAAsB,uBAAuB,8CAA8C,UAAU,MAAM,sBAAsB,SAAS,OAAO,sBAAsB,4BAA4B,sBAAsB,SAAS,OAAO,4BAA4B,wCAAwC,iBAAiB,QAAQ,KAAK,gDAAgD,2CAA2C,qBAAqB,4BAA4B,qCAAqC,QAAQ,KAAK,gDAAgD,2CAA2C,2HAA2H,iCAAiC,wGAAwG,uCAAuC,iCAAiC,kCAAkC,iBAAiB,SAAS,kDAAkD,kCAAkC,iBAAiB,UAAU,MAAM,wBAAwB,mBAAmB,0EAA0E,EAAE,SAAS,8CAA8C,OAAO,4BAA4B,2BAA2B,gCAAgC,iBAAiB,OAAO,gEAAgE,6BAA6B,QAAQ,gBAAgB,iBAAiB,QAAQ,iCAAiC,4BAA4B,OAAO,mCAAmC,8BAA8B,QAAQ,EAAE,KAAK,kKAAkK,oCAAoC,qCAAqC,yCAAyC,kEAAkE,eAAe,KAAK,2CAA2C,uBAAuB,oUAAoU,MAAM,EAAE,8CAA8C,0CAA0C,+FAA+F,mBAAmB,QAAQ,6CAA6C,aAAa,QAAQ,kBAAkB,aAAa,QAAQ,kBAAkB,4BAA4B,qBAAqB,QAAQ,uBAAuB,iBAAiB,QAAQ,KAAK,sCAAsC,yBAAyB,MAAM,2BAA2B,+EAA+E,4BAA4B,OAAO,0BAA0B,6BAA6B,OAAO,wBAAwB,2BAA2B,OAAO,wBAAwB,2BAA2B,OAAO,2BAA2B,8BAA8B,OAAO,mFAAmF,8BAA8B,OAAO,MAAM,EAAE,gCAAgC,wHAAwH,uDAAuD,OAAO,MAAM,EAAE,gCAAgC,uHAAuH,8CAA8C,+CAA+C,uFAAuF,MAAM,iCAAiC,4BAA4B,gDAAgD,QAAQ,KAAK,mCAAmC,4BAA4B,8BAA8B,QAAQ,KAAK,mCAAmC,4BAA4B,iEAAiE,QAAQ,KAAK,gCAAgC,mBAAmB,KAAK,iCAAiC,uBAAuB,KAAK,sCAAsC,6BAA6B,6BAA6B,kCAAkC,6DAA6D,KAAK,gCAAgC,4BAA4B,gCAAgC,QAAQ,KAAK,+BAA+B,uCAAuC,KAAK,+BAA+B,2CAA2C,KAAK,kCAAkC,wCAAwC,KAAK,sCAAsC,YAAY,0CAA0C,8DAA8D,sBAAsB,4BAA4B,8EAA8E,QAAQ,KAAK,gCAAgC,4BAA4B,4BAA4B,6CAA6C,QAAQ,KAAK,kCAAkC,+MAA+M,KAAK,0CAA0C,wCAAwC,sBAAsB,sBAAsB,oFAAoF,6DAA6D,8DAA8D,gCAAgC,gCAAgC,4BAA4B,0EAA0E,QAAQ,KAAK,0CAA0C,wCAAwC,sBAAsB,sBAAsB,oFAAoF,6DAA6D,8DAA8D,gCAAgC,gCAAgC,4BAA4B,0EAA0E,QAAQ,KAAK,0CAA0C,wCAAwC,sBAAsB,sBAAsB,oFAAoF,4BAA4B,0EAA0E,QAAQ,KAAK,8CAA8C,0CAA0C,aAAa,4BAA4B,uCAAuC,QAAQ,KAAK,uCAAuC,qEAAqE,kDAAkD,+BAA+B,kDAAkD,oDAAoD,SAAS,uEAAuE,QAAQ,YAAY,MAAM,gCAAgC,wLAAwL,4CAA4C,oBAAoB,oBAAoB,iBAAiB,iBAAiB,OAAO,mGAAmG,oCAAoC,8BAA8B,6DAA6D,KAAK,kDAAkD,uIAAuI,MAAM,sCAAsC,uCAAuC,KAAK,yCAAyC,mDAAmD,gBAAgB,kBAAkB,kBAAkB,OAAO,eAAe,KAAK,6CAA6C,uBAAuB,uBAAuB,eAAe,KAAK,gCAAgC,uEAAuE,sDAAsD,8CAA8C,+CAA+C,KAAK,sDAAsD,iDAAiD,mEAAmE,iBAAiB,6EAA6E,GAAG,8EAA8E,EAAE,QAAQ,4BAA4B,8CAA8C,OAAO,KAAK,mDAAmD,wBAAwB,wCAAwC,oCAAoC,iBAAiB,2IAA2I,EAAE,QAAQ,gBAAgB,6EAA6E,OAAO,KAAK,iDAAiD,wBAAwB,iBAAiB,0IAA0I,EAAE,QAAQ,gBAAgB,4EAA4E,OAAO,KAAK,kDAAkD,iDAAiD,iGAAiG,iBAAiB,6EAA6E,GAAG,8EAA8E,EAAE,QAAQ,wCAAwC,4EAA4E,OAAO,KAAK,8CAA8C,yBAAyB,mDAAmD,gEAAgE,uDAAuD,iDAAiD,oDAAoD,mBAAmB,4BAA4B,oCAAoC,uDAAuD,8BAA8B,QAAQ,KAAK,6CAA6C,mCAAmC,4BAA4B,6BAA6B,QAAQ,KAAK,4CAA4C,mCAAmC,4BAA4B,2DAA2D,QAAQ,KAAK,mBAAmB,mCAAmC,gCAAgC,iDAAiD,yEAAyE,qBAAqB,QAAQ,MAAM,2CAA2C,8HAA8H,+BAA+B,6BAA6B,6BAA6B,OAAO,4BAA4B,6BAA6B,mCAAmC,yBAAyB,OAAO,oBAAoB,KAAK,gDAAgD,+CAA+C,gCAAgC,+BAA+B,sBAAsB,+BAA+B,OAAO,6BAA6B,uBAAuB,KAAK,0DAA0D,8BAA8B,0JAA0J,iCAAiC,2BAA2B,6BAA6B,6BAA6B,OAAO,wBAAwB,KAAK,kCAAkC,oBAAoB,gFAAgF,2BAA2B,0BAA0B,iFAAiF,oBAAoB,oBAAoB,sBAAsB,2BAA2B,wBAAwB,6BAA6B,8BAA8B,WAAW,8BAA8B,8CAA8C,iBAAiB,SAAS,2BAA2B,6CAA6C,4DAA4D,YAAY,EAAE,SAAS,8BAA8B,mDAAmD,sCAAsC,iEAAiE,cAAc,EAAE,YAAY,EAAE,SAAS,oCAAoC,sBAAsB,2BAA2B,yBAAyB,6BAA6B,2GAA2G,0CAA0C,+IAA+I,WAAW,wBAAwB,qHAAqH,uBAAuB,SAAS,eAAe,2BAA2B,oBAAoB,6BAA6B,qFAAqF,iDAAiD,0DAA0D,6EAA6E,GAAG,6EAA6E,EAAE,aAAa,WAAW,SAAS,mCAAmC,OAAO,yBAAyB,uCAAuC,gHAAgH,UAAU,EAAE,OAAO,oCAAoC,+CAA+C,4CAA4C,+BAA+B,qBAAqB,QAAQ,qCAAqC,gDAAgD,oBAAoB,+BAA+B,qBAAqB,QAAQ,wCAAwC,mDAAmD,uBAAuB,+BAA+B,qBAAqB,QAAQ,2CAA2C,sDAAsD,0BAA0B,sBAAsB,qBAAqB,QAAQ,wCAAwC,mDAAmD,uBAAuB,+BAA+B,qBAAqB,QAAQ,iCAAiC,kCAAkC,sBAAsB,QAAQ,iCAAiC,kCAAkC,sBAAsB,QAAQ,mBAAmB,MAAM,kCAAkC,oBAAoB,qVAAqV,gCAAgC,4CAA4C,sCAAsC,mGAAmG,0CAA0C,2CAA2C,yCAAyC,kCAAkC,kCAAkC,eAAe,0BAA0B,aAAa,6DAA6D,4CAA4C,gCAAgC,gCAAgC,aAAa,WAAW,8BAA8B,UAAU,OAAO,+BAA+B,wCAAwC,uBAAuB,sBAAsB,kEAAkE,EAAE,sBAAsB,SAAS,0EAA0E,qBAAqB,OAAO,OAAO,uBAAuB,uBAAuB,uBAAuB,wBAAwB,wBAAwB,oCAAoC,qFAAqF,mBAAmB,mBAAmB,6FAA6F,yBAAyB,qCAAqC,yBAAyB,WAAW,SAAS,oCAAoC,0BAA0B,0BAA0B,iBAAiB,sCAAsC,yBAAyB,mCAAmC,mCAAmC,WAAW,SAAS,uBAAuB,qFAAqF,iBAAiB,6BAA6B,4CAA4C,sCAAsC,aAAa,WAAW,SAAS,eAAe,2BAA2B,uBAAuB,0BAA0B,uBAAuB,uBAAuB,YAAY,MAAM,wDAAwD,wDAAwD,WAAW,SAAS,qBAAqB,yDAAyD,EAAE,QAAQ,mCAAmC,8CAA8C,kBAAkB,qBAAqB,QAAQ,mCAAmC,8CAA8C,kBAAkB,qBAAqB,QAAQ,kCAAkC,6CAA6C,iBAAiB,qBAAqB,QAAQ,0CAA0C,qDAAqD,0DAA0D,qBAAqB,QAAQ,0CAA0C,0CAA0C,qDAAqD,0DAA0D,qBAAqB,QAAQ,sCAAsC,iDAAiD,sBAAsB,qBAAqB,QAAQ,oCAAoC,+CAA+C,oDAAoD,qBAAqB,QAAQ,4CAA4C,qEAAqE,gCAAgC,qBAAqB,QAAQ,qCAAqC,gDAAgD,qBAAqB,qBAAqB,QAAQ,mCAAmC,4DAA4D,uBAAuB,qBAAqB,QAAQ,mCAAmC,8CAA8C,eAAe,sBAAsB,wBAAwB,sBAAsB,YAAY,MAAM,wDAAwD,wBAAwB,wEAAwE,EAAE,WAAW,UAAU,mBAAmB,wBAAwB,oEAAoE,EAAE,yCAAyC,SAAS,qBAAqB,QAAQ,gCAAgC,0FAA0F,qBAAqB,OAAO,OAAO,qCAAqC,uBAAuB,SAAS,qBAAqB,OAAO,OAAO,uBAAuB,0EAA0E,0EAA0E,4BAA4B,4BAA4B,SAAS,qBAAqB,OAAO,OAAO,uBAAuB,yDAAyD,yDAAyD,0CAA0C,0CAA0C,SAAS,uBAAuB,iEAAiE,OAAO,8DAA8D,kBAAkB,OAAO,kCAAkC,uBAAuB,iEAAiE,OAAO,8DAA8D,kBAAkB,OAAO,kCAAkC,qBAAqB,2DAA2D,OAAO,sDAAsD,kBAAkB,OAAO,0BAA0B,8CAA8C,6BAA6B,uCAAuC,yBAAyB,OAAO,OAAO,gCAAgC,aAAa,yBAAyB,OAAO,OAAO,+BAA+B,yDAAyD,yDAAyD,aAAa,WAAW,0EAA0E,mFAAmF,sCAAsC,SAAS,8BAA8B,QAAQ,iCAAiC,iCAAiC,QAAQ,+BAA+B,gCAAgC,QAAQ,+BAA+B,wMAAwM,6CAA6C,gIAAgI,QAAQ,8BAA8B,6CAA6C,uBAAuB,OAAO,+CAA+C,MAAM,4CAA4C,mBAAmB,KAAK,0CAA0C,oBAAoB,KAAK,4CAA4C,mBAAmB,6BAA6B,KAAK,2CAA2C,oBAAoB,KAAK,gEAAgE,yBAAyB,sBAAsB,yBAAyB,4DAA4D,2BAA2B,uBAAuB,oCAAoC,yDAAyD,kCAAkC,gCAAgC,gCAAgC,SAAS,OAAO,yBAAyB,2BAA2B,6CAA6C,6CAA6C,SAAS,kDAAkD,4CAA4C,+BAA+B,+BAA+B,OAAO,iCAAiC,iCAAiC,KAAK,qHAAqH,sCAAsC,mHAAmH,kCAAkC,+CAA+C,uBAAuB,kDAAkD,6BAA6B,qGAAqG,iCAAiC,gCAAgC,8CAA8C,kCAAkC,2CAA2C,aAAa,wCAAwC,mCAAmC,YAAY,MAAM,sFAAsF,iCAAiC,WAAW,SAAS,+DAA+D,6BAA6B,wEAAwE,8EAA8E,UAAU,EAAE,qBAAqB,OAAO,sCAAsC,6CAA6C,iBAAiB,yBAAyB,QAAQ,0CAA0C,iDAAiD,qBAAqB,yBAAyB,QAAQ,uCAAuC,8CAA8C,kBAAkB,yBAAyB,QAAQ,4CAA4C,sBAAsB,kEAAkE,gDAAgD,YAAY,EAAE,iEAAiE,uBAAuB,+FAA+F,mEAAmE,YAAY,EAAE,SAAS,oBAAoB,QAAQ,uBAAuB,MAAM,6DAA6D,wEAAwE,4BAA4B,8CAA8C,oBAAoB,KAAK,+DAA+D,2BAA2B,gDAAgD,yBAAyB,wEAAwE,0BAA0B,uDAAuD,SAAS,OAAO,KAAK,8DAA8D,wCAAwC,gDAAgD,4BAA4B,wEAAwE,kCAAkC,sDAAsD,SAAS,OAAO,iDAAiD,yBAAyB,OAAO,KAAK,+CAA+C,wBAAwB,KAAK,4CAA4C,qBAAqB,KAAK,8CAA8C,+BAA+B,KAAK,gDAAgD,sDAAsD,iEAAiE,kBAAkB,gEAAgE,UAAU,EAAE,QAAQ,IAAI,KAAK,sCAAsC,6DAA6D,4CAA4C,qCAAqC,mBAAmB,iCAAiC,qBAAqB,qBAAqB,oDAAoD,8BAA8B,gDAAgD,6BAA6B,iEAAiE,mBAAmB,WAAW,SAAS,OAAO,8BAA8B,4CAA4C,oDAAoD,wBAAwB,oEAAoE,SAAS,qBAAqB,OAAO,kCAAkC,iDAAiD,sEAAsE,qBAAqB,OAAO,sCAAsC,6CAA6C,iBAAiB,yBAAyB,QAAQ,+DAA+D,MAAM,gCAAgC,sGAAsG,4BAA4B,kEAAkE,4CAA4C,YAAY,0bAA0b,8FAA8F,uCAAuC,UAAU,oBAAoB,0CAA0C,UAAU,EAAE,sCAAsC,qBAAqB,8JAA8J,UAAU,EAAE,oBAAoB,OAAO,iCAAiC,8CAA8C,kBAAkB,mBAAmB,QAAQ,gCAAgC,6CAA6C,iBAAiB,mBAAmB,QAAQ,sCAAsC,mDAAmD,uBAAuB,mBAAmB,QAAQ,oCAAoC,iDAAiD,qBAAqB,mBAAmB,QAAQ,oCAAoC,iDAAiD,qBAAqB,mBAAmB,QAAQ,iBAAiB,MAAM,sCAAsC,kCAAkC,8KAA8K,qCAAqC,gDAAgD,iDAAiD,4CAA4C,UAAU,EAAE,gDAAgD,0CAA0C,oEAAoE,YAAY,EAAE,UAAU,EAAE,wDAAwD,8CAA8C,8CAA8C,0DAA0D,6CAA6C,qBAAqB,OAAO,OAAO,2EAA2E,uBAAuB,OAAO,OAAO,uFAAuF,WAAW,SAAS,oBAAoB,OAAO,oCAAoC,+CAA+C,mBAAmB,qBAAqB,QAAQ,mCAAmC,8CAA8C,8GAA8G,qBAAqB,QAAQ,oCAAoC,+CAA+C,8GAA8G,qBAAqB,QAAQ,+BAA+B,0CAA0C,cAAc,qBAAqB,QAAQ,+BAA+B,0CAA0C,cAAc,qBAAqB,QAAQ,iCAAiC,4CAA4C,gBAAgB,qBAAqB,QAAQ,mBAAmB,MAAM,oCAAoC,iBAAiB,KAAK,oCAAoC,iBAAiB,KAAK,6CAA6C,gBAAgB,cAAc,KAAK,yCAAyC,wCAAwC,yKAAyK,mCAAmC,YAAY,gDAAgD,qBAAqB,OAAO,OAAO,uBAAuB,+BAA+B,2BAA2B,2BAA2B,YAAY,MAAM,8BAA8B,8BAA8B,WAAW,SAAS,gDAAgD,OAAO,kCAAkC,iDAAiD,OAAO,qDAAqD,EAAE,0CAA0C,oCAAoC,sFAAsF,qBAAqB,OAAO,OAAO,8BAA8B,OAAO,yBAAyB,iCAAiC,yBAAyB,SAAS,qBAAqB,OAAO,OAAO,wCAAwC,SAAS,kBAAkB,OAAO,iCAAiC,gGAAgG,2BAA2B,qBAAqB,OAAO,OAAO,+BAA+B,OAAO,0BAA0B,2DAA2D,OAAO,OAAO,kFAAkF,OAAO,OAAO,+DAA+D,aAAa,qCAAqC,WAAW,6CAA6C,+BAA+B,SAAS,qBAAqB,OAAO,kBAAkB,kBAAkB,OAAO,iCAAiC,6EAA6E,qBAAqB,OAAO,OAAO,8BAA8B,OAAO,yBAAyB,gCAAgC,OAAO,0BAA0B,kBAAkB,OAAO,wBAAwB,SAAS,qBAAqB,OAAO,gBAAgB,kBAAkB,OAAO,4CAA4C,EAAE,kDAAkD,qCAAqC,KAAK,gDAAgD,8CAA8C,kCAAkC,gBAAgB,KAAK,+CAA+C,6DAA6D,aAAa,OAAO,OAAO,wCAAwC,gBAAgB,gBAAgB,SAAS,OAAO,eAAe,KAAK,4CAA4C,+CAA+C,KAAK,yCAAyC,sBAAsB,KAAK,sCAAsC,uHAAuH,qCAAqC,8OAA8O,2BAA2B,6BAA6B,iEAAiE,oBAAoB,SAAS,sBAAsB,iBAAiB,6BAA6B,0BAA0B,mDAAmD,+DAA+D,yBAAyB,kCAAkC,aAAa,WAAW,SAAS,oBAAoB,OAAO,uCAAuC,+CAA+C,mBAAmB,yBAAyB,QAAQ,uCAAuC,+CAA+C,iCAAiC,yBAAyB,QAAQ,sCAAsC,+CAA+C,8DAA8D,yDAAyD,UAAU,kBAAkB,yBAAyB,QAAQ,2CAA2C,kDAAkD,wBAAwB,yBAAyB,QAAQ,uBAAuB,MAAM,6DAA6D,yGAAyG,KAAK,sDAAsD,kEAAkE,0CAA0C,eAAe,KAAK,iDAAiD,oDAAoD,KAAK,iCAAiC,6GAA6G,6BAA6B,oLAAoL,wBAAwB,UAAU,4BAA4B,4DAA4D,8BAA8B,UAAU,EAAE,sEAAsE,wBAAwB,6FAA6F,8DAA8D,sBAAsB,YAAY,EAAE,wEAAwE,8DAA8D,sBAAsB,YAAY,EAAE,SAAS,mHAAmH,qBAAqB,OAAO,iCAAiC,6CAA6C,iBAAiB,oBAAoB,QAAQ,mCAAmC,+CAA+C,iEAAiE,oBAAoB,QAAQ,oCAAoC,gDAAgD,qBAAqB,oBAAoB,QAAQ,0DAA0D,MAAM,yCAAyC,+BAA+B,KAAK,2CAA2C,2BAA2B,uBAAuB,uBAAuB,uBAAuB,uBAAuB,KAAK,2CAA2C,uBAAuB,uBAAuB,KAAK,+CAA+C,yDAAyD,gDAAgD,KAAK,6CAA6C,wEAAwE,2GAA2G,8BAA8B,iDAAiD,iDAAiD,iDAAiD,iDAAiD,OAAO,0CAA0C,mBAAmB,iBAAiB,cAAc,iBAAiB,oBAAoB,qBAAqB,kBAAkB,gBAAgB,mBAAmB,sBAAsB,uBAAuB,yCAAyC,qBAAqB,uCAAuC,2BAA2B,uCAAuC,2BAA2B,uBAAuB,OAAO,OAAO,sDAAsD,0CAA0C,oCAAoC,SAAS,0BAA0B,uDAAuD,0BAA0B,sBAAsB,eAAe,aAAa,+BAA+B,sCAAsC,oBAAoB,0BAA0B,yDAAyD,wBAAwB,iBAAiB,eAAe,aAAa,0BAA0B,wFAAwF,sCAAsC,kBAAkB,cAAc,MAAM,2CAA2C,oBAAoB,yBAAyB,aAAa,WAAW,SAAS,OAAO,qEAAqE,mBAAmB,OAAO,OAAO,qBAAqB,kBAAkB,kBAAkB,sEAAsE,OAAO,kBAAkB,4CAA4C,KAAK,yCAAyC,+CAA+C,KAAK,2CAA2C,6BAA6B,6BAA6B,KAAK,uDAAuD,mCAAmC,+BAA+B,+BAA+B,kBAAkB,uBAAuB,wCAAwC,0EAA0E,OAAO,KAAK,6CAA6C,yDAAyD,iCAAiC,mDAAmD,iBAAiB,iBAAiB,+IAA+I,oCAAoC,oCAAoC,QAAQ,MAAM,uBAAuB,kBAAkB,OAAO,KAAK,iCAAiC,gJAAgJ,6BAA6B,8FAA8F,qFAAqF,4DAA4D,2EAA2E,MAAM,0DAA0D,mEAAmE,+CAA+C,iDAAiD,2DAA2D,YAAY,EAAE,iKAAiK,mEAAmE,0CAA0C,qCAAqC,YAAY,EAAE,SAAS,qBAAqB,OAAO,kCAAkC,qBAAqB,8DAA8D,2BAA2B,mDAAmD,kFAAkF,OAAO,OAAO,iDAAiD,uTAAuT,cAAc,WAAW,SAAS,iCAAiC,OAAO,+BAA+B,oGAAoG,gCAAgC,mCAAmC,iFAAiF,oBAAoB,+CAA+C,iCAAiC,YAAY,MAAM,2BAA2B,WAAW,UAAU,eAAe,6CAA6C,SAAS,kEAAkE,OAAO,gCAAgC,iCAAiC,0BAA0B,OAAO,4CAA4C,kBAAkB,iIAAiI,mGAAmG,4CAA4C,6CAA6C,sBAAsB,2EAA2E,8BAA8B,yFAAyF,2BAA2B,2BAA2B,aAAa,yBAAyB,yBAAyB,yBAAyB,yBAAyB,WAAW,qDAAqD,wBAAwB,+BAA+B,WAAW,oDAAoD,wBAAwB,+BAA+B,yBAAyB,WAAW,SAAS,wBAAwB,OAAO,iCAAiC,0BAA0B,sCAAsC,OAAO,uCAAuC,mDAAmD,uBAAuB,oBAAoB,QAAQ,iCAAiC,+DAA+D,0DAA0D,oBAAoB,QAAQ,qCAAqC,+DAA+D,0DAA0D,oBAAoB,QAAQ,0DAA0D,MAAM,+CAA+C,0CAA0C,KAAK,sCAAsC,gCAAgC,iDAAiD,KAAK,uCAAuC,mCAAmC,6DAA6D,KAAK,kDAAkD,2CAA2C,qBAAqB,oBAAoB,qBAAqB,oBAAoB,oBAAoB,KAAK,uCAAuC,+EAA+E,0BAA0B,wBAAwB,qBAAqB,qBAAqB,yCAAyC,OAAO,KAAK,yDAAyD,0DAA0D,KAAK,oCAAoC,iJAAiJ,gCAAgC,uFAAuF,+DAA+D,uCAAuC,8CAA8C,oDAAoD,oDAAoD,YAAY,MAAM,8EAA8E,uBAAuB,gCAAgC,WAAW,UAAU,EAAE,oLAAoL,0EAA0E,iDAAiD,iDAAiD,UAAU,oBAAoB,2DAA2D,sEAAsE,UAAU,EAAE,qBAAqB,OAAO,0CAA0C,mDAAmD,uBAAuB,uBAAuB,QAAQ,oCAAoC,+DAA+D,wCAAwC,uBAAuB,QAAQ,wCAAwC,+DAA+D,wCAAwC,uBAAuB,QAAQ,6DAA6D,MAAM,6CAA6C,sDAAsD,uBAAuB,QAAQ,EAAE,KAAK,6CAA6C,oDAAoD,2BAA2B,OAAO,wBAAwB,KAAK,4CAA4C,mCAAmC,uFAAuF,KAAK,6CAA6C,sCAAsC,oGAAoG,KAAK,oCAAoC,qNAAqN,qCAAqC,qDAAqD,2BAA2B,mEAAmE,6DAA6D,SAAS,OAAO,iCAAiC,qCAAqC,4CAA4C,yQAAyQ,6DAA6D,uBAAuB,kDAAkD,iDAAiD,mCAAmC,iFAAiF,8BAA8B,2BAA2B,cAAc,MAAM,yCAAyC,8CAA8C,+CAA+C,wCAAwC,8BAA8B,aAAa,WAAW,6BAA6B,2CAA2C,sCAAsC,WAAW,uCAAuC,SAAS,OAAO,iCAAiC,qCAAqC,4CAA4C,gFAAgF,6DAA6D,uBAAuB,6CAA6C,8BAA8B,mCAAmC,oCAAoC,oFAAoF,wCAAwC,aAAa,WAAW,uCAAuC,SAAS,OAAO,gCAAgC,+EAA+E,2BAA2B,+CAA+C,mCAAmC,mCAAmC,SAAS,eAAe,eAAe,yFAAyF,OAAO,gDAAgD,iGAAiG,6BAA6B,kDAAkD,6BAA6B,uBAAuB,oBAAoB,oBAAoB,qBAAqB,sFAAsF,WAAW,qBAAqB,uCAAuC,sBAAsB,uBAAuB,UAAU,MAAM,kDAAkD,6BAA6B,uBAAuB,oBAAoB,oBAAoB,qBAAqB,sFAAsF,WAAW,sBAAsB,uCAAuC,sBAAsB,uBAAuB,SAAS,OAAO,6BAA6B,gEAAgE,4BAA4B,gEAAgE,2BAA2B,kDAAkD,0DAA0D,mDAAmD,uCAAuC,qBAAqB,OAAO,oCAAoC,6CAA6C,iBAAiB,uBAAuB,QAAQ,uCAAuC,gDAAgD,sCAAsC,sDAAsD,2IAA2I,SAAS,sCAAsC,iDAAiD,SAAS,iBAAiB,uMAAuM,uBAAuB,QAAQ,qCAAqC,wDAAwD,wCAAwC,uBAAuB,QAAQ,sCAAsC,+CAA+C,mBAAmB,wBAAwB,uBAAuB,QAAQ,qCAAqC,8CAA8C,kBAAkB,uBAAuB,QAAQ,oCAAoC,6CAA6C,wBAAwB,uBAAuB,QAAQ,6DAA6D,MAAM,+CAA+C,cAAc,mFAAmF,KAAK,oDAAoD,2IAA2I,qBAAqB,oBAAoB,eAAe,OAAO,qBAAqB,oBAAoB,eAAe,OAAO,cAAc,+DAA+D,KAAK,iBAAiB,gCAAgC,iCAAiC,2BAA2B,2BAA2B,2BAA2B,sBAAsB,cAAc,sCAAsC,sCAAsC,8BAA8B,YAAY,sBAAsB,iEAAiE,UAAU,OAAO,8BAA8B,6DAA6D,2BAA2B,sCAAsC,UAAU,OAAO,6BAA6B,8CAA8C,2BAA2B,8BAA8B,UAAU,OAAO,iCAAiC,2BAA2B,kCAAkC,OAAO,yBAAyB,mBAAmB,UAAU,OAAO,MAAM,kBAAkB,uCAAuC,8DAA8D,8DAA8D,KAAK,qCAAqC,uFAAuF,KAAK,6EAA6E,2FAA2F,4BAA4B,2BAA2B,QAAQ,KAAK,4CAA4C,+EAA+E,sBAAsB,kCAAkC,kCAAkC,OAAO,oCAAoC,mCAAmC,oBAAoB,KAAK,wCAAwC,qBAAqB,8BAA8B,+CAA+C,SAAS,8BAA8B,8CAA8C,SAAS,QAAQ,wBAAwB,KAAK,iCAAiC,sDAAsD,+EAA+E,iFAAiF,oCAAoC,0CAA0C,wCAAwC,OAAO,0BAA0B,4DAA4D,wDAAwD,OAAO,4BAA4B,iDAAiD,iCAAiC,QAAQ,KAAK,kCAAkC,0EAA0E,MAAM,mEAAmE,wBAAwB,0BAA0B,mLAAmL,qEAAqE,uEAAuE,qBAAqB,OAAO,2BAA2B,2BAA2B,OAAO,oCAAoC,0BAA0B,QAAQ,oCAAoC,+CAA+C,iCAAiC,yBAAyB,QAAQ,mCAAmC,8CAA8C,kBAAkB,yBAAyB,QAAQ,wCAAwC,mEAAmE,QAAQ,mCAAmC,8CAA8C,kBAAkB,yBAAyB,QAAQ,yCAAyC,oDAAoD,wBAAwB,yBAAyB,QAAQ,mCAAmC,iDAAiD,QAAQ,gDAAgD,8DAA8D,QAAQ,kCAAkC,yCAAyC,yBAAyB,QAAQ,+BAA+B,oEAAoE,QAAQ,uBAAuB,KAAK,qDAAqD,+FAA+F,KAAK,+CAA+C,6FAA6F,6FAA6F,oBAAoB,KAAK,oDAAoD,8BAA8B,wKAAwK,oCAAoC,kCAAkC,iCAAiC,uDAAuD,oEAAoE,uBAAuB,oBAAoB,KAAK,gDAAgD,yEAAyE,KAAK,6DAA6D,wDAAwD,qBAAqB,gDAAgD,sBAAsB,mCAAmC,uFAAuF,mGAAmG,2BAA2B,mDAAmD,gCAAgC,+DAA+D,YAAY,SAAS,8FAA8F,oCAAoC,QAAQ,MAAM,uEAAuE,OAAO,iCAAiC,KAAK,4CAA4C,4DAA4D,gDAAgD,gEAAgE,KAAK,4DAA4D,mDAAmD,oMAAoM,KAAK,+BAA+B,uFAAuF,MAAM,6DAA6D,yBAAyB,yGAAyG,OAAO,yBAAyB,sEAAsE,OAAO,2BAA2B,kCAAkC,OAAO,oCAAoC,yCAAyC,QAAQ,oCAAoC,+CAA+C,6BAA6B,iEAAiE,qBAAqB,QAAQ,kCAAkC,6CAA6C,kBAAkB,2CAA2C,qBAAqB,QAAQ,+BAA+B,mGAAmG,+BAA+B,kCAAkC,qBAAqB,QAAQ,gCAAgC,wKAAwK,kCAAkC,2BAA2B,mBAAmB,OAAO,uBAAuB,OAAO,iCAAiC,mCAAmC,YAAY,MAAM,mCAAmC,mBAAmB,SAAS,uBAAuB,OAAO,iCAAiC,WAAW,uBAAuB,cAAc,QAAQ,kCAAkC,kBAAkB,QAAQ,sCAAsC,SAAS,qBAAqB,QAAQ,gDAAgD,2DAA2D,iEAAiE,wEAAwE,+DAA+D,8BAA8B,oDAAoD,gDAAgD,6CAA6C,UAAU,QAAQ,+BAA+B,qEAAqE,QAAQ,oDAAoD,KAAK,+EAA+E,4BAA4B,gCAAgC,OAAO,4BAA4B,iCAAiC,OAAO,MAAM,+BAA+B,4DAA4D,MAAM,uDAAuD,qFAAqF,2BAA2B,mCAAmC,OAAO,oCAAoC,0CAA0C,QAAQ,oCAAoC,+CAA+C,kEAAkE,qBAAqB,QAAQ,mCAAmC,iDAAiD,QAAQ,gDAAgD,8DAA8D,QAAQ,kCAAkC,gEAAgE,QAAQ,sCAAsC,iDAAiD,+CAA+C,+CAA+C,4CAA4C,qBAAqB,QAAQ,+BAA+B,+DAA+D,QAAQ,oDAAoD,KAAK,mCAAmC,4BAA4B,6DAA6D,QAAQ,KAAK,gCAAgC,2CAA2C,MAAM,mCAAmC,oCAAoC,8CAA8C,EAAE,MAAM,iDAAiD,kCAAkC,2BAA2B,uIAAuI,OAAO,qCAAqC,6DAA6D,kCAAkC,UAAU,EAAE,OAAO,oCAAoC,+CAA+C,oBAAoB,6BAA6B,qCAAqC,4FAA4F,wDAAwD,QAAQ,mCAAmC,8CAA8C,kBAAkB,sBAAsB,kBAAkB,uDAAuD,qBAAqB,QAAQ,kDAAkD,gDAAgD,kKAAkK,0DAA0D,sBAAsB,kBAAkB,6DAA6D,qBAAqB,QAAQ,uDAAuD,gDAAgD,2LAA2L,wIAAwI,sBAAsB,kBAAkB,kEAAkE,qBAAqB,QAAQ,+DAA+D,gDAAgD,2DAA2D,2JAA2J,2DAA2D,uCAAuC,2CAA2C,kBAAkB,4DAA4D,qBAAqB,QAAQ,oEAAoE,gDAAgD,2DAA2D,yKAAyK,+GAA+G,uCAAuC,yDAAyD,kBAAkB,iEAAiE,qBAAqB,QAAQ,oCAAoC,yBAAyB,QAAQ,sCAAsC,6CAA6C,QAAQ,+BAA+B,kDAAkD,QAAQ,oCAAoC,KAAK,sCAAsC,uDAAuD,MAAM,sCAAsC,uDAAuD,MAAM,uCAAuC,wDAAwD,MAAM,uCAAuC,wDAAwD,MAAM,6IAA6I,iPAAiP,gPAAgP,iPAAiP,oCAAoC,yCAAyC,MAAM,iDAAiD,qBAAqB,0BAA0B,oCAAoC,wBAAwB,2EAA2E,qBAAqB,OAAO,2BAA2B,yEAAyE,OAAO,oCAAoC,+CAA+C,8EAA8E,yBAAyB,QAAQ,mCAAmC,8CAA8C,kBAAkB,yBAAyB,QAAQ,oCAAoC,0BAA0B,QAAQ,0CAA0C,+BAA+B,mJAAmJ,QAAQ,+BAA+B,kDAAkD,QAAQ,uBAAuB,KAAK,oCAAoC,iDAAiD,MAAM,iDAAiD,gBAAgB,2BAA2B,kFAAkF,OAAO,0BAA0B,wCAAwC,6BAA6B,qBAAqB,OAAO,oCAAoC,mDAAmD,mBAAmB,8BAA8B,yBAAyB,QAAQ,mCAAmC,8CAA8C,kBAAkB,yBAAyB,QAAQ,0CAA0C,+BAA+B,sCAAsC,iCAAiC,QAAQ,+BAA+B,kDAAkD,QAAQ,uBAAuB,KAAK,qCAAqC,oDAAoD,MAAM,kDAAkD,2BAA2B,2DAA2D,OAAO,oCAAoC,+CAA+C,mBAAmB,qBAAqB,QAAQ,mCAAmC,8CAA8C,kBAAkB,qBAAqB,QAAQ,0CAA0C,+BAA+B,4CAA4C,QAAQ,+BAA+B,mDAAmD,QAAQ,mBAAmB,KAAK,oCAAoC,2CAA2C,MAAM,0CAA0C,8BAA8B,kBAAkB,OAAO,iCAAiC,wDAAwD,+CAA+C,mCAAmC,wBAAwB,QAAQ,sCAAsC,iDAAiD,QAAQ,mDAAmD,8DAA8D,QAAQ,kCAAkC,2CAA2C,QAAQ,sBAAsB,KAAK,gBAAgB,wBAAwB,eAAe,KAAK,6BAA6B,wOAAwO,sBAAsB,mRAAmR,iDAAiD,6GAA6G,sFAAsF,qEAAqE,mHAAmH,8BAA8B,6DAA6D,6DAA6D,SAAS,mBAAmB,wCAAwC,wCAAwC,wCAAwC,wCAAwC,6DAA6D,sEAAsE,qCAAqC,qCAAqC,qCAAqC,2BAA2B,WAAW,UAAU,MAAM,sBAAsB,SAAS,mBAAmB,wCAAwC,wCAAwC,wCAAwC,wCAAwC,6DAA6D,0EAA0E,qCAAqC,qCAAqC,qCAAqC,2BAA2B,WAAW,UAAU,MAAM,sBAAsB,SAAS,sHAAsH,oCAAoC,iCAAiC,yBAAyB,4YAA4Y,2DAA2D,2DAA2D,WAAW,6BAA6B,uLAAuL,+BAA+B,sRAAsR,cAAc,MAAM,+FAA+F,aAAa,YAAY,MAAM,8CAA8C,WAAW,6BAA6B,yLAAyL,+BAA+B,sRAAsR,cAAc,MAAM,+FAA+F,aAAa,YAAY,MAAM,8CAA8C,WAAW,UAAU,MAAM,4CAA4C,4GAA4G,4CAA4C,gHAAgH,SAAS,2BAA2B,iCAAiC,OAAO,wCAAwC,iJAAiJ,OAAO,uCAAuC,oDAAoD,sCAAsC,mBAAmB,QAAQ,uCAAuC,oDAAoD,sCAAsC,mBAAmB,QAAQ,wCAAwC,qDAAqD,uCAAuC,mBAAmB,QAAQ,qCAAqC,kDAAkD,2EAA2E,mBAAmB,QAAQ,sCAAsC,mDAAmD,qCAAqC,mBAAmB,QAAQ,oCAAoC,iDAAiD,mCAAmC,mBAAmB,QAAQ,oCAAoC,iDAAiD,mCAAmC,mBAAmB,QAAQ,iCAAiC,qMAAqM,wDAAwD,QAAQ,iBAAiB,MAAM,kCAAkC,yCAAyC,2BAA2B,KAAK,yCAAyC,2BAA2B,KAAK,wCAAwC,0BAA0B,KAAK,sCAAsC,wBAAwB,KAAK,sCAAsC,6BAA6B,KAAK,gDAAgD,6DAA6D,KAAK,6DAA6D,mmBAAmmB,gFAAgF,wEAAwE,KAAK,wCAAwC,qJAAqJ,6BAA6B,+GAA+G,4BAA4B,+EAA+E,SAAS,2BAA2B,uDAAuD,8EAA8E,YAAY,2BAA2B,sBAAsB,wBAAwB,WAAW,SAAS,uCAAuC,8DAA8D,OAAO,8BAA8B,0CAA0C,cAAc,oBAAoB,QAAQ,8BAA8B,0CAA0C,cAAc,oBAAoB,QAAQ,oCAAoC,gDAAgD,oBAAoB,oBAAoB,QAAQ,wCAAwC,uDAAuD,2EAA2E,mGAAmG,oBAAoB,QAAQ,oCAAoC,gDAAgD,oBAAoB,oBAAoB,QAAQ,kBAAkB,KAAK,8BAA8B,wCAAwC,MAAM,4CAA4C,ghBAAghB,EAAE,8DAA8D,sBAAsB,4CAA4C,MAAM,EAAE,0CAA0C,uEAAuE,KAAK,gDAAgD,0CAA0C,KAAK,wCAAwC,gFAAgF,6FAA6F,4CAA4C,+BAA+B,KAAK,8CAA8C,gFAAgF,8EAA8E,+BAA+B,KAAK,6CAA6C,gFAAgF,8EAA8E,+BAA+B,KAAK,yDAAyD,uKAAuK,KAAK,2DAA2D,wPAAwP,KAAK,qDAAqD,wJAAwJ,KAAK,qDAAqD,8GAA8G,2CAA2C,OAAO,gIAAgI,mBAAmB,kHAAkH,uBAAuB,eAAe,OAAO,kCAAkC,wBAAwB,uBAAuB,aAAa,wJAAwJ,yBAAyB,qBAAqB,aAAa,yBAAyB,0BAA0B,kGAAkG,SAAS,OAAO,mBAAmB,4BAA4B,kHAAkH,OAAO,kBAAkB,KAAK,6DAA6D,+GAA+G,yBAAyB,gBAAgB,gBAAgB,uBAAuB,0EAA0E,OAAO,sBAAsB,KAAK,yCAAyC,kEAAkE,2RAA2R,mCAAmC,0BAA0B,uBAAuB,mBAAmB,yBAAyB,mBAAmB,yBAAyB,+CAA+C,OAAO,mBAAmB,6BAA6B,+BAA+B,KAAK,6CAA6C,kEAAkE,2EAA2E,yBAAyB,uBAAuB,yBAAyB,yBAAyB,OAAO,2HAA2H,UAAU,yBAAyB,uBAAuB,mBAAmB,yBAAyB,mBAAmB,yBAAyB,+CAA+C,OAAO,+BAA+B,KAAK,+CAA+C,2EAA2E,yBAAyB,2BAA2B,yBAAyB,yBAAyB,OAAO,uHAAuH,UAAU,yBAAyB,2BAA2B,mBAAmB,yBAAyB,mBAAmB,yBAAyB,+CAA+C,OAAO,+BAA+B,KAAK,mDAAmD,gCAAgC,gBAAgB,+GAA+G,4BAA4B,wBAAwB,oBAAoB,oEAAoE,oEAAoE,SAAS,OAAO,wCAAwC,KAAK,sCAAsC,mEAAmE,KAAK,iKAAiK,mDAAmD,sVAAsV,KAAK,yCAAyC,mDAAmD,KAAK,qDAAqD,sHAAsH,yBAAyB,mFAAmF,OAAO,eAAe,eAAe,KAAK,oDAAoD,+GAA+G,yBAAyB,yDAAyD,6BAA6B,8BAA8B,UAAU,MAAM,uBAAuB,2BAA2B,4BAA4B,wBAAwB,uCAAuC,yBAAyB,6BAA6B,WAAW,SAAS,OAAO,aAAa,0BAA0B,gHAAgH,mDAAmD,OAAO,sBAAsB,KAAK,4CAA4C,+IAA+I,KAAK,qCAAqC,kDAAkD,0CAA0C,yCAAyC,kBAAkB,MAAM,0CAA0C,iDAAiD,yBAAyB,0BAA0B,qBAAqB,6BAA6B,qCAAqC,qCAAqC,OAAO,oBAAoB,KAAK,wCAAwC,iOAAiO,6BAA6B,iKAAiK,qBAAqB,YAAY,kDAAkD,qBAAqB,YAAY,yBAAyB,4BAA4B,0JAA0J,SAAS,2BAA2B,uDAAuD,yFAAyF,iFAAiF,YAAY,4BAA4B,sBAAsB,yBAAyB,yBAAyB,WAAW,SAAS,wCAAwC,8DAA8D,OAAO,8BAA8B,2CAA2C,oBAAoB,oBAAoB,QAAQ,+BAA+B,2CAA2C,eAAe,oBAAoB,QAAQ,+BAA+B,2CAA2C,eAAe,oBAAoB,QAAQ,8BAA8B,2CAA2C,oBAAoB,oBAAoB,QAAQ,+BAA+B,2CAA2C,eAAe,oBAAoB,QAAQ,+BAA+B,2CAA2C,eAAe,oBAAoB,QAAQ,oCAAoC,gDAAgD,oBAAoB,oBAAoB,QAAQ,wCAAwC,uDAAuD,2EAA2E,mGAAmG,gEAAgE,+CAA+C,oBAAoB,QAAQ,oCAAoC,gDAAgD,oBAAoB,oBAAoB,QAAQ,kBAAkB,KAAK,yDAAyD,yDAAyD,8BAA8B,wCAAwC,MAAM,qCAAqC,kDAAkD,0CAA0C,iDAAiD,iDAAiD,yCAAyC,gDAAgD,8CAA8C,kBAAkB,MAAM,+BAA+B,gJAAgJ,8BAA8B,mFAAmF,yNAAyN,OAAO,0CAA0C,sLAAsL,gBAAgB,4KAA4K,OAAO,+BAA+B,4CAA4C,OAAO,+BAA+B,0EAA0E,OAAO,wCAAwC,+BAA+B,OAAO,oCAAoC,+CAA+C,iCAAiC,qBAAqB,QAAQ,oCAAoC,+CAA+C,iCAAiC,qBAAqB,QAAQ,oCAAoC,+CAA+C,iCAAiC,qBAAqB,QAAQ,wCAAwC,mDAAmD,qCAAqC,qBAAqB,QAAQ,sCAAsC,iDAAiD,mCAAmC,qBAAqB,QAAQ,mBAAmB,MAAM,sCAAsC,sBAAsB,KAAK,kCAAkC,yFAAyF,iCAAiC,gHAAgH,yCAAyC,GAAG,yCAAyC,OAAO,gCAAgC,yEAAyE,OAAO,uCAAuC,+CAA+C,iCAAiC,wBAAwB,QAAQ,uCAAuC,+CAA+C,iCAAiC,wBAAwB,QAAQ,2CAA2C,mDAAmD,uBAAuB,wBAAwB,QAAQ,sBAAsB,MAAM,6CAA6C,0BAA0B,KAAK,yCAAyC,kHAAkH,2CAA2C,gHAAgH,QAAQ,sBAAsB,MAAM,4DAA4D,yBAAyB,gFAAgF,wDAAwD,QAAQ,KAAK,gCAAgC,6DAA6D,+BAA+B,mHAAmH,OAAO,mCAAmC,6CAA6C,+BAA+B,sBAAsB,QAAQ,mCAAmC,6CAA6C,+BAA+B,sBAAsB,QAAQ,oBAAoB,MAAM,kCAAkC,gBAAgB,KAAK,kCAAkC,wBAAwB,KAAK,0CAA0C,oCAAoC,0HAA0H,KAAK,kCAAkC,iEAAiE,0CAA0C,4MAA4M,OAAO,kCAAkC,8FAA8F,iGAAiG,OAAO,iCAAiC,sCAAsC,yHAAyH,OAAO,4CAA4C,0FAA0F,2FAA2F,OAAO,0CAA0C,0FAA0F,0FAA0F,OAAO,MAAM,EAAE,+CAA+C,8FAA8F,yDAAyD,uKAAuK,wGAAwG,yCAAyC,SAAS,GAAG,wCAAwC,6DAA6D,SAAS,GAAG,kFAAkF,gCAAgC,SAAS,OAAO,gDAAgD,MAAM,wDAAwD,6HAA6H,MAAM,sFAAsF,6CAA6C,yBAAyB,mCAAmC,iFAAiF,gCAAgC,+BAA+B,qDAAqD,qBAAqB,4BAA4B,2FAA2F,SAAS,QAAQ,KAAK,8CAA8C,oDAAoD,4BAA4B,qBAAqB,oBAAoB,KAAK,uGAAuG,6DAA6D,+DAA+D,6DAA6D,6DAA6D,iDAAiD,4JAA4J,MAAM,qDAAqD,0DAA0D,qFAAqF,mDAAmD,yCAAyC,SAAS,GAAG,wCAAwC,6DAA6D,SAAS,GAAG,kGAAkG,yEAAyE,kEAAkE,qCAAqC,YAAY,MAAM,kCAAkC,WAAW,SAAS,OAAO,gDAAgD,MAAM,6DAA6D,2GAA2G,sDAAsD,yCAAyC,SAAS,GAAG,6DAA6D,SAAS,GAAG,kCAAkC,sCAAsC,kEAAkE,4CAA4C,mDAAmD,SAAS,GAAG,+FAA+F,uCAAuC,aAAa,WAAW,SAAS,OAAO,gDAAgD,MAAM,wDAAwD,gDAAgD,mFAAmF,wCAAwC,OAAO,OAAO,wCAAwC,4DAA4D,OAAO,OAAO,kFAAkF,kCAAkC,WAAW,SAAS,OAAO,iEAAiE,MAAM,4DAA4D,4CAA4C,+EAA+E,wEAAwE,0CAA0C,QAAQ,oBAAoB,8CAA8C,QAAQ,EAAE,MAAM,gEAAgE,gDAAgD,gGAAgG,yFAAyF,QAAQ,8CAA8C,8CAA8C,QAAQ,IAAI,KAAK,6DAA6D,mCAAmC,kEAAkE,oBAAoB,OAAO,2HAA2H,2BAA2B,qCAAqC,OAAO,6BAA6B,yDAAyD,OAAO,+BAA+B,+DAA+D,+CAA+C,sEAAsE,8CAA8C,YAAY,EAAE,UAAU,EAAE,OAAO,iCAAiC,iEAAiE,mEAAmE,sEAAsE,kEAAkE,YAAY,EAAE,UAAU,EAAE,OAAO,0GAA0G,MAAM,kEAAkE,yCAAyC,kCAAkC,oEAAoE,mCAAmC,4CAA4C,UAAU,OAAO,oCAAoC,wFAAwF,mCAAmC,gEAAgE,UAAU,OAAO,oFAAoF,MAAM,sEAAsE,+BAA+B,oBAAoB,2CAA2C,oCAAoC,iFAAiF,sBAAsB,SAAS,wBAAwB,OAAO,4BAA4B,0CAA0C,OAAO,iCAAiC,gEAAgE,+FAA+F,yEAAyE,6DAA6D,YAAY,EAAE,UAAU,EAAE,OAAO,gFAAgF,MAAM,2EAA2E,kDAAkD,mCAAmC,oHAAoH,mCAAmC,2DAA2D,UAAU,OAAO,yDAAyD,MAAM,qDAAqD,8EAA8E,MAAM,sCAAsC,gCAAgC,yBAAyB,6BAA6B,QAAQ,KAAK,gDAAgD,8BAA8B,wDAAwD,cAAc,mFAAmF,QAAQ,EAAE,MAAM,qDAAqD,4CAA4C,kEAAkE,kFAAkF,wDAAwD,kCAAkC,QAAQ,EAAE,MAAM,sDAAsD,4CAA4C,mEAAmE,8FAA8F,sEAAsE,QAAQ,sCAAsC,mCAAmC,QAAQ,IAAI,MAAM,yDAAyD,4CAA4C,sEAAsE,8FAA8F,uFAAuF,QAAQ,oDAAoD,sCAAsC,QAAQ,IAAI,MAAM,8DAA8D,4CAA4C,mCAAmC,+EAA+E,aAAa,sCAAsC,2DAA2D,gDAAgD,mDAAmD,YAAY,EAAE,UAAU,SAAS,yCAAyC,6CAA6C,SAAS,QAAQ,MAAM,mDAAmD,wCAAwC,+HAA+H,UAAU,EAAE,OAAO,kBAAkB,MAAM,oDAAoD,yHAAyH,wCAAwC,OAAO,OAAO,wCAAwC,4DAA4D,OAAO,OAAO,kCAAkC,uCAAuC,kDAAkD,6LAA6L,EAAE,WAAW,gCAAgC,SAAS,OAAO,iDAAiD,MAAM,6CAA6C,mFAAmF,KAAK,4DAA4D,2CAA2C,gDAAgD,8DAA8D,oCAAoC,qCAAqC,+BAA+B,gEAAgE,wBAAwB,OAAO,iCAAiC,4DAA4D,uBAAuB,gCAAgC,+BAA+B,uBAAuB,gCAAgC,2FAA2F,SAAS,sCAAsC,iCAAiC,wCAAwC,kCAAkC,iCAAiC,yBAAyB,kCAAkC,WAAW,SAAS,uBAAuB,8BAA8B,kDAAkD,2BAA2B,0BAA0B,WAAW,mBAAmB,SAAS,YAAY,yBAAyB,kFAAkF,oBAAoB,0DAA0D,+DAA+D,iCAAiC,WAAW,UAAU,EAAE,+BAA+B,uCAAuC,OAAO,gCAAgC,qEAAqE,yBAAyB,sCAAsC,SAAS,uBAAuB,kFAAkF,+CAA+C,qBAAqB,mBAAmB,SAAS,OAAO,0BAA0B,4BAA4B,8CAA8C,iCAAiC,uMAAuM,uBAAuB,qBAAqB,OAAO,KAAK,8BAA8B,uLAAuL,0BAA0B,4BAA4B,oCAAoC,uFAAuF,qoBAAqoB,+MAA+M,uCAAuC,uCAAuC,uTAAuT,8DAA8D,2FAA2F,qGAAqG,0IAA0I,YAAY,MAAM,2FAA2F,oGAAoG,0IAA0I,WAAW,qDAAqD,mDAAmD,oEAAoE,kEAAkE,mCAAmC,mDAAmD,6CAA6C,iCAAiC,cAAc,YAAY,8BAA8B,4BAA4B,YAAY,MAAM,2DAA2D,WAAW,0DAA0D,2DAA2D,UAAU,EAAE,OAAO,kCAAkC,8CAA8C,kBAAkB,oBAAoB,QAAQ,mCAAmC,+CAA+C,+EAA+E,oBAAoB,QAAQ,+BAA+B,uDAAuD,+CAA+C,oBAAoB,QAAQ,uCAAuC,mDAAmD,uBAAuB,oBAAoB,QAAQ,uCAAuC,oDAAoD,wBAAwB,oBAAoB,QAAQ,qCAAqC,iCAAiC,uCAAuC,2BAA2B,0CAA0C,oBAAoB,QAAQ,0CAA0C,sDAAsD,2BAA2B,oBAAoB,QAAQ,0CAA0C,sDAAsD,2BAA2B,oBAAoB,QAAQ,wCAAwC,oDAAoD,yBAAyB,oBAAoB,QAAQ,uCAAuC,wCAAwC,QAAQ,kBAAkB,MAAM,qEAAqE,+DAA+D,gDAAgD,oDAAoD,yBAAyB,4EAA4E,QAAQ,EAAE,KAAK,gDAAgD,oDAAoD,yBAAyB,4EAA4E,QAAQ,EAAE,KAAK,+BAA+B,+OAA+O,2BAA2B,4BAA4B,kNAAkN,wEAAwE,yJAAyJ,0IAA0I,+EAA+E,iCAAiC,yEAAyE,mCAAmC,YAAY,oCAAoC,yCAAyC,YAAY,iDAAiD,iDAAiD,YAAY,8BAA8B,iDAAiD,YAAY,iFAAiF,uEAAuE,kGAAkG,oBAAoB,uCAAuC,4FAA4F,+BAA+B,WAAW,oBAAoB,uCAAuC,6FAA6F,+BAA+B,WAAW,4BAA4B,UAAU,EAAE,OAAO,mCAAmC,4BAA4B,+DAA+D,4HAA4H,sCAAsC,mCAAmC,yCAAyC,8EAA8E,wCAAwC,wCAAwC,kCAAkC,kCAAkC,uBAAuB,oDAAoD,EAAE,cAAc,sCAAsC,iHAAiH,mDAAmD,oCAAoC,8CAA8C,8CAA8C,yBAAyB,sFAAsF,EAAE,gBAAgB,cAAc,mCAAmC,wCAAwC,wCAAwC,uBAAuB,gFAAgF,EAAE,uBAAuB,kDAAkD,EAAE,cAAc,EAAE,YAAY,MAAM,qBAAqB,gDAAgD,EAAE,qBAAqB,0EAA0E,EAAE,qBAAqB,8CAA8C,EAAE,WAAW,UAAU,EAAE,QAAQ,4BAA4B,uEAAuE,sGAAsG,UAAU,EAAE,OAAO,6BAA6B,0DAA0D,8FAA8F,OAAO,6BAA6B,0DAA0D,+FAA+F,OAAO,6BAA6B,6YAA6Y,+GAA+G,wCAAwC,oFAAoF,UAAU,MAAM,mFAAmF,SAAS,qDAAqD,yBAAyB,6CAA6C,6CAA6C,UAAU,sBAAsB,uEAAuE,gFAAgF,kCAAkC,kCAAkC,UAAU,oDAAoD,oGAAoG,mFAAmF,iBAAiB,wCAAwC,EAAE,oBAAoB,4BAA4B,yCAAyC,8BAA8B,4BAA4B,sCAAsC,sCAAsC,2BAA2B,aAAa,qCAAqC,WAAW,SAAS,0BAA0B,0DAA0D,oCAAoC,oCAAoC,yBAAyB,qCAAqC,WAAW,SAAS,8BAA8B,wDAAwD,yBAAyB,kCAAkC,kCAAkC,WAAW,4BAA4B,oCAAoC,2GAA2G,6DAA6D,6DAA6D,cAAc,mBAAmB,WAAW,oDAAoD,yBAAyB,yBAAyB,WAAW,oDAAoD,yBAAyB,yBAAyB,WAAW,wBAAwB,wBAAwB,qBAAqB,gGAAgG,EAAE,WAAW,SAAS,2CAA2C,yKAAyK,2BAA2B,2BAA2B,kCAAkC,WAAW,8FAA8F,2BAA2B,6CAA6C,YAAY,MAAM,yFAAyF,mCAAmC,wBAAwB,6BAA6B,cAAc,MAAM,6BAA6B,aAAa,WAAW,uDAAuD,2CAA2C,0BAA0B,4BAA4B,4BAA4B,wBAAwB,WAAW,SAAS,6BAA6B,sBAAsB,gIAAgI,0DAA0D,mMAAmM,wBAAwB,mBAAmB,0CAA0C,EAAE,SAAS,OAAO,+BAA+B,0CAA0C,cAAc,oDAAoD,qBAAqB,QAAQ,+BAA+B,0CAA0C,cAAc,oDAAoD,qBAAqB,QAAQ,mCAAmC,qGAAqG,wDAAwD,4BAA4B,2BAA2B,qBAAqB,QAAQ,oCAAoC,8BAA8B,kCAAkC,oBAAoB,kCAAkC,2DAA2D,cAAc,MAAM,+CAA+C,uEAAuE,qDAAqD,aAAa,WAAW,oBAAoB,kCAAkC,2DAA2D,cAAc,MAAM,+CAA+C,uEAAuE,qDAAqD,aAAa,WAAW,wFAAwF,SAAS,kBAAkB,+BAA+B,0CAA0C,qCAAqC,qDAAqD,iDAAiD,2EAA2E,SAAS,kBAAkB,+BAA+B,0CAA0C,qCAAqC,qDAAqD,iDAAiD,2EAA2E,SAAS,qBAAqB,QAAQ,gCAAgC,+BAA+B,iDAAiD,+CAA+C,SAAS,qBAAqB,QAAQ,gCAAgC,kFAAkF,QAAQ,+CAA+C,MAAM,8BAA8B,yMAAyM,yIAAyI,oEAAoE,+CAA+C,2EAA2E,+IAA+I,8CAA8C,gCAAgC,KAAK,wDAAwD,oCAAoC,yCAAyC,MAAM,kEAAkE,yDAAyD,2DAA2D,KAAK,4BAA4B,kEAAkE,KAAK,oBAAoB,+BAA+B,MAAM,EAAE,2CAA2C,mDAAmD,yDAAyD,2DAA2D,KAAK,4BAA4B,kEAAkE,KAAK,oBAAoB,+BAA+B,MAAM,EAAE,2CAA2C,mDAAmD,uDAAuD,mDAAmD,uFAAuF,KAAK,4BAA4B,mEAAmE,KAAK,oBAAoB,6BAA6B,MAAM,EAAE,uCAAuC,+CAA+C,wDAAwD,iCAAiC,wBAAwB,kBAAkB,KAAK,4BAA4B,gDAAgD,KAAK,oBAAoB,6BAA6B,MAAM,EAAE,yCAAyC,iDAAiD,uDAAuD,2BAA2B,2BAA2B,OAAO,oCAAoC,uDAAuD,QAAQ,oCAAoC,iFAAiF,2BAA2B,qBAAqB,QAAQ,4CAA4C,6GAA6G,qHAAqH,6BAA6B,UAAU,8LAA8L,OAAO,+CAA+C,gMAAgM,6DAA6D,kCAAkC,wGAAwG,SAAS,gEAAgE,mCAAmC,oGAAoG,wBAAwB,WAAW,mCAAmC,oGAAoG,wBAAwB,WAAW,UAAU,eAAe,QAAQ,gDAAgD,sMAAsM,kCAAkC,SAAS,6DAA6D,qGAAqG,QAAQ,qCAAqC,sBAAsB,QAAQ,+BAA+B,+DAA+D,QAAQ,oDAAoD,KAAK,qCAAqC,2BAA2B,KAAK,qJAAqJ,sbAAsb,qFAAqF,iCAAiC,MAAM,6BAA6B,4BAA4B,MAAM,+BAA+B,4BAA4B,MAAM,+BAA+B,0BAA0B,MAAM,+BAA+B,4CAA4C,MAAM,+BAA+B,8BAA8B,MAAM,4BAA4B,0BAA0B,MAAM,2BAA2B,qCAAqC,4CAA4C,kGAAkG,OAAO,uDAAuD,kDAAkD,gCAAgC,qGAAqG,MAAM,gFAAgF,gCAAgC,MAAM,EAAE,sFAAsF,oCAAoC,MAAM,6BAA6B,+BAA+B,MAAM,+BAA+B,+BAA+B,MAAM,+BAA+B,6BAA6B,MAAM,+BAA+B,kDAAkD,MAAM,+BAA+B,iCAAiC,MAAM,4BAA4B,6BAA6B,MAAM,2BAA2B,oDAAoD,oCAAoC,iGAAiG,MAAM,+CAA+C,kCAAkC,MAAM,EAAE,yCAAyC,oEAAoE,MAAM,iCAAiC,gDAAgD,KAAK,yCAAyC,6DAA6D,MAAM,iCAAiC,4CAA4C,2CAA2C,oEAAoE,KAAK,8CAA8C,iCAAiC,MAAM,EAAE,oFAAoF,gFAAgF,kBAAkB,GAAG,GAAG,C;;;;;;;;;;ACAzg/V,iDAAiD,iFAAiF,mFAAmF,MAAM,MAAM,wBAAwB,KAAK,GAAG,gFAAgF,mBAAmB,gBAAgB,mBAAmB,4GAA4G,OAAO,qDAAqD,aAAa,kGAAkG,qBAAqB,qCAAqC,qBAAqB,MAAM,6EAA6E,QAAQ,qFAAqF,kCAAkC,MAAM,8DAA8D,iCAAiC,oEAAoE,gEAAgE,wCAAwC,4EAA4E,4FAA4F,OAAO,KAAK,iEAAiE,8DAA8D,gEAAgE,yBAAyB,UAAU,IAAI,QAAQ,IAAI,MAAM,uDAAuD,8EAA8E,YAAY,6CAA6C,YAAY,EAAE,iDAAiD,oDAAoD,sCAAsC,0BAA0B,WAAW,+BAA+B,uDAAuD,UAAU,EAAE,QAAQ,EAAE,gCAAgC,MAAM,2DAA2D,wDAAwD,WAAW,EAAE,kDAAkD,yBAAyB,gDAAgD,8BAA8B,sCAAsC,iCAAiC,WAAW,UAAU,EAAE,QAAQ,EAAE,gCAAgC,MAAM,8DAA8D,iCAAiC,gEAAgE,oEAAoE,+BAA+B,OAAO,KAAK,iEAAiE,0EAA0E,gEAAgE,yBAAyB,UAAU,IAAI,QAAQ,aAAa,MAAM,uDAAuD,8EAA8E,YAAY,6CAA6C,YAAY,EAAE,iDAAiD,oDAAoD,+BAA+B,uDAAuD,UAAU,EAAE,QAAQ,EAAE,gCAAgC,KAAK,qDAAqD,8EAA8E,YAAY,EAAE,+CAA+C,oDAAoD,+BAA+B,UAAU,EAAE,QAAQ,EAAE,sBAAsB,MAAM,yDAAyD,gCAAgC,MAAM,oDAAoD,uDAAuD,8BAA8B,EAAE,MAAM,uDAAuD,kDAAkD,0EAA0E,SAAS,aAAa,iBAAiB,qEAAqE,0DAA0D,YAAY,aAAa,wEAAwE,SAAS,0BAA0B,OAAO,mBAAmB,MAAM,0DAA0D,wFAAwF,iBAAiB,EAAE,MAAM,wDAAwD,uDAAuD,YAAY,EAAE,MAAM,mEAAmE,6CAA6C,wDAAwD,yBAAyB,UAAU,EAAE,QAAQ,EAAE,MAAM,qDAAqD,sBAAsB,0IAA0I,iBAAiB,EAAE,iDAAiD,YAAY,aAAa,oCAAoC,OAAO,0DAA0D,YAAY,aAAa,sCAAsC,8DAA8D,aAAa,aAAa,iDAAiD,kDAAkD,wDAAwD,iCAAiC,uDAAuD,EAAE,SAAS,OAAO,yCAAyC,iCAAiC,MAAM,sDAAsD,wEAAwE,MAAM,yDAAyD,sEAAsE,sFAAsF,gDAAgD,uDAAuD,QAAQ,MAAM,sDAAsD,6DAA6D,OAAO,MAAM,+IAA+I,QAAQ,wDAAwD,aAAa,+EAA+E,sFAAsF,wBAAwB,MAAM,iEAAiE,uCAAuC,qFAAqF,wDAAwD,8CAA8C,iGAAiG,mGAAmG,kCAAkC,yCAAyC,oFAAoF,kDAAkD,yCAAyC,sCAAsC,uDAAuD,uBAAuB,mFAAmF,oBAAoB,4CAA4C,SAAS,kBAAkB,wBAAwB,QAAQ,MAAM,gGAAgG,OAAO,MAAM,gDAAgD,sDAAsD,4CAA4C,4FAA4F,MAAM,+CAA+C,oDAAoD,8DAA8D,MAAM,kJAAkJ,cAAc,mDAAmD,UAAU,wJAAwJ,gBAAgB,oCAAoC,OAAO,6BAA6B,qBAAqB,4CAA4C,SAAS,QAAQ,EAAE,MAAM,8KAA8K,8CAA8C,QAAQ,4CAA4C,aAAa,iFAAiF,0DAA0D,gDAAgD,6BAA6B,OAAO,4FAA4F,iDAAiD,OAAO,uEAAuE,MAAM,sJAAsJ,QAAQ,6BAA6B,aAAa,yEAAyE,qDAAqD,wDAAwD,sDAAsD,OAAO,mGAAmG,iFAAiF,MAAM,oDAAoD,qCAAqC,2BAA2B,+BAA+B,0BAA0B,2CAA2C,wCAAwC,sDAAsD,aAAa,sEAAsE,WAAW,SAAS,sBAAsB,kDAAkD,SAAS,QAAQ,MAAM,qBAAqB,OAAO,oBAAoB,MAAM,6FAA6F,QAAQ,mBAAmB,QAAQ,sBAAsB,QAAQ,uEAAuE,iEAAiE,4BAA4B,OAAO,oBAAoB,oBAAoB,OAAO,wCAAwC,oDAAoD,2FAA2F,WAAW,SAAS,OAAO,0BAA0B,MAAM,wSAAwS,QAAQ,qBAAqB,QAAQ,kBAAkB,QAAQ,kBAAkB,WAAW,+GAA+G,uCAAuC,kBAAkB,OAAO,8CAA8C,2BAA2B,iFAAiF,OAAO,iIAAiI,MAAM,mBAAmB,cAAc,yPAAyP,gBAAgB,+NAA+N,qBAAqB,6CAA6C,kBAAkB,+EAA+E,iBAAiB,iCAAiC,gBAAgB,iVAAiV,iBAAiB,qOAAqO,mBAAmB,uDAAuD,iBAAiB,qDAAqD,eAAe,0IAA0I,gBAAgB,gRAAgR,gBAAgB,oFAAoF,eAAe,0MAA0M,iBAAiB,2NAA2N,mBAAmB,yQAAyQ,sBAAsB,+KAA+K,kBAAkB,qUAAqU,mBAAmB,mKAAmK,MAAM,wBAAwB,8BAA8B,g5BAAg5B,gCAAgC,qCAAqC,oBAAoB,qDAAqD,oCAAoC,MAAM,sCAAsC,sCAAsC,kDAAkD,gDAAgD,sCAAsC,oDAAoD,kDAAkD,oDAAoD,oCAAoC,wCAAwC,gDAAgD,gDAAgD,sDAAsD,0EAA0E,0DAA0D,OAAO,MAAM,sBAAsB,0BAA0B,wDAAwD,2GAA2G,kCAAkC,uPAAuP,6CAA6C,sOAAsO,SAAS,QAAQ,wDAAwD,mDAAmD,OAAO,KAAK,gDAAgD,OAAO,oBAAoB,MAAM,mEAAmE,kPAAkP,kCAAkC,kNAAkN,yNAAyN,QAAQ,wDAAwD,kDAAkD,OAAO,KAAK,+CAA+C,OAAO,oBAAoB,MAAM,2BAA2B,yDAAyD,yEAAyE,kCAAkC,+QAA+Q,QAAQ,mDAAmD,oBAAoB,MAAM,0DAA0D,yEAAyE,kCAAkC,iKAAiK,qRAAqR,QAAQ,kDAAkD,oBAAoB,MAAM,6BAA6B,yDAAyD,yEAAyE,kCAAkC,8SAA8S,iNAAiN,6CAA6C,qNAAqN,SAAS,QAAQ,iDAAiD,sBAAsB,MAAM,oEAAoE,+IAA+I,kCAAkC,yQAAyQ,6LAA6L,sOAAsO,UAAU,gDAAgD,oBAAoB,MAAM,8BAA8B,wDAAwD,0BAA0B,6MAA6M,QAAQ,MAAM,yDAAyD,0BAA0B,wMAAwM,QAAQ,MAAM,4BAA4B,0EAA0E,6BAA6B,mBAAmB,+FAA+F,wMAAwM,QAAQ,MAAM,+DAA+D,0BAA0B,8KAA8K,QAAQ,MAAM,0BAA0B,4EAA4E,oCAAoC,mBAAmB,+FAA+F,sMAAsM,QAAQ,oBAAoB,MAAM,oEAAoE,iCAAiC,8KAA8K,QAAQ,oBAAoB,MAAM,6BAA6B,0DAA0D,2DAA2D,kEAAkE,OAAO,KAAK,8DAA8D,OAAO,MAAM,2DAA2D,2DAA2D,iEAAiE,OAAO,KAAK,6DAA6D,OAAO,MAAM,4DAA4D,wFAAwF,kCAAkC,6IAA6I,0GAA0G,uEAAuE,MAAM,oBAAoB,ukDAAukD,2QAA2Q,4BAA4B,wwBAAwwB,sBAAsB,sCAAsC,2BAA2B,yBAAyB,0BAA0B,wBAAwB,wBAAwB,qBAAqB,wBAAwB,mBAAmB,eAAe,+EAA+E,gBAAgB,+EAA+E,iBAAiB,sBAAsB,QAAQ,2BAA2B,6BAA6B,iCAAiC,sCAAsC,sBAAsB,kBAAkB,MAAM,oIAAoI,QAAQ,qGAAqG,QAAQ,qGAAqG,iBAAiB,6IAA6I,sBAAsB,iUAAiU,8CAA8C,kCAAkC,OAAO,2CAA2C,yBAAyB,OAAO,oBAAoB,MAAM,0HAA0H,eAAe,2GAA2G,sBAAsB,mQAAmQ,oBAAoB,MAAM,6HAA6H,4CAA4C,wBAAwB,gGAAgG,omBAAomB,4CAA4C,+CAA+C,YAAY,wCAAwC,4CAA4C,+CAA+C,YAAY,sCAAsC,4CAA4C,8CAA8C,gDAAgD,8CAA8C,cAAc,EAAE,YAAY,EAAE,OAAO,MAAM,iGAAiG,eAAe,sGAAsG,sBAAsB,0BAA0B,kRAAkR,OAAO,6HAA6H,sDAAsD,gUAAgU,QAAQ,MAAM,qJAAqJ,OAAO,6QAA6Q,oBAAoB,MAAM,uGAAuG,eAAe,sGAAsG,sBAAsB,0BAA0B,8CAA8C,OAAO,iNAAiN,oBAAoB,MAAM,6FAA6F,QAAQ,sFAAsF,aAAa,kHAAkH,sBAAsB,uBAAuB,yKAAyK,OAAO,kEAAkE,gJAAgJ,kBAAkB,MAAM,wDAAwD,aAAa,wGAAwG,sBAAsB,4FAA4F,kvBAAkvB,oBAAoB,MAAM,6DAA6D,aAAa,2GAA2G,sBAAsB,kGAAkG,+pBAA+pB,oBAAoB,MAAM,wGAAwG,aAAa,yGAAyG,sBAAsB,2DAA2D,kEAAkE,kBAAkB,MAAM,oFAAoF,aAAa,+GAA+G,sBAAsB,mCAAmC,mCAAmC,2NAA2N,OAAO,+DAA+D,0LAA0L,2CAA2C,qCAAqC,SAAS,+CAA+C,wCAAwC,SAAS,gUAAgU,UAAU,MAAM,8HAA8H,mKAAmK,6EAA6E,2CAA2C,SAAS,OAAO,yEAAyE,wDAAwD,aAAa,EAAE,OAAO,oBAAoB,MAAM,oFAAoF,eAAe,6GAA6G,sBAAsB,mCAAmC,mCAAmC,uJAAuJ,OAAO,6DAA6D,4LAA4L,2CAA2C,qCAAqC,SAAS,+CAA+C,wCAAwC,SAAS,6TAA6T,YAAY,MAAM,+HAA+H,iKAAiK,4EAA4E,2CAA2C,SAAS,OAAO,yEAAyE,wDAAwD,aAAa,EAAE,OAAO,oBAAoB,MAAM,uJAAuJ,eAAe,8GAA8G,sBAAsB,2GAA2G,uBAAuB,yBAAyB,OAAO,0CAA0C,OAAO,kBAAkB,MAAM,2HAA2H,QAAQ,gHAAgH,sBAAsB,mRAAmR,2CAA2C,sJAAsJ,OAAO,oEAAoE,ocAAoc,uQAAuQ,iWAAiW,0ZAA0Z,oBAAoB,MAAM,yHAAyH,QAAQ,8GAA8G,sBAAsB,sUAAsU,2CAA2C,sJAAsJ,OAAO,oEAAoE,uaAAua,kLAAkL,gUAAgU,2XAA2X,oBAAoB,MAAM,2GAA2G,SAAS,uGAAuG,sBAAsB,4IAA4I,wDAAwD,yDAAyD,WAAW,oDAAoD,yGAAyG,gDAAgD,WAAW,UAAU,EAAE,yJAAyJ,2FAA2F,wDAAwD,4DAA4D,WAAW,oDAAoD,0FAA0F,yDAAyD,sDAAsD,kFAAkF,wFAAwF,uDAAuD,aAAa,0DAA0D,WAAW,UAAU,4CAA4C,iHAAiH,iEAAiE,UAAU,kFAAkF,+FAA+F,wCAAwC,WAAW,UAAU,6CAA6C,6FAA6F,uCAAuC,WAAW,UAAU,0CAA0C,mDAAmD,UAAU,EAAE,iPAAiP,iDAAiD,oCAAoC,0HAA0H,iGAAiG,udAAud,oBAAoB,MAAM,6HAA6H,SAAS,0GAA0G,oBAAoB,kHAAkH,sBAAsB,2DAA2D,uBAAuB,yHAAyH,+EAA+E,4BAA4B,OAAO,kBAAkB,MAAM,4HAA4H,QAAQ,oGAAoG,0BAA0B,kBAAkB,MAAM,oEAAoE,QAAQ,2GAA2G,4BAA4B,kBAAkB,MAAM,mEAAmE,QAAQ,0GAA0G,8BAA8B,4CAA4C,OAAO,oBAAoB,MAAM,oDAAoD,0BAA0B,kBAAkB,MAAM,sDAAsD,qFAAqF,8EAA8E,kBAAkB,MAAM,sDAAsD,qFAAqF,8EAA8E,kBAAkB,MAAM,+HAA+H,gBAAgB,wCAAwC,oBAAoB,OAAO,2CAA2C,MAAM,kDAAkD,gBAAgB,yCAAyC,oBAAoB,OAAO,4CAA4C,MAAM,+CAA+C,gBAAgB,mCAAmC,oBAAoB,OAAO,sCAAsC,MAAM,kDAAkD,gBAAgB,sCAAsC,oBAAoB,OAAO,yCAAyC,MAAM,gDAAgD,gBAAgB,oCAAoC,oBAAoB,OAAO,uCAAuC,MAAM,iDAAiD,gBAAgB,qCAAqC,oBAAoB,OAAO,wCAAwC,MAAM,sDAAsD,kBAAkB,wCAAwC,oBAAoB,OAAO,yCAAyC,MAAM,yDAAyD,sBAAsB,2CAA2C,oBAAoB,OAAO,wCAAwC,MAAM,+DAA+D,yBAAyB,iDAAiD,oBAAoB,OAAO,wCAAwC,MAAM,mEAAmE,yBAAyB,iDAAiD,oBAAoB,OAAO,2CAA2C,MAAM,4CAA4C,0CAA0C,kCAAkC,OAAO,mFAAmF,kBAAkB,KAAK,4CAA4C,0CAA0C,kCAAkC,OAAO,mFAAmF,kBAAkB,KAAK,+FAA+F,mNAAmN,uIAAuI,kBAAkB,MAAM,oDAAoD,sBAAsB,mEAAmE,6BAA6B,2DAA2D,4HAA4H,iIAAiI,iBAAiB,IAAI,kDAAkD,WAAW,iBAAiB,kPAAkP,sBAAsB,6FAA6F,gFAAgF,0CAA0C,OAAO,wBAAwB,MAAM,4DAA4D,wDAAwD,sBAAsB,sCAAsC,kBAAkB,MAAM,+EAA+E,+EAA+E,8DAA8D,uEAAuE,yCAAyC,8BAA8B,8EAA8E,wDAAwD,iNAAiN,gTAAgT,qOAAqO,8UAA8U,MAAM,6EAA6E,+EAA+E,6DAA6D,uEAAuE,8EAA8E,8BAA8B,yCAAyC,wDAAwD,iNAAiN,gTAAgT,qOAAqO,8UAA8U,MAAM,0GAA0G,QAAQ,2DAA2D,QAAQ,uGAAuG,sBAAsB,mEAAmE,4BAA4B,8GAA8G,2DAA2D,qBAAqB,cAAc,iBAAiB,wCAAwC,yHAAyH,qEAAqE,OAAO,wBAAwB,MAAM,2DAA2D,uDAAuD,sBAAsB,sCAAsC,kBAAkB,MAAM,mEAAmE,oHAAoH,iRAAiR,2CAA2C,EAAE,2RAA2R,4FAA4F,UAAU,qCAAqC,wCAAwC,4NAA4N,2CAA2C,0CAA0C,gFAAgF,iDAAiD,+HAA+H,6HAA6H,0EAA0E,oGAAoG,kEAAkE,cAAc,EAAE,WAAW,UAAU,EAAE,iEAAiE,mCAAmC,qCAAqC,oFAAoF,uCAAuC,yCAAyC,2dAA2d,mDAAmD,8DAA8D,2CAA2C,2GAA2G,2CAA2C,oEAAoE,yCAAyC,EAAE,yEAAyE,iFAAiF,EAAE,qIAAqI,MAAM,iEAAiE,oHAAoH,iRAAiR,4CAA4C,EAAE,uTAAuT,wCAAwC,sCAAsC,gFAAgF,mPAAmP,gFAAgF,iDAAiD,+HAA+H,6HAA6H,yEAAyE,oGAAoG,kEAAkE,cAAc,EAAE,WAAW,UAAU,EAAE,oEAAoE,wDAAwD,qCAAqC,oFAAoF,qCAAqC,kDAAkD,+DAA+D,uCAAuC,6cAA6c,2CAA2C,8LAA8L,mEAAmE,EAAE,qEAAqE,iFAAiF,EAAE,uKAAuK,MAAM,qDAAqD,sBAAsB,mEAAmE,sEAAsE,qBAAqB,kEAAkE,+CAA+C,8NAA8N,gCAAgC,kRAAkR,2GAA2G,iDAAiD,4WAA4W,+CAA+C,6DAA6D,UAAU,EAAE,OAAO,+EAA+E,qDAAqD,obAAob,2CAA2C,EAAE,0EAA0E,0EAA0E,EAAE,QAAQ,6DAA6D,yDAAyD,sBAAsB,sCAAsC,+CAA+C,kBAAkB,MAAM,oDAAoD,sBAAsB,mEAAmE,6BAA6B,2DAA2D,8GAA8G,6GAA6G,uBAAuB,WAAW,iBAAiB,kPAAkP,qBAAqB,4DAA4D,mFAAmF,0DAA0D,OAAO,wBAAwB,MAAM,4DAA4D,wDAAwD,sBAAsB,sCAAsC,uCAAuC,kBAAkB,MAAM,gFAAgF,qIAAqI,8DAA8D,mEAAmE,oCAAoC,8BAA8B,oEAAoE,sDAAsD,ojBAAojB,gIAAgI,8HAA8H,kIAAkI,gIAAgI,UAAU,EAAE,6CAA6C,+hBAA+hB,iFAAiF,EAAE,OAAO,kJAAkJ,oCAAoC,qCAAqC,kEAAkE,sgBAAsgB,2CAA2C,kKAAkK,oBAAoB,MAAM,8EAA8E,qIAAqI,6DAA6D,mEAAmE,oEAAoE,8BAA8B,oCAAoC,sDAAsD,gjBAAgjB,gIAAgI,8HAA8H,kIAAkI,gIAAgI,UAAU,EAAE,6CAA6C,+hBAA+hB,iFAAiF,EAAE,OAAO,kJAAkJ,oEAAoE,sCAAsC,yCAAyC,sgBAAsgB,2CAA2C,kKAAkK,oBAAoB,MAAM,2DAA2D,sBAAsB,mEAAmE,0GAA0G,0DAA0D,oBAAoB,wBAAwB,YAAY,EAAE,UAAU,SAAS,gHAAgH,6GAA6G,gJAAgJ,2EAA2E,UAAU,EAAE,gEAAgE,wBAAwB,MAAM,mEAAmE,+DAA+D,sBAAsB,uCAAuC,kBAAkB,MAAM,sEAAsE,kKAAkK,yDAAyD,wBAAwB,uBAAuB,aAAa,6CAA6C,2CAA2C,OAAO,kFAAkF,oHAAoH,UAAU,6CAA6C,4CAA4C,iEAAiE,iEAAiE,oCAAoC,qEAAqE,oCAAoC,2EAA2E,+GAA+G,2CAA2C,6CAA6C,0CAA0C,EAAE,kFAAkF,oHAAoH,UAAU,uKAAuK,iEAAiE,mCAAmC,2EAA2E,mEAAmE,MAAM,oEAAoE,kKAAkK,wDAAwD,wBAAwB,uBAAuB,YAAY,6CAA6C,2CAA2C,OAAO,kFAAkF,oHAAoH,UAAU,6CAA6C,4CAA4C,iEAAiE,iEAAiE,oCAAoC,qEAAqE,oCAAoC,2EAA2E,8GAA8G,2CAA2C,6CAA6C,0CAA0C,EAAE,kFAAkF,oHAAoH,UAAU,0KAA0K,iEAAiE,mCAAmC,2EAA2E,mEAAmE,MAAM,0DAA0D,sBAAsB,mEAAmE,4BAA4B,4HAA4H,YAAY,iDAAiD,YAAY,EAAE,6GAA6G,qDAAqD,WAAW,iBAAiB,yDAAyD,0FAA0F,6LAA6L,uHAAuH,+DAA+D,6FAA6F,SAAS,0CAA0C,OAAO,wBAAwB,MAAM,kEAAkE,8DAA8D,sBAAsB,uCAAuC,uCAAuC,kBAAkB,MAAM,4FAA4F,6LAA6L,qJAAqJ,2EAA2E,oBAAoB,gBAAgB,qCAAqC,mCAAmC,yTAAyT,uEAAuE,iDAAiD,8JAA8J,4JAA4J,UAAU,EAAE,mEAAmE,kEAAkE,0dAA0d,8JAA8J,mKAAmK,oBAAoB,4EAA4E,EAAE,MAAM,0FAA0F,4NAA4N,kJAAkJ,mCAAmC,yCAAyC,2EAA2E,oBAAoB,gBAAgB,0TAA0T,iFAAiF,iDAAiD,8JAA8J,4JAA4J,UAAU,EAAE,mGAAmG,kEAAkE,seAAse,uKAAuK,mKAAmK,oBAAoB,4FAA4F,EAAE,MAAM,mDAAmD,sBAAsB,mEAAmE,sEAAsE,qBAAqB,kEAAkE,+CAA+C,yLAAyL,gCAAgC,qOAAqO,uEAAuE,UAAU,wFAAwF,2GAA2G,iDAAiD,ySAAyS,+EAA+E,qDAAqD,0aAA0a,2CAA2C,EAAE,0EAA0E,0EAA0E,EAAE,wEAAwE,+CAA+C,6DAA6D,UAAU,EAAE,OAAO,MAAM,2DAA2D,uDAAuD,sBAAsB,sCAAsC,+CAA+C,kBAAkB,MAAM,yDAAyD,sBAAsB,qEAAqE,uEAAuE,qBAAqB,kEAAkE,2CAA2C,6HAA6H,YAAY,wDAAwD,qCAAqC,kHAAkH,0DAA0D,EAAE,uBAAuB,2BAA2B,OAAO,sEAAsE,OAAO,gCAAgC,kRAAkR,4GAA4G,gDAAgD,sHAAsH,+EAA+E,mDAAmD,kXAAkX,wCAAwC,GAAG,4EAA4E,0EAA0E,EAAE,gQAAgQ,YAAY,6OAA6O,wEAAwE,+CAA+C,6DAA6D,UAAU,EAAE,OAAO,MAAM,iEAAiE,6DAA6D,sBAAsB,sCAAsC,+CAA+C,kBAAkB,MAAM,2DAA2D,sBAAsB,mEAAmE,oHAAoH,yDAAyD,QAAQ,2BAA2B,EAAE,QAAQ,IAAI,kIAAkI,YAAY,IAAI,qJAAqJ,2EAA2E,UAAU,EAAE,gEAAgE,wBAAwB,MAAM,mEAAmE,+DAA+D,sBAAsB,sCAAsC,kBAAkB,MAAM,sEAAsE,0GAA0G,yDAAyD,wBAAwB,uBAAuB,YAAY,6CAA6C,4CAA4C,OAAO,kFAAkF,yFAAyF,UAAU,6CAA6C,4CAA4C,iEAAiE,iEAAiE,iCAAiC,iCAAiC,iCAAiC,uCAAuC,8GAA8G,2CAA2C,8CAA8C,0CAA0C,EAAE,kFAAkF,yFAAyF,UAAU,uKAAuK,iEAAiE,gCAAgC,uCAAuC,mEAAmE,oBAAoB,MAAM,oEAAoE,0GAA0G,wDAAwD,wBAAwB,uBAAuB,YAAY,6CAA6C,4CAA4C,OAAO,kFAAkF,yFAAyF,UAAU,6CAA6C,4CAA4C,iEAAiE,iEAAiE,iCAAiC,iCAAiC,iCAAiC,uCAAuC,8GAA8G,2CAA2C,8CAA8C,0CAA0C,EAAE,oFAAoF,yFAAyF,UAAU,uKAAuK,iEAAiE,gCAAgC,uCAAuC,mEAAmE,oBAAoB,MAAM,0DAA0D,sBAAsB,mEAAmE,4BAA4B,4HAA4H,YAAY,iDAAiD,YAAY,EAAE,6GAA6G,qDAAqD,WAAW,iBAAiB,iJAAiJ,iFAAiF,OAAO,wBAAwB,MAAM,kEAAkE,8DAA8D,sBAAsB,sCAAsC,kBAAkB,MAAM,sFAAsF,6LAA6L,yMAAyM,qJAAqJ,uCAAuC,oBAAoB,gBAAgB,qCAAqC,mCAAmC,wTAAwT,wEAAwE,0CAA0C,oHAAoH,kHAAkH,yEAAyE,0DAA0D,kEAAkE,cAAc,EAAE,WAAW,UAAU,EAAE,mEAAmE,kEAAkE,seAAse,uFAAuF,iMAAiM,oBAAoB,wCAAwC,EAAE,qEAAqE,iFAAiF,EAAE,MAAM,oFAAoF,4NAA4N,yMAAyM,kJAAkJ,mCAAmC,yCAAyC,uCAAuC,oBAAoB,gBAAgB,yTAAyT,+EAA+E,0CAA0C,oHAAoH,kHAAkH,yEAAyE,0DAA0D,kEAAkE,cAAc,EAAE,WAAW,UAAU,EAAE,qGAAqG,kEAAkE,kfAAkf,gGAAgG,iMAAiM,oBAAoB,wDAAwD,EAAE,qEAAqE,iFAAiF,EAAE,2FAA2F,MAAM,yDAAyD,sBAAsB,mEAAmE,4BAA4B,iGAAiG,YAAY,kDAAkD,YAAY,EAAE,8GAA8G,uBAAuB,cAAc,iBAAiB,iJAAiJ,iFAAiF,OAAO,wBAAwB,MAAM,iEAAiE,6DAA6D,sBAAsB,sCAAsC,kBAAkB,MAAM,qFAAqF,qKAAqK,iMAAiM,2KAA2K,iEAAiE,YAAY,wCAAwC,iDAAiD,qDAAqD,6BAA6B,6CAA6C,UAAU,qCAAqC,wCAAwC,yTAAyT,8FAA8F,iDAAiD,+HAA+H,6HAA6H,UAAU,EAAE,iEAAiE,oFAAoF,uCAAuC,kCAAkC,0eAA0e,2CAA2C,gMAAgM,iDAAiD,6BAA6B,gDAAgD,UAAU,EAAE,qEAAqE,iFAAiF,EAAE,yGAAyG,MAAM,mFAAmF,2LAA2L,iMAAiM,6KAA6K,iEAAiE,YAAY,sCAAsC,wCAAwC,wCAAwC,iDAAiD,2EAA2E,6BAA6B,gDAAgD,UAAU,yTAAyT,uGAAuG,UAAU,iDAAiD,+HAA+H,6HAA6H,UAAU,EAAE,mGAAmG,oFAAoF,gFAAgF,0CAA0C,6cAA6c,2CAA2C,gMAAgM,iDAAiD,6BAA6B,4EAA4E,UAAU,EAAE,qEAAqE,iFAAiF,EAAE,6IAA6I,MAAM,8BAA8B,+BAA+B,gCAAgC,gCAAgC,+BAA+B,8BAA8B,4BAA4B,yBAAyB,MAAM,+DAA+D,+BAA+B,sCAAsC,WAAW,qDAAqD,gHAAgH,gGAAgG,4FAA4F,gGAAgG,MAAM,iDAAiD,0BAA0B,MAAM,qDAAqD,yCAAyC,oCAAoC,+DAA+D,2BAA2B,QAAQ,MAAM,2BAA2B,OAAO,wBAAwB,MAAM,6DAA6D,yDAAyD,sGAAsG,iCAAiC,oHAAoH,YAAY,EAAE,yBAAyB,qGAAqG,kEAAkE,uBAAuB,2EAA2E,uFAAuF,qEAAqE,UAAU,gCAAgC,YAAY,EAAE,MAAM,yDAAyD,2FAA2F,6BAA6B,gHAAgH,YAAY,EAAE,qBAAqB,oHAAoH,sEAAsE,+BAA+B,wBAAwB,gDAAgD,SAAS,cAAc,kCAAkC,qBAAqB,UAAU,mEAAmE,uFAAuF,qEAAqE,UAAU,gCAAgC,YAAY,EAAE,MAAM,sGAAsG,QAAQ,2DAA2D,QAAQ,6GAA6G,sBAAsB,mEAAmE,4BAA4B,8GAA8G,2DAA2D,sCAAsC,uHAAuH,iEAAiE,wBAAwB,MAAM,iEAAiE,6DAA6D,sBAAsB,yCAAyC,6CAA6C,kBAAkB,MAAM,yEAAyE,qKAAqK,6BAA6B,iMAAiM,mKAAmK,8DAA8D,0BAA0B,iDAAiD,qCAAqC,wCAAwC,sTAAsT,sDAAsD,iDAAiD,+HAA+H,6HAA6H,UAAU,EAAE,iEAAiE,oFAAoF,oeAAoe,2CAA2C,kKAAkK,0DAA0D,0BAA0B,8CAA8C,UAAU,EAAE,qEAAqE,iFAAiF,EAAE,yGAAyG,MAAM,uEAAuE,oHAAoH,4BAA4B,qOAAqO,yMAAyM,wCAAwC,oCAAoC,8DAA8D,0BAA0B,8DAA8D,UAAU,oPAAoP,qEAAqE,sHAAsH,+HAA+H,6HAA6H,UAAU,EAAE,qGAAqG,oFAAoF,8fAA8f,2CAA2C,+JAA+J,0BAA0B,0DAA0D,2EAA2E,EAAE,qEAAqE,iFAAiF,EAAE,qKAAqK,MAAM,wBAAwB,mBAAmB,+BAA+B,KAAK,cAAc,2BAA2B,IAAI,IAAI,C;;;;;;;;;;ACAjryH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAI;AACJ;AACA,IAAI;AACJ;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;;;;;AC1BA,mBAAO,CAAC,8FAAuH,EAAE,mBAAO,CAAC,wIAAsN,E;;;;;;;;;;ACA/V,mBAAO,CAAC,8FAAuH,EAAE,mBAAO,CAAC,oJAA4N,E;;;;;;;;;;ACArW;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,2BAA2B,gBAAgB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,gDAAgD,YAAY;AAC5D,MAAM;AACN,qDAAqD,YAAY;AACjE;AACA;AACA;AACA;AACA;AACA,CAAC,W;;;;;;;;;;AC1GD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,kBAAkB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,kDAAkD,uBAAuB,+BAA+B;AACxG,sCAAsC;AACtC,gCAAgC;AAChC,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA,kBAAkB,qBAAqB;AACvC;AACA;AACA;AACA;;AAEA;AACA,6BAA6B;;AAE7B;AACA,uCAAuC;;AAEvC;AACA;AACA;AACA,+BAA+B;AAC/B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+EAA+E;AAC/E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,gBAAgB;AAChB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,mBAAmB,YAAY;AAC/B,kEAAkE,6CAA6C;AAC/G,2EAA2E,+CAA+C;AAC1H,yEAAyE,8CAA8C;AACvH,iCAAiC,4DAA4D;AAC7F,YAAY;AACZ,MAAM;AACN;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,YAAY;AAC9B;AACA;AACA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,6BAA6B;AAC7B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B,+BAA+B;;AAE/B;AACA;AACA;AACA;;AAEA;AACA,0CAA0C;AAC1C,0CAA0C;AAC1C,2CAA2C;AAC3C,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,eAAe,MAAM;AACrB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA,0CAA0C,MAAM;AAChD;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uDAAuD;AACvD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,0BAA0B;AAC5D,mCAAmC,0BAA0B;;AAE7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,uCAAuC,kCAAkC;AACzE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,uCAAuC,kCAAkC;AACzE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,iDAAiD;AACjD;AACA;AACA;AACA,oDAAoD;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,+CAA+C;AAC/C;AACA,mBAAmB,0BAA0B;AAC7C;AACA,sEAAsE;AACtE;AACA;AACA;AACA,mEAAmE;AACnE;AACA;AACA;;AAEA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAoB,kBAAkB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,2DAA2D;AAC3D,oBAAoB,iBAAiB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,+DAA+D;AAC/D,wDAAwD;;AAExD;AACA,0DAA0D;AAC1D,qEAAqE;AACrE,8DAA8D;AAC9D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,uDAAuD;AACvD,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,0BAA0B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,+BAA+B;AAC/B,kFAAkF;AAClF,kFAAkF;AAClF,iEAAiE;AACjE,iEAAiE;AACjE,gDAAgD;AAChD,gDAAgD;AAChD,oCAAoC,EAAE,sCAAsC;AAC5E,gCAAgC;AAChC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AAAM;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA,oBAAoB,sBAAsB;AAC1C;AACA,wBAAwB,sBAAsB;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA,kCAAkC;AAClC;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kCAAkC;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,MAAM;AAC1B,qBAAqB,MAAM;AAC3B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,+BAA+B;AAClD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gFAAgF;;AAEhF;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,yBAAyB,0BAA0B;AACnD;AACA,oEAAoE;AACpE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB,eAAe;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oCAAoC,0CAA0C,wDAAwD;AACtI;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA,+FAA+F;AAC/F,oCAAoC;AACpC,8BAA8B;AAC9B,kBAAkB,kBAAkB;AACpC;AACA,sCAAsC;AACtC;AACA,uCAAuC;AACvC,oBAAoB,qBAAqB;AACzC;AACA;AACA;AACA,sBAAsB,mBAAmB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,eAAe;AACtC;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB,gBAAgB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,wBAAwB;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAyB;AACzB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC,sBAAsB,WAAW;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,+CAA+C;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;;AAEA;AACA;AACA,0DAA0D;AAC1D,8CAA8C;AAC9C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oBAAoB,yBAAyB;AAC7C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,MAAM;AACN;;AAEA;AACA,wBAAwB;AACxB,0BAA0B;AAC1B,MAAM;AACN;;AAEA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,sBAAsB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA,EAAE;;AAEF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;;;;;;;;;;ACxxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wCAAwC;AACxC;AACA,QAAQ,OAAO;AACf;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX,UAAU;AACV;AACA,2BAA2B,cAAc;AACzC;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,UAAU;AACV;AACA;AACA,SAAS;AACT,QAAQ;AACR,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG,W;;;;;;UCtNH;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;;ACL4C;AACM;AACb;AACJ;AACQ","sources":["webpack://easy-charts/./src/js/dependencies/d3.js","webpack://easy-charts/./src/js/dependencies/uvcharts.js","webpack://easy-charts/./node_modules/script-loader/addScript.js","webpack://easy-charts/./src/js/dependencies/d3.js?05b8","webpack://easy-charts/./src/js/dependencies/uvcharts.js?677f","webpack://easy-charts/./src/js/dependencies/canvas-toblob.js","webpack://easy-charts/./src/js/dependencies/canvg.js","webpack://easy-charts/./src/js/dependencies/filesaver.js","webpack://easy-charts/webpack/bootstrap","webpack://easy-charts/webpack/runtime/compat get default export","webpack://easy-charts/webpack/runtime/define property getters","webpack://easy-charts/webpack/runtime/hasOwnProperty shorthand","webpack://easy-charts/webpack/runtime/make namespace object","webpack://easy-charts/./src/js/dependencies.js"],"sourcesContent":["module.exports = \"!function() {\\n\\tvar d3 = {\\n\\t\\tversion: \\\"3.5.12\\\"\\n\\t};\\n\\tvar d3_arraySlice = [].slice, d3_array = function( list ) {\\n\\t\\treturn d3_arraySlice.call( list );\\n\\t};\\n\\tvar d3_document = this.document;\\n\\tfunction d3_documentElement( node ) {\\n\\t\\treturn node && ( node.ownerDocument || node.document || node ).documentElement;\\n\\t}\\n\\tfunction d3_window( node ) {\\n\\t\\treturn node && ( node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView );\\n\\t}\\n\\tif ( d3_document ) {\\n\\t\\ttry {\\n\\t\\t\\td3_array( d3_document.documentElement.childNodes )[0].nodeType;\\n\\t\\t} catch ( e ) {\\n\\t\\t\\td3_array = function( list ) {\\n\\t\\t\\t\\tvar i = list.length, array = new Array( i );\\n\\t\\t\\t\\twhile ( i-- ) array[i] = list[i];\\n\\t\\t\\t\\treturn array;\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\tif ( !Date.now ) Date.now = function() {\\n\\t\\treturn +new Date();\\n\\t};\\n\\tif ( d3_document ) {\\n\\t\\ttry {\\n\\t\\t\\td3_document.createElement( \\\"DIV\\\" ).style.setProperty( \\\"opacity\\\", 0, \\\"\\\" );\\n\\t\\t} catch ( error ) {\\n\\t\\t\\tvar d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\\n\\t\\t\\td3_element_prototype.setAttribute = function( name, value ) {\\n\\t\\t\\t\\td3_element_setAttribute.call( this, name, value + \\\"\\\" );\\n\\t\\t\\t};\\n\\t\\t\\td3_element_prototype.setAttributeNS = function( space, local, value ) {\\n\\t\\t\\t\\td3_element_setAttributeNS.call( this, space, local, value + \\\"\\\" );\\n\\t\\t\\t};\\n\\t\\t\\td3_style_prototype.setProperty = function( name, value, priority ) {\\n\\t\\t\\t\\td3_style_setProperty.call( this, name, value + \\\"\\\", priority );\\n\\t\\t\\t};\\n\\t\\t}\\n\\t}\\n\\td3.ascending = d3_ascending;\\n\\tfunction d3_ascending( a, b ) {\\n\\t\\treturn a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\\n\\t}\\n\\td3.descending = function( a, b ) {\\n\\t\\treturn b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\\n\\t};\\n\\td3.min = function( array, f ) {\\n\\t\\tvar i = -1, n = array.length, a, b;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null && b >= b ) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null && a > b ) a = b;\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null && b >= b ) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null && a > b ) a = b;\\n\\t\\t}\\n\\t\\treturn a;\\n\\t};\\n\\td3.max = function( array, f ) {\\n\\t\\tvar i = -1, n = array.length, a, b;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null && b >= b ) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null && b > a ) a = b;\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null && b >= b ) {\\n\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null && b > a ) a = b;\\n\\t\\t}\\n\\t\\treturn a;\\n\\t};\\n\\td3.extent = function( array, f ) {\\n\\t\\tvar i = -1, n = array.length, a, b, c;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null && b >= b ) {\\n\\t\\t\\t\\ta = c = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = array[i] ) != null ) {\\n\\t\\t\\t\\tif ( a > b ) a = b;\\n\\t\\t\\t\\tif ( c < b ) c = b;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null && b >= b ) {\\n\\t\\t\\t\\ta = c = b;\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) if ( ( b = f.call( array, array[i], i ) ) != null ) {\\n\\t\\t\\t\\tif ( a > b ) a = b;\\n\\t\\t\\t\\tif ( c < b ) c = b;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn [ a, c ];\\n\\t};\\n\\tfunction d3_number( x ) {\\n\\t\\treturn x === null ? NaN : +x;\\n\\t}\\n\\tfunction d3_numeric( x ) {\\n\\t\\treturn !isNaN( x );\\n\\t}\\n\\td3.sum = function( array, f ) {\\n\\t\\tvar s = 0, n = array.length, a, i = -1;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = +array[i] ) ) s += a;\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = +f.call( array, array[i], i ) ) ) s += a;\\n\\t\\t}\\n\\t\\treturn s;\\n\\t};\\n\\td3.mean = function( array, f ) {\\n\\t\\tvar s = 0, n = array.length, a, i = -1, j = n;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = d3_number( array[i] ) ) ) s += a; else --j;\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = d3_number( f.call( array, array[i], i ) ) ) ) s += a; else --j;\\n\\t\\t}\\n\\t\\tif ( j ) return s / j;\\n\\t};\\n\\td3.quantile = function( values, p ) {\\n\\t\\tvar H = ( values.length - 1 ) * p + 1, h = Math.floor( H ), v = +values[h - 1], e = H - h;\\n\\t\\treturn e ? v + e * ( values[h] - v ) : v;\\n\\t};\\n\\td3.median = function( array, f ) {\\n\\t\\tvar numbers = [], n = array.length, a, i = -1;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = d3_number( array[i] ) ) ) numbers.push( a );\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) if ( d3_numeric( a = d3_number( f.call( array, array[i], i ) ) ) ) numbers.push( a );\\n\\t\\t}\\n\\t\\tif ( numbers.length ) return d3.quantile( numbers.sort( d3_ascending ), .5 );\\n\\t};\\n\\td3.variance = function( array, f ) {\\n\\t\\tvar n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\\n\\t\\tif ( arguments.length === 1 ) {\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( d3_numeric( a = d3_number( array[i] ) ) ) {\\n\\t\\t\\t\\t\\td = a - m;\\n\\t\\t\\t\\t\\tm += d / ++j;\\n\\t\\t\\t\\t\\ts += d * ( a - m );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( d3_numeric( a = d3_number( f.call( array, array[i], i ) ) ) ) {\\n\\t\\t\\t\\t\\td = a - m;\\n\\t\\t\\t\\t\\tm += d / ++j;\\n\\t\\t\\t\\t\\ts += d * ( a - m );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( j > 1 ) return s / ( j - 1 );\\n\\t};\\n\\td3.deviation = function() {\\n\\t\\tvar v = d3.variance.apply( this, arguments );\\n\\t\\treturn v ? Math.sqrt( v ) : v;\\n\\t};\\n\\tfunction d3_bisector( compare ) {\\n\\t\\treturn {\\n\\t\\t\\tleft: function( a, x, lo, hi ) {\\n\\t\\t\\t\\tif ( arguments.length < 3 ) lo = 0;\\n\\t\\t\\t\\tif ( arguments.length < 4 ) hi = a.length;\\n\\t\\t\\t\\twhile ( lo < hi ) {\\n\\t\\t\\t\\t\\tvar mid = lo + hi >>> 1;\\n\\t\\t\\t\\t\\tif ( compare( a[mid], x ) < 0 ) lo = mid + 1; else hi = mid;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn lo;\\n\\t\\t\\t},\\n\\t\\t\\tright: function( a, x, lo, hi ) {\\n\\t\\t\\t\\tif ( arguments.length < 3 ) lo = 0;\\n\\t\\t\\t\\tif ( arguments.length < 4 ) hi = a.length;\\n\\t\\t\\t\\twhile ( lo < hi ) {\\n\\t\\t\\t\\t\\tvar mid = lo + hi >>> 1;\\n\\t\\t\\t\\t\\tif ( compare( a[mid], x ) > 0 ) hi = mid; else lo = mid + 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn lo;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tvar d3_bisect = d3_bisector( d3_ascending );\\n\\td3.bisectLeft = d3_bisect.left;\\n\\td3.bisect = d3.bisectRight = d3_bisect.right;\\n\\td3.bisector = function( f ) {\\n\\t\\treturn d3_bisector( f.length === 1 ? function( d, x ) {\\n\\t\\t\\treturn d3_ascending( f( d ), x );\\n\\t\\t} : f );\\n\\t};\\n\\td3.shuffle = function( array, i0, i1 ) {\\n\\t\\tif ( ( m = arguments.length ) < 3 ) {\\n\\t\\t\\ti1 = array.length;\\n\\t\\t\\tif ( m < 2 ) i0 = 0;\\n\\t\\t}\\n\\t\\tvar m = i1 - i0, t, i;\\n\\t\\twhile ( m ) {\\n\\t\\t\\ti = Math.random() * m-- | 0;\\n\\t\\t\\tt = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\\n\\t\\t}\\n\\t\\treturn array;\\n\\t};\\n\\td3.permute = function( array, indexes ) {\\n\\t\\tvar i = indexes.length, permutes = new Array( i );\\n\\t\\twhile ( i-- ) permutes[i] = array[indexes[i]];\\n\\t\\treturn permutes;\\n\\t};\\n\\td3.pairs = function( array ) {\\n\\t\\tvar i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array( n < 0 ? 0 : n );\\n\\t\\twhile ( i < n ) pairs[i] = [ p0 = p1, p1 = array[++i] ];\\n\\t\\treturn pairs;\\n\\t};\\n\\td3.zip = function() {\\n\\t\\tif ( !( n = arguments.length ) ) return [];\\n\\t\\tfor ( var i = -1, m = d3.min( arguments, d3_zipLength ), zips = new Array( m ); ++i < m; ) {\\n\\t\\t\\tfor ( var j = -1, n, zip = zips[i] = new Array( n ); ++j < n; ) {\\n\\t\\t\\t\\tzip[j] = arguments[j][i];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn zips;\\n\\t};\\n\\tfunction d3_zipLength( d ) {\\n\\t\\treturn d.length;\\n\\t}\\n\\td3.transpose = function( matrix ) {\\n\\t\\treturn d3.zip.apply( d3, matrix );\\n\\t};\\n\\td3.keys = function( map ) {\\n\\t\\tvar keys = [];\\n\\t\\tfor ( var key in map ) keys.push( key );\\n\\t\\treturn keys;\\n\\t};\\n\\td3.values = function( map ) {\\n\\t\\tvar values = [];\\n\\t\\tfor ( var key in map ) values.push( map[key] );\\n\\t\\treturn values;\\n\\t};\\n\\td3.entries = function( map ) {\\n\\t\\tvar entries = [];\\n\\t\\tfor ( var key in map ) entries.push( {\\n\\t\\t\\tkey: key,\\n\\t\\t\\tvalue: map[key]\\n\\t\\t} );\\n\\t\\treturn entries;\\n\\t};\\n\\td3.merge = function( arrays ) {\\n\\t\\tvar n = arrays.length, m, i = -1, j = 0, merged, array;\\n\\t\\twhile ( ++i < n ) j += arrays[i].length;\\n\\t\\tmerged = new Array( j );\\n\\t\\twhile ( --n >= 0 ) {\\n\\t\\t\\tarray = arrays[n];\\n\\t\\t\\tm = array.length;\\n\\t\\t\\twhile ( --m >= 0 ) {\\n\\t\\t\\t\\tmerged[--j] = array[m];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn merged;\\n\\t};\\n\\tvar abs = Math.abs;\\n\\td3.range = function( start, stop, step ) {\\n\\t\\tif ( arguments.length < 3 ) {\\n\\t\\t\\tstep = 1;\\n\\t\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\t\\tstop = start;\\n\\t\\t\\t\\tstart = 0;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( ( stop - start ) / step === Infinity ) throw new Error( \\\"infinite range\\\" );\\n\\t\\tvar range = [], k = d3_range_integerScale( abs( step ) ), i = -1, j;\\n\\t\\tstart *= k, stop *= k, step *= k;\\n\\t\\tif ( step < 0 ) while ( ( j = start + step * ++i ) > stop ) range.push( j / k ); else while ( ( j = start + step * ++i ) < stop ) range.push( j / k );\\n\\t\\treturn range;\\n\\t};\\n\\tfunction d3_range_integerScale( x ) {\\n\\t\\tvar k = 1;\\n\\t\\twhile ( x * k % 1 ) k *= 10;\\n\\t\\treturn k;\\n\\t}\\n\\tfunction d3_class( ctor, properties ) {\\n\\t\\tfor ( var key in properties ) {\\n\\t\\t\\tObject.defineProperty( ctor.prototype, key, {\\n\\t\\t\\t\\tvalue: properties[key],\\n\\t\\t\\t\\tenumerable: false\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t}\\n\\td3.map = function( object, f ) {\\n\\t\\tvar map = new d3_Map();\\n\\t\\tif ( object instanceof d3_Map ) {\\n\\t\\t\\tobject.forEach( function( key, value ) {\\n\\t\\t\\t\\tmap.set( key, value );\\n\\t\\t\\t} );\\n\\t\\t} else if ( Array.isArray( object ) ) {\\n\\t\\t\\tvar i = -1, n = object.length, o;\\n\\t\\t\\tif ( arguments.length === 1 ) while ( ++i < n ) map.set( i, object[i] ); else while ( ++i < n ) map.set( f.call( object, o = object[i], i ), o );\\n\\t\\t} else {\\n\\t\\t\\tfor ( var key in object ) map.set( key, object[key] );\\n\\t\\t}\\n\\t\\treturn map;\\n\\t};\\n\\tfunction d3_Map() {\\n\\t\\tthis._ = Object.create( null );\\n\\t}\\n\\tvar d3_map_proto = \\\"__proto__\\\", d3_map_zero = \\\"\\\\x00\\\";\\n\\td3_class( d3_Map, {\\n\\t\\thas: d3_map_has,\\n\\t\\tget: function( key ) {\\n\\t\\t\\treturn this._[d3_map_escape( key )];\\n\\t\\t},\\n\\t\\tset: function( key, value ) {\\n\\t\\t\\treturn this._[d3_map_escape( key )] = value;\\n\\t\\t},\\n\\t\\tremove: d3_map_remove,\\n\\t\\tkeys: d3_map_keys,\\n\\t\\tvalues: function() {\\n\\t\\t\\tvar values = [];\\n\\t\\t\\tfor ( var key in this._ ) values.push( this._[key] );\\n\\t\\t\\treturn values;\\n\\t\\t},\\n\\t\\tentries: function() {\\n\\t\\t\\tvar entries = [];\\n\\t\\t\\tfor ( var key in this._ ) entries.push( {\\n\\t\\t\\t\\tkey: d3_map_unescape( key ),\\n\\t\\t\\t\\tvalue: this._[key]\\n\\t\\t\\t} );\\n\\t\\t\\treturn entries;\\n\\t\\t},\\n\\t\\tsize: d3_map_size,\\n\\t\\tempty: d3_map_empty,\\n\\t\\tforEach: function( f ) {\\n\\t\\t\\tfor ( var key in this._ ) f.call( this, d3_map_unescape( key ), this._[key] );\\n\\t\\t}\\n\\t} );\\n\\tfunction d3_map_escape( key ) {\\n\\t\\treturn ( key += \\\"\\\" ) === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\\n\\t}\\n\\tfunction d3_map_unescape( key ) {\\n\\t\\treturn ( key += \\\"\\\" )[0] === d3_map_zero ? key.slice( 1 ) : key;\\n\\t}\\n\\tfunction d3_map_has( key ) {\\n\\t\\treturn d3_map_escape( key ) in this._;\\n\\t}\\n\\tfunction d3_map_remove( key ) {\\n\\t\\treturn ( key = d3_map_escape( key ) ) in this._ && delete this._[key];\\n\\t}\\n\\tfunction d3_map_keys() {\\n\\t\\tvar keys = [];\\n\\t\\tfor ( var key in this._ ) keys.push( d3_map_unescape( key ) );\\n\\t\\treturn keys;\\n\\t}\\n\\tfunction d3_map_size() {\\n\\t\\tvar size = 0;\\n\\t\\tfor ( var key in this._ ) ++size;\\n\\t\\treturn size;\\n\\t}\\n\\tfunction d3_map_empty() {\\n\\t\\tfor ( var key in this._ ) return false;\\n\\t\\treturn true;\\n\\t}\\n\\td3.nest = function() {\\n\\t\\tvar nest = {}, keys = [], sortKeys = [], sortValues, rollup;\\n\\t\\tfunction map( mapType, array, depth ) {\\n\\t\\t\\tif ( depth >= keys.length ) return rollup ? rollup.call( nest, array ) : sortValues ? array.sort( sortValues ) : array;\\n\\t\\t\\tvar i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( values = valuesByKey.get( keyValue = key( object = array[i] ) ) ) {\\n\\t\\t\\t\\t\\tvalues.push( object );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvaluesByKey.set( keyValue, [ object ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( mapType ) {\\n\\t\\t\\t\\tobject = mapType();\\n\\t\\t\\t\\tsetter = function( keyValue, values ) {\\n\\t\\t\\t\\t\\tobject.set( keyValue, map( mapType, values, depth ) );\\n\\t\\t\\t\\t};\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tobject = {};\\n\\t\\t\\t\\tsetter = function( keyValue, values ) {\\n\\t\\t\\t\\t\\tobject[keyValue] = map( mapType, values, depth );\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tvaluesByKey.forEach( setter );\\n\\t\\t\\treturn object;\\n\\t\\t}\\n\\t\\tfunction entries( map, depth ) {\\n\\t\\t\\tif ( depth >= keys.length ) return map;\\n\\t\\t\\tvar array = [], sortKey = sortKeys[depth++];\\n\\t\\t\\tmap.forEach( function( key, keyMap ) {\\n\\t\\t\\t\\tarray.push( {\\n\\t\\t\\t\\t\\tkey: key,\\n\\t\\t\\t\\t\\tvalues: entries( keyMap, depth )\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} );\\n\\t\\t\\treturn sortKey ? array.sort( function( a, b ) {\\n\\t\\t\\t\\treturn sortKey( a.key, b.key );\\n\\t\\t\\t} ) : array;\\n\\t\\t}\\n\\t\\tnest.map = function( array, mapType ) {\\n\\t\\t\\treturn map( mapType, array, 0 );\\n\\t\\t};\\n\\t\\tnest.entries = function( array ) {\\n\\t\\t\\treturn entries( map( d3.map, array, 0 ), 0 );\\n\\t\\t};\\n\\t\\tnest.key = function( d ) {\\n\\t\\t\\tkeys.push( d );\\n\\t\\t\\treturn nest;\\n\\t\\t};\\n\\t\\tnest.sortKeys = function( order ) {\\n\\t\\t\\tsortKeys[keys.length - 1] = order;\\n\\t\\t\\treturn nest;\\n\\t\\t};\\n\\t\\tnest.sortValues = function( order ) {\\n\\t\\t\\tsortValues = order;\\n\\t\\t\\treturn nest;\\n\\t\\t};\\n\\t\\tnest.rollup = function( f ) {\\n\\t\\t\\trollup = f;\\n\\t\\t\\treturn nest;\\n\\t\\t};\\n\\t\\treturn nest;\\n\\t};\\n\\td3.set = function( array ) {\\n\\t\\tvar set = new d3_Set();\\n\\t\\tif ( array ) for ( var i = 0, n = array.length; i < n; ++i ) set.add( array[i] );\\n\\t\\treturn set;\\n\\t};\\n\\tfunction d3_Set() {\\n\\t\\tthis._ = Object.create( null );\\n\\t}\\n\\td3_class( d3_Set, {\\n\\t\\thas: d3_map_has,\\n\\t\\tadd: function( key ) {\\n\\t\\t\\tthis._[d3_map_escape( key += \\\"\\\" )] = true;\\n\\t\\t\\treturn key;\\n\\t\\t},\\n\\t\\tremove: d3_map_remove,\\n\\t\\tvalues: d3_map_keys,\\n\\t\\tsize: d3_map_size,\\n\\t\\tempty: d3_map_empty,\\n\\t\\tforEach: function( f ) {\\n\\t\\t\\tfor ( var key in this._ ) f.call( this, d3_map_unescape( key ) );\\n\\t\\t}\\n\\t} );\\n\\td3.behavior = {};\\n\\tfunction d3_identity( d ) {\\n\\t\\treturn d;\\n\\t}\\n\\td3.rebind = function( target, source ) {\\n\\t\\tvar i = 1, n = arguments.length, method;\\n\\t\\twhile ( ++i < n ) target[method = arguments[i]] = d3_rebind( target, source, source[method] );\\n\\t\\treturn target;\\n\\t};\\n\\tfunction d3_rebind( target, source, method ) {\\n\\t\\treturn function() {\\n\\t\\t\\tvar value = method.apply( source, arguments );\\n\\t\\t\\treturn value === source ? target : value;\\n\\t\\t};\\n\\t}\\n\\tfunction d3_vendorSymbol( object, name ) {\\n\\t\\tif ( name in object ) return name;\\n\\t\\tname = name.charAt( 0 ).toUpperCase() + name.slice( 1 );\\n\\t\\tfor ( var i = 0, n = d3_vendorPrefixes.length; i < n; ++i ) {\\n\\t\\t\\tvar prefixName = d3_vendorPrefixes[i] + name;\\n\\t\\t\\tif ( prefixName in object ) return prefixName;\\n\\t\\t}\\n\\t}\\n\\tvar d3_vendorPrefixes = [ \\\"webkit\\\", \\\"ms\\\", \\\"moz\\\", \\\"Moz\\\", \\\"o\\\", \\\"O\\\" ];\\n\\tfunction d3_noop() {}\\n\\td3.dispatch = function() {\\n\\t\\tvar dispatch = new d3_dispatch(), i = -1, n = arguments.length;\\n\\t\\twhile ( ++i < n ) dispatch[arguments[i]] = d3_dispatch_event( dispatch );\\n\\t\\treturn dispatch;\\n\\t};\\n\\tfunction d3_dispatch() {}\\n\\td3_dispatch.prototype.on = function( type, listener ) {\\n\\t\\tvar i = type.indexOf( \\\".\\\" ), name = \\\"\\\";\\n\\t\\tif ( i >= 0 ) {\\n\\t\\t\\tname = type.slice( i + 1 );\\n\\t\\t\\ttype = type.slice( 0, i );\\n\\t\\t}\\n\\t\\tif ( type ) return arguments.length < 2 ? this[type].on( name ) : this[type].on( name, listener );\\n\\t\\tif ( arguments.length === 2 ) {\\n\\t\\t\\tif ( listener == null ) for ( type in this ) {\\n\\t\\t\\t\\tif ( this.hasOwnProperty( type ) ) this[type].on( name, null );\\n\\t\\t\\t}\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_dispatch_event( dispatch ) {\\n\\t\\tvar listeners = [], listenerByName = new d3_Map();\\n\\t\\tfunction event() {\\n\\t\\t\\tvar z = listeners, i = -1, n = z.length, l;\\n\\t\\t\\twhile ( ++i < n ) if ( l = z[i].on ) l.apply( this, arguments );\\n\\t\\t\\treturn dispatch;\\n\\t\\t}\\n\\t\\tevent.on = function( name, listener ) {\\n\\t\\t\\tvar l = listenerByName.get( name ), i;\\n\\t\\t\\tif ( arguments.length < 2 ) return l && l.on;\\n\\t\\t\\tif ( l ) {\\n\\t\\t\\t\\tl.on = null;\\n\\t\\t\\t\\tlisteners = listeners.slice( 0, i = listeners.indexOf( l ) ).concat( listeners.slice( i + 1 ) );\\n\\t\\t\\t\\tlistenerByName.remove( name );\\n\\t\\t\\t}\\n\\t\\t\\tif ( listener ) listeners.push( listenerByName.set( name, {\\n\\t\\t\\t\\ton: listener\\n\\t\\t\\t} ) );\\n\\t\\t\\treturn dispatch;\\n\\t\\t};\\n\\t\\treturn event;\\n\\t}\\n\\td3.event = null;\\n\\tfunction d3_eventPreventDefault() {\\n\\t\\td3.event.preventDefault();\\n\\t}\\n\\tfunction d3_eventSource() {\\n\\t\\tvar e = d3.event, s;\\n\\t\\twhile ( s = e.sourceEvent ) e = s;\\n\\t\\treturn e;\\n\\t}\\n\\tfunction d3_eventDispatch( target ) {\\n\\t\\tvar dispatch = new d3_dispatch(), i = 0, n = arguments.length;\\n\\t\\twhile ( ++i < n ) dispatch[arguments[i]] = d3_dispatch_event( dispatch );\\n\\t\\tdispatch.of = function( thiz, argumentz ) {\\n\\t\\t\\treturn function( e1 ) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tvar e0 = e1.sourceEvent = d3.event;\\n\\t\\t\\t\\t\\te1.target = target;\\n\\t\\t\\t\\t\\td3.event = e1;\\n\\t\\t\\t\\t\\tdispatch[e1.type].apply( thiz, argumentz );\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\td3.event = e0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\treturn dispatch;\\n\\t}\\n\\td3.requote = function( s ) {\\n\\t\\treturn s.replace( d3_requote_re, \\\"\\\\\\\\$&\\\" );\\n\\t};\\n\\tvar d3_requote_re = /[\\\\\\\\\\\\^\\\\$\\\\*\\\\+\\\\?\\\\|\\\\[\\\\]\\\\(\\\\)\\\\.\\\\{\\\\}]/g;\\n\\tvar d3_subclass = {}.__proto__ ? function( object, prototype ) {\\n\\t\\tobject.__proto__ = prototype;\\n\\t} : function( object, prototype ) {\\n\\t\\tfor ( var property in prototype ) object[property] = prototype[property];\\n\\t};\\n\\tfunction d3_selection( groups ) {\\n\\t\\td3_subclass( groups, d3_selectionPrototype );\\n\\t\\treturn groups;\\n\\t}\\n\\tvar d3_select = function( s, n ) {\\n\\t\\t\\treturn n.querySelector( s );\\n\\t\\t}, d3_selectAll = function( s, n ) {\\n\\t\\t\\treturn n.querySelectorAll( s );\\n\\t\\t}, d3_selectMatches = function( n, s ) {\\n\\t\\t\\tvar d3_selectMatcher = n.matches || n[d3_vendorSymbol( n, \\\"matchesSelector\\\" )];\\n\\t\\t\\td3_selectMatches = function( n, s ) {\\n\\t\\t\\t\\treturn d3_selectMatcher.call( n, s );\\n\\t\\t\\t};\\n\\t\\t\\treturn d3_selectMatches( n, s );\\n\\t\\t};\\n\\tif ( typeof Sizzle === \\\"function\\\" ) {\\n\\t\\td3_select = function( s, n ) {\\n\\t\\t\\treturn Sizzle( s, n )[0] || null;\\n\\t\\t};\\n\\t\\td3_selectAll = Sizzle;\\n\\t\\td3_selectMatches = Sizzle.matchesSelector;\\n\\t}\\n\\td3.selection = function() {\\n\\t\\treturn d3.select( d3_document.documentElement );\\n\\t};\\n\\tvar d3_selectionPrototype = d3.selection.prototype = [];\\n\\td3_selectionPrototype.select = function( selector ) {\\n\\t\\tvar subgroups = [], subgroup, subnode, group, node;\\n\\t\\tselector = d3_selection_selector( selector );\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tsubgroup.parentNode = ( group = this[j] ).parentNode;\\n\\t\\t\\tfor ( var i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\tsubgroup.push( subnode = selector.call( node, node.__data__, i, j ) );\\n\\t\\t\\t\\t\\tif ( subnode && \\\"__data__\\\" in node ) subnode.__data__ = node.__data__;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsubgroup.push( null );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_selection( subgroups );\\n\\t};\\n\\tfunction d3_selection_selector( selector ) {\\n\\t\\treturn typeof selector === \\\"function\\\" ? selector : function() {\\n\\t\\t\\treturn d3_select( selector, this );\\n\\t\\t};\\n\\t}\\n\\td3_selectionPrototype.selectAll = function( selector ) {\\n\\t\\tvar subgroups = [], subgroup, node;\\n\\t\\tselector = d3_selection_selectorAll( selector );\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tfor ( var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\tsubgroups.push( subgroup = d3_array( selector.call( node, node.__data__, i, j ) ) );\\n\\t\\t\\t\\t\\tsubgroup.parentNode = node;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_selection( subgroups );\\n\\t};\\n\\tfunction d3_selection_selectorAll( selector ) {\\n\\t\\treturn typeof selector === \\\"function\\\" ? selector : function() {\\n\\t\\t\\treturn d3_selectAll( selector, this );\\n\\t\\t};\\n\\t}\\n\\tvar d3_nsPrefix = {\\n\\t\\tsvg: \\\"http://www.w3.org/2000/svg\\\",\\n\\t\\txhtml: \\\"http://www.w3.org/1999/xhtml\\\",\\n\\t\\txlink: \\\"http://www.w3.org/1999/xlink\\\",\\n\\t\\txml: \\\"http://www.w3.org/XML/1998/namespace\\\",\\n\\t\\txmlns: \\\"http://www.w3.org/2000/xmlns/\\\"\\n\\t};\\n\\td3.ns = {\\n\\t\\tprefix: d3_nsPrefix,\\n\\t\\tqualify: function( name ) {\\n\\t\\t\\tvar i = name.indexOf( \\\":\\\" ), prefix = name;\\n\\t\\t\\tif ( i >= 0 && ( prefix = name.slice( 0, i ) ) !== \\\"xmlns\\\" ) name = name.slice( i + 1 );\\n\\t\\t\\treturn d3_nsPrefix.hasOwnProperty( prefix ) ? {\\n\\t\\t\\t\\tspace: d3_nsPrefix[prefix],\\n\\t\\t\\t\\tlocal: name\\n\\t\\t\\t} : name;\\n\\t\\t}\\n\\t};\\n\\td3_selectionPrototype.attr = function( name, value ) {\\n\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\tif ( typeof name === \\\"string\\\" ) {\\n\\t\\t\\t\\tvar node = this.node();\\n\\t\\t\\t\\tname = d3.ns.qualify( name );\\n\\t\\t\\t\\treturn name.local ? node.getAttributeNS( name.space, name.local ) : node.getAttribute( name );\\n\\t\\t\\t}\\n\\t\\t\\tfor ( value in name ) this.each( d3_selection_attr( value, name[value] ) );\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\treturn this.each( d3_selection_attr( name, value ) );\\n\\t};\\n\\tfunction d3_selection_attr( name, value ) {\\n\\t\\tname = d3.ns.qualify( name );\\n\\t\\tfunction attrNull() {\\n\\t\\t\\tthis.removeAttribute( name );\\n\\t\\t}\\n\\t\\tfunction attrNullNS() {\\n\\t\\t\\tthis.removeAttributeNS( name.space, name.local );\\n\\t\\t}\\n\\t\\tfunction attrConstant() {\\n\\t\\t\\tthis.setAttribute( name, value );\\n\\t\\t}\\n\\t\\tfunction attrConstantNS() {\\n\\t\\t\\tthis.setAttributeNS( name.space, name.local, value );\\n\\t\\t}\\n\\t\\tfunction attrFunction() {\\n\\t\\t\\tvar x = value.apply( this, arguments );\\n\\t\\t\\tif ( x == null ) this.removeAttribute( name ); else this.setAttribute( name, x );\\n\\t\\t}\\n\\t\\tfunction attrFunctionNS() {\\n\\t\\t\\tvar x = value.apply( this, arguments );\\n\\t\\t\\tif ( x == null ) this.removeAttributeNS( name.space, name.local ); else this.setAttributeNS( name.space, name.local, x );\\n\\t\\t}\\n\\t\\treturn value == null ? name.local ? attrNullNS : attrNull : typeof value === \\\"function\\\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\\n\\t}\\n\\tfunction d3_collapse( s ) {\\n\\t\\treturn s.trim().replace( /\\\\s+/g, \\\" \\\" );\\n\\t}\\n\\td3_selectionPrototype.classed = function( name, value ) {\\n\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\tif ( typeof name === \\\"string\\\" ) {\\n\\t\\t\\t\\tvar node = this.node(), n = ( name = d3_selection_classes( name ) ).length, i = -1;\\n\\t\\t\\t\\tif ( value = node.classList ) {\\n\\t\\t\\t\\t\\twhile ( ++i < n ) if ( !value.contains( name[i] ) ) return false;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvalue = node.getAttribute( \\\"class\\\" );\\n\\t\\t\\t\\t\\twhile ( ++i < n ) if ( !d3_selection_classedRe( name[i] ).test( value ) ) return false;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( value in name ) this.each( d3_selection_classed( value, name[value] ) );\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\treturn this.each( d3_selection_classed( name, value ) );\\n\\t};\\n\\tfunction d3_selection_classedRe( name ) {\\n\\t\\treturn new RegExp( \\\"(?:^|\\\\\\\\s+)\\\" + d3.requote( name ) + \\\"(?:\\\\\\\\s+|$)\\\", \\\"g\\\" );\\n\\t}\\n\\tfunction d3_selection_classes( name ) {\\n\\t\\treturn ( name + \\\"\\\" ).trim().split( /^|\\\\s+/ );\\n\\t}\\n\\tfunction d3_selection_classed( name, value ) {\\n\\t\\tname = d3_selection_classes( name ).map( d3_selection_classedName );\\n\\t\\tvar n = name.length;\\n\\t\\tfunction classedConstant() {\\n\\t\\t\\tvar i = -1;\\n\\t\\t\\twhile ( ++i < n ) name[i]( this, value );\\n\\t\\t}\\n\\t\\tfunction classedFunction() {\\n\\t\\t\\tvar i = -1, x = value.apply( this, arguments );\\n\\t\\t\\twhile ( ++i < n ) name[i]( this, x );\\n\\t\\t}\\n\\t\\treturn typeof value === \\\"function\\\" ? classedFunction : classedConstant;\\n\\t}\\n\\tfunction d3_selection_classedName( name ) {\\n\\t\\tvar re = d3_selection_classedRe( name );\\n\\t\\treturn function( node, value ) {\\n\\t\\t\\tif ( c = node.classList ) return value ? c.add( name ) : c.remove( name );\\n\\t\\t\\tvar c = node.getAttribute( \\\"class\\\" ) || \\\"\\\";\\n\\t\\t\\tif ( value ) {\\n\\t\\t\\t\\tre.lastIndex = 0;\\n\\t\\t\\t\\tif ( !re.test( c ) ) node.setAttribute( \\\"class\\\", d3_collapse( c + \\\" \\\" + name ) );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnode.setAttribute( \\\"class\\\", d3_collapse( c.replace( re, \\\" \\\" ) ) );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\td3_selectionPrototype.style = function( name, value, priority ) {\\n\\t\\tvar n = arguments.length;\\n\\t\\tif ( n < 3 ) {\\n\\t\\t\\tif ( typeof name !== \\\"string\\\" ) {\\n\\t\\t\\t\\tif ( n < 2 ) value = \\\"\\\";\\n\\t\\t\\t\\tfor ( priority in name ) this.each( d3_selection_style( priority, name[priority], value ) );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t\\tif ( n < 2 ) {\\n\\t\\t\\t\\tvar node = this.node();\\n\\t\\t\\t\\treturn d3_window( node ).getComputedStyle( node, null ).getPropertyValue( name );\\n\\t\\t\\t}\\n\\t\\t\\tpriority = \\\"\\\";\\n\\t\\t}\\n\\t\\treturn this.each( d3_selection_style( name, value, priority ) );\\n\\t};\\n\\tfunction d3_selection_style( name, value, priority ) {\\n\\t\\tfunction styleNull() {\\n\\t\\t\\tthis.style.removeProperty( name );\\n\\t\\t}\\n\\t\\tfunction styleConstant() {\\n\\t\\t\\tthis.style.setProperty( name, value, priority );\\n\\t\\t}\\n\\t\\tfunction styleFunction() {\\n\\t\\t\\tvar x = value.apply( this, arguments );\\n\\t\\t\\tif ( x == null ) this.style.removeProperty( name ); else this.style.setProperty( name, x, priority );\\n\\t\\t}\\n\\t\\treturn value == null ? styleNull : typeof value === \\\"function\\\" ? styleFunction : styleConstant;\\n\\t}\\n\\td3_selectionPrototype.property = function( name, value ) {\\n\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\tif ( typeof name === \\\"string\\\" ) return this.node()[name];\\n\\t\\t\\tfor ( value in name ) this.each( d3_selection_property( value, name[value] ) );\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\treturn this.each( d3_selection_property( name, value ) );\\n\\t};\\n\\tfunction d3_selection_property( name, value ) {\\n\\t\\tfunction propertyNull() {\\n\\t\\t\\tdelete this[name];\\n\\t\\t}\\n\\t\\tfunction propertyConstant() {\\n\\t\\t\\tthis[name] = value;\\n\\t\\t}\\n\\t\\tfunction propertyFunction() {\\n\\t\\t\\tvar x = value.apply( this, arguments );\\n\\t\\t\\tif ( x == null ) delete this[name]; else this[name] = x;\\n\\t\\t}\\n\\t\\treturn value == null ? propertyNull : typeof value === \\\"function\\\" ? propertyFunction : propertyConstant;\\n\\t}\\n\\td3_selectionPrototype.text = function( value ) {\\n\\t\\treturn arguments.length ? this.each( typeof value === \\\"function\\\" ? function() {\\n\\t\\t\\tvar v = value.apply( this, arguments );\\n\\t\\t\\tthis.textContent = v == null ? \\\"\\\" : v;\\n\\t\\t} : value == null ? function() {\\n\\t\\t\\tthis.textContent = \\\"\\\";\\n\\t\\t} : function() {\\n\\t\\t\\tthis.textContent = value;\\n\\t\\t} ) : this.node().textContent;\\n\\t};\\n\\td3_selectionPrototype.html = function( value ) {\\n\\t\\treturn arguments.length ? this.each( typeof value === \\\"function\\\" ? function() {\\n\\t\\t\\tvar v = value.apply( this, arguments );\\n\\t\\t\\tthis.innerHTML = v == null ? \\\"\\\" : v;\\n\\t\\t} : value == null ? function() {\\n\\t\\t\\tthis.innerHTML = \\\"\\\";\\n\\t\\t} : function() {\\n\\t\\t\\tthis.innerHTML = value;\\n\\t\\t} ) : this.node().innerHTML;\\n\\t};\\n\\td3_selectionPrototype.append = function( name ) {\\n\\t\\tname = d3_selection_creator( name );\\n\\t\\treturn this.select( function() {\\n\\t\\t\\treturn this.appendChild( name.apply( this, arguments ) );\\n\\t\\t} );\\n\\t};\\n\\tfunction d3_selection_creator( name ) {\\n\\t\\tfunction create() {\\n\\t\\t\\tvar document = this.ownerDocument, namespace = this.namespaceURI;\\n\\t\\t\\treturn namespace ? document.createElementNS( namespace, name ) : document.createElement( name );\\n\\t\\t}\\n\\t\\tfunction createNS() {\\n\\t\\t\\treturn this.ownerDocument.createElementNS( name.space, name.local );\\n\\t\\t}\\n\\t\\treturn typeof name === \\\"function\\\" ? name : ( name = d3.ns.qualify( name ) ).local ? createNS : create;\\n\\t}\\n\\td3_selectionPrototype.insert = function( name, before ) {\\n\\t\\tname = d3_selection_creator( name );\\n\\t\\tbefore = d3_selection_selector( before );\\n\\t\\treturn this.select( function() {\\n\\t\\t\\treturn this.insertBefore( name.apply( this, arguments ), before.apply( this, arguments ) || null );\\n\\t\\t} );\\n\\t};\\n\\td3_selectionPrototype.remove = function() {\\n\\t\\treturn this.each( d3_selectionRemove );\\n\\t};\\n\\tfunction d3_selectionRemove() {\\n\\t\\tvar parent = this.parentNode;\\n\\t\\tif ( parent ) parent.removeChild( this );\\n\\t}\\n\\td3_selectionPrototype.data = function( value, key ) {\\n\\t\\tvar i = -1, n = this.length, group, node;\\n\\t\\tif ( !arguments.length ) {\\n\\t\\t\\tvalue = new Array( n = ( group = this[0] ).length );\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\tvalue[i] = node.__data__;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn value;\\n\\t\\t}\\n\\t\\tfunction bind( group, groupData ) {\\n\\t\\t\\tvar i, n = group.length, m = groupData.length, n0 = Math.min( n, m ), updateNodes = new Array( m ), enterNodes = new Array( m ), exitNodes = new Array( n ), node, nodeData;\\n\\t\\t\\tif ( key ) {\\n\\t\\t\\t\\tvar nodeByKeyValue = new d3_Map(), keyValues = new Array( n ), keyValue;\\n\\t\\t\\t\\tfor ( i = -1; ++i < n; ) {\\n\\t\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\t\\tif ( nodeByKeyValue.has( keyValue = key.call( node, node.__data__, i ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\texitNodes[i] = node;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tnodeByKeyValue.set( keyValue, node );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tkeyValues[i] = keyValue;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor ( i = -1; ++i < m; ) {\\n\\t\\t\\t\\t\\tif ( !( node = nodeByKeyValue.get( keyValue = key.call( groupData, nodeData = groupData[i], i ) ) ) ) {\\n\\t\\t\\t\\t\\t\\tenterNodes[i] = d3_selection_dataNode( nodeData );\\n\\t\\t\\t\\t\\t} else if ( node !== true ) {\\n\\t\\t\\t\\t\\t\\tupdateNodes[i] = node;\\n\\t\\t\\t\\t\\t\\tnode.__data__ = nodeData;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnodeByKeyValue.set( keyValue, true );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor ( i = -1; ++i < n; ) {\\n\\t\\t\\t\\t\\tif ( i in keyValues && nodeByKeyValue.get( keyValues[i] ) !== true ) {\\n\\t\\t\\t\\t\\t\\texitNodes[i] = group[i];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfor ( i = -1; ++i < n0; ) {\\n\\t\\t\\t\\t\\tnode = group[i];\\n\\t\\t\\t\\t\\tnodeData = groupData[i];\\n\\t\\t\\t\\t\\tif ( node ) {\\n\\t\\t\\t\\t\\t\\tnode.__data__ = nodeData;\\n\\t\\t\\t\\t\\t\\tupdateNodes[i] = node;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tenterNodes[i] = d3_selection_dataNode( nodeData );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor ( ;i < m; ++i ) {\\n\\t\\t\\t\\t\\tenterNodes[i] = d3_selection_dataNode( groupData[i] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor ( ;i < n; ++i ) {\\n\\t\\t\\t\\t\\texitNodes[i] = group[i];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tenterNodes.update = updateNodes;\\n\\t\\t\\tenterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\\n\\t\\t\\tenter.push( enterNodes );\\n\\t\\t\\tupdate.push( updateNodes );\\n\\t\\t\\texit.push( exitNodes );\\n\\t\\t}\\n\\t\\tvar enter = d3_selection_enter( [] ), update = d3_selection( [] ), exit = d3_selection( [] );\\n\\t\\tif ( typeof value === \\\"function\\\" ) {\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tbind( group = this[i], value.call( group, group.parentNode.__data__, i ) );\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tbind( group = this[i], value );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tupdate.enter = function() {\\n\\t\\t\\treturn enter;\\n\\t\\t};\\n\\t\\tupdate.exit = function() {\\n\\t\\t\\treturn exit;\\n\\t\\t};\\n\\t\\treturn update;\\n\\t};\\n\\tfunction d3_selection_dataNode( data ) {\\n\\t\\treturn {\\n\\t\\t\\t__data__: data\\n\\t\\t};\\n\\t}\\n\\td3_selectionPrototype.datum = function( value ) {\\n\\t\\treturn arguments.length ? this.property( \\\"__data__\\\", value ) : this.property( \\\"__data__\\\" );\\n\\t};\\n\\td3_selectionPrototype.filter = function( filter ) {\\n\\t\\tvar subgroups = [], subgroup, group, node;\\n\\t\\tif ( typeof filter !== \\\"function\\\" ) filter = d3_selection_filter( filter );\\n\\t\\tfor ( var j = 0, m = this.length; j < m; j++ ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tsubgroup.parentNode = ( group = this[j] ).parentNode;\\n\\t\\t\\tfor ( var i = 0, n = group.length; i < n; i++ ) {\\n\\t\\t\\t\\tif ( ( node = group[i] ) && filter.call( node, node.__data__, i, j ) ) {\\n\\t\\t\\t\\t\\tsubgroup.push( node );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_selection( subgroups );\\n\\t};\\n\\tfunction d3_selection_filter( selector ) {\\n\\t\\treturn function() {\\n\\t\\t\\treturn d3_selectMatches( this, selector );\\n\\t\\t};\\n\\t}\\n\\td3_selectionPrototype.order = function() {\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tfor ( var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\tif ( next && next !== node.nextSibling ) next.parentNode.insertBefore( node, next );\\n\\t\\t\\t\\t\\tnext = node;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn this;\\n\\t};\\n\\td3_selectionPrototype.sort = function( comparator ) {\\n\\t\\tcomparator = d3_selection_sortComparator.apply( this, arguments );\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) this[j].sort( comparator );\\n\\t\\treturn this.order();\\n\\t};\\n\\tfunction d3_selection_sortComparator( comparator ) {\\n\\t\\tif ( !arguments.length ) comparator = d3_ascending;\\n\\t\\treturn function( a, b ) {\\n\\t\\t\\treturn a && b ? comparator( a.__data__, b.__data__ ) : !a - !b;\\n\\t\\t};\\n\\t}\\n\\td3_selectionPrototype.each = function( callback ) {\\n\\t\\treturn d3_selection_each( this, function( node, i, j ) {\\n\\t\\t\\tcallback.call( node, node.__data__, i, j );\\n\\t\\t} );\\n\\t};\\n\\tfunction d3_selection_each( groups, callback ) {\\n\\t\\tfor ( var j = 0, m = groups.length; j < m; j++ ) {\\n\\t\\t\\tfor ( var group = groups[j], i = 0, n = group.length, node; i < n; i++ ) {\\n\\t\\t\\t\\tif ( node = group[i] ) callback( node, i, j );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn groups;\\n\\t}\\n\\td3_selectionPrototype.call = function( callback ) {\\n\\t\\tvar args = d3_array( arguments );\\n\\t\\tcallback.apply( args[0] = this, args );\\n\\t\\treturn this;\\n\\t};\\n\\td3_selectionPrototype.empty = function() {\\n\\t\\treturn !this.node();\\n\\t};\\n\\td3_selectionPrototype.node = function() {\\n\\t\\tfor ( var j = 0, m = this.length; j < m; j++ ) {\\n\\t\\t\\tfor ( var group = this[j], i = 0, n = group.length; i < n; i++ ) {\\n\\t\\t\\t\\tvar node = group[i];\\n\\t\\t\\t\\tif ( node ) return node;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn null;\\n\\t};\\n\\td3_selectionPrototype.size = function() {\\n\\t\\tvar n = 0;\\n\\t\\td3_selection_each( this, function() {\\n\\t\\t\\t++n;\\n\\t\\t} );\\n\\t\\treturn n;\\n\\t};\\n\\tfunction d3_selection_enter( selection ) {\\n\\t\\td3_subclass( selection, d3_selection_enterPrototype );\\n\\t\\treturn selection;\\n\\t}\\n\\tvar d3_selection_enterPrototype = [];\\n\\td3.selection.enter = d3_selection_enter;\\n\\td3.selection.enter.prototype = d3_selection_enterPrototype;\\n\\td3_selection_enterPrototype.append = d3_selectionPrototype.append;\\n\\td3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\\n\\td3_selection_enterPrototype.node = d3_selectionPrototype.node;\\n\\td3_selection_enterPrototype.call = d3_selectionPrototype.call;\\n\\td3_selection_enterPrototype.size = d3_selectionPrototype.size;\\n\\td3_selection_enterPrototype.select = function( selector ) {\\n\\t\\tvar subgroups = [], subgroup, subnode, upgroup, group, node;\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tupgroup = ( group = this[j] ).update;\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tsubgroup.parentNode = group.parentNode;\\n\\t\\t\\tfor ( var i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\tsubgroup.push( upgroup[i] = subnode = selector.call( group.parentNode, node.__data__, i, j ) );\\n\\t\\t\\t\\t\\tsubnode.__data__ = node.__data__;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsubgroup.push( null );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_selection( subgroups );\\n\\t};\\n\\td3_selection_enterPrototype.insert = function( name, before ) {\\n\\t\\tif ( arguments.length < 2 ) before = d3_selection_enterInsertBefore( this );\\n\\t\\treturn d3_selectionPrototype.insert.call( this, name, before );\\n\\t};\\n\\tfunction d3_selection_enterInsertBefore( enter ) {\\n\\t\\tvar i0, j0;\\n\\t\\treturn function( d, i, j ) {\\n\\t\\t\\tvar group = enter[j].update, n = group.length, node;\\n\\t\\t\\tif ( j != j0 ) j0 = j, i0 = 0;\\n\\t\\t\\tif ( i >= i0 ) i0 = i + 1;\\n\\t\\t\\twhile ( !( node = group[i0] ) && ++i0 < n ) ;\\n\\t\\t\\treturn node;\\n\\t\\t};\\n\\t}\\n\\td3.select = function( node ) {\\n\\t\\tvar group;\\n\\t\\tif ( typeof node === \\\"string\\\" ) {\\n\\t\\t\\tgroup = [ d3_select( node, d3_document ) ];\\n\\t\\t\\tgroup.parentNode = d3_document.documentElement;\\n\\t\\t} else {\\n\\t\\t\\tgroup = [ node ];\\n\\t\\t\\tgroup.parentNode = d3_documentElement( node );\\n\\t\\t}\\n\\t\\treturn d3_selection( [ group ] );\\n\\t};\\n\\td3.selectAll = function( nodes ) {\\n\\t\\tvar group;\\n\\t\\tif ( typeof nodes === \\\"string\\\" ) {\\n\\t\\t\\tgroup = d3_array( d3_selectAll( nodes, d3_document ) );\\n\\t\\t\\tgroup.parentNode = d3_document.documentElement;\\n\\t\\t} else {\\n\\t\\t\\tgroup = d3_array( nodes );\\n\\t\\t\\tgroup.parentNode = null;\\n\\t\\t}\\n\\t\\treturn d3_selection( [ group ] );\\n\\t};\\n\\td3_selectionPrototype.on = function( type, listener, capture ) {\\n\\t\\tvar n = arguments.length;\\n\\t\\tif ( n < 3 ) {\\n\\t\\t\\tif ( typeof type !== \\\"string\\\" ) {\\n\\t\\t\\t\\tif ( n < 2 ) listener = false;\\n\\t\\t\\t\\tfor ( capture in type ) this.each( d3_selection_on( capture, type[capture], listener ) );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t\\tif ( n < 2 ) return ( n = this.node()[\\\"__on\\\" + type] ) && n._;\\n\\t\\t\\tcapture = false;\\n\\t\\t}\\n\\t\\treturn this.each( d3_selection_on( type, listener, capture ) );\\n\\t};\\n\\tfunction d3_selection_on( type, listener, capture ) {\\n\\t\\tvar name = \\\"__on\\\" + type, i = type.indexOf( \\\".\\\" ), wrap = d3_selection_onListener;\\n\\t\\tif ( i > 0 ) type = type.slice( 0, i );\\n\\t\\tvar filter = d3_selection_onFilters.get( type );\\n\\t\\tif ( filter ) type = filter, wrap = d3_selection_onFilter;\\n\\t\\tfunction onRemove() {\\n\\t\\t\\tvar l = this[name];\\n\\t\\t\\tif ( l ) {\\n\\t\\t\\t\\tthis.removeEventListener( type, l, l.$ );\\n\\t\\t\\t\\tdelete this[name];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction onAdd() {\\n\\t\\t\\tvar l = wrap( listener, d3_array( arguments ) );\\n\\t\\t\\tonRemove.call( this );\\n\\t\\t\\tthis.addEventListener( type, this[name] = l, l.$ = capture );\\n\\t\\t\\tl._ = listener;\\n\\t\\t}\\n\\t\\tfunction removeAll() {\\n\\t\\t\\tvar re = new RegExp( \\\"^__on([^.]+)\\\" + d3.requote( type ) + \\\"$\\\" ), match;\\n\\t\\t\\tfor ( var name in this ) {\\n\\t\\t\\t\\tif ( match = name.match( re ) ) {\\n\\t\\t\\t\\t\\tvar l = this[name];\\n\\t\\t\\t\\t\\tthis.removeEventListener( match[1], l, l.$ );\\n\\t\\t\\t\\t\\tdelete this[name];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\\n\\t}\\n\\tvar d3_selection_onFilters = d3.map( {\\n\\t\\tmouseenter: \\\"mouseover\\\",\\n\\t\\tmouseleave: \\\"mouseout\\\"\\n\\t} );\\n\\tif ( d3_document ) {\\n\\t\\td3_selection_onFilters.forEach( function( k ) {\\n\\t\\t\\tif ( \\\"on\\\" + k in d3_document ) d3_selection_onFilters.remove( k );\\n\\t\\t} );\\n\\t}\\n\\tfunction d3_selection_onListener( listener, argumentz ) {\\n\\t\\treturn function( e ) {\\n\\t\\t\\tvar o = d3.event;\\n\\t\\t\\td3.event = e;\\n\\t\\t\\targumentz[0] = this.__data__;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tlistener.apply( this, argumentz );\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\td3.event = o;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tfunction d3_selection_onFilter( listener, argumentz ) {\\n\\t\\tvar l = d3_selection_onListener( listener, argumentz );\\n\\t\\treturn function( e ) {\\n\\t\\t\\tvar target = this, related = e.relatedTarget;\\n\\t\\t\\tif ( !related || related !== target && !( related.compareDocumentPosition( target ) & 8 ) ) {\\n\\t\\t\\t\\tl.call( target, e );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tvar d3_event_dragSelect, d3_event_dragId = 0;\\n\\tfunction d3_event_dragSuppress( node ) {\\n\\t\\tvar name = \\\".dragsuppress-\\\" + ++d3_event_dragId, click = \\\"click\\\" + name, w = d3.select( d3_window( node ) ).on( \\\"touchmove\\\" + name, d3_eventPreventDefault ).on( \\\"dragstart\\\" + name, d3_eventPreventDefault ).on( \\\"selectstart\\\" + name, d3_eventPreventDefault );\\n\\t\\tif ( d3_event_dragSelect == null ) {\\n\\t\\t\\td3_event_dragSelect = \\\"onselectstart\\\" in node ? false : d3_vendorSymbol( node.style, \\\"userSelect\\\" );\\n\\t\\t}\\n\\t\\tif ( d3_event_dragSelect ) {\\n\\t\\t\\tvar style = d3_documentElement( node ).style, select = style[d3_event_dragSelect];\\n\\t\\t\\tstyle[d3_event_dragSelect] = \\\"none\\\";\\n\\t\\t}\\n\\t\\treturn function( suppressClick ) {\\n\\t\\t\\tw.on( name, null );\\n\\t\\t\\tif ( d3_event_dragSelect ) style[d3_event_dragSelect] = select;\\n\\t\\t\\tif ( suppressClick ) {\\n\\t\\t\\t\\tvar off = function() {\\n\\t\\t\\t\\t\\tw.on( click, null );\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tw.on( click, function() {\\n\\t\\t\\t\\t\\td3_eventPreventDefault();\\n\\t\\t\\t\\t\\toff();\\n\\t\\t\\t\\t}, true );\\n\\t\\t\\t\\tsetTimeout( off, 0 );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\td3.mouse = function( container ) {\\n\\t\\treturn d3_mousePoint( container, d3_eventSource() );\\n\\t};\\n\\tvar d3_mouse_bug44083 = this.navigator && /WebKit/.test( this.navigator.userAgent ) ? -1 : 0;\\n\\tfunction d3_mousePoint( container, e ) {\\n\\t\\tif ( e.changedTouches ) e = e.changedTouches[0];\\n\\t\\tvar svg = container.ownerSVGElement || container;\\n\\t\\tif ( svg.createSVGPoint ) {\\n\\t\\t\\tvar point = svg.createSVGPoint();\\n\\t\\t\\tif ( d3_mouse_bug44083 < 0 ) {\\n\\t\\t\\t\\tvar window = d3_window( container );\\n\\t\\t\\t\\tif ( window.scrollX || window.scrollY ) {\\n\\t\\t\\t\\t\\tsvg = d3.select( \\\"body\\\" ).append( \\\"svg\\\" ).style( {\\n\\t\\t\\t\\t\\t\\tposition: \\\"absolute\\\",\\n\\t\\t\\t\\t\\t\\ttop: 0,\\n\\t\\t\\t\\t\\t\\tleft: 0,\\n\\t\\t\\t\\t\\t\\tmargin: 0,\\n\\t\\t\\t\\t\\t\\tpadding: 0,\\n\\t\\t\\t\\t\\t\\tborder: \\\"none\\\"\\n\\t\\t\\t\\t\\t}, \\\"important\\\" );\\n\\t\\t\\t\\t\\tvar ctm = svg[0][0].getScreenCTM();\\n\\t\\t\\t\\t\\td3_mouse_bug44083 = !( ctm.f || ctm.e );\\n\\t\\t\\t\\t\\tsvg.remove();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( d3_mouse_bug44083 ) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX,\\n\\t\\t\\tpoint.y = e.clientY;\\n\\t\\t\\tpoint = point.matrixTransform( container.getScreenCTM().inverse() );\\n\\t\\t\\treturn [ point.x, point.y ];\\n\\t\\t}\\n\\t\\tvar rect = container.getBoundingClientRect();\\n\\t\\treturn [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\\n\\t}\\n\\td3.touch = function( container, touches, identifier ) {\\n\\t\\tif ( arguments.length < 3 ) identifier = touches, touches = d3_eventSource().changedTouches;\\n\\t\\tif ( touches ) for ( var i = 0, n = touches.length, touch; i < n; ++i ) {\\n\\t\\t\\tif ( ( touch = touches[i] ).identifier === identifier ) {\\n\\t\\t\\t\\treturn d3_mousePoint( container, touch );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\td3.behavior.drag = function() {\\n\\t\\tvar event = d3_eventDispatch( drag, \\\"drag\\\", \\\"dragstart\\\", \\\"dragend\\\" ), origin = null, mousedown = dragstart( d3_noop, d3.mouse, d3_window, \\\"mousemove\\\", \\\"mouseup\\\" ), touchstart = dragstart( d3_behavior_dragTouchId, d3.touch, d3_identity, \\\"touchmove\\\", \\\"touchend\\\" );\\n\\t\\tfunction drag() {\\n\\t\\t\\tthis.on( \\\"mousedown.drag\\\", mousedown ).on( \\\"touchstart.drag\\\", touchstart );\\n\\t\\t}\\n\\t\\tfunction dragstart( id, position, subject, move, end ) {\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\tvar that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of( that, arguments ), dragged = 0, dragId = id(), dragName = \\\".drag\\\" + ( dragId == null ? \\\"\\\" : \\\"-\\\" + dragId ), dragOffset, dragSubject = d3.select( subject( target ) ).on( move + dragName, moved ).on( end + dragName, ended ), dragRestore = d3_event_dragSuppress( target ), position0 = position( parent, dragId );\\n\\t\\t\\t\\tif ( origin ) {\\n\\t\\t\\t\\t\\tdragOffset = origin.apply( that, arguments );\\n\\t\\t\\t\\t\\tdragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tdragOffset = [ 0, 0 ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdispatch( {\\n\\t\\t\\t\\t\\ttype: \\\"dragstart\\\"\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\tfunction moved() {\\n\\t\\t\\t\\t\\tvar position1 = position( parent, dragId ), dx, dy;\\n\\t\\t\\t\\t\\tif ( !position1 ) return;\\n\\t\\t\\t\\t\\tdx = position1[0] - position0[0];\\n\\t\\t\\t\\t\\tdy = position1[1] - position0[1];\\n\\t\\t\\t\\t\\tdragged |= dx | dy;\\n\\t\\t\\t\\t\\tposition0 = position1;\\n\\t\\t\\t\\t\\tdispatch( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"drag\\\",\\n\\t\\t\\t\\t\\t\\tx: position1[0] + dragOffset[0],\\n\\t\\t\\t\\t\\t\\ty: position1[1] + dragOffset[1],\\n\\t\\t\\t\\t\\t\\tdx: dx,\\n\\t\\t\\t\\t\\t\\tdy: dy\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfunction ended() {\\n\\t\\t\\t\\t\\tif ( !position( parent, dragId ) ) return;\\n\\t\\t\\t\\t\\tdragSubject.on( move + dragName, null ).on( end + dragName, null );\\n\\t\\t\\t\\t\\tdragRestore( dragged );\\n\\t\\t\\t\\t\\tdispatch( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"dragend\\\"\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tdrag.origin = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return origin;\\n\\t\\t\\torigin = x;\\n\\t\\t\\treturn drag;\\n\\t\\t};\\n\\t\\treturn d3.rebind( drag, event, \\\"on\\\" );\\n\\t};\\n\\tfunction d3_behavior_dragTouchId() {\\n\\t\\treturn d3.event.changedTouches[0].identifier;\\n\\t}\\n\\td3.touches = function( container, touches ) {\\n\\t\\tif ( arguments.length < 2 ) touches = d3_eventSource().touches;\\n\\t\\treturn touches ? d3_array( touches ).map( function( touch ) {\\n\\t\\t\\tvar point = d3_mousePoint( container, touch );\\n\\t\\t\\tpoint.identifier = touch.identifier;\\n\\t\\t\\treturn point;\\n\\t\\t} ) : [];\\n\\t};\\n\\tvar  = 1e-6, 2 =  * ,  = Math.PI,  = 2 * ,  =  - , half =  / 2, d3_radians =  / 180, d3_degrees = 180 / ;\\n\\tfunction d3_sgn( x ) {\\n\\t\\treturn x > 0 ? 1 : x < 0 ? -1 : 0;\\n\\t}\\n\\tfunction d3_cross2d( a, b, c ) {\\n\\t\\treturn ( b[0] - a[0] ) * ( c[1] - a[1] ) - ( b[1] - a[1] ) * ( c[0] - a[0] );\\n\\t}\\n\\tfunction d3_acos( x ) {\\n\\t\\treturn x > 1 ? 0 : x < -1 ?  : Math.acos( x );\\n\\t}\\n\\tfunction d3_asin( x ) {\\n\\t\\treturn x > 1 ? half : x < -1 ? -half : Math.asin( x );\\n\\t}\\n\\tfunction d3_sinh( x ) {\\n\\t\\treturn ( ( x = Math.exp( x ) ) - 1 / x ) / 2;\\n\\t}\\n\\tfunction d3_cosh( x ) {\\n\\t\\treturn ( ( x = Math.exp( x ) ) + 1 / x ) / 2;\\n\\t}\\n\\tfunction d3_tanh( x ) {\\n\\t\\treturn ( ( x = Math.exp( 2 * x ) ) - 1 ) / ( x + 1 );\\n\\t}\\n\\tfunction d3_haversin( x ) {\\n\\t\\treturn ( x = Math.sin( x / 2 ) ) * x;\\n\\t}\\n\\tvar  = Math.SQRT2, 2 = 2, 4 = 4;\\n\\td3.interpolateZoom = function( p0, p1 ) {\\n\\t\\tvar ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\\n\\t\\tif ( d2 < 2 ) {\\n\\t\\t\\tS = Math.log( w1 / w0 ) / ;\\n\\t\\t\\ti = function( t ) {\\n\\t\\t\\t\\treturn [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(  * t * S ) ];\\n\\t\\t\\t};\\n\\t\\t} else {\\n\\t\\t\\tvar d1 = Math.sqrt( d2 ), b0 = ( w1 * w1 - w0 * w0 + 4 * d2 ) / ( 2 * w0 * 2 * d1 ), b1 = ( w1 * w1 - w0 * w0 - 4 * d2 ) / ( 2 * w1 * 2 * d1 ), r0 = Math.log( Math.sqrt( b0 * b0 + 1 ) - b0 ), r1 = Math.log( Math.sqrt( b1 * b1 + 1 ) - b1 );\\n\\t\\t\\tS = ( r1 - r0 ) / ;\\n\\t\\t\\ti = function( t ) {\\n\\t\\t\\t\\tvar s = t * S, coshr0 = d3_cosh( r0 ), u = w0 / ( 2 * d1 ) * ( coshr0 * d3_tanh(  * s + r0 ) - d3_sinh( r0 ) );\\n\\t\\t\\t\\treturn [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(  * s + r0 ) ];\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\ti.duration = S * 1e3;\\n\\t\\treturn i;\\n\\t};\\n\\td3.behavior.zoom = function() {\\n\\t\\tvar view = {\\n\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\ty: 0,\\n\\t\\t\\t\\tk: 1\\n\\t\\t\\t}, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \\\"mousedown.zoom\\\", mousemove = \\\"mousemove.zoom\\\", mouseup = \\\"mouseup.zoom\\\", mousewheelTimer, touchstart = \\\"touchstart.zoom\\\", touchtime, event = d3_eventDispatch( zoom, \\\"zoomstart\\\", \\\"zoom\\\", \\\"zoomend\\\" ), x0, x1, y0, y1;\\n\\t\\tif ( !d3_behavior_zoomWheel ) {\\n\\t\\t\\td3_behavior_zoomWheel = \\\"onwheel\\\" in d3_document ? ( d3_behavior_zoomDelta = function() {\\n\\t\\t\\t\\treturn -d3.event.deltaY * ( d3.event.deltaMode ? 120 : 1 );\\n\\t\\t\\t}, \\\"wheel\\\" ) : \\\"onmousewheel\\\" in d3_document ? ( d3_behavior_zoomDelta = function() {\\n\\t\\t\\t\\treturn d3.event.wheelDelta;\\n\\t\\t\\t}, \\\"mousewheel\\\" ) : ( d3_behavior_zoomDelta = function() {\\n\\t\\t\\t\\treturn -d3.event.detail;\\n\\t\\t\\t}, \\\"MozMousePixelScroll\\\" );\\n\\t\\t}\\n\\t\\tfunction zoom( g ) {\\n\\t\\t\\tg.on( mousedown, mousedowned ).on( d3_behavior_zoomWheel + \\\".zoom\\\", mousewheeled ).on( \\\"dblclick.zoom\\\", dblclicked ).on( touchstart, touchstarted );\\n\\t\\t}\\n\\t\\tzoom.event = function( g ) {\\n\\t\\t\\tg.each( function() {\\n\\t\\t\\t\\tvar dispatch = event.of( this, arguments ), view1 = view;\\n\\t\\t\\t\\tif ( d3_transitionInheritId ) {\\n\\t\\t\\t\\t\\td3.select( this ).transition().each( \\\"start.zoom\\\", function() {\\n\\t\\t\\t\\t\\t\\tview = this.__chart__ || {\\n\\t\\t\\t\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\t\\t\\t\\ty: 0,\\n\\t\\t\\t\\t\\t\\t\\tk: 1\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tzoomstarted( dispatch );\\n\\t\\t\\t\\t\\t} ).tween( \\\"zoom:zoom\\\", function() {\\n\\t\\t\\t\\t\\t\\tvar dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom( [ ( cx - view.x ) / view.k, ( cy - view.y ) / view.k, dx / view.k ], [ ( cx - view1.x ) / view1.k, ( cy - view1.y ) / view1.k, dx / view1.k ] );\\n\\t\\t\\t\\t\\t\\treturn function( t ) {\\n\\t\\t\\t\\t\\t\\t\\tvar l = i( t ), k = dx / l[2];\\n\\t\\t\\t\\t\\t\\t\\tthis.__chart__ = view = {\\n\\t\\t\\t\\t\\t\\t\\t\\tx: cx - l[0] * k,\\n\\t\\t\\t\\t\\t\\t\\t\\ty: cy - l[1] * k,\\n\\t\\t\\t\\t\\t\\t\\t\\tk: k\\n\\t\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\t\\tzoomed( dispatch );\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t} ).each( \\\"interrupt.zoom\\\", function() {\\n\\t\\t\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t\\t\\t} ).each( \\\"end.zoom\\\", function() {\\n\\t\\t\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tthis.__chart__ = view;\\n\\t\\t\\t\\t\\tzoomstarted( dispatch );\\n\\t\\t\\t\\t\\tzoomed( dispatch );\\n\\t\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tzoom.translate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ view.x, view.y ];\\n\\t\\t\\tview = {\\n\\t\\t\\t\\tx: +_[0],\\n\\t\\t\\t\\ty: +_[1],\\n\\t\\t\\t\\tk: view.k\\n\\t\\t\\t};\\n\\t\\t\\trescale();\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.scale = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return view.k;\\n\\t\\t\\tview = {\\n\\t\\t\\t\\tx: view.x,\\n\\t\\t\\t\\ty: view.y,\\n\\t\\t\\t\\tk: null\\n\\t\\t\\t};\\n\\t\\t\\tscaleTo( +_ );\\n\\t\\t\\trescale();\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.scaleExtent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return scaleExtent;\\n\\t\\t\\tscaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.center = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return center;\\n\\t\\t\\tcenter = _ && [ +_[0], +_[1] ];\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.size = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = _ && [ +_[0], +_[1] ];\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.duration = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return duration;\\n\\t\\t\\tduration = +_;\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.x = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return x1;\\n\\t\\t\\tx1 = z;\\n\\t\\t\\tx0 = z.copy();\\n\\t\\t\\tview = {\\n\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\ty: 0,\\n\\t\\t\\t\\tk: 1\\n\\t\\t\\t};\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tzoom.y = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return y1;\\n\\t\\t\\ty1 = z;\\n\\t\\t\\ty0 = z.copy();\\n\\t\\t\\tview = {\\n\\t\\t\\t\\tx: 0,\\n\\t\\t\\t\\ty: 0,\\n\\t\\t\\t\\tk: 1\\n\\t\\t\\t};\\n\\t\\t\\treturn zoom;\\n\\t\\t};\\n\\t\\tfunction location( p ) {\\n\\t\\t\\treturn [ ( p[0] - view.x ) / view.k, ( p[1] - view.y ) / view.k ];\\n\\t\\t}\\n\\t\\tfunction point( l ) {\\n\\t\\t\\treturn [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\\n\\t\\t}\\n\\t\\tfunction scaleTo( s ) {\\n\\t\\t\\tview.k = Math.max( scaleExtent[0], Math.min( scaleExtent[1], s ) );\\n\\t\\t}\\n\\t\\tfunction translateTo( p, l ) {\\n\\t\\t\\tl = point( l );\\n\\t\\t\\tview.x += p[0] - l[0];\\n\\t\\t\\tview.y += p[1] - l[1];\\n\\t\\t}\\n\\t\\tfunction zoomTo( that, p, l, k ) {\\n\\t\\t\\tthat.__chart__ = {\\n\\t\\t\\t\\tx: view.x,\\n\\t\\t\\t\\ty: view.y,\\n\\t\\t\\t\\tk: view.k\\n\\t\\t\\t};\\n\\t\\t\\tscaleTo( Math.pow( 2, k ) );\\n\\t\\t\\ttranslateTo( center0 = p, l );\\n\\t\\t\\tthat = d3.select( that );\\n\\t\\t\\tif ( duration > 0 ) that = that.transition().duration( duration );\\n\\t\\t\\tthat.call( zoom.event );\\n\\t\\t}\\n\\t\\tfunction rescale() {\\n\\t\\t\\tif ( x1 ) x1.domain( x0.range().map( function( x ) {\\n\\t\\t\\t\\treturn ( x - view.x ) / view.k;\\n\\t\\t\\t} ).map( x0.invert ) );\\n\\t\\t\\tif ( y1 ) y1.domain( y0.range().map( function( y ) {\\n\\t\\t\\t\\treturn ( y - view.y ) / view.k;\\n\\t\\t\\t} ).map( y0.invert ) );\\n\\t\\t}\\n\\t\\tfunction zoomstarted( dispatch ) {\\n\\t\\t\\tif ( !zooming++ ) dispatch( {\\n\\t\\t\\t\\ttype: \\\"zoomstart\\\"\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tfunction zoomed( dispatch ) {\\n\\t\\t\\trescale();\\n\\t\\t\\tdispatch( {\\n\\t\\t\\t\\ttype: \\\"zoom\\\",\\n\\t\\t\\t\\tscale: view.k,\\n\\t\\t\\t\\ttranslate: [ view.x, view.y ]\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tfunction zoomended( dispatch ) {\\n\\t\\t\\tif ( !--zooming ) dispatch( {\\n\\t\\t\\t\\ttype: \\\"zoomend\\\"\\n\\t\\t\\t} ), center0 = null;\\n\\t\\t}\\n\\t\\tfunction mousedowned() {\\n\\t\\t\\tvar that = this, dispatch = event.of( that, arguments ), dragged = 0, subject = d3.select( d3_window( that ) ).on( mousemove, moved ).on( mouseup, ended ), location0 = location( d3.mouse( that ) ), dragRestore = d3_event_dragSuppress( that );\\n\\t\\t\\td3_selection_interrupt.call( that );\\n\\t\\t\\tzoomstarted( dispatch );\\n\\t\\t\\tfunction moved() {\\n\\t\\t\\t\\tdragged = 1;\\n\\t\\t\\t\\ttranslateTo( d3.mouse( that ), location0 );\\n\\t\\t\\t\\tzoomed( dispatch );\\n\\t\\t\\t}\\n\\t\\t\\tfunction ended() {\\n\\t\\t\\t\\tsubject.on( mousemove, null ).on( mouseup, null );\\n\\t\\t\\t\\tdragRestore( dragged );\\n\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction touchstarted() {\\n\\t\\t\\tvar that = this, dispatch = event.of( that, arguments ), locations0 = {}, distance0 = 0, scale0, zoomName = \\\".zoom-\\\" + d3.event.changedTouches[0].identifier, touchmove = \\\"touchmove\\\" + zoomName, touchend = \\\"touchend\\\" + zoomName, targets = [], subject = d3.select( that ), dragRestore = d3_event_dragSuppress( that );\\n\\t\\t\\tstarted();\\n\\t\\t\\tzoomstarted( dispatch );\\n\\t\\t\\tsubject.on( mousedown, null ).on( touchstart, started );\\n\\t\\t\\tfunction relocate() {\\n\\t\\t\\t\\tvar touches = d3.touches( that );\\n\\t\\t\\t\\tscale0 = view.k;\\n\\t\\t\\t\\ttouches.forEach( function( t ) {\\n\\t\\t\\t\\t\\tif ( t.identifier in locations0 ) locations0[t.identifier] = location( t );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn touches;\\n\\t\\t\\t}\\n\\t\\t\\tfunction started() {\\n\\t\\t\\t\\tvar target = d3.event.target;\\n\\t\\t\\t\\td3.select( target ).on( touchmove, moved ).on( touchend, ended );\\n\\t\\t\\t\\ttargets.push( target );\\n\\t\\t\\t\\tvar changed = d3.event.changedTouches;\\n\\t\\t\\t\\tfor ( var i = 0, n = changed.length; i < n; ++i ) {\\n\\t\\t\\t\\t\\tlocations0[changed[i].identifier] = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar touches = relocate(), now = Date.now();\\n\\t\\t\\t\\tif ( touches.length === 1 ) {\\n\\t\\t\\t\\t\\tif ( now - touchtime < 500 ) {\\n\\t\\t\\t\\t\\t\\tvar p = touches[0];\\n\\t\\t\\t\\t\\t\\tzoomTo( that, p, locations0[p.identifier], Math.floor( Math.log( view.k ) / Math.LN2 ) + 1 );\\n\\t\\t\\t\\t\\t\\td3_eventPreventDefault();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttouchtime = now;\\n\\t\\t\\t\\t} else if ( touches.length > 1 ) {\\n\\t\\t\\t\\t\\tvar p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\\n\\t\\t\\t\\t\\tdistance0 = dx * dx + dy * dy;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction moved() {\\n\\t\\t\\t\\tvar touches = d3.touches( that ), p0, l0, p1, l1;\\n\\t\\t\\t\\td3_selection_interrupt.call( that );\\n\\t\\t\\t\\tfor ( var i = 0, n = touches.length; i < n; ++i, l1 = null ) {\\n\\t\\t\\t\\t\\tp1 = touches[i];\\n\\t\\t\\t\\t\\tif ( l1 = locations0[p1.identifier] ) {\\n\\t\\t\\t\\t\\t\\tif ( l0 ) break;\\n\\t\\t\\t\\t\\t\\tp0 = p1, l0 = l1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( l1 ) {\\n\\t\\t\\t\\t\\tvar distance1 = ( distance1 = p1[0] - p0[0] ) * distance1 + ( distance1 = p1[1] - p0[1] ) * distance1, scale1 = distance0 && Math.sqrt( distance1 / distance0 );\\n\\t\\t\\t\\t\\tp0 = [ ( p0[0] + p1[0] ) / 2, ( p0[1] + p1[1] ) / 2 ];\\n\\t\\t\\t\\t\\tl0 = [ ( l0[0] + l1[0] ) / 2, ( l0[1] + l1[1] ) / 2 ];\\n\\t\\t\\t\\t\\tscaleTo( scale1 * scale0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttouchtime = null;\\n\\t\\t\\t\\ttranslateTo( p0, l0 );\\n\\t\\t\\t\\tzoomed( dispatch );\\n\\t\\t\\t}\\n\\t\\t\\tfunction ended() {\\n\\t\\t\\t\\tif ( d3.event.touches.length ) {\\n\\t\\t\\t\\t\\tvar changed = d3.event.changedTouches;\\n\\t\\t\\t\\t\\tfor ( var i = 0, n = changed.length; i < n; ++i ) {\\n\\t\\t\\t\\t\\t\\tdelete locations0[changed[i].identifier];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor ( var identifier in locations0 ) {\\n\\t\\t\\t\\t\\t\\treturn void relocate();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\td3.selectAll( targets ).on( zoomName, null );\\n\\t\\t\\t\\tsubject.on( mousedown, mousedowned ).on( touchstart, touchstarted );\\n\\t\\t\\t\\tdragRestore();\\n\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction mousewheeled() {\\n\\t\\t\\tvar dispatch = event.of( this, arguments );\\n\\t\\t\\tif ( mousewheelTimer ) clearTimeout( mousewheelTimer ); else d3_selection_interrupt.call( this ),\\n\\t\\t\\ttranslate0 = location( center0 = center || d3.mouse( this ) ), zoomstarted( dispatch );\\n\\t\\t\\tmousewheelTimer = setTimeout( function() {\\n\\t\\t\\t\\tmousewheelTimer = null;\\n\\t\\t\\t\\tzoomended( dispatch );\\n\\t\\t\\t}, 50 );\\n\\t\\t\\td3_eventPreventDefault();\\n\\t\\t\\tscaleTo( Math.pow( 2, d3_behavior_zoomDelta() * .002 ) * view.k );\\n\\t\\t\\ttranslateTo( center0, translate0 );\\n\\t\\t\\tzoomed( dispatch );\\n\\t\\t}\\n\\t\\tfunction dblclicked() {\\n\\t\\t\\tvar p = d3.mouse( this ), k = Math.log( view.k ) / Math.LN2;\\n\\t\\t\\tzoomTo( this, p, location( p ), d3.event.shiftKey ? Math.ceil( k ) - 1 : Math.floor( k ) + 1 );\\n\\t\\t}\\n\\t\\treturn d3.rebind( zoom, event, \\\"on\\\" );\\n\\t};\\n\\tvar d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\\n\\td3.color = d3_color;\\n\\tfunction d3_color() {}\\n\\td3_color.prototype.toString = function() {\\n\\t\\treturn this.rgb() + \\\"\\\";\\n\\t};\\n\\td3.hsl = d3_hsl;\\n\\tfunction d3_hsl( h, s, l ) {\\n\\t\\treturn this instanceof d3_hsl ? void ( this.h = +h, this.s = +s, this.l = +l ) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl( h.h, h.s, h.l ) : d3_rgb_parse( \\\"\\\" + h, d3_rgb_hsl, d3_hsl ) : new d3_hsl( h, s, l );\\n\\t}\\n\\tvar d3_hslPrototype = d3_hsl.prototype = new d3_color();\\n\\td3_hslPrototype.brighter = function( k ) {\\n\\t\\tk = Math.pow( .7, arguments.length ? k : 1 );\\n\\t\\treturn new d3_hsl( this.h, this.s, this.l / k );\\n\\t};\\n\\td3_hslPrototype.darker = function( k ) {\\n\\t\\tk = Math.pow( .7, arguments.length ? k : 1 );\\n\\t\\treturn new d3_hsl( this.h, this.s, k * this.l );\\n\\t};\\n\\td3_hslPrototype.rgb = function() {\\n\\t\\treturn d3_hsl_rgb( this.h, this.s, this.l );\\n\\t};\\n\\tfunction d3_hsl_rgb( h, s, l ) {\\n\\t\\tvar m1, m2;\\n\\t\\th = isNaN( h ) ? 0 : ( h %= 360 ) < 0 ? h + 360 : h;\\n\\t\\ts = isNaN( s ) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\\n\\t\\tl = l < 0 ? 0 : l > 1 ? 1 : l;\\n\\t\\tm2 = l <= .5 ? l * ( 1 + s ) : l + s - l * s;\\n\\t\\tm1 = 2 * l - m2;\\n\\t\\tfunction v( h ) {\\n\\t\\t\\tif ( h > 360 ) h -= 360; else if ( h < 0 ) h += 360;\\n\\t\\t\\tif ( h < 60 ) return m1 + ( m2 - m1 ) * h / 60;\\n\\t\\t\\tif ( h < 180 ) return m2;\\n\\t\\t\\tif ( h < 240 ) return m1 + ( m2 - m1 ) * ( 240 - h ) / 60;\\n\\t\\t\\treturn m1;\\n\\t\\t}\\n\\t\\tfunction vv( h ) {\\n\\t\\t\\treturn Math.round( v( h ) * 255 );\\n\\t\\t}\\n\\t\\treturn new d3_rgb( vv( h + 120 ), vv( h ), vv( h - 120 ) );\\n\\t}\\n\\td3.hcl = d3_hcl;\\n\\tfunction d3_hcl( h, c, l ) {\\n\\t\\treturn this instanceof d3_hcl ? void ( this.h = +h, this.c = +c, this.l = +l ) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl( h.h, h.c, h.l ) : h instanceof d3_lab ? d3_lab_hcl( h.l, h.a, h.b ) : d3_lab_hcl( ( h = d3_rgb_lab( ( h = d3.rgb( h ) ).r, h.g, h.b ) ).l, h.a, h.b ) : new d3_hcl( h, c, l );\\n\\t}\\n\\tvar d3_hclPrototype = d3_hcl.prototype = new d3_color();\\n\\td3_hclPrototype.brighter = function( k ) {\\n\\t\\treturn new d3_hcl( this.h, this.c, Math.min( 100, this.l + d3_lab_K * ( arguments.length ? k : 1 ) ) );\\n\\t};\\n\\td3_hclPrototype.darker = function( k ) {\\n\\t\\treturn new d3_hcl( this.h, this.c, Math.max( 0, this.l - d3_lab_K * ( arguments.length ? k : 1 ) ) );\\n\\t};\\n\\td3_hclPrototype.rgb = function() {\\n\\t\\treturn d3_hcl_lab( this.h, this.c, this.l ).rgb();\\n\\t};\\n\\tfunction d3_hcl_lab( h, c, l ) {\\n\\t\\tif ( isNaN( h ) ) h = 0;\\n\\t\\tif ( isNaN( c ) ) c = 0;\\n\\t\\treturn new d3_lab( l, Math.cos( h *= d3_radians ) * c, Math.sin( h ) * c );\\n\\t}\\n\\td3.lab = d3_lab;\\n\\tfunction d3_lab( l, a, b ) {\\n\\t\\treturn this instanceof d3_lab ? void ( this.l = +l, this.a = +a, this.b = +b ) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab( l.l, l.a, l.b ) : l instanceof d3_hcl ? d3_hcl_lab( l.h, l.c, l.l ) : d3_rgb_lab( ( l = d3_rgb( l ) ).r, l.g, l.b ) : new d3_lab( l, a, b );\\n\\t}\\n\\tvar d3_lab_K = 18;\\n\\tvar d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\\n\\tvar d3_labPrototype = d3_lab.prototype = new d3_color();\\n\\td3_labPrototype.brighter = function( k ) {\\n\\t\\treturn new d3_lab( Math.min( 100, this.l + d3_lab_K * ( arguments.length ? k : 1 ) ), this.a, this.b );\\n\\t};\\n\\td3_labPrototype.darker = function( k ) {\\n\\t\\treturn new d3_lab( Math.max( 0, this.l - d3_lab_K * ( arguments.length ? k : 1 ) ), this.a, this.b );\\n\\t};\\n\\td3_labPrototype.rgb = function() {\\n\\t\\treturn d3_lab_rgb( this.l, this.a, this.b );\\n\\t};\\n\\tfunction d3_lab_rgb( l, a, b ) {\\n\\t\\tvar y = ( l + 16 ) / 116, x = y + a / 500, z = y - b / 200;\\n\\t\\tx = d3_lab_xyz( x ) * d3_lab_X;\\n\\t\\ty = d3_lab_xyz( y ) * d3_lab_Y;\\n\\t\\tz = d3_lab_xyz( z ) * d3_lab_Z;\\n\\t\\treturn new d3_rgb( d3_xyz_rgb( 3.2404542 * x - 1.5371385 * y - .4985314 * z ), d3_xyz_rgb( -.969266 * x + 1.8760108 * y + .041556 * z ), d3_xyz_rgb( .0556434 * x - .2040259 * y + 1.0572252 * z ) );\\n\\t}\\n\\tfunction d3_lab_hcl( l, a, b ) {\\n\\t\\treturn l > 0 ? new d3_hcl( Math.atan2( b, a ) * d3_degrees, Math.sqrt( a * a + b * b ), l ) : new d3_hcl( NaN, NaN, l );\\n\\t}\\n\\tfunction d3_lab_xyz( x ) {\\n\\t\\treturn x > .206893034 ? x * x * x : ( x - 4 / 29 ) / 7.787037;\\n\\t}\\n\\tfunction d3_xyz_lab( x ) {\\n\\t\\treturn x > .008856 ? Math.pow( x, 1 / 3 ) : 7.787037 * x + 4 / 29;\\n\\t}\\n\\tfunction d3_xyz_rgb( r ) {\\n\\t\\treturn Math.round( 255 * ( r <= .00304 ? 12.92 * r : 1.055 * Math.pow( r, 1 / 2.4 ) - .055 ) );\\n\\t}\\n\\td3.rgb = d3_rgb;\\n\\tfunction d3_rgb( r, g, b ) {\\n\\t\\treturn this instanceof d3_rgb ? void ( this.r = ~~r, this.g = ~~g, this.b = ~~b ) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb( r.r, r.g, r.b ) : d3_rgb_parse( \\\"\\\" + r, d3_rgb, d3_hsl_rgb ) : new d3_rgb( r, g, b );\\n\\t}\\n\\tfunction d3_rgbNumber( value ) {\\n\\t\\treturn new d3_rgb( value >> 16, value >> 8 & 255, value & 255 );\\n\\t}\\n\\tfunction d3_rgbString( value ) {\\n\\t\\treturn d3_rgbNumber( value ) + \\\"\\\";\\n\\t}\\n\\tvar d3_rgbPrototype = d3_rgb.prototype = new d3_color();\\n\\td3_rgbPrototype.brighter = function( k ) {\\n\\t\\tk = Math.pow( .7, arguments.length ? k : 1 );\\n\\t\\tvar r = this.r, g = this.g, b = this.b, i = 30;\\n\\t\\tif ( !r && !g && !b ) return new d3_rgb( i, i, i );\\n\\t\\tif ( r && r < i ) r = i;\\n\\t\\tif ( g && g < i ) g = i;\\n\\t\\tif ( b && b < i ) b = i;\\n\\t\\treturn new d3_rgb( Math.min( 255, r / k ), Math.min( 255, g / k ), Math.min( 255, b / k ) );\\n\\t};\\n\\td3_rgbPrototype.darker = function( k ) {\\n\\t\\tk = Math.pow( .7, arguments.length ? k : 1 );\\n\\t\\treturn new d3_rgb( k * this.r, k * this.g, k * this.b );\\n\\t};\\n\\td3_rgbPrototype.hsl = function() {\\n\\t\\treturn d3_rgb_hsl( this.r, this.g, this.b );\\n\\t};\\n\\td3_rgbPrototype.toString = function() {\\n\\t\\treturn \\\"#\\\" + d3_rgb_hex( this.r ) + d3_rgb_hex( this.g ) + d3_rgb_hex( this.b );\\n\\t};\\n\\tfunction d3_rgb_hex( v ) {\\n\\t\\treturn v < 16 ? \\\"0\\\" + Math.max( 0, v ).toString( 16 ) : Math.min( 255, v ).toString( 16 );\\n\\t}\\n\\tfunction d3_rgb_parse( format, rgb, hsl ) {\\n\\t\\tvar r = 0, g = 0, b = 0, m1, m2, color;\\n\\t\\tm1 = /([a-z]+)\\\\((.*)\\\\)/.exec( format = format.toLowerCase() );\\n\\t\\tif ( m1 ) {\\n\\t\\t\\tm2 = m1[2].split( \\\",\\\" );\\n\\t\\t\\tswitch ( m1[1] ) {\\n\\t\\t\\tcase \\\"hsl\\\":\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn hsl( parseFloat( m2[0] ), parseFloat( m2[1] ) / 100, parseFloat( m2[2] ) / 100 );\\n\\t\\t\\t}\\n\\n\\t\\t\\tcase \\\"rgb\\\":\\n\\t\\t\\t{\\n\\t\\t\\t\\treturn rgb( d3_rgb_parseNumber( m2[0] ), d3_rgb_parseNumber( m2[1] ), d3_rgb_parseNumber( m2[2] ) );\\n\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( color = d3_rgb_names.get( format ) ) {\\n\\t\\t\\treturn rgb( color.r, color.g, color.b );\\n\\t\\t}\\n\\t\\tif ( format != null && format.charAt( 0 ) === \\\"#\\\" && !isNaN( color = parseInt( format.slice( 1 ), 16 ) ) ) {\\n\\t\\t\\tif ( format.length === 4 ) {\\n\\t\\t\\t\\tr = ( color & 3840 ) >> 4;\\n\\t\\t\\t\\tr = r >> 4 | r;\\n\\t\\t\\t\\tg = color & 240;\\n\\t\\t\\t\\tg = g >> 4 | g;\\n\\t\\t\\t\\tb = color & 15;\\n\\t\\t\\t\\tb = b << 4 | b;\\n\\t\\t\\t} else if ( format.length === 7 ) {\\n\\t\\t\\t\\tr = ( color & 16711680 ) >> 16;\\n\\t\\t\\t\\tg = ( color & 65280 ) >> 8;\\n\\t\\t\\t\\tb = color & 255;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn rgb( r, g, b );\\n\\t}\\n\\tfunction d3_rgb_hsl( r, g, b ) {\\n\\t\\tvar min = Math.min( r /= 255, g /= 255, b /= 255 ), max = Math.max( r, g, b ), d = max - min, h, s, l = ( max + min ) / 2;\\n\\t\\tif ( d ) {\\n\\t\\t\\ts = l < .5 ? d / ( max + min ) : d / ( 2 - max - min );\\n\\t\\t\\tif ( r == max ) h = ( g - b ) / d + ( g < b ? 6 : 0 ); else if ( g == max ) h = ( b - r ) / d + 2; else h = ( r - g ) / d + 4;\\n\\t\\t\\th *= 60;\\n\\t\\t} else {\\n\\t\\t\\th = NaN;\\n\\t\\t\\ts = l > 0 && l < 1 ? 0 : h;\\n\\t\\t}\\n\\t\\treturn new d3_hsl( h, s, l );\\n\\t}\\n\\tfunction d3_rgb_lab( r, g, b ) {\\n\\t\\tr = d3_rgb_xyz( r );\\n\\t\\tg = d3_rgb_xyz( g );\\n\\t\\tb = d3_rgb_xyz( b );\\n\\t\\tvar x = d3_xyz_lab( ( .4124564 * r + .3575761 * g + .1804375 * b ) / d3_lab_X ), y = d3_xyz_lab( ( .2126729 * r + .7151522 * g + .072175 * b ) / d3_lab_Y ), z = d3_xyz_lab( ( .0193339 * r + .119192 * g + .9503041 * b ) / d3_lab_Z );\\n\\t\\treturn d3_lab( 116 * y - 16, 500 * ( x - y ), 200 * ( y - z ) );\\n\\t}\\n\\tfunction d3_rgb_xyz( r ) {\\n\\t\\treturn ( r /= 255 ) <= .04045 ? r / 12.92 : Math.pow( ( r + .055 ) / 1.055, 2.4 );\\n\\t}\\n\\tfunction d3_rgb_parseNumber( c ) {\\n\\t\\tvar f = parseFloat( c );\\n\\t\\treturn c.charAt( c.length - 1 ) === \\\"%\\\" ? Math.round( f * 2.55 ) : f;\\n\\t}\\n\\tvar d3_rgb_names = d3.map( {\\n\\t\\taliceblue: 15792383,\\n\\t\\tantiquewhite: 16444375,\\n\\t\\taqua: 65535,\\n\\t\\taquamarine: 8388564,\\n\\t\\tazure: 15794175,\\n\\t\\tbeige: 16119260,\\n\\t\\tbisque: 16770244,\\n\\t\\tblack: 0,\\n\\t\\tblanchedalmond: 16772045,\\n\\t\\tblue: 255,\\n\\t\\tblueviolet: 9055202,\\n\\t\\tbrown: 10824234,\\n\\t\\tburlywood: 14596231,\\n\\t\\tcadetblue: 6266528,\\n\\t\\tchartreuse: 8388352,\\n\\t\\tchocolate: 13789470,\\n\\t\\tcoral: 16744272,\\n\\t\\tcornflowerblue: 6591981,\\n\\t\\tcornsilk: 16775388,\\n\\t\\tcrimson: 14423100,\\n\\t\\tcyan: 65535,\\n\\t\\tdarkblue: 139,\\n\\t\\tdarkcyan: 35723,\\n\\t\\tdarkgoldenrod: 12092939,\\n\\t\\tdarkgray: 11119017,\\n\\t\\tdarkgreen: 25600,\\n\\t\\tdarkgrey: 11119017,\\n\\t\\tdarkkhaki: 12433259,\\n\\t\\tdarkmagenta: 9109643,\\n\\t\\tdarkolivegreen: 5597999,\\n\\t\\tdarkorange: 16747520,\\n\\t\\tdarkorchid: 10040012,\\n\\t\\tdarkred: 9109504,\\n\\t\\tdarksalmon: 15308410,\\n\\t\\tdarkseagreen: 9419919,\\n\\t\\tdarkslateblue: 4734347,\\n\\t\\tdarkslategray: 3100495,\\n\\t\\tdarkslategrey: 3100495,\\n\\t\\tdarkturquoise: 52945,\\n\\t\\tdarkviolet: 9699539,\\n\\t\\tdeeppink: 16716947,\\n\\t\\tdeepskyblue: 49151,\\n\\t\\tdimgray: 6908265,\\n\\t\\tdimgrey: 6908265,\\n\\t\\tdodgerblue: 2003199,\\n\\t\\tfirebrick: 11674146,\\n\\t\\tfloralwhite: 16775920,\\n\\t\\tforestgreen: 2263842,\\n\\t\\tfuchsia: 16711935,\\n\\t\\tgainsboro: 14474460,\\n\\t\\tghostwhite: 16316671,\\n\\t\\tgold: 16766720,\\n\\t\\tgoldenrod: 14329120,\\n\\t\\tgray: 8421504,\\n\\t\\tgreen: 32768,\\n\\t\\tgreenyellow: 11403055,\\n\\t\\tgrey: 8421504,\\n\\t\\thoneydew: 15794160,\\n\\t\\thotpink: 16738740,\\n\\t\\tindianred: 13458524,\\n\\t\\tindigo: 4915330,\\n\\t\\tivory: 16777200,\\n\\t\\tkhaki: 15787660,\\n\\t\\tlavender: 15132410,\\n\\t\\tlavenderblush: 16773365,\\n\\t\\tlawngreen: 8190976,\\n\\t\\tlemonchiffon: 16775885,\\n\\t\\tlightblue: 11393254,\\n\\t\\tlightcoral: 15761536,\\n\\t\\tlightcyan: 14745599,\\n\\t\\tlightgoldenrodyellow: 16448210,\\n\\t\\tlightgray: 13882323,\\n\\t\\tlightgreen: 9498256,\\n\\t\\tlightgrey: 13882323,\\n\\t\\tlightpink: 16758465,\\n\\t\\tlightsalmon: 16752762,\\n\\t\\tlightseagreen: 2142890,\\n\\t\\tlightskyblue: 8900346,\\n\\t\\tlightslategray: 7833753,\\n\\t\\tlightslategrey: 7833753,\\n\\t\\tlightsteelblue: 11584734,\\n\\t\\tlightyellow: 16777184,\\n\\t\\tlime: 65280,\\n\\t\\tlimegreen: 3329330,\\n\\t\\tlinen: 16445670,\\n\\t\\tmagenta: 16711935,\\n\\t\\tmaroon: 8388608,\\n\\t\\tmediumaquamarine: 6737322,\\n\\t\\tmediumblue: 205,\\n\\t\\tmediumorchid: 12211667,\\n\\t\\tmediumpurple: 9662683,\\n\\t\\tmediumseagreen: 3978097,\\n\\t\\tmediumslateblue: 8087790,\\n\\t\\tmediumspringgreen: 64154,\\n\\t\\tmediumturquoise: 4772300,\\n\\t\\tmediumvioletred: 13047173,\\n\\t\\tmidnightblue: 1644912,\\n\\t\\tmintcream: 16121850,\\n\\t\\tmistyrose: 16770273,\\n\\t\\tmoccasin: 16770229,\\n\\t\\tnavajowhite: 16768685,\\n\\t\\tnavy: 128,\\n\\t\\toldlace: 16643558,\\n\\t\\tolive: 8421376,\\n\\t\\tolivedrab: 7048739,\\n\\t\\torange: 16753920,\\n\\t\\torangered: 16729344,\\n\\t\\torchid: 14315734,\\n\\t\\tpalegoldenrod: 15657130,\\n\\t\\tpalegreen: 10025880,\\n\\t\\tpaleturquoise: 11529966,\\n\\t\\tpalevioletred: 14381203,\\n\\t\\tpapayawhip: 16773077,\\n\\t\\tpeachpuff: 16767673,\\n\\t\\tperu: 13468991,\\n\\t\\tpink: 16761035,\\n\\t\\tplum: 14524637,\\n\\t\\tpowderblue: 11591910,\\n\\t\\tpurple: 8388736,\\n\\t\\trebeccapurple: 6697881,\\n\\t\\tred: 16711680,\\n\\t\\trosybrown: 12357519,\\n\\t\\troyalblue: 4286945,\\n\\t\\tsaddlebrown: 9127187,\\n\\t\\tsalmon: 16416882,\\n\\t\\tsandybrown: 16032864,\\n\\t\\tseagreen: 3050327,\\n\\t\\tseashell: 16774638,\\n\\t\\tsienna: 10506797,\\n\\t\\tsilver: 12632256,\\n\\t\\tskyblue: 8900331,\\n\\t\\tslateblue: 6970061,\\n\\t\\tslategray: 7372944,\\n\\t\\tslategrey: 7372944,\\n\\t\\tsnow: 16775930,\\n\\t\\tspringgreen: 65407,\\n\\t\\tsteelblue: 4620980,\\n\\t\\ttan: 13808780,\\n\\t\\tteal: 32896,\\n\\t\\tthistle: 14204888,\\n\\t\\ttomato: 16737095,\\n\\t\\tturquoise: 4251856,\\n\\t\\tviolet: 15631086,\\n\\t\\twheat: 16113331,\\n\\t\\twhite: 16777215,\\n\\t\\twhitesmoke: 16119285,\\n\\t\\tyellow: 16776960,\\n\\t\\tyellowgreen: 10145074\\n\\t} );\\n\\td3_rgb_names.forEach( function( key, value ) {\\n\\t\\td3_rgb_names.set( key, d3_rgbNumber( value ) );\\n\\t} );\\n\\tfunction d3_functor( v ) {\\n\\t\\treturn typeof v === \\\"function\\\" ? v : function() {\\n\\t\\t\\treturn v;\\n\\t\\t};\\n\\t}\\n\\td3.functor = d3_functor;\\n\\td3.xhr = d3_xhrType( d3_identity );\\n\\tfunction d3_xhrType( response ) {\\n\\t\\treturn function( url, mimeType, callback ) {\\n\\t\\t\\tif ( arguments.length === 2 && typeof mimeType === \\\"function\\\" ) callback = mimeType,\\n\\t\\t\\tmimeType = null;\\n\\t\\t\\treturn d3_xhr( url, mimeType, response, callback );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_xhr( url, mimeType, response, callback ) {\\n\\t\\tvar xhr = {}, dispatch = d3.dispatch( \\\"beforesend\\\", \\\"progress\\\", \\\"load\\\", \\\"error\\\" ), headers = {}, request = new XMLHttpRequest(), responseType = null;\\n\\t\\tif ( this.XDomainRequest && !( \\\"withCredentials\\\" in request ) && /^(http(s)?:)?\\\\/\\\\//.test( url ) ) request = new XDomainRequest();\\n\\t\\t\\\"onload\\\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\\n\\t\\t\\trequest.readyState > 3 && respond();\\n\\t\\t};\\n\\t\\tfunction respond() {\\n\\t\\t\\tvar status = request.status, result;\\n\\t\\t\\tif ( !status && d3_xhrHasResponse( request ) || status >= 200 && status < 300 || status === 304 ) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\tresult = response.call( xhr, request );\\n\\t\\t\\t\\t} catch ( e ) {\\n\\t\\t\\t\\t\\tdispatch.error.call( xhr, e );\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tdispatch.load.call( xhr, result );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tdispatch.error.call( xhr, request );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\trequest.onprogress = function( event ) {\\n\\t\\t\\tvar o = d3.event;\\n\\t\\t\\td3.event = event;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\tdispatch.progress.call( xhr, request );\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\td3.event = o;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\txhr.header = function( name, value ) {\\n\\t\\t\\tname = ( name + \\\"\\\" ).toLowerCase();\\n\\t\\t\\tif ( arguments.length < 2 ) return headers[name];\\n\\t\\t\\tif ( value == null ) delete headers[name]; else headers[name] = value + \\\"\\\";\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\txhr.mimeType = function( value ) {\\n\\t\\t\\tif ( !arguments.length ) return mimeType;\\n\\t\\t\\tmimeType = value == null ? null : value + \\\"\\\";\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\txhr.responseType = function( value ) {\\n\\t\\t\\tif ( !arguments.length ) return responseType;\\n\\t\\t\\tresponseType = value;\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\txhr.response = function( value ) {\\n\\t\\t\\tresponse = value;\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\t[ \\\"get\\\", \\\"post\\\" ].forEach( function( method ) {\\n\\t\\t\\txhr[method] = function() {\\n\\t\\t\\t\\treturn xhr.send.apply( xhr, [ method ].concat( d3_array( arguments ) ) );\\n\\t\\t\\t};\\n\\t\\t} );\\n\\t\\txhr.send = function( method, data, callback ) {\\n\\t\\t\\tif ( arguments.length === 2 && typeof data === \\\"function\\\" ) callback = data, data = null;\\n\\t\\t\\trequest.open( method, url, true );\\n\\t\\t\\tif ( mimeType != null && !( \\\"accept\\\" in headers ) ) headers[\\\"accept\\\"] = mimeType + \\\",*/*\\\";\\n\\t\\t\\tif ( request.setRequestHeader ) for ( var name in headers ) request.setRequestHeader( name, headers[name] );\\n\\t\\t\\tif ( mimeType != null && request.overrideMimeType ) request.overrideMimeType( mimeType );\\n\\t\\t\\tif ( responseType != null ) request.responseType = responseType;\\n\\t\\t\\tif ( callback != null ) xhr.on( \\\"error\\\", callback ).on( \\\"load\\\", function( request ) {\\n\\t\\t\\t\\tcallback( null, request );\\n\\t\\t\\t} );\\n\\t\\t\\tdispatch.beforesend.call( xhr, request );\\n\\t\\t\\trequest.send( data == null ? null : data );\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\txhr.abort = function() {\\n\\t\\t\\trequest.abort();\\n\\t\\t\\treturn xhr;\\n\\t\\t};\\n\\t\\td3.rebind( xhr, dispatch, \\\"on\\\" );\\n\\t\\treturn callback == null ? xhr : xhr.get( d3_xhr_fixCallback( callback ) );\\n\\t}\\n\\tfunction d3_xhr_fixCallback( callback ) {\\n\\t\\treturn callback.length === 1 ? function( error, request ) {\\n\\t\\t\\tcallback( error == null ? request : null );\\n\\t\\t} : callback;\\n\\t}\\n\\tfunction d3_xhrHasResponse( request ) {\\n\\t\\tvar type = request.responseType;\\n\\t\\treturn type && type !== \\\"text\\\" ? request.response : request.responseText;\\n\\t}\\n\\td3.dsv = function( delimiter, mimeType ) {\\n\\t\\tvar reFormat = new RegExp( '[\\\"' + delimiter + \\\"\\\\n]\\\" ), delimiterCode = delimiter.charCodeAt( 0 );\\n\\t\\tfunction dsv( url, row, callback ) {\\n\\t\\t\\tif ( arguments.length < 3 ) callback = row, row = null;\\n\\t\\t\\tvar xhr = d3_xhr( url, mimeType, row == null ? response : typedResponse( row ), callback );\\n\\t\\t\\txhr.row = function( _ ) {\\n\\t\\t\\t\\treturn arguments.length ? xhr.response( ( row = _ ) == null ? response : typedResponse( _ ) ) : row;\\n\\t\\t\\t};\\n\\t\\t\\treturn xhr;\\n\\t\\t}\\n\\t\\tfunction response( request ) {\\n\\t\\t\\treturn dsv.parse( request.responseText );\\n\\t\\t}\\n\\t\\tfunction typedResponse( f ) {\\n\\t\\t\\treturn function( request ) {\\n\\t\\t\\t\\treturn dsv.parse( request.responseText, f );\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tdsv.parse = function( text, f ) {\\n\\t\\t\\tvar o;\\n\\t\\t\\treturn dsv.parseRows( text, function( row, i ) {\\n\\t\\t\\t\\tif ( o ) return o( row, i - 1 );\\n\\t\\t\\t\\tvar a = new Function( \\\"d\\\", \\\"return {\\\" + row.map( function( name, i ) {\\n\\t\\t\\t\\t\\treturn JSON.stringify( name ) + \\\": d[\\\" + i + \\\"]\\\";\\n\\t\\t\\t\\t} ).join( \\\",\\\" ) + \\\"}\\\" );\\n\\t\\t\\t\\to = f ? function( row, i ) {\\n\\t\\t\\t\\t\\treturn f( a( row ), i );\\n\\t\\t\\t\\t} : a;\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tdsv.parseRows = function( text, f ) {\\n\\t\\t\\tvar EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\\n\\t\\t\\tfunction token() {\\n\\t\\t\\t\\tif ( I >= N ) return EOF;\\n\\t\\t\\t\\tif ( eol ) return eol = false, EOL;\\n\\t\\t\\t\\tvar j = I;\\n\\t\\t\\t\\tif ( text.charCodeAt( j ) === 34 ) {\\n\\t\\t\\t\\t\\tvar i = j;\\n\\t\\t\\t\\t\\twhile ( i++ < N ) {\\n\\t\\t\\t\\t\\t\\tif ( text.charCodeAt( i ) === 34 ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( text.charCodeAt( i + 1 ) !== 34 ) break;\\n\\t\\t\\t\\t\\t\\t\\t++i;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tI = i + 2;\\n\\t\\t\\t\\t\\tvar c = text.charCodeAt( i + 1 );\\n\\t\\t\\t\\t\\tif ( c === 13 ) {\\n\\t\\t\\t\\t\\t\\teol = true;\\n\\t\\t\\t\\t\\t\\tif ( text.charCodeAt( i + 2 ) === 10 ) ++I;\\n\\t\\t\\t\\t\\t} else if ( c === 10 ) {\\n\\t\\t\\t\\t\\t\\teol = true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn text.slice( j + 1, i ).replace( /\\\"\\\"/g, '\\\"' );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile ( I < N ) {\\n\\t\\t\\t\\t\\tvar c = text.charCodeAt( I++ ), k = 1;\\n\\t\\t\\t\\t\\tif ( c === 10 ) eol = true; else if ( c === 13 ) {\\n\\t\\t\\t\\t\\t\\teol = true;\\n\\t\\t\\t\\t\\t\\tif ( text.charCodeAt( I ) === 10 ) ++I, ++k;\\n\\t\\t\\t\\t\\t} else if ( c !== delimiterCode ) continue;\\n\\t\\t\\t\\t\\treturn text.slice( j, I - k );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn text.slice( j );\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ( t = token() ) !== EOF ) {\\n\\t\\t\\t\\tvar a = [];\\n\\t\\t\\t\\twhile ( t !== EOL && t !== EOF ) {\\n\\t\\t\\t\\t\\ta.push( t );\\n\\t\\t\\t\\t\\tt = token();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( f && ( a = f( a, n++ ) ) == null ) continue;\\n\\t\\t\\t\\trows.push( a );\\n\\t\\t\\t}\\n\\t\\t\\treturn rows;\\n\\t\\t};\\n\\t\\tdsv.format = function( rows ) {\\n\\t\\t\\tif ( Array.isArray( rows[0] ) ) return dsv.formatRows( rows );\\n\\t\\t\\tvar fieldSet = new d3_Set(), fields = [];\\n\\t\\t\\trows.forEach( function( row ) {\\n\\t\\t\\t\\tfor ( var field in row ) {\\n\\t\\t\\t\\t\\tif ( !fieldSet.has( field ) ) {\\n\\t\\t\\t\\t\\t\\tfields.push( fieldSet.add( field ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\treturn [ fields.map( formatValue ).join( delimiter ) ].concat( rows.map( function( row ) {\\n\\t\\t\\t\\treturn fields.map( function( field ) {\\n\\t\\t\\t\\t\\treturn formatValue( row[field] );\\n\\t\\t\\t\\t} ).join( delimiter );\\n\\t\\t\\t} ) ).join( \\\"\\\\n\\\" );\\n\\t\\t};\\n\\t\\tdsv.formatRows = function( rows ) {\\n\\t\\t\\treturn rows.map( formatRow ).join( \\\"\\\\n\\\" );\\n\\t\\t};\\n\\t\\tfunction formatRow( row ) {\\n\\t\\t\\treturn row.map( formatValue ).join( delimiter );\\n\\t\\t}\\n\\t\\tfunction formatValue( text ) {\\n\\t\\t\\treturn reFormat.test( text ) ? '\\\"' + text.replace( /\\\\\\\"/g, '\\\"\\\"' ) + '\\\"' : text;\\n\\t\\t}\\n\\t\\treturn dsv;\\n\\t};\\n\\td3.csv = d3.dsv( \\\",\\\", \\\"text/csv\\\" );\\n\\td3.tsv = d3.dsv( \\\"\\t\\\", \\\"text/tab-separated-values\\\" );\\n\\tvar d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol( this, \\\"requestAnimationFrame\\\" )] || function( callback ) {\\n\\t\\tsetTimeout( callback, 17 );\\n\\t};\\n\\td3.timer = function() {\\n\\t\\td3_timer.apply( this, arguments );\\n\\t};\\n\\tfunction d3_timer( callback, delay, then ) {\\n\\t\\tvar n = arguments.length;\\n\\t\\tif ( n < 2 ) delay = 0;\\n\\t\\tif ( n < 3 ) then = Date.now();\\n\\t\\tvar time = then + delay, timer = {\\n\\t\\t\\tc: callback,\\n\\t\\t\\tt: time,\\n\\t\\t\\tn: null\\n\\t\\t};\\n\\t\\tif ( d3_timer_queueTail ) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\\n\\t\\td3_timer_queueTail = timer;\\n\\t\\tif ( !d3_timer_interval ) {\\n\\t\\t\\td3_timer_timeout = clearTimeout( d3_timer_timeout );\\n\\t\\t\\td3_timer_interval = 1;\\n\\t\\t\\td3_timer_frame( d3_timer_step );\\n\\t\\t}\\n\\t\\treturn timer;\\n\\t}\\n\\tfunction d3_timer_step() {\\n\\t\\tvar now = d3_timer_mark(), delay = d3_timer_sweep() - now;\\n\\t\\tif ( delay > 24 ) {\\n\\t\\t\\tif ( isFinite( delay ) ) {\\n\\t\\t\\t\\tclearTimeout( d3_timer_timeout );\\n\\t\\t\\t\\td3_timer_timeout = setTimeout( d3_timer_step, delay );\\n\\t\\t\\t}\\n\\t\\t\\td3_timer_interval = 0;\\n\\t\\t} else {\\n\\t\\t\\td3_timer_interval = 1;\\n\\t\\t\\td3_timer_frame( d3_timer_step );\\n\\t\\t}\\n\\t}\\n\\td3.timer.flush = function() {\\n\\t\\td3_timer_mark();\\n\\t\\td3_timer_sweep();\\n\\t};\\n\\tfunction d3_timer_mark() {\\n\\t\\tvar now = Date.now(), timer = d3_timer_queueHead;\\n\\t\\twhile ( timer ) {\\n\\t\\t\\tif ( now >= timer.t && timer.c( now - timer.t ) ) timer.c = null;\\n\\t\\t\\ttimer = timer.n;\\n\\t\\t}\\n\\t\\treturn now;\\n\\t}\\n\\tfunction d3_timer_sweep() {\\n\\t\\tvar t0, t1 = d3_timer_queueHead, time = Infinity;\\n\\t\\twhile ( t1 ) {\\n\\t\\t\\tif ( t1.c ) {\\n\\t\\t\\t\\tif ( t1.t < time ) time = t1.t;\\n\\t\\t\\t\\tt1 = ( t0 = t1 ).n;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tt1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\td3_timer_queueTail = t0;\\n\\t\\treturn time;\\n\\t}\\n\\tfunction d3_format_precision( x, p ) {\\n\\t\\treturn p - ( x ? Math.ceil( Math.log( x ) / Math.LN10 ) : 1 );\\n\\t}\\n\\td3.round = function( x, n ) {\\n\\t\\treturn n ? Math.round( x * ( n = Math.pow( 10, n ) ) ) / n : Math.round( x );\\n\\t};\\n\\tvar d3_formatPrefixes = [ \\\"y\\\", \\\"z\\\", \\\"a\\\", \\\"f\\\", \\\"p\\\", \\\"n\\\", \\\"\\\", \\\"m\\\", \\\"\\\", \\\"k\\\", \\\"M\\\", \\\"G\\\", \\\"T\\\", \\\"P\\\", \\\"E\\\", \\\"Z\\\", \\\"Y\\\" ].map( d3_formatPrefix );\\n\\td3.formatPrefix = function( value, precision ) {\\n\\t\\tvar i = 0;\\n\\t\\tif ( value = +value ) {\\n\\t\\t\\tif ( value < 0 ) value *= -1;\\n\\t\\t\\tif ( precision ) value = d3.round( value, d3_format_precision( value, precision ) );\\n\\t\\t\\ti = 1 + Math.floor( 1e-12 + Math.log( value ) / Math.LN10 );\\n\\t\\t\\ti = Math.max( -24, Math.min( 24, Math.floor( ( i - 1 ) / 3 ) * 3 ) );\\n\\t\\t}\\n\\t\\treturn d3_formatPrefixes[8 + i / 3];\\n\\t};\\n\\tfunction d3_formatPrefix( d, i ) {\\n\\t\\tvar k = Math.pow( 10, abs( 8 - i ) * 3 );\\n\\t\\treturn {\\n\\t\\t\\tscale: i > 8 ? function( d ) {\\n\\t\\t\\t\\treturn d / k;\\n\\t\\t\\t} : function( d ) {\\n\\t\\t\\t\\treturn d * k;\\n\\t\\t\\t},\\n\\t\\t\\tsymbol: d\\n\\t\\t};\\n\\t}\\n\\tfunction d3_locale_numberFormat( locale ) {\\n\\t\\tvar locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function( value, width ) {\\n\\t\\t\\tvar i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\\n\\t\\t\\twhile ( i > 0 && g > 0 ) {\\n\\t\\t\\t\\tif ( length + g + 1 > width ) g = Math.max( 1, width - length );\\n\\t\\t\\t\\tt.push( value.substring( i -= g, i + g ) );\\n\\t\\t\\t\\tif ( ( length += g + 1 ) > width ) break;\\n\\t\\t\\t\\tg = locale_grouping[j = ( j + 1 ) % locale_grouping.length];\\n\\t\\t\\t}\\n\\t\\t\\treturn t.reverse().join( locale_thousands );\\n\\t\\t} : d3_identity;\\n\\t\\treturn function( specifier ) {\\n\\t\\t\\tvar match = d3_format_re.exec( specifier ), fill = match[1] || \\\" \\\", align = match[2] || \\\">\\\", sign = match[3] || \\\"-\\\", symbol = match[4] || \\\"\\\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \\\"\\\", suffix = \\\"\\\", integer = false, exponent = true;\\n\\t\\t\\tif ( precision ) precision = +precision.substring( 1 );\\n\\t\\t\\tif ( zfill || fill === \\\"0\\\" && align === \\\"=\\\" ) {\\n\\t\\t\\t\\tzfill = fill = \\\"0\\\";\\n\\t\\t\\t\\talign = \\\"=\\\";\\n\\t\\t\\t}\\n\\t\\t\\tswitch ( type ) {\\n\\t\\t\\tcase \\\"n\\\":\\n\\t\\t\\t\\tcomma = true;\\n\\t\\t\\t\\ttype = \\\"g\\\";\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"%\\\":\\n\\t\\t\\t\\tscale = 100;\\n\\t\\t\\t\\tsuffix = \\\"%\\\";\\n\\t\\t\\t\\ttype = \\\"f\\\";\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"p\\\":\\n\\t\\t\\t\\tscale = 100;\\n\\t\\t\\t\\tsuffix = \\\"%\\\";\\n\\t\\t\\t\\ttype = \\\"r\\\";\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"b\\\":\\n\\t\\t\\tcase \\\"o\\\":\\n\\t\\t\\tcase \\\"x\\\":\\n\\t\\t\\tcase \\\"X\\\":\\n\\t\\t\\t\\tif ( symbol === \\\"#\\\" ) prefix = \\\"0\\\" + type.toLowerCase();\\n\\n\\t\\t\\tcase \\\"c\\\":\\n\\t\\t\\t\\texponent = false;\\n\\n\\t\\t\\tcase \\\"d\\\":\\n\\t\\t\\t\\tinteger = true;\\n\\t\\t\\t\\tprecision = 0;\\n\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\tcase \\\"s\\\":\\n\\t\\t\\t\\tscale = -1;\\n\\t\\t\\t\\ttype = \\\"r\\\";\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t\\tif ( symbol === \\\"$\\\" ) prefix = locale_currency[0], suffix = locale_currency[1];\\n\\t\\t\\tif ( type == \\\"r\\\" && !precision ) type = \\\"g\\\";\\n\\t\\t\\tif ( precision != null ) {\\n\\t\\t\\t\\tif ( type == \\\"g\\\" ) precision = Math.max( 1, Math.min( 21, precision ) ); else if ( type == \\\"e\\\" || type == \\\"f\\\" ) precision = Math.max( 0, Math.min( 20, precision ) );\\n\\t\\t\\t}\\n\\t\\t\\ttype = d3_format_types.get( type ) || d3_format_typeDefault;\\n\\t\\t\\tvar zcomma = zfill && comma;\\n\\t\\t\\treturn function( value ) {\\n\\t\\t\\t\\tvar fullSuffix = suffix;\\n\\t\\t\\t\\tif ( integer && value % 1 ) return \\\"\\\";\\n\\t\\t\\t\\tvar negative = value < 0 || value === 0 && 1 / value < 0 ? ( value = -value, \\\"-\\\" ) : sign === \\\"-\\\" ? \\\"\\\" : sign;\\n\\t\\t\\t\\tif ( scale < 0 ) {\\n\\t\\t\\t\\t\\tvar unit = d3.formatPrefix( value, precision );\\n\\t\\t\\t\\t\\tvalue = unit.scale( value );\\n\\t\\t\\t\\t\\tfullSuffix = unit.symbol + suffix;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvalue *= scale;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvalue = type( value, precision );\\n\\t\\t\\t\\tvar i = value.lastIndexOf( \\\".\\\" ), before, after;\\n\\t\\t\\t\\tif ( i < 0 ) {\\n\\t\\t\\t\\t\\tvar j = exponent ? value.lastIndexOf( \\\"e\\\" ) : -1;\\n\\t\\t\\t\\t\\tif ( j < 0 ) before = value, after = \\\"\\\"; else before = value.substring( 0, j ), after = value.substring( j );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbefore = value.substring( 0, i );\\n\\t\\t\\t\\t\\tafter = locale_decimal + value.substring( i + 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !zfill && comma ) before = formatGroup( before, Infinity );\\n\\t\\t\\t\\tvar length = prefix.length + before.length + after.length + ( zcomma ? 0 : negative.length ), padding = length < width ? new Array( length = width - length + 1 ).join( fill ) : \\\"\\\";\\n\\t\\t\\t\\tif ( zcomma ) before = formatGroup( padding + before, padding.length ? width - after.length : Infinity );\\n\\t\\t\\t\\tnegative += prefix;\\n\\t\\t\\t\\tvalue = before + after;\\n\\t\\t\\t\\treturn ( align === \\\"<\\\" ? negative + value + padding : align === \\\">\\\" ? padding + negative + value : align === \\\"^\\\" ? padding.substring( 0, length >>= 1 ) + negative + value + padding.substring( length ) : negative + ( zcomma ? value : padding + value ) ) + fullSuffix;\\n\\t\\t\\t};\\n\\t\\t};\\n\\t}\\n\\tvar d3_format_re = /(?:([^{])?([<>=^]))?([+\\\\- ])?([$#])?(0)?(\\\\d+)?(,)?(\\\\.-?\\\\d+)?([a-z%])?/i;\\n\\tvar d3_format_types = d3.map( {\\n\\t\\tb: function( x ) {\\n\\t\\t\\treturn x.toString( 2 );\\n\\t\\t},\\n\\t\\tc: function( x ) {\\n\\t\\t\\treturn String.fromCharCode( x );\\n\\t\\t},\\n\\t\\to: function( x ) {\\n\\t\\t\\treturn x.toString( 8 );\\n\\t\\t},\\n\\t\\tx: function( x ) {\\n\\t\\t\\treturn x.toString( 16 );\\n\\t\\t},\\n\\t\\tX: function( x ) {\\n\\t\\t\\treturn x.toString( 16 ).toUpperCase();\\n\\t\\t},\\n\\t\\tg: function( x, p ) {\\n\\t\\t\\treturn x.toPrecision( p );\\n\\t\\t},\\n\\t\\te: function( x, p ) {\\n\\t\\t\\treturn x.toExponential( p );\\n\\t\\t},\\n\\t\\tf: function( x, p ) {\\n\\t\\t\\treturn x.toFixed( p );\\n\\t\\t},\\n\\t\\tr: function( x, p ) {\\n\\t\\t\\treturn ( x = d3.round( x, d3_format_precision( x, p ) ) ).toFixed( Math.max( 0, Math.min( 20, d3_format_precision( x * ( 1 + 1e-15 ), p ) ) ) );\\n\\t\\t}\\n\\t} );\\n\\tfunction d3_format_typeDefault( x ) {\\n\\t\\treturn x + \\\"\\\";\\n\\t}\\n\\tvar d3_time = d3.time = {}, d3_date = Date;\\n\\tfunction d3_date_utc() {\\n\\t\\tthis._ = new Date( arguments.length > 1 ? Date.UTC.apply( this, arguments ) : arguments[0] );\\n\\t}\\n\\td3_date_utc.prototype = {\\n\\t\\tgetDate: function() {\\n\\t\\t\\treturn this._.getUTCDate();\\n\\t\\t},\\n\\t\\tgetDay: function() {\\n\\t\\t\\treturn this._.getUTCDay();\\n\\t\\t},\\n\\t\\tgetFullYear: function() {\\n\\t\\t\\treturn this._.getUTCFullYear();\\n\\t\\t},\\n\\t\\tgetHours: function() {\\n\\t\\t\\treturn this._.getUTCHours();\\n\\t\\t},\\n\\t\\tgetMilliseconds: function() {\\n\\t\\t\\treturn this._.getUTCMilliseconds();\\n\\t\\t},\\n\\t\\tgetMinutes: function() {\\n\\t\\t\\treturn this._.getUTCMinutes();\\n\\t\\t},\\n\\t\\tgetMonth: function() {\\n\\t\\t\\treturn this._.getUTCMonth();\\n\\t\\t},\\n\\t\\tgetSeconds: function() {\\n\\t\\t\\treturn this._.getUTCSeconds();\\n\\t\\t},\\n\\t\\tgetTime: function() {\\n\\t\\t\\treturn this._.getTime();\\n\\t\\t},\\n\\t\\tgetTimezoneOffset: function() {\\n\\t\\t\\treturn 0;\\n\\t\\t},\\n\\t\\tvalueOf: function() {\\n\\t\\t\\treturn this._.valueOf();\\n\\t\\t},\\n\\t\\tsetDate: function() {\\n\\t\\t\\td3_time_prototype.setUTCDate.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetDay: function() {\\n\\t\\t\\td3_time_prototype.setUTCDay.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetFullYear: function() {\\n\\t\\t\\td3_time_prototype.setUTCFullYear.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetHours: function() {\\n\\t\\t\\td3_time_prototype.setUTCHours.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetMilliseconds: function() {\\n\\t\\t\\td3_time_prototype.setUTCMilliseconds.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetMinutes: function() {\\n\\t\\t\\td3_time_prototype.setUTCMinutes.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetMonth: function() {\\n\\t\\t\\td3_time_prototype.setUTCMonth.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetSeconds: function() {\\n\\t\\t\\td3_time_prototype.setUTCSeconds.apply( this._, arguments );\\n\\t\\t},\\n\\t\\tsetTime: function() {\\n\\t\\t\\td3_time_prototype.setTime.apply( this._, arguments );\\n\\t\\t}\\n\\t};\\n\\tvar d3_time_prototype = Date.prototype;\\n\\tfunction d3_time_interval( local, step, number ) {\\n\\t\\tfunction round( date ) {\\n\\t\\t\\tvar d0 = local( date ), d1 = offset( d0, 1 );\\n\\t\\t\\treturn date - d0 < d1 - date ? d0 : d1;\\n\\t\\t}\\n\\t\\tfunction ceil( date ) {\\n\\t\\t\\tstep( date = local( new d3_date( date - 1 ) ), 1 );\\n\\t\\t\\treturn date;\\n\\t\\t}\\n\\t\\tfunction offset( date, k ) {\\n\\t\\t\\tstep( date = new d3_date( +date ), k );\\n\\t\\t\\treturn date;\\n\\t\\t}\\n\\t\\tfunction range( t0, t1, dt ) {\\n\\t\\t\\tvar time = ceil( t0 ), times = [];\\n\\t\\t\\tif ( dt > 1 ) {\\n\\t\\t\\t\\twhile ( time < t1 ) {\\n\\t\\t\\t\\t\\tif ( !( number( time ) % dt ) ) times.push( new Date( +time ) );\\n\\t\\t\\t\\t\\tstep( time, 1 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\twhile ( time < t1 ) times.push( new Date( +time ) ), step( time, 1 );\\n\\t\\t\\t}\\n\\t\\t\\treturn times;\\n\\t\\t}\\n\\t\\tfunction range_utc( t0, t1, dt ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\td3_date = d3_date_utc;\\n\\t\\t\\t\\tvar utc = new d3_date_utc();\\n\\t\\t\\t\\tutc._ = t0;\\n\\t\\t\\t\\treturn range( utc, t1, dt );\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\td3_date = Date;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tlocal.floor = local;\\n\\t\\tlocal.round = round;\\n\\t\\tlocal.ceil = ceil;\\n\\t\\tlocal.offset = offset;\\n\\t\\tlocal.range = range;\\n\\t\\tvar utc = local.utc = d3_time_interval_utc( local );\\n\\t\\tutc.floor = utc;\\n\\t\\tutc.round = d3_time_interval_utc( round );\\n\\t\\tutc.ceil = d3_time_interval_utc( ceil );\\n\\t\\tutc.offset = d3_time_interval_utc( offset );\\n\\t\\tutc.range = range_utc;\\n\\t\\treturn local;\\n\\t}\\n\\tfunction d3_time_interval_utc( method ) {\\n\\t\\treturn function( date, k ) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\td3_date = d3_date_utc;\\n\\t\\t\\t\\tvar utc = new d3_date_utc();\\n\\t\\t\\t\\tutc._ = date;\\n\\t\\t\\t\\treturn method( utc, k )._;\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\td3_date = Date;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\td3_time.year = d3_time_interval( function( date ) {\\n\\t\\tdate = d3_time.day( date );\\n\\t\\tdate.setMonth( 0, 1 );\\n\\t\\treturn date;\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setFullYear( date.getFullYear() + offset );\\n\\t}, function( date ) {\\n\\t\\treturn date.getFullYear();\\n\\t} );\\n\\td3_time.years = d3_time.year.range;\\n\\td3_time.years.utc = d3_time.year.utc.range;\\n\\td3_time.day = d3_time_interval( function( date ) {\\n\\t\\tvar day = new d3_date( 2e3, 0 );\\n\\t\\tday.setFullYear( date.getFullYear(), date.getMonth(), date.getDate() );\\n\\t\\treturn day;\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setDate( date.getDate() + offset );\\n\\t}, function( date ) {\\n\\t\\treturn date.getDate() - 1;\\n\\t} );\\n\\td3_time.days = d3_time.day.range;\\n\\td3_time.days.utc = d3_time.day.utc.range;\\n\\td3_time.dayOfYear = function( date ) {\\n\\t\\tvar year = d3_time.year( date );\\n\\t\\treturn Math.floor( ( date - year - ( date.getTimezoneOffset() - year.getTimezoneOffset() ) * 6e4 ) / 864e5 );\\n\\t};\\n\\t[ \\\"sunday\\\", \\\"monday\\\", \\\"tuesday\\\", \\\"wednesday\\\", \\\"thursday\\\", \\\"friday\\\", \\\"saturday\\\" ].forEach( function( day, i ) {\\n\\t\\ti = 7 - i;\\n\\t\\tvar interval = d3_time[day] = d3_time_interval( function( date ) {\\n\\t\\t\\t( date = d3_time.day( date ) ).setDate( date.getDate() - ( date.getDay() + i ) % 7 );\\n\\t\\t\\treturn date;\\n\\t\\t}, function( date, offset ) {\\n\\t\\t\\tdate.setDate( date.getDate() + Math.floor( offset ) * 7 );\\n\\t\\t}, function( date ) {\\n\\t\\t\\tvar day = d3_time.year( date ).getDay();\\n\\t\\t\\treturn Math.floor( ( d3_time.dayOfYear( date ) + ( day + i ) % 7 ) / 7 ) - ( day !== i );\\n\\t\\t} );\\n\\t\\td3_time[day + \\\"s\\\"] = interval.range;\\n\\t\\td3_time[day + \\\"s\\\"].utc = interval.utc.range;\\n\\t\\td3_time[day + \\\"OfYear\\\"] = function( date ) {\\n\\t\\t\\tvar day = d3_time.year( date ).getDay();\\n\\t\\t\\treturn Math.floor( ( d3_time.dayOfYear( date ) + ( day + i ) % 7 ) / 7 );\\n\\t\\t};\\n\\t} );\\n\\td3_time.week = d3_time.sunday;\\n\\td3_time.weeks = d3_time.sunday.range;\\n\\td3_time.weeks.utc = d3_time.sunday.utc.range;\\n\\td3_time.weekOfYear = d3_time.sundayOfYear;\\n\\tfunction d3_locale_timeFormat( locale ) {\\n\\t\\tvar locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\\n\\t\\tfunction d3_time_format( template ) {\\n\\t\\t\\tvar n = template.length;\\n\\t\\t\\tfunction format( date ) {\\n\\t\\t\\t\\tvar string = [], i = -1, j = 0, c, p, f;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\tif ( template.charCodeAt( i ) === 37 ) {\\n\\t\\t\\t\\t\\t\\tstring.push( template.slice( j, i ) );\\n\\t\\t\\t\\t\\t\\tif ( ( p = d3_time_formatPads[c = template.charAt( ++i )] ) != null ) c = template.charAt( ++i );\\n\\t\\t\\t\\t\\t\\tif ( f = d3_time_formats[c] ) c = f( date, p == null ? c === \\\"e\\\" ? \\\" \\\" : \\\"0\\\" : p );\\n\\t\\t\\t\\t\\t\\tstring.push( c );\\n\\t\\t\\t\\t\\t\\tj = i + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tstring.push( template.slice( j, i ) );\\n\\t\\t\\t\\treturn string.join( \\\"\\\" );\\n\\t\\t\\t}\\n\\t\\t\\tformat.parse = function( string ) {\\n\\t\\t\\t\\tvar d = {\\n\\t\\t\\t\\t\\t\\ty: 1900,\\n\\t\\t\\t\\t\\t\\tm: 0,\\n\\t\\t\\t\\t\\t\\td: 1,\\n\\t\\t\\t\\t\\t\\tH: 0,\\n\\t\\t\\t\\t\\t\\tM: 0,\\n\\t\\t\\t\\t\\t\\tS: 0,\\n\\t\\t\\t\\t\\t\\tL: 0,\\n\\t\\t\\t\\t\\t\\tZ: null\\n\\t\\t\\t\\t\\t}, i = d3_time_parse( d, template, string, 0 );\\n\\t\\t\\t\\tif ( i != string.length ) return null;\\n\\t\\t\\t\\tif ( \\\"p\\\" in d ) d.H = d.H % 12 + d.p * 12;\\n\\t\\t\\t\\tvar localZ = d.Z != null && d3_date !== d3_date_utc, date = new ( localZ ? d3_date_utc : d3_date )();\\n\\t\\t\\t\\tif ( \\\"j\\\" in d ) date.setFullYear( d.y, 0, d.j ); else if ( \\\"W\\\" in d || \\\"U\\\" in d ) {\\n\\t\\t\\t\\t\\tif ( !( \\\"w\\\" in d ) ) d.w = \\\"W\\\" in d ? 1 : 0;\\n\\t\\t\\t\\t\\tdate.setFullYear( d.y, 0, 1 );\\n\\t\\t\\t\\t\\tdate.setFullYear( d.y, 0, \\\"W\\\" in d ? ( d.w + 6 ) % 7 + d.W * 7 - ( date.getDay() + 5 ) % 7 : d.w + d.U * 7 - ( date.getDay() + 6 ) % 7 );\\n\\t\\t\\t\\t} else date.setFullYear( d.y, d.m, d.d );\\n\\t\\t\\t\\tdate.setHours( d.H + ( d.Z / 100 | 0 ), d.M + d.Z % 100, d.S, d.L );\\n\\t\\t\\t\\treturn localZ ? date._ : date;\\n\\t\\t\\t};\\n\\t\\t\\tformat.toString = function() {\\n\\t\\t\\t\\treturn template;\\n\\t\\t\\t};\\n\\t\\t\\treturn format;\\n\\t\\t}\\n\\t\\tfunction d3_time_parse( date, template, string, j ) {\\n\\t\\t\\tvar c, p, t, i = 0, n = template.length, m = string.length;\\n\\t\\t\\twhile ( i < n ) {\\n\\t\\t\\t\\tif ( j >= m ) return -1;\\n\\t\\t\\t\\tc = template.charCodeAt( i++ );\\n\\t\\t\\t\\tif ( c === 37 ) {\\n\\t\\t\\t\\t\\tt = template.charAt( i++ );\\n\\t\\t\\t\\t\\tp = d3_time_parsers[t in d3_time_formatPads ? template.charAt( i++ ) : t];\\n\\t\\t\\t\\t\\tif ( !p || ( j = p( date, string, j ) ) < 0 ) return -1;\\n\\t\\t\\t\\t} else if ( c != string.charCodeAt( j++ ) ) {\\n\\t\\t\\t\\t\\treturn -1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn j;\\n\\t\\t}\\n\\t\\td3_time_format.utc = function( template ) {\\n\\t\\t\\tvar local = d3_time_format( template );\\n\\t\\t\\tfunction format( date ) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\td3_date = d3_date_utc;\\n\\t\\t\\t\\t\\tvar utc = new d3_date();\\n\\t\\t\\t\\t\\tutc._ = date;\\n\\t\\t\\t\\t\\treturn local( utc );\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\td3_date = Date;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tformat.parse = function( string ) {\\n\\t\\t\\t\\ttry {\\n\\t\\t\\t\\t\\td3_date = d3_date_utc;\\n\\t\\t\\t\\t\\tvar date = local.parse( string );\\n\\t\\t\\t\\t\\treturn date && date._;\\n\\t\\t\\t\\t} finally {\\n\\t\\t\\t\\t\\td3_date = Date;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tformat.toString = local.toString;\\n\\t\\t\\treturn format;\\n\\t\\t};\\n\\t\\td3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\\n\\t\\tvar d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe( locale_days ), d3_time_dayLookup = d3_time_formatLookup( locale_days ), d3_time_dayAbbrevRe = d3_time_formatRe( locale_shortDays ), d3_time_dayAbbrevLookup = d3_time_formatLookup( locale_shortDays ), d3_time_monthRe = d3_time_formatRe( locale_months ), d3_time_monthLookup = d3_time_formatLookup( locale_months ), d3_time_monthAbbrevRe = d3_time_formatRe( locale_shortMonths ), d3_time_monthAbbrevLookup = d3_time_formatLookup( locale_shortMonths );\\n\\t\\tlocale_periods.forEach( function( p, i ) {\\n\\t\\t\\td3_time_periodLookup.set( p.toLowerCase(), i );\\n\\t\\t} );\\n\\t\\tvar d3_time_formats = {\\n\\t\\t\\ta: function( d ) {\\n\\t\\t\\t\\treturn locale_shortDays[d.getDay()];\\n\\t\\t\\t},\\n\\t\\t\\tA: function( d ) {\\n\\t\\t\\t\\treturn locale_days[d.getDay()];\\n\\t\\t\\t},\\n\\t\\t\\tb: function( d ) {\\n\\t\\t\\t\\treturn locale_shortMonths[d.getMonth()];\\n\\t\\t\\t},\\n\\t\\t\\tB: function( d ) {\\n\\t\\t\\t\\treturn locale_months[d.getMonth()];\\n\\t\\t\\t},\\n\\t\\t\\tc: d3_time_format( locale_dateTime ),\\n\\t\\t\\td: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getDate(), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\te: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getDate(), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tH: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getHours(), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tI: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getHours() % 12 || 12, p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tj: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( 1 + d3_time.dayOfYear( d ), p, 3 );\\n\\t\\t\\t},\\n\\t\\t\\tL: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getMilliseconds(), p, 3 );\\n\\t\\t\\t},\\n\\t\\t\\tm: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getMonth() + 1, p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tM: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getMinutes(), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tp: function( d ) {\\n\\t\\t\\t\\treturn locale_periods[+( d.getHours() >= 12 )];\\n\\t\\t\\t},\\n\\t\\t\\tS: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getSeconds(), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tU: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d3_time.sundayOfYear( d ), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tw: function( d ) {\\n\\t\\t\\t\\treturn d.getDay();\\n\\t\\t\\t},\\n\\t\\t\\tW: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d3_time.mondayOfYear( d ), p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tx: d3_time_format( locale_date ),\\n\\t\\t\\tX: d3_time_format( locale_time ),\\n\\t\\t\\ty: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getFullYear() % 100, p, 2 );\\n\\t\\t\\t},\\n\\t\\t\\tY: function( d, p ) {\\n\\t\\t\\t\\treturn d3_time_formatPad( d.getFullYear() % 1e4, p, 4 );\\n\\t\\t\\t},\\n\\t\\t\\tZ: d3_time_zone,\\n\\t\\t\\t\\\"%\\\": function() {\\n\\t\\t\\t\\treturn \\\"%\\\";\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tvar d3_time_parsers = {\\n\\t\\t\\ta: d3_time_parseWeekdayAbbrev,\\n\\t\\t\\tA: d3_time_parseWeekday,\\n\\t\\t\\tb: d3_time_parseMonthAbbrev,\\n\\t\\t\\tB: d3_time_parseMonth,\\n\\t\\t\\tc: d3_time_parseLocaleFull,\\n\\t\\t\\td: d3_time_parseDay,\\n\\t\\t\\te: d3_time_parseDay,\\n\\t\\t\\tH: d3_time_parseHour24,\\n\\t\\t\\tI: d3_time_parseHour24,\\n\\t\\t\\tj: d3_time_parseDayOfYear,\\n\\t\\t\\tL: d3_time_parseMilliseconds,\\n\\t\\t\\tm: d3_time_parseMonthNumber,\\n\\t\\t\\tM: d3_time_parseMinutes,\\n\\t\\t\\tp: d3_time_parseAmPm,\\n\\t\\t\\tS: d3_time_parseSeconds,\\n\\t\\t\\tU: d3_time_parseWeekNumberSunday,\\n\\t\\t\\tw: d3_time_parseWeekdayNumber,\\n\\t\\t\\tW: d3_time_parseWeekNumberMonday,\\n\\t\\t\\tx: d3_time_parseLocaleDate,\\n\\t\\t\\tX: d3_time_parseLocaleTime,\\n\\t\\t\\ty: d3_time_parseYear,\\n\\t\\t\\tY: d3_time_parseFullYear,\\n\\t\\t\\tZ: d3_time_parseZone,\\n\\t\\t\\t\\\"%\\\": d3_time_parseLiteralPercent\\n\\t\\t};\\n\\t\\tfunction d3_time_parseWeekdayAbbrev( date, string, i ) {\\n\\t\\t\\td3_time_dayAbbrevRe.lastIndex = 0;\\n\\t\\t\\tvar n = d3_time_dayAbbrevRe.exec( string.slice( i ) );\\n\\t\\t\\treturn n ? ( date.w = d3_time_dayAbbrevLookup.get( n[0].toLowerCase() ), i + n[0].length ) : -1;\\n\\t\\t}\\n\\t\\tfunction d3_time_parseWeekday( date, string, i ) {\\n\\t\\t\\td3_time_dayRe.lastIndex = 0;\\n\\t\\t\\tvar n = d3_time_dayRe.exec( string.slice( i ) );\\n\\t\\t\\treturn n ? ( date.w = d3_time_dayLookup.get( n[0].toLowerCase() ), i + n[0].length ) : -1;\\n\\t\\t}\\n\\t\\tfunction d3_time_parseMonthAbbrev( date, string, i ) {\\n\\t\\t\\td3_time_monthAbbrevRe.lastIndex = 0;\\n\\t\\t\\tvar n = d3_time_monthAbbrevRe.exec( string.slice( i ) );\\n\\t\\t\\treturn n ? ( date.m = d3_time_monthAbbrevLookup.get( n[0].toLowerCase() ), i + n[0].length ) : -1;\\n\\t\\t}\\n\\t\\tfunction d3_time_parseMonth( date, string, i ) {\\n\\t\\t\\td3_time_monthRe.lastIndex = 0;\\n\\t\\t\\tvar n = d3_time_monthRe.exec( string.slice( i ) );\\n\\t\\t\\treturn n ? ( date.m = d3_time_monthLookup.get( n[0].toLowerCase() ), i + n[0].length ) : -1;\\n\\t\\t}\\n\\t\\tfunction d3_time_parseLocaleFull( date, string, i ) {\\n\\t\\t\\treturn d3_time_parse( date, d3_time_formats.c.toString(), string, i );\\n\\t\\t}\\n\\t\\tfunction d3_time_parseLocaleDate( date, string, i ) {\\n\\t\\t\\treturn d3_time_parse( date, d3_time_formats.x.toString(), string, i );\\n\\t\\t}\\n\\t\\tfunction d3_time_parseLocaleTime( date, string, i ) {\\n\\t\\t\\treturn d3_time_parse( date, d3_time_formats.X.toString(), string, i );\\n\\t\\t}\\n\\t\\tfunction d3_time_parseAmPm( date, string, i ) {\\n\\t\\t\\tvar n = d3_time_periodLookup.get( string.slice( i, i += 2 ).toLowerCase() );\\n\\t\\t\\treturn n == null ? -1 : ( date.p = n, i );\\n\\t\\t}\\n\\t\\treturn d3_time_format;\\n\\t}\\n\\tvar d3_time_formatPads = {\\n\\t\\t\\t\\\"-\\\": \\\"\\\",\\n\\t\\t\\t_: \\\" \\\",\\n\\t\\t\\t\\\"0\\\": \\\"0\\\"\\n\\t\\t}, d3_time_numberRe = /^\\\\s*\\\\d+/, d3_time_percentRe = /^%/;\\n\\tfunction d3_time_formatPad( value, fill, width ) {\\n\\t\\tvar sign = value < 0 ? \\\"-\\\" : \\\"\\\", string = ( sign ? -value : value ) + \\\"\\\", length = string.length;\\n\\t\\treturn sign + ( length < width ? new Array( width - length + 1 ).join( fill ) + string : string );\\n\\t}\\n\\tfunction d3_time_formatRe( names ) {\\n\\t\\treturn new RegExp( \\\"^(?:\\\" + names.map( d3.requote ).join( \\\"|\\\" ) + \\\")\\\", \\\"i\\\" );\\n\\t}\\n\\tfunction d3_time_formatLookup( names ) {\\n\\t\\tvar map = new d3_Map(), i = -1, n = names.length;\\n\\t\\twhile ( ++i < n ) map.set( names[i].toLowerCase(), i );\\n\\t\\treturn map;\\n\\t}\\n\\tfunction d3_time_parseWeekdayNumber( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 1 ) );\\n\\t\\treturn n ? ( date.w = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseWeekNumberSunday( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i ) );\\n\\t\\treturn n ? ( date.U = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseWeekNumberMonday( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i ) );\\n\\t\\treturn n ? ( date.W = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseFullYear( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 4 ) );\\n\\t\\treturn n ? ( date.y = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseYear( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.y = d3_time_expandYear( +n[0] ), i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseZone( date, string, i ) {\\n\\t\\treturn /^[+-]\\\\d{4}$/.test( string = string.slice( i, i + 5 ) ) ? ( date.Z = -string,\\n\\t\\ti + 5 ) : -1;\\n\\t}\\n\\tfunction d3_time_expandYear( d ) {\\n\\t\\treturn d + ( d > 68 ? 1900 : 2e3 );\\n\\t}\\n\\tfunction d3_time_parseMonthNumber( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.m = n[0] - 1, i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseDay( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.d = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseDayOfYear( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 3 ) );\\n\\t\\treturn n ? ( date.j = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseHour24( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.H = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseMinutes( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.M = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseSeconds( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 2 ) );\\n\\t\\treturn n ? ( date.S = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_parseMilliseconds( date, string, i ) {\\n\\t\\td3_time_numberRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_numberRe.exec( string.slice( i, i + 3 ) );\\n\\t\\treturn n ? ( date.L = +n[0], i + n[0].length ) : -1;\\n\\t}\\n\\tfunction d3_time_zone( d ) {\\n\\t\\tvar z = d.getTimezoneOffset(), zs = z > 0 ? \\\"-\\\" : \\\"+\\\", zh = abs( z ) / 60 | 0, zm = abs( z ) % 60;\\n\\t\\treturn zs + d3_time_formatPad( zh, \\\"0\\\", 2 ) + d3_time_formatPad( zm, \\\"0\\\", 2 );\\n\\t}\\n\\tfunction d3_time_parseLiteralPercent( date, string, i ) {\\n\\t\\td3_time_percentRe.lastIndex = 0;\\n\\t\\tvar n = d3_time_percentRe.exec( string.slice( i, i + 1 ) );\\n\\t\\treturn n ? i + n[0].length : -1;\\n\\t}\\n\\tfunction d3_time_formatMulti( formats ) {\\n\\t\\tvar n = formats.length, i = -1;\\n\\t\\twhile ( ++i < n ) formats[i][0] = this( formats[i][0] );\\n\\t\\treturn function( date ) {\\n\\t\\t\\tvar i = 0, f = formats[i];\\n\\t\\t\\twhile ( !f[1]( date ) ) f = formats[++i];\\n\\t\\t\\treturn f[0]( date );\\n\\t\\t};\\n\\t}\\n\\td3.locale = function( locale ) {\\n\\t\\treturn {\\n\\t\\t\\tnumberFormat: d3_locale_numberFormat( locale ),\\n\\t\\t\\ttimeFormat: d3_locale_timeFormat( locale )\\n\\t\\t};\\n\\t};\\n\\tvar d3_locale_enUS = d3.locale( {\\n\\t\\tdecimal: \\\".\\\",\\n\\t\\tthousands: \\\",\\\",\\n\\t\\tgrouping: [ 3 ],\\n\\t\\tcurrency: [ \\\"$\\\", \\\"\\\" ],\\n\\t\\tdateTime: \\\"%a %b %e %X %Y\\\",\\n\\t\\tdate: \\\"%m/%d/%Y\\\",\\n\\t\\ttime: \\\"%H:%M:%S\\\",\\n\\t\\tperiods: [ \\\"AM\\\", \\\"PM\\\" ],\\n\\t\\tdays: [ \\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\" ],\\n\\t\\tshortDays: [ \\\"Sun\\\", \\\"Mon\\\", \\\"Tue\\\", \\\"Wed\\\", \\\"Thu\\\", \\\"Fri\\\", \\\"Sat\\\" ],\\n\\t\\tmonths: [ \\\"January\\\", \\\"February\\\", \\\"March\\\", \\\"April\\\", \\\"May\\\", \\\"June\\\", \\\"July\\\", \\\"August\\\", \\\"September\\\", \\\"October\\\", \\\"November\\\", \\\"December\\\" ],\\n\\t\\tshortMonths: [ \\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", \\\"Apr\\\", \\\"May\\\", \\\"Jun\\\", \\\"Jul\\\", \\\"Aug\\\", \\\"Sep\\\", \\\"Oct\\\", \\\"Nov\\\", \\\"Dec\\\" ]\\n\\t} );\\n\\td3.format = d3_locale_enUS.numberFormat;\\n\\td3.geo = {};\\n\\tfunction d3_adder() {}\\n\\td3_adder.prototype = {\\n\\t\\ts: 0,\\n\\t\\tt: 0,\\n\\t\\tadd: function( y ) {\\n\\t\\t\\td3_adderSum( y, this.t, d3_adderTemp );\\n\\t\\t\\td3_adderSum( d3_adderTemp.s, this.s, this );\\n\\t\\t\\tif ( this.s ) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\\n\\t\\t},\\n\\t\\treset: function() {\\n\\t\\t\\tthis.s = this.t = 0;\\n\\t\\t},\\n\\t\\tvalueOf: function() {\\n\\t\\t\\treturn this.s;\\n\\t\\t}\\n\\t};\\n\\tvar d3_adderTemp = new d3_adder();\\n\\tfunction d3_adderSum( a, b, o ) {\\n\\t\\tvar x = o.s = a + b, bv = x - a, av = x - bv;\\n\\t\\to.t = a - av + ( b - bv );\\n\\t}\\n\\td3.geo.stream = function( object, listener ) {\\n\\t\\tif ( object && d3_geo_streamObjectType.hasOwnProperty( object.type ) ) {\\n\\t\\t\\td3_geo_streamObjectType[object.type]( object, listener );\\n\\t\\t} else {\\n\\t\\t\\td3_geo_streamGeometry( object, listener );\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_streamGeometry( geometry, listener ) {\\n\\t\\tif ( geometry && d3_geo_streamGeometryType.hasOwnProperty( geometry.type ) ) {\\n\\t\\t\\td3_geo_streamGeometryType[geometry.type]( geometry, listener );\\n\\t\\t}\\n\\t}\\n\\tvar d3_geo_streamObjectType = {\\n\\t\\tFeature: function( feature, listener ) {\\n\\t\\t\\td3_geo_streamGeometry( feature.geometry, listener );\\n\\t\\t},\\n\\t\\tFeatureCollection: function( object, listener ) {\\n\\t\\t\\tvar features = object.features, i = -1, n = features.length;\\n\\t\\t\\twhile ( ++i < n ) d3_geo_streamGeometry( features[i].geometry, listener );\\n\\t\\t}\\n\\t};\\n\\tvar d3_geo_streamGeometryType = {\\n\\t\\tSphere: function( object, listener ) {\\n\\t\\t\\tlistener.sphere();\\n\\t\\t},\\n\\t\\tPoint: function( object, listener ) {\\n\\t\\t\\tobject = object.coordinates;\\n\\t\\t\\tlistener.point( object[0], object[1], object[2] );\\n\\t\\t},\\n\\t\\tMultiPoint: function( object, listener ) {\\n\\t\\t\\tvar coordinates = object.coordinates, i = -1, n = coordinates.length;\\n\\t\\t\\twhile ( ++i < n ) object = coordinates[i], listener.point( object[0], object[1], object[2] );\\n\\t\\t},\\n\\t\\tLineString: function( object, listener ) {\\n\\t\\t\\td3_geo_streamLine( object.coordinates, listener, 0 );\\n\\t\\t},\\n\\t\\tMultiLineString: function( object, listener ) {\\n\\t\\t\\tvar coordinates = object.coordinates, i = -1, n = coordinates.length;\\n\\t\\t\\twhile ( ++i < n ) d3_geo_streamLine( coordinates[i], listener, 0 );\\n\\t\\t},\\n\\t\\tPolygon: function( object, listener ) {\\n\\t\\t\\td3_geo_streamPolygon( object.coordinates, listener );\\n\\t\\t},\\n\\t\\tMultiPolygon: function( object, listener ) {\\n\\t\\t\\tvar coordinates = object.coordinates, i = -1, n = coordinates.length;\\n\\t\\t\\twhile ( ++i < n ) d3_geo_streamPolygon( coordinates[i], listener );\\n\\t\\t},\\n\\t\\tGeometryCollection: function( object, listener ) {\\n\\t\\t\\tvar geometries = object.geometries, i = -1, n = geometries.length;\\n\\t\\t\\twhile ( ++i < n ) d3_geo_streamGeometry( geometries[i], listener );\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_streamLine( coordinates, listener, closed ) {\\n\\t\\tvar i = -1, n = coordinates.length - closed, coordinate;\\n\\t\\tlistener.lineStart();\\n\\t\\twhile ( ++i < n ) coordinate = coordinates[i], listener.point( coordinate[0], coordinate[1], coordinate[2] );\\n\\t\\tlistener.lineEnd();\\n\\t}\\n\\tfunction d3_geo_streamPolygon( coordinates, listener ) {\\n\\t\\tvar i = -1, n = coordinates.length;\\n\\t\\tlistener.polygonStart();\\n\\t\\twhile ( ++i < n ) d3_geo_streamLine( coordinates[i], listener, 1 );\\n\\t\\tlistener.polygonEnd();\\n\\t}\\n\\td3.geo.area = function( object ) {\\n\\t\\td3_geo_areaSum = 0;\\n\\t\\td3.geo.stream( object, d3_geo_area );\\n\\t\\treturn d3_geo_areaSum;\\n\\t};\\n\\tvar d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\\n\\tvar d3_geo_area = {\\n\\t\\tsphere: function() {\\n\\t\\t\\td3_geo_areaSum += 4 * ;\\n\\t\\t},\\n\\t\\tpoint: d3_noop,\\n\\t\\tlineStart: d3_noop,\\n\\t\\tlineEnd: d3_noop,\\n\\t\\tpolygonStart: function() {\\n\\t\\t\\td3_geo_areaRingSum.reset();\\n\\t\\t\\td3_geo_area.lineStart = d3_geo_areaRingStart;\\n\\t\\t},\\n\\t\\tpolygonEnd: function() {\\n\\t\\t\\tvar area = 2 * d3_geo_areaRingSum;\\n\\t\\t\\td3_geo_areaSum += area < 0 ? 4 *  + area : area;\\n\\t\\t\\td3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_areaRingStart() {\\n\\t\\tvar 00, 00, 0, cos0, sin0;\\n\\t\\td3_geo_area.point = function( ,  ) {\\n\\t\\t\\td3_geo_area.point = nextPoint;\\n\\t\\t\\t0 = ( 00 =  ) * d3_radians, cos0 = Math.cos(  = ( 00 =  ) * d3_radians / 2 +  / 4 ),\\n\\t\\t\\tsin0 = Math.sin(  );\\n\\t\\t};\\n\\t\\tfunction nextPoint( ,  ) {\\n\\t\\t\\t *= d3_radians;\\n\\t\\t\\t =  * d3_radians / 2 +  / 4;\\n\\t\\t\\tvar d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, cos = Math.cos(  ), sin = Math.sin(  ), k = sin0 * sin, u = cos0 * cos + k * Math.cos( ad ), v = k * sd * Math.sin( ad );\\n\\t\\t\\td3_geo_areaRingSum.add( Math.atan2( v, u ) );\\n\\t\\t\\t0 = , cos0 = cos, sin0 = sin;\\n\\t\\t}\\n\\t\\td3_geo_area.lineEnd = function() {\\n\\t\\t\\tnextPoint( 00, 00 );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_cartesian( spherical ) {\\n\\t\\tvar  = spherical[0],  = spherical[1], cos = Math.cos(  );\\n\\t\\treturn [ cos * Math.cos(  ), cos * Math.sin(  ), Math.sin(  ) ];\\n\\t}\\n\\tfunction d3_geo_cartesianDot( a, b ) {\\n\\t\\treturn a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\\n\\t}\\n\\tfunction d3_geo_cartesianCross( a, b ) {\\n\\t\\treturn [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\\n\\t}\\n\\tfunction d3_geo_cartesianAdd( a, b ) {\\n\\t\\ta[0] += b[0];\\n\\t\\ta[1] += b[1];\\n\\t\\ta[2] += b[2];\\n\\t}\\n\\tfunction d3_geo_cartesianScale( vector, k ) {\\n\\t\\treturn [ vector[0] * k, vector[1] * k, vector[2] * k ];\\n\\t}\\n\\tfunction d3_geo_cartesianNormalize( d ) {\\n\\t\\tvar l = Math.sqrt( d[0] * d[0] + d[1] * d[1] + d[2] * d[2] );\\n\\t\\td[0] /= l;\\n\\t\\td[1] /= l;\\n\\t\\td[2] /= l;\\n\\t}\\n\\tfunction d3_geo_spherical( cartesian ) {\\n\\t\\treturn [ Math.atan2( cartesian[1], cartesian[0] ), d3_asin( cartesian[2] ) ];\\n\\t}\\n\\tfunction d3_geo_sphericalEqual( a, b ) {\\n\\t\\treturn abs( a[0] - b[0] ) <  && abs( a[1] - b[1] ) < ;\\n\\t}\\n\\td3.geo.bounds = function() {\\n\\t\\tvar 0, 0, 1, 1, _, __, __, p0, dSum, ranges, range;\\n\\t\\tvar bound = {\\n\\t\\t\\tpoint: point,\\n\\t\\t\\tlineStart: lineStart,\\n\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\tbound.point = ringPoint;\\n\\t\\t\\t\\tbound.lineStart = ringStart;\\n\\t\\t\\t\\tbound.lineEnd = ringEnd;\\n\\t\\t\\t\\tdSum = 0;\\n\\t\\t\\t\\td3_geo_area.polygonStart();\\n\\t\\t\\t},\\n\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\td3_geo_area.polygonEnd();\\n\\t\\t\\t\\tbound.point = point;\\n\\t\\t\\t\\tbound.lineStart = lineStart;\\n\\t\\t\\t\\tbound.lineEnd = lineEnd;\\n\\t\\t\\t\\tif ( d3_geo_areaRingSum < 0 ) 0 = -( 1 = 180 ), 0 = -( 1 = 90 ); else if ( dSum >  ) 1 = 90; else if ( dSum < - ) 0 = -90;\\n\\t\\t\\t\\trange[0] = 0, range[1] = 1;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tfunction point( ,  ) {\\n\\t\\t\\tranges.push( range = [ 0 = , 1 =  ] );\\n\\t\\t\\tif (  < 0 ) 0 = ;\\n\\t\\t\\tif (  > 1 ) 1 = ;\\n\\t\\t}\\n\\t\\tfunction linePoint( ,  ) {\\n\\t\\t\\tvar p = d3_geo_cartesian( [  * d3_radians,  * d3_radians ] );\\n\\t\\t\\tif ( p0 ) {\\n\\t\\t\\t\\tvar normal = d3_geo_cartesianCross( p0, p ), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross( equatorial, normal );\\n\\t\\t\\t\\td3_geo_cartesianNormalize( inflection );\\n\\t\\t\\t\\tinflection = d3_geo_spherical( inflection );\\n\\t\\t\\t\\tvar d =  - _, s = d > 0 ? 1 : -1, i = inflection[0] * d3_degrees * s, antimeridian = abs( d ) > 180;\\n\\t\\t\\t\\tif ( antimeridian ^ ( s * _ < i && i < s *  ) ) {\\n\\t\\t\\t\\t\\tvar i = inflection[1] * d3_degrees;\\n\\t\\t\\t\\t\\tif ( i > 1 ) 1 = i;\\n\\t\\t\\t\\t} else if ( i = ( i + 360 ) % 360 - 180, antimeridian ^ ( s * _ < i && i < s *  ) ) {\\n\\t\\t\\t\\t\\tvar i = -inflection[1] * d3_degrees;\\n\\t\\t\\t\\t\\tif ( i < 0 ) 0 = i;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif (  < 0 ) 0 = ;\\n\\t\\t\\t\\t\\tif (  > 1 ) 1 = ;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( antimeridian ) {\\n\\t\\t\\t\\t\\tif (  < _ ) {\\n\\t\\t\\t\\t\\t\\tif ( angle( 0,  ) > angle( 0, 1 ) ) 1 = ;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif ( angle( , 1 ) > angle( 0, 1 ) ) 0 = ;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( 1 >= 0 ) {\\n\\t\\t\\t\\t\\t\\tif (  < 0 ) 0 = ;\\n\\t\\t\\t\\t\\t\\tif (  > 1 ) 1 = ;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif (  > _ ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( angle( 0,  ) > angle( 0, 1 ) ) 1 = ;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif ( angle( , 1 ) > angle( 0, 1 ) ) 0 = ;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpoint( ,  );\\n\\t\\t\\t}\\n\\t\\t\\tp0 = p, _ = ;\\n\\t\\t}\\n\\t\\tfunction lineStart() {\\n\\t\\t\\tbound.point = linePoint;\\n\\t\\t}\\n\\t\\tfunction lineEnd() {\\n\\t\\t\\trange[0] = 0, range[1] = 1;\\n\\t\\t\\tbound.point = point;\\n\\t\\t\\tp0 = null;\\n\\t\\t}\\n\\t\\tfunction ringPoint( ,  ) {\\n\\t\\t\\tif ( p0 ) {\\n\\t\\t\\t\\tvar d =  - _;\\n\\t\\t\\t\\tdSum += abs( d ) > 180 ? d + ( d > 0 ? 360 : -360 ) : d;\\n\\t\\t\\t} else __ = , __ = ;\\n\\t\\t\\td3_geo_area.point( ,  );\\n\\t\\t\\tlinePoint( ,  );\\n\\t\\t}\\n\\t\\tfunction ringStart() {\\n\\t\\t\\td3_geo_area.lineStart();\\n\\t\\t}\\n\\t\\tfunction ringEnd() {\\n\\t\\t\\tringPoint( __, __ );\\n\\t\\t\\td3_geo_area.lineEnd();\\n\\t\\t\\tif ( abs( dSum ) >  ) 0 = -( 1 = 180 );\\n\\t\\t\\trange[0] = 0, range[1] = 1;\\n\\t\\t\\tp0 = null;\\n\\t\\t}\\n\\t\\tfunction angle( 0, 1 ) {\\n\\t\\t\\treturn ( 1 -= 0 ) < 0 ? 1 + 360 : 1;\\n\\t\\t}\\n\\t\\tfunction compareRanges( a, b ) {\\n\\t\\t\\treturn a[0] - b[0];\\n\\t\\t}\\n\\t\\tfunction withinRange( x, range ) {\\n\\t\\t\\treturn range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\\n\\t\\t}\\n\\t\\treturn function( feature ) {\\n\\t\\t\\t1 = 1 = -( 0 = 0 = Infinity );\\n\\t\\t\\tranges = [];\\n\\t\\t\\td3.geo.stream( feature, bound );\\n\\t\\t\\tvar n = ranges.length;\\n\\t\\t\\tif ( n ) {\\n\\t\\t\\t\\tranges.sort( compareRanges );\\n\\t\\t\\t\\tfor ( var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i ) {\\n\\t\\t\\t\\t\\tb = ranges[i];\\n\\t\\t\\t\\t\\tif ( withinRange( b[0], a ) || withinRange( b[1], a ) ) {\\n\\t\\t\\t\\t\\t\\tif ( angle( a[0], b[1] ) > angle( a[0], a[1] ) ) a[1] = b[1];\\n\\t\\t\\t\\t\\t\\tif ( angle( b[0], a[1] ) > angle( a[0], a[1] ) ) a[0] = b[0];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmerged.push( a = b );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar best = -Infinity, d;\\n\\t\\t\\t\\tfor ( var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i ) {\\n\\t\\t\\t\\t\\tb = merged[i];\\n\\t\\t\\t\\t\\tif ( ( d = angle( a[1], b[0] ) ) > best ) best = d, 0 = b[0], 1 = a[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tranges = range = null;\\n\\t\\t\\treturn 0 === Infinity || 0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ 0, 0 ], [ 1, 1 ] ];\\n\\t\\t};\\n\\t}();\\n\\td3.geo.centroid = function( object ) {\\n\\t\\td3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\\n\\t\\td3.geo.stream( object, d3_geo_centroid );\\n\\t\\tvar x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\\n\\t\\tif ( m < 2 ) {\\n\\t\\t\\tx = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\\n\\t\\t\\tif ( d3_geo_centroidW1 <  ) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\\n\\t\\t\\tm = x * x + y * y + z * z;\\n\\t\\t\\tif ( m < 2 ) return [ NaN, NaN ];\\n\\t\\t}\\n\\t\\treturn [ Math.atan2( y, x ) * d3_degrees, d3_asin( z / Math.sqrt( m ) ) * d3_degrees ];\\n\\t};\\n\\tvar d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\\n\\tvar d3_geo_centroid = {\\n\\t\\tsphere: d3_noop,\\n\\t\\tpoint: d3_geo_centroidPoint,\\n\\t\\tlineStart: d3_geo_centroidLineStart,\\n\\t\\tlineEnd: d3_geo_centroidLineEnd,\\n\\t\\tpolygonStart: function() {\\n\\t\\t\\td3_geo_centroid.lineStart = d3_geo_centroidRingStart;\\n\\t\\t},\\n\\t\\tpolygonEnd: function() {\\n\\t\\t\\td3_geo_centroid.lineStart = d3_geo_centroidLineStart;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_centroidPoint( ,  ) {\\n\\t\\t *= d3_radians;\\n\\t\\tvar cos = Math.cos(  *= d3_radians );\\n\\t\\td3_geo_centroidPointXYZ( cos * Math.cos(  ), cos * Math.sin(  ), Math.sin(  ) );\\n\\t}\\n\\tfunction d3_geo_centroidPointXYZ( x, y, z ) {\\n\\t\\t++d3_geo_centroidW0;\\n\\t\\td3_geo_centroidX0 += ( x - d3_geo_centroidX0 ) / d3_geo_centroidW0;\\n\\t\\td3_geo_centroidY0 += ( y - d3_geo_centroidY0 ) / d3_geo_centroidW0;\\n\\t\\td3_geo_centroidZ0 += ( z - d3_geo_centroidZ0 ) / d3_geo_centroidW0;\\n\\t}\\n\\tfunction d3_geo_centroidLineStart() {\\n\\t\\tvar x0, y0, z0;\\n\\t\\td3_geo_centroid.point = function( ,  ) {\\n\\t\\t\\t *= d3_radians;\\n\\t\\t\\tvar cos = Math.cos(  *= d3_radians );\\n\\t\\t\\tx0 = cos * Math.cos(  );\\n\\t\\t\\ty0 = cos * Math.sin(  );\\n\\t\\t\\tz0 = Math.sin(  );\\n\\t\\t\\td3_geo_centroid.point = nextPoint;\\n\\t\\t\\td3_geo_centroidPointXYZ( x0, y0, z0 );\\n\\t\\t};\\n\\t\\tfunction nextPoint( ,  ) {\\n\\t\\t\\t *= d3_radians;\\n\\t\\t\\tvar cos = Math.cos(  *= d3_radians ), x = cos * Math.cos(  ), y = cos * Math.sin(  ), z = Math.sin(  ), w = Math.atan2( Math.sqrt( ( w = y0 * z - z0 * y ) * w + ( w = z0 * x - x0 * z ) * w + ( w = x0 * y - y0 * x ) * w ), x0 * x + y0 * y + z0 * z );\\n\\t\\t\\td3_geo_centroidW1 += w;\\n\\t\\t\\td3_geo_centroidX1 += w * ( x0 + ( x0 = x ) );\\n\\t\\t\\td3_geo_centroidY1 += w * ( y0 + ( y0 = y ) );\\n\\t\\t\\td3_geo_centroidZ1 += w * ( z0 + ( z0 = z ) );\\n\\t\\t\\td3_geo_centroidPointXYZ( x0, y0, z0 );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_centroidLineEnd() {\\n\\t\\td3_geo_centroid.point = d3_geo_centroidPoint;\\n\\t}\\n\\tfunction d3_geo_centroidRingStart() {\\n\\t\\tvar 00, 00, x0, y0, z0;\\n\\t\\td3_geo_centroid.point = function( ,  ) {\\n\\t\\t\\t00 = , 00 = ;\\n\\t\\t\\td3_geo_centroid.point = nextPoint;\\n\\t\\t\\t *= d3_radians;\\n\\t\\t\\tvar cos = Math.cos(  *= d3_radians );\\n\\t\\t\\tx0 = cos * Math.cos(  );\\n\\t\\t\\ty0 = cos * Math.sin(  );\\n\\t\\t\\tz0 = Math.sin(  );\\n\\t\\t\\td3_geo_centroidPointXYZ( x0, y0, z0 );\\n\\t\\t};\\n\\t\\td3_geo_centroid.lineEnd = function() {\\n\\t\\t\\tnextPoint( 00, 00 );\\n\\t\\t\\td3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\\n\\t\\t\\td3_geo_centroid.point = d3_geo_centroidPoint;\\n\\t\\t};\\n\\t\\tfunction nextPoint( ,  ) {\\n\\t\\t\\t *= d3_radians;\\n\\t\\t\\tvar cos = Math.cos(  *= d3_radians ), x = cos * Math.cos(  ), y = cos * Math.sin(  ), z = Math.sin(  ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt( cx * cx + cy * cy + cz * cz ), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos( u ) / m, w = Math.atan2( m, u );\\n\\t\\t\\td3_geo_centroidX2 += v * cx;\\n\\t\\t\\td3_geo_centroidY2 += v * cy;\\n\\t\\t\\td3_geo_centroidZ2 += v * cz;\\n\\t\\t\\td3_geo_centroidW1 += w;\\n\\t\\t\\td3_geo_centroidX1 += w * ( x0 + ( x0 = x ) );\\n\\t\\t\\td3_geo_centroidY1 += w * ( y0 + ( y0 = y ) );\\n\\t\\t\\td3_geo_centroidZ1 += w * ( z0 + ( z0 = z ) );\\n\\t\\t\\td3_geo_centroidPointXYZ( x0, y0, z0 );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_compose( a, b ) {\\n\\t\\tfunction compose( x, y ) {\\n\\t\\t\\treturn x = a( x, y ), b( x[0], x[1] );\\n\\t\\t}\\n\\t\\tif ( a.invert && b.invert ) compose.invert = function( x, y ) {\\n\\t\\t\\treturn x = b.invert( x, y ), x && a.invert( x[0], x[1] );\\n\\t\\t};\\n\\t\\treturn compose;\\n\\t}\\n\\tfunction d3_true() {\\n\\t\\treturn true;\\n\\t}\\n\\tfunction d3_geo_clipPolygon( segments, compare, clipStartInside, interpolate, listener ) {\\n\\t\\tvar subject = [], clip = [];\\n\\t\\tsegments.forEach( function( segment ) {\\n\\t\\t\\tif ( ( n = segment.length - 1 ) <= 0 ) return;\\n\\t\\t\\tvar n, p0 = segment[0], p1 = segment[n];\\n\\t\\t\\tif ( d3_geo_sphericalEqual( p0, p1 ) ) {\\n\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\tfor ( var i = 0; i < n; ++i ) listener.point( ( p0 = segment[i] )[0], p0[1] );\\n\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tvar a = new d3_geo_clipPolygonIntersection( p0, segment, null, true ), b = new d3_geo_clipPolygonIntersection( p0, null, a, false );\\n\\t\\t\\ta.o = b;\\n\\t\\t\\tsubject.push( a );\\n\\t\\t\\tclip.push( b );\\n\\t\\t\\ta = new d3_geo_clipPolygonIntersection( p1, segment, null, false );\\n\\t\\t\\tb = new d3_geo_clipPolygonIntersection( p1, null, a, true );\\n\\t\\t\\ta.o = b;\\n\\t\\t\\tsubject.push( a );\\n\\t\\t\\tclip.push( b );\\n\\t\\t} );\\n\\t\\tclip.sort( compare );\\n\\t\\td3_geo_clipPolygonLinkCircular( subject );\\n\\t\\td3_geo_clipPolygonLinkCircular( clip );\\n\\t\\tif ( !subject.length ) return;\\n\\t\\tfor ( var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i ) {\\n\\t\\t\\tclip[i].e = entry = !entry;\\n\\t\\t}\\n\\t\\tvar start = subject[0], points, point;\\n\\t\\twhile ( 1 ) {\\n\\t\\t\\tvar current = start, isSubject = true;\\n\\t\\t\\twhile ( current.v ) if ( ( current = current.n ) === start ) return;\\n\\t\\t\\tpoints = current.z;\\n\\t\\t\\tlistener.lineStart();\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tcurrent.v = current.o.v = true;\\n\\t\\t\\t\\tif ( current.e ) {\\n\\t\\t\\t\\t\\tif ( isSubject ) {\\n\\t\\t\\t\\t\\t\\tfor ( var i = 0, n = points.length; i < n; ++i ) listener.point( ( point = points[i] )[0], point[1] );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tinterpolate( current.x, current.n.x, 1, listener );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurrent = current.n;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( isSubject ) {\\n\\t\\t\\t\\t\\t\\tpoints = current.p.z;\\n\\t\\t\\t\\t\\t\\tfor ( var i = points.length - 1; i >= 0; --i ) listener.point( ( point = points[i] )[0], point[1] );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tinterpolate( current.x, current.p.x, -1, listener );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tcurrent = current.p;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tcurrent = current.o;\\n\\t\\t\\t\\tpoints = current.z;\\n\\t\\t\\t\\tisSubject = !isSubject;\\n\\t\\t\\t} while ( !current.v );\\n\\t\\t\\tlistener.lineEnd();\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_clipPolygonLinkCircular( array ) {\\n\\t\\tif ( !( n = array.length ) ) return;\\n\\t\\tvar n, i = 0, a = array[0], b;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\ta.n = b = array[i];\\n\\t\\t\\tb.p = a;\\n\\t\\t\\ta = b;\\n\\t\\t}\\n\\t\\ta.n = b = array[0];\\n\\t\\tb.p = a;\\n\\t}\\n\\tfunction d3_geo_clipPolygonIntersection( point, points, other, entry ) {\\n\\t\\tthis.x = point;\\n\\t\\tthis.z = points;\\n\\t\\tthis.o = other;\\n\\t\\tthis.e = entry;\\n\\t\\tthis.v = false;\\n\\t\\tthis.n = this.p = null;\\n\\t}\\n\\tfunction d3_geo_clip( pointVisible, clipLine, interpolate, clipStart ) {\\n\\t\\treturn function( rotate, listener ) {\\n\\t\\t\\tvar line = clipLine( listener ), rotatedClipStart = rotate.invert( clipStart[0], clipStart[1] );\\n\\t\\t\\tvar clip = {\\n\\t\\t\\t\\tpoint: point,\\n\\t\\t\\t\\tlineStart: lineStart,\\n\\t\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\t\\tclip.point = pointRing;\\n\\t\\t\\t\\t\\tclip.lineStart = ringStart;\\n\\t\\t\\t\\t\\tclip.lineEnd = ringEnd;\\n\\t\\t\\t\\t\\tsegments = [];\\n\\t\\t\\t\\t\\tpolygon = [];\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\t\\tclip.point = point;\\n\\t\\t\\t\\t\\tclip.lineStart = lineStart;\\n\\t\\t\\t\\t\\tclip.lineEnd = lineEnd;\\n\\t\\t\\t\\t\\tsegments = d3.merge( segments );\\n\\t\\t\\t\\t\\tvar clipStartInside = d3_geo_pointInPolygon( rotatedClipStart, polygon );\\n\\t\\t\\t\\t\\tif ( segments.length ) {\\n\\t\\t\\t\\t\\t\\tif ( !polygonStarted ) listener.polygonStart(), polygonStarted = true;\\n\\t\\t\\t\\t\\t\\td3_geo_clipPolygon( segments, d3_geo_clipSort, clipStartInside, interpolate, listener );\\n\\t\\t\\t\\t\\t} else if ( clipStartInside ) {\\n\\t\\t\\t\\t\\t\\tif ( !polygonStarted ) listener.polygonStart(), polygonStarted = true;\\n\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\tinterpolate( null, null, 1, listener );\\n\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( polygonStarted ) listener.polygonEnd(), polygonStarted = false;\\n\\t\\t\\t\\t\\tsegments = polygon = null;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tsphere: function() {\\n\\t\\t\\t\\t\\tlistener.polygonStart();\\n\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\tinterpolate( null, null, 1, listener );\\n\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\tlistener.polygonEnd();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfunction point( ,  ) {\\n\\t\\t\\t\\tvar point = rotate( ,  );\\n\\t\\t\\t\\tif ( pointVisible(  = point[0],  = point[1] ) ) listener.point( ,  );\\n\\t\\t\\t}\\n\\t\\t\\tfunction pointLine( ,  ) {\\n\\t\\t\\t\\tvar point = rotate( ,  );\\n\\t\\t\\t\\tline.point( point[0], point[1] );\\n\\t\\t\\t}\\n\\t\\t\\tfunction lineStart() {\\n\\t\\t\\t\\tclip.point = pointLine;\\n\\t\\t\\t\\tline.lineStart();\\n\\t\\t\\t}\\n\\t\\t\\tfunction lineEnd() {\\n\\t\\t\\t\\tclip.point = point;\\n\\t\\t\\t\\tline.lineEnd();\\n\\t\\t\\t}\\n\\t\\t\\tvar segments;\\n\\t\\t\\tvar buffer = d3_geo_clipBufferListener(), ringListener = clipLine( buffer ), polygonStarted = false, polygon, ring;\\n\\t\\t\\tfunction pointRing( ,  ) {\\n\\t\\t\\t\\tring.push( [ ,  ] );\\n\\t\\t\\t\\tvar point = rotate( ,  );\\n\\t\\t\\t\\tringListener.point( point[0], point[1] );\\n\\t\\t\\t}\\n\\t\\t\\tfunction ringStart() {\\n\\t\\t\\t\\tringListener.lineStart();\\n\\t\\t\\t\\tring = [];\\n\\t\\t\\t}\\n\\t\\t\\tfunction ringEnd() {\\n\\t\\t\\t\\tpointRing( ring[0][0], ring[0][1] );\\n\\t\\t\\t\\tringListener.lineEnd();\\n\\t\\t\\t\\tvar clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\\n\\t\\t\\t\\tring.pop();\\n\\t\\t\\t\\tpolygon.push( ring );\\n\\t\\t\\t\\tring = null;\\n\\t\\t\\t\\tif ( !n ) return;\\n\\t\\t\\t\\tif ( clean & 1 ) {\\n\\t\\t\\t\\t\\tsegment = ringSegments[0];\\n\\t\\t\\t\\t\\tvar n = segment.length - 1, i = -1, point;\\n\\t\\t\\t\\t\\tif ( n > 0 ) {\\n\\t\\t\\t\\t\\t\\tif ( !polygonStarted ) listener.polygonStart(), polygonStarted = true;\\n\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\twhile ( ++i < n ) listener.point( ( point = segment[i] )[0], point[1] );\\n\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( n > 1 && clean & 2 ) ringSegments.push( ringSegments.pop().concat( ringSegments.shift() ) );\\n\\t\\t\\t\\tsegments.push( ringSegments.filter( d3_geo_clipSegmentLength1 ) );\\n\\t\\t\\t}\\n\\t\\t\\treturn clip;\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_clipSegmentLength1( segment ) {\\n\\t\\treturn segment.length > 1;\\n\\t}\\n\\tfunction d3_geo_clipBufferListener() {\\n\\t\\tvar lines = [], line;\\n\\t\\treturn {\\n\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\tlines.push( line = [] );\\n\\t\\t\\t},\\n\\t\\t\\tpoint: function( ,  ) {\\n\\t\\t\\t\\tline.push( [ ,  ] );\\n\\t\\t\\t},\\n\\t\\t\\tlineEnd: d3_noop,\\n\\t\\t\\tbuffer: function() {\\n\\t\\t\\t\\tvar buffer = lines;\\n\\t\\t\\t\\tlines = [];\\n\\t\\t\\t\\tline = null;\\n\\t\\t\\t\\treturn buffer;\\n\\t\\t\\t},\\n\\t\\t\\trejoin: function() {\\n\\t\\t\\t\\tif ( lines.length > 1 ) lines.push( lines.pop().concat( lines.shift() ) );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_clipSort( a, b ) {\\n\\t\\treturn ( ( a = a.x )[0] < 0 ? a[1] - half -  : half - a[1] ) - ( ( b = b.x )[0] < 0 ? b[1] - half -  : half - b[1] );\\n\\t}\\n\\tvar d3_geo_clipAntimeridian = d3_geo_clip( d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -, - / 2 ] );\\n\\tfunction d3_geo_clipAntimeridianLine( listener ) {\\n\\t\\tvar 0 = NaN, 0 = NaN, s0 = NaN, clean;\\n\\t\\treturn {\\n\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\tclean = 1;\\n\\t\\t\\t},\\n\\t\\t\\tpoint: function( 1, 1 ) {\\n\\t\\t\\t\\tvar s1 = 1 > 0 ?  : -, d = abs( 1 - 0 );\\n\\t\\t\\t\\tif ( abs( d -  ) <  ) {\\n\\t\\t\\t\\t\\tlistener.point( 0, 0 = ( 0 + 1 ) / 2 > 0 ? half : -half );\\n\\t\\t\\t\\t\\tlistener.point( s0, 0 );\\n\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\tlistener.point( s1, 0 );\\n\\t\\t\\t\\t\\tlistener.point( 1, 0 );\\n\\t\\t\\t\\t\\tclean = 0;\\n\\t\\t\\t\\t} else if ( s0 !== s1 && d >=  ) {\\n\\t\\t\\t\\t\\tif ( abs( 0 - s0 ) <  ) 0 -= s0 * ;\\n\\t\\t\\t\\t\\tif ( abs( 1 - s1 ) <  ) 1 -= s1 * ;\\n\\t\\t\\t\\t\\t0 = d3_geo_clipAntimeridianIntersect( 0, 0, 1, 1 );\\n\\t\\t\\t\\t\\tlistener.point( s0, 0 );\\n\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\tlistener.point( s1, 0 );\\n\\t\\t\\t\\t\\tclean = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlistener.point( 0 = 1, 0 = 1 );\\n\\t\\t\\t\\ts0 = s1;\\n\\t\\t\\t},\\n\\t\\t\\tlineEnd: function() {\\n\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t0 = 0 = NaN;\\n\\t\\t\\t},\\n\\t\\t\\tclean: function() {\\n\\t\\t\\t\\treturn 2 - clean;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_clipAntimeridianIntersect( 0, 0, 1, 1 ) {\\n\\t\\tvar cos0, cos1, sin0_1 = Math.sin( 0 - 1 );\\n\\t\\treturn abs( sin0_1 ) >  ? Math.atan( ( Math.sin( 0 ) * ( cos1 = Math.cos( 1 ) ) * Math.sin( 1 ) - Math.sin( 1 ) * ( cos0 = Math.cos( 0 ) ) * Math.sin( 0 ) ) / ( cos0 * cos1 * sin0_1 ) ) : ( 0 + 1 ) / 2;\\n\\t}\\n\\tfunction d3_geo_clipAntimeridianInterpolate( from, to, direction, listener ) {\\n\\t\\tvar ;\\n\\t\\tif ( from == null ) {\\n\\t\\t\\t = direction * half;\\n\\t\\t\\tlistener.point( -,  );\\n\\t\\t\\tlistener.point( 0,  );\\n\\t\\t\\tlistener.point( ,  );\\n\\t\\t\\tlistener.point( , 0 );\\n\\t\\t\\tlistener.point( , - );\\n\\t\\t\\tlistener.point( 0, - );\\n\\t\\t\\tlistener.point( -, - );\\n\\t\\t\\tlistener.point( -, 0 );\\n\\t\\t\\tlistener.point( -,  );\\n\\t\\t} else if ( abs( from[0] - to[0] ) >  ) {\\n\\t\\t\\tvar s = from[0] < to[0] ?  : -;\\n\\t\\t\\t = direction * s / 2;\\n\\t\\t\\tlistener.point( -s,  );\\n\\t\\t\\tlistener.point( 0,  );\\n\\t\\t\\tlistener.point( s,  );\\n\\t\\t} else {\\n\\t\\t\\tlistener.point( to[0], to[1] );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_pointInPolygon( point, polygon ) {\\n\\t\\tvar meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin( meridian ), -Math.cos( meridian ), 0 ], polarAngle = 0, winding = 0;\\n\\t\\td3_geo_areaRingSum.reset();\\n\\t\\tfor ( var i = 0, n = polygon.length; i < n; ++i ) {\\n\\t\\t\\tvar ring = polygon[i], m = ring.length;\\n\\t\\t\\tif ( !m ) continue;\\n\\t\\t\\tvar point0 = ring[0], 0 = point0[0], 0 = point0[1] / 2 +  / 4, sin0 = Math.sin( 0 ), cos0 = Math.cos( 0 ), j = 1;\\n\\t\\t\\twhile ( true ) {\\n\\t\\t\\t\\tif ( j === m ) j = 0;\\n\\t\\t\\t\\tpoint = ring[j];\\n\\t\\t\\t\\tvar  = point[0],  = point[1] / 2 +  / 4, sin = Math.sin(  ), cos = Math.cos(  ), d =  - 0, sd = d >= 0 ? 1 : -1, ad = sd * d, antimeridian = ad > , k = sin0 * sin;\\n\\t\\t\\t\\td3_geo_areaRingSum.add( Math.atan2( k * sd * Math.sin( ad ), cos0 * cos + k * Math.cos( ad ) ) );\\n\\t\\t\\t\\tpolarAngle += antimeridian ? d + sd *  : d;\\n\\t\\t\\t\\tif ( antimeridian ^ 0 >= meridian ^  >= meridian ) {\\n\\t\\t\\t\\t\\tvar arc = d3_geo_cartesianCross( d3_geo_cartesian( point0 ), d3_geo_cartesian( point ) );\\n\\t\\t\\t\\t\\td3_geo_cartesianNormalize( arc );\\n\\t\\t\\t\\t\\tvar intersection = d3_geo_cartesianCross( meridianNormal, arc );\\n\\t\\t\\t\\t\\td3_geo_cartesianNormalize( intersection );\\n\\t\\t\\t\\t\\tvar arc = ( antimeridian ^ d >= 0 ? -1 : 1 ) * d3_asin( intersection[2] );\\n\\t\\t\\t\\t\\tif ( parallel > arc || parallel === arc && ( arc[0] || arc[1] ) ) {\\n\\t\\t\\t\\t\\t\\twinding += antimeridian ^ d >= 0 ? 1 : -1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !j++ ) break;\\n\\t\\t\\t\\t0 = , sin0 = sin, cos0 = cos, point0 = point;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ( polarAngle < - || polarAngle <  && d3_geo_areaRingSum < 0 ) ^ winding & 1;\\n\\t}\\n\\tfunction d3_geo_clipCircle( radius ) {\\n\\t\\tvar cr = Math.cos( radius ), smallRadius = cr > 0, notHemisphere = abs( cr ) > , interpolate = d3_geo_circleInterpolate( radius, 6 * d3_radians );\\n\\t\\treturn d3_geo_clip( visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -, radius -  ] );\\n\\t\\tfunction visible( ,  ) {\\n\\t\\t\\treturn Math.cos(  ) * Math.cos(  ) > cr;\\n\\t\\t}\\n\\t\\tfunction clipLine( listener ) {\\n\\t\\t\\tvar point0, c0, v0, v00, clean;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\t\\tv00 = v0 = false;\\n\\t\\t\\t\\t\\tclean = 1;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpoint: function( ,  ) {\\n\\t\\t\\t\\t\\tvar point1 = [ ,  ], point2, v = visible( ,  ), c = smallRadius ? v ? 0 : code( ,  ) : v ? code(  + (  < 0 ?  : - ),  ) : 0;\\n\\t\\t\\t\\t\\tif ( !point0 && ( v00 = v0 = v ) ) listener.lineStart();\\n\\t\\t\\t\\t\\tif ( v !== v0 ) {\\n\\t\\t\\t\\t\\t\\tpoint2 = intersect( point0, point1 );\\n\\t\\t\\t\\t\\t\\tif ( d3_geo_sphericalEqual( point0, point2 ) || d3_geo_sphericalEqual( point1, point2 ) ) {\\n\\t\\t\\t\\t\\t\\t\\tpoint1[0] += ;\\n\\t\\t\\t\\t\\t\\t\\tpoint1[1] += ;\\n\\t\\t\\t\\t\\t\\t\\tv = visible( point1[0], point1[1] );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( v !== v0 ) {\\n\\t\\t\\t\\t\\t\\tclean = 0;\\n\\t\\t\\t\\t\\t\\tif ( v ) {\\n\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\tpoint2 = intersect( point1, point0 );\\n\\t\\t\\t\\t\\t\\t\\tlistener.point( point2[0], point2[1] );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tpoint2 = intersect( point0, point1 );\\n\\t\\t\\t\\t\\t\\t\\tlistener.point( point2[0], point2[1] );\\n\\t\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tpoint0 = point2;\\n\\t\\t\\t\\t\\t} else if ( notHemisphere && point0 && smallRadius ^ v ) {\\n\\t\\t\\t\\t\\t\\tvar t;\\n\\t\\t\\t\\t\\t\\tif ( !( c & c0 ) && ( t = intersect( point1, point0, true ) ) ) {\\n\\t\\t\\t\\t\\t\\t\\tclean = 0;\\n\\t\\t\\t\\t\\t\\t\\tif ( smallRadius ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.point( t[0][0], t[0][1] );\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.point( t[1][0], t[1][1] );\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.point( t[1][0], t[1][1] );\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.point( t[0][0], t[0][1] );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( v && ( !point0 || !d3_geo_sphericalEqual( point0, point1 ) ) ) {\\n\\t\\t\\t\\t\\t\\tlistener.point( point1[0], point1[1] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tpoint0 = point1, v0 = v, c0 = c;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlineEnd: function() {\\n\\t\\t\\t\\t\\tif ( v0 ) listener.lineEnd();\\n\\t\\t\\t\\t\\tpoint0 = null;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tclean: function() {\\n\\t\\t\\t\\t\\treturn clean | ( v00 && v0 ) << 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfunction intersect( a, b, two ) {\\n\\t\\t\\tvar pa = d3_geo_cartesian( a ), pb = d3_geo_cartesian( b );\\n\\t\\t\\tvar n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross( pa, pb ), n2n2 = d3_geo_cartesianDot( n2, n2 ), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\\n\\t\\t\\tif ( !determinant ) return !two && a;\\n\\t\\t\\tvar c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross( n1, n2 ), A = d3_geo_cartesianScale( n1, c1 ), B = d3_geo_cartesianScale( n2, c2 );\\n\\t\\t\\td3_geo_cartesianAdd( A, B );\\n\\t\\t\\tvar u = n1xn2, w = d3_geo_cartesianDot( A, u ), uu = d3_geo_cartesianDot( u, u ), t2 = w * w - uu * ( d3_geo_cartesianDot( A, A ) - 1 );\\n\\t\\t\\tif ( t2 < 0 ) return;\\n\\t\\t\\tvar t = Math.sqrt( t2 ), q = d3_geo_cartesianScale( u, ( -w - t ) / uu );\\n\\t\\t\\td3_geo_cartesianAdd( q, A );\\n\\t\\t\\tq = d3_geo_spherical( q );\\n\\t\\t\\tif ( !two ) return q;\\n\\t\\t\\tvar 0 = a[0], 1 = b[0], 0 = a[1], 1 = b[1], z;\\n\\t\\t\\tif ( 1 < 0 ) z = 0, 0 = 1, 1 = z;\\n\\t\\t\\tvar  = 1 - 0, polar = abs(  -  ) < , meridian = polar ||  < ;\\n\\t\\t\\tif ( !polar && 1 < 0 ) z = 0, 0 = 1, 1 = z;\\n\\t\\t\\tif ( meridian ? polar ? 0 + 1 > 0 ^ q[1] < ( abs( q[0] - 0 ) <  ? 0 : 1 ) : 0 <= q[1] && q[1] <= 1 :  >  ^ ( 0 <= q[0] && q[0] <= 1 ) ) {\\n\\t\\t\\t\\tvar q1 = d3_geo_cartesianScale( u, ( -w + t ) / uu );\\n\\t\\t\\t\\td3_geo_cartesianAdd( q1, A );\\n\\t\\t\\t\\treturn [ q, d3_geo_spherical( q1 ) ];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction code( ,  ) {\\n\\t\\t\\tvar r = smallRadius ? radius :  - radius, code = 0;\\n\\t\\t\\tif (  < -r ) code |= 1; else if (  > r ) code |= 2;\\n\\t\\t\\tif (  < -r ) code |= 4; else if (  > r ) code |= 8;\\n\\t\\t\\treturn code;\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_clipLine( x0, y0, x1, y1 ) {\\n\\t\\treturn function( line ) {\\n\\t\\t\\tvar a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\\n\\t\\t\\tr = x0 - ax;\\n\\t\\t\\tif ( !dx && r > 0 ) return;\\n\\t\\t\\tr /= dx;\\n\\t\\t\\tif ( dx < 0 ) {\\n\\t\\t\\t\\tif ( r < t0 ) return;\\n\\t\\t\\t\\tif ( r < t1 ) t1 = r;\\n\\t\\t\\t} else if ( dx > 0 ) {\\n\\t\\t\\t\\tif ( r > t1 ) return;\\n\\t\\t\\t\\tif ( r > t0 ) t0 = r;\\n\\t\\t\\t}\\n\\t\\t\\tr = x1 - ax;\\n\\t\\t\\tif ( !dx && r < 0 ) return;\\n\\t\\t\\tr /= dx;\\n\\t\\t\\tif ( dx < 0 ) {\\n\\t\\t\\t\\tif ( r > t1 ) return;\\n\\t\\t\\t\\tif ( r > t0 ) t0 = r;\\n\\t\\t\\t} else if ( dx > 0 ) {\\n\\t\\t\\t\\tif ( r < t0 ) return;\\n\\t\\t\\t\\tif ( r < t1 ) t1 = r;\\n\\t\\t\\t}\\n\\t\\t\\tr = y0 - ay;\\n\\t\\t\\tif ( !dy && r > 0 ) return;\\n\\t\\t\\tr /= dy;\\n\\t\\t\\tif ( dy < 0 ) {\\n\\t\\t\\t\\tif ( r < t0 ) return;\\n\\t\\t\\t\\tif ( r < t1 ) t1 = r;\\n\\t\\t\\t} else if ( dy > 0 ) {\\n\\t\\t\\t\\tif ( r > t1 ) return;\\n\\t\\t\\t\\tif ( r > t0 ) t0 = r;\\n\\t\\t\\t}\\n\\t\\t\\tr = y1 - ay;\\n\\t\\t\\tif ( !dy && r < 0 ) return;\\n\\t\\t\\tr /= dy;\\n\\t\\t\\tif ( dy < 0 ) {\\n\\t\\t\\t\\tif ( r > t1 ) return;\\n\\t\\t\\t\\tif ( r > t0 ) t0 = r;\\n\\t\\t\\t} else if ( dy > 0 ) {\\n\\t\\t\\t\\tif ( r < t0 ) return;\\n\\t\\t\\t\\tif ( r < t1 ) t1 = r;\\n\\t\\t\\t}\\n\\t\\t\\tif ( t0 > 0 ) line.a = {\\n\\t\\t\\t\\tx: ax + t0 * dx,\\n\\t\\t\\t\\ty: ay + t0 * dy\\n\\t\\t\\t};\\n\\t\\t\\tif ( t1 < 1 ) line.b = {\\n\\t\\t\\t\\tx: ax + t1 * dx,\\n\\t\\t\\t\\ty: ay + t1 * dy\\n\\t\\t\\t};\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t}\\n\\tvar d3_geo_clipExtentMAX = 1e9;\\n\\td3.geo.clipExtent = function() {\\n\\t\\tvar x0, y0, x1, y1, stream, clip, clipExtent = {\\n\\t\\t\\tstream: function( output ) {\\n\\t\\t\\t\\tif ( stream ) stream.valid = false;\\n\\t\\t\\t\\tstream = clip( output );\\n\\t\\t\\t\\tstream.valid = true;\\n\\t\\t\\t\\treturn stream;\\n\\t\\t\\t},\\n\\t\\t\\textent: function( _ ) {\\n\\t\\t\\t\\tif ( !arguments.length ) return [ [ x0, y0 ], [ x1, y1 ] ];\\n\\t\\t\\t\\tclip = d3_geo_clipExtent( x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1] );\\n\\t\\t\\t\\tif ( stream ) stream.valid = false, stream = null;\\n\\t\\t\\t\\treturn clipExtent;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\treturn clipExtent.extent( [ [ 0, 0 ], [ 960, 500 ] ] );\\n\\t};\\n\\tfunction d3_geo_clipExtent( x0, y0, x1, y1 ) {\\n\\t\\treturn function( listener ) {\\n\\t\\t\\tvar listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine( x0, y0, x1, y1 ), segments, polygon, ring;\\n\\t\\t\\tvar clip = {\\n\\t\\t\\t\\tpoint: point,\\n\\t\\t\\t\\tlineStart: lineStart,\\n\\t\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\t\\tlistener = bufferListener;\\n\\t\\t\\t\\t\\tsegments = [];\\n\\t\\t\\t\\t\\tpolygon = [];\\n\\t\\t\\t\\t\\tclean = true;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\t\\tlistener = listener_;\\n\\t\\t\\t\\t\\tsegments = d3.merge( segments );\\n\\t\\t\\t\\t\\tvar clipStartInside = insidePolygon( [ x0, y1 ] ), inside = clean && clipStartInside, visible = segments.length;\\n\\t\\t\\t\\t\\tif ( inside || visible ) {\\n\\t\\t\\t\\t\\t\\tlistener.polygonStart();\\n\\t\\t\\t\\t\\t\\tif ( inside ) {\\n\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\tinterpolate( null, null, 1, listener );\\n\\t\\t\\t\\t\\t\\t\\tlistener.lineEnd();\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tif ( visible ) {\\n\\t\\t\\t\\t\\t\\t\\td3_geo_clipPolygon( segments, compare, clipStartInside, interpolate, listener );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tlistener.polygonEnd();\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsegments = polygon = ring = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfunction insidePolygon( p ) {\\n\\t\\t\\t\\tvar wn = 0, n = polygon.length, y = p[1];\\n\\t\\t\\t\\tfor ( var i = 0; i < n; ++i ) {\\n\\t\\t\\t\\t\\tfor ( var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j ) {\\n\\t\\t\\t\\t\\t\\tb = v[j];\\n\\t\\t\\t\\t\\t\\tif ( a[1] <= y ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( b[1] > y && d3_cross2d( a, b, p ) > 0 ) ++wn;\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tif ( b[1] <= y && d3_cross2d( a, b, p ) < 0 ) --wn;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\ta = b;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn wn !== 0;\\n\\t\\t\\t}\\n\\t\\t\\tfunction interpolate( from, to, direction, listener ) {\\n\\t\\t\\t\\tvar a = 0, a1 = 0;\\n\\t\\t\\t\\tif ( from == null || ( a = corner( from, direction ) ) !== ( a1 = corner( to, direction ) ) || comparePoints( from, to ) < 0 ^ direction > 0 ) {\\n\\t\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\t\\tlistener.point( a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0 );\\n\\t\\t\\t\\t\\t} while ( ( a = ( a + direction + 4 ) % 4 ) !== a1 );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tlistener.point( to[0], to[1] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction pointVisible( x, y ) {\\n\\t\\t\\t\\treturn x0 <= x && x <= x1 && y0 <= y && y <= y1;\\n\\t\\t\\t}\\n\\t\\t\\tfunction point( x, y ) {\\n\\t\\t\\t\\tif ( pointVisible( x, y ) ) listener.point( x, y );\\n\\t\\t\\t}\\n\\t\\t\\tvar x__, y__, v__, x_, y_, v_, first, clean;\\n\\t\\t\\tfunction lineStart() {\\n\\t\\t\\t\\tclip.point = linePoint;\\n\\t\\t\\t\\tif ( polygon ) polygon.push( ring = [] );\\n\\t\\t\\t\\tfirst = true;\\n\\t\\t\\t\\tv_ = false;\\n\\t\\t\\t\\tx_ = y_ = NaN;\\n\\t\\t\\t}\\n\\t\\t\\tfunction lineEnd() {\\n\\t\\t\\t\\tif ( segments ) {\\n\\t\\t\\t\\t\\tlinePoint( x__, y__ );\\n\\t\\t\\t\\t\\tif ( v__ && v_ ) bufferListener.rejoin();\\n\\t\\t\\t\\t\\tsegments.push( bufferListener.buffer() );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tclip.point = point;\\n\\t\\t\\t\\tif ( v_ ) listener.lineEnd();\\n\\t\\t\\t}\\n\\t\\t\\tfunction linePoint( x, y ) {\\n\\t\\t\\t\\tx = Math.max( -d3_geo_clipExtentMAX, Math.min( d3_geo_clipExtentMAX, x ) );\\n\\t\\t\\t\\ty = Math.max( -d3_geo_clipExtentMAX, Math.min( d3_geo_clipExtentMAX, y ) );\\n\\t\\t\\t\\tvar v = pointVisible( x, y );\\n\\t\\t\\t\\tif ( polygon ) ring.push( [ x, y ] );\\n\\t\\t\\t\\tif ( first ) {\\n\\t\\t\\t\\t\\tx__ = x, y__ = y, v__ = v;\\n\\t\\t\\t\\t\\tfirst = false;\\n\\t\\t\\t\\t\\tif ( v ) {\\n\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\tlistener.point( x, y );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( v && v_ ) listener.point( x, y ); else {\\n\\t\\t\\t\\t\\t\\tvar l = {\\n\\t\\t\\t\\t\\t\\t\\ta: {\\n\\t\\t\\t\\t\\t\\t\\t\\tx: x_,\\n\\t\\t\\t\\t\\t\\t\\t\\ty: y_\\n\\t\\t\\t\\t\\t\\t\\t},\\n\\t\\t\\t\\t\\t\\t\\tb: {\\n\\t\\t\\t\\t\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\t\\t\\t\\t\\ty: y\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t\\tif ( clipLine( l ) ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( !v_ ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\t\\tlistener.point( l.a.x, l.a.y );\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlistener.point( l.b.x, l.b.y );\\n\\t\\t\\t\\t\\t\\t\\tif ( !v ) listener.lineEnd();\\n\\t\\t\\t\\t\\t\\t\\tclean = false;\\n\\t\\t\\t\\t\\t\\t} else if ( v ) {\\n\\t\\t\\t\\t\\t\\t\\tlistener.lineStart();\\n\\t\\t\\t\\t\\t\\t\\tlistener.point( x, y );\\n\\t\\t\\t\\t\\t\\t\\tclean = false;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tx_ = x, y_ = y, v_ = v;\\n\\t\\t\\t}\\n\\t\\t\\treturn clip;\\n\\t\\t};\\n\\t\\tfunction corner( p, direction ) {\\n\\t\\t\\treturn abs( p[0] - x0 ) <  ? direction > 0 ? 0 : 3 : abs( p[0] - x1 ) <  ? direction > 0 ? 2 : 1 : abs( p[1] - y0 ) <  ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\\n\\t\\t}\\n\\t\\tfunction compare( a, b ) {\\n\\t\\t\\treturn comparePoints( a.x, b.x );\\n\\t\\t}\\n\\t\\tfunction comparePoints( a, b ) {\\n\\t\\t\\tvar ca = corner( a, 1 ), cb = corner( b, 1 );\\n\\t\\t\\treturn ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_conic( projectAt ) {\\n\\t\\tvar 0 = 0, 1 =  / 3, m = d3_geo_projectionMutator( projectAt ), p = m( 0, 1 );\\n\\t\\tp.parallels = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ 0 /  * 180, 1 /  * 180 ];\\n\\t\\t\\treturn m( 0 = _[0] *  / 180, 1 = _[1] *  / 180 );\\n\\t\\t};\\n\\t\\treturn p;\\n\\t}\\n\\tfunction d3_geo_conicEqualArea( 0, 1 ) {\\n\\t\\tvar sin0 = Math.sin( 0 ), n = ( sin0 + Math.sin( 1 ) ) / 2, C = 1 + sin0 * ( 2 * n - sin0 ), 0 = Math.sqrt( C ) / n;\\n\\t\\tfunction forward( ,  ) {\\n\\t\\t\\tvar  = Math.sqrt( C - 2 * n * Math.sin(  ) ) / n;\\n\\t\\t\\treturn [  * Math.sin(  *= n ), 0 -  * Math.cos(  ) ];\\n\\t\\t}\\n\\t\\tforward.invert = function( x, y ) {\\n\\t\\t\\tvar 0_y = 0 - y;\\n\\t\\t\\treturn [ Math.atan2( x, 0_y ) / n, d3_asin( ( C - ( x * x + 0_y * 0_y ) * n * n ) / ( 2 * n ) ) ];\\n\\t\\t};\\n\\t\\treturn forward;\\n\\t}\\n\\t( d3.geo.conicEqualArea = function() {\\n\\t\\treturn d3_geo_conic( d3_geo_conicEqualArea );\\n\\t} ).raw = d3_geo_conicEqualArea;\\n\\td3.geo.albers = function() {\\n\\t\\treturn d3.geo.conicEqualArea().rotate( [ 96, 0 ] ).center( [ -.6, 38.7 ] ).parallels( [ 29.5, 45.5 ] ).scale( 1070 );\\n\\t};\\n\\td3.geo.albersUsa = function() {\\n\\t\\tvar lower48 = d3.geo.albers();\\n\\t\\tvar alaska = d3.geo.conicEqualArea().rotate( [ 154, 0 ] ).center( [ -2, 58.5 ] ).parallels( [ 55, 65 ] );\\n\\t\\tvar hawaii = d3.geo.conicEqualArea().rotate( [ 157, 0 ] ).center( [ -3, 19.9 ] ).parallels( [ 8, 18 ] );\\n\\t\\tvar point, pointStream = {\\n\\t\\t\\t\\tpoint: function( x, y ) {\\n\\t\\t\\t\\t\\tpoint = [ x, y ];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}, lower48Point, alaskaPoint, hawaiiPoint;\\n\\t\\tfunction albersUsa( coordinates ) {\\n\\t\\t\\tvar x = coordinates[0], y = coordinates[1];\\n\\t\\t\\tpoint = null;\\n\\t\\t\\t( lower48Point( x, y ), point ) || ( alaskaPoint( x, y ), point ) || hawaiiPoint( x, y );\\n\\t\\t\\treturn point;\\n\\t\\t}\\n\\t\\talbersUsa.invert = function( coordinates ) {\\n\\t\\t\\tvar k = lower48.scale(), t = lower48.translate(), x = ( coordinates[0] - t[0] ) / k, y = ( coordinates[1] - t[1] ) / k;\\n\\t\\t\\treturn ( y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48 ).invert( coordinates );\\n\\t\\t};\\n\\t\\talbersUsa.stream = function( stream ) {\\n\\t\\t\\tvar lower48Stream = lower48.stream( stream ), alaskaStream = alaska.stream( stream ), hawaiiStream = hawaii.stream( stream );\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tpoint: function( x, y ) {\\n\\t\\t\\t\\t\\tlower48Stream.point( x, y );\\n\\t\\t\\t\\t\\talaskaStream.point( x, y );\\n\\t\\t\\t\\t\\thawaiiStream.point( x, y );\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tsphere: function() {\\n\\t\\t\\t\\t\\tlower48Stream.sphere();\\n\\t\\t\\t\\t\\talaskaStream.sphere();\\n\\t\\t\\t\\t\\thawaiiStream.sphere();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\t\\tlower48Stream.lineStart();\\n\\t\\t\\t\\t\\talaskaStream.lineStart();\\n\\t\\t\\t\\t\\thawaiiStream.lineStart();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tlineEnd: function() {\\n\\t\\t\\t\\t\\tlower48Stream.lineEnd();\\n\\t\\t\\t\\t\\talaskaStream.lineEnd();\\n\\t\\t\\t\\t\\thawaiiStream.lineEnd();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\t\\tlower48Stream.polygonStart();\\n\\t\\t\\t\\t\\talaskaStream.polygonStart();\\n\\t\\t\\t\\t\\thawaiiStream.polygonStart();\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\t\\tlower48Stream.polygonEnd();\\n\\t\\t\\t\\t\\talaskaStream.polygonEnd();\\n\\t\\t\\t\\t\\thawaiiStream.polygonEnd();\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\talbersUsa.precision = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return lower48.precision();\\n\\t\\t\\tlower48.precision( _ );\\n\\t\\t\\talaska.precision( _ );\\n\\t\\t\\thawaii.precision( _ );\\n\\t\\t\\treturn albersUsa;\\n\\t\\t};\\n\\t\\talbersUsa.scale = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return lower48.scale();\\n\\t\\t\\tlower48.scale( _ );\\n\\t\\t\\talaska.scale( _ * .35 );\\n\\t\\t\\thawaii.scale( _ );\\n\\t\\t\\treturn albersUsa.translate( lower48.translate() );\\n\\t\\t};\\n\\t\\talbersUsa.translate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return lower48.translate();\\n\\t\\t\\tvar k = lower48.scale(), x = +_[0], y = +_[1];\\n\\t\\t\\tlower48Point = lower48.translate( _ ).clipExtent( [ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ] ).stream( pointStream ).point;\\n\\t\\t\\talaskaPoint = alaska.translate( [ x - .307 * k, y + .201 * k ] ).clipExtent( [ [ x - .425 * k + , y + .12 * k +  ], [ x - .214 * k - , y + .234 * k -  ] ] ).stream( pointStream ).point;\\n\\t\\t\\thawaiiPoint = hawaii.translate( [ x - .205 * k, y + .212 * k ] ).clipExtent( [ [ x - .214 * k + , y + .166 * k +  ], [ x - .115 * k - , y + .234 * k -  ] ] ).stream( pointStream ).point;\\n\\t\\t\\treturn albersUsa;\\n\\t\\t};\\n\\t\\treturn albersUsa.scale( 1070 );\\n\\t};\\n\\tvar d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\\n\\t\\tpoint: d3_noop,\\n\\t\\tlineStart: d3_noop,\\n\\t\\tlineEnd: d3_noop,\\n\\t\\tpolygonStart: function() {\\n\\t\\t\\td3_geo_pathAreaPolygon = 0;\\n\\t\\t\\td3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\\n\\t\\t},\\n\\t\\tpolygonEnd: function() {\\n\\t\\t\\td3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\\n\\t\\t\\td3_geo_pathAreaSum += abs( d3_geo_pathAreaPolygon / 2 );\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_pathAreaRingStart() {\\n\\t\\tvar x00, y00, x0, y0;\\n\\t\\td3_geo_pathArea.point = function( x, y ) {\\n\\t\\t\\td3_geo_pathArea.point = nextPoint;\\n\\t\\t\\tx00 = x0 = x, y00 = y0 = y;\\n\\t\\t};\\n\\t\\tfunction nextPoint( x, y ) {\\n\\t\\t\\td3_geo_pathAreaPolygon += y0 * x - x0 * y;\\n\\t\\t\\tx0 = x, y0 = y;\\n\\t\\t}\\n\\t\\td3_geo_pathArea.lineEnd = function() {\\n\\t\\t\\tnextPoint( x00, y00 );\\n\\t\\t};\\n\\t}\\n\\tvar d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\\n\\tvar d3_geo_pathBounds = {\\n\\t\\tpoint: d3_geo_pathBoundsPoint,\\n\\t\\tlineStart: d3_noop,\\n\\t\\tlineEnd: d3_noop,\\n\\t\\tpolygonStart: d3_noop,\\n\\t\\tpolygonEnd: d3_noop\\n\\t};\\n\\tfunction d3_geo_pathBoundsPoint( x, y ) {\\n\\t\\tif ( x < d3_geo_pathBoundsX0 ) d3_geo_pathBoundsX0 = x;\\n\\t\\tif ( x > d3_geo_pathBoundsX1 ) d3_geo_pathBoundsX1 = x;\\n\\t\\tif ( y < d3_geo_pathBoundsY0 ) d3_geo_pathBoundsY0 = y;\\n\\t\\tif ( y > d3_geo_pathBoundsY1 ) d3_geo_pathBoundsY1 = y;\\n\\t}\\n\\tfunction d3_geo_pathBuffer() {\\n\\t\\tvar pointCircle = d3_geo_pathBufferCircle( 4.5 ), buffer = [];\\n\\t\\tvar stream = {\\n\\t\\t\\tpoint: point,\\n\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\tstream.point = pointLineStart;\\n\\t\\t\\t},\\n\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\tstream.lineEnd = lineEndPolygon;\\n\\t\\t\\t},\\n\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\tstream.lineEnd = lineEnd;\\n\\t\\t\\t\\tstream.point = point;\\n\\t\\t\\t},\\n\\t\\t\\tpointRadius: function( _ ) {\\n\\t\\t\\t\\tpointCircle = d3_geo_pathBufferCircle( _ );\\n\\t\\t\\t\\treturn stream;\\n\\t\\t\\t},\\n\\t\\t\\tresult: function() {\\n\\t\\t\\t\\tif ( buffer.length ) {\\n\\t\\t\\t\\t\\tvar result = buffer.join( \\\"\\\" );\\n\\t\\t\\t\\t\\tbuffer = [];\\n\\t\\t\\t\\t\\treturn result;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tfunction point( x, y ) {\\n\\t\\t\\tbuffer.push( \\\"M\\\", x, \\\",\\\", y, pointCircle );\\n\\t\\t}\\n\\t\\tfunction pointLineStart( x, y ) {\\n\\t\\t\\tbuffer.push( \\\"M\\\", x, \\\",\\\", y );\\n\\t\\t\\tstream.point = pointLine;\\n\\t\\t}\\n\\t\\tfunction pointLine( x, y ) {\\n\\t\\t\\tbuffer.push( \\\"L\\\", x, \\\",\\\", y );\\n\\t\\t}\\n\\t\\tfunction lineEnd() {\\n\\t\\t\\tstream.point = point;\\n\\t\\t}\\n\\t\\tfunction lineEndPolygon() {\\n\\t\\t\\tbuffer.push( \\\"Z\\\" );\\n\\t\\t}\\n\\t\\treturn stream;\\n\\t}\\n\\tfunction d3_geo_pathBufferCircle( radius ) {\\n\\t\\treturn \\\"m0,\\\" + radius + \\\"a\\\" + radius + \\\",\\\" + radius + \\\" 0 1,1 0,\\\" + -2 * radius + \\\"a\\\" + radius + \\\",\\\" + radius + \\\" 0 1,1 0,\\\" + 2 * radius + \\\"z\\\";\\n\\t}\\n\\tvar d3_geo_pathCentroid = {\\n\\t\\tpoint: d3_geo_pathCentroidPoint,\\n\\t\\tlineStart: d3_geo_pathCentroidLineStart,\\n\\t\\tlineEnd: d3_geo_pathCentroidLineEnd,\\n\\t\\tpolygonStart: function() {\\n\\t\\t\\td3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\\n\\t\\t},\\n\\t\\tpolygonEnd: function() {\\n\\t\\t\\td3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\\n\\t\\t\\td3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\\n\\t\\t\\td3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_pathCentroidPoint( x, y ) {\\n\\t\\td3_geo_centroidX0 += x;\\n\\t\\td3_geo_centroidY0 += y;\\n\\t\\t++d3_geo_centroidZ0;\\n\\t}\\n\\tfunction d3_geo_pathCentroidLineStart() {\\n\\t\\tvar x0, y0;\\n\\t\\td3_geo_pathCentroid.point = function( x, y ) {\\n\\t\\t\\td3_geo_pathCentroid.point = nextPoint;\\n\\t\\t\\td3_geo_pathCentroidPoint( x0 = x, y0 = y );\\n\\t\\t};\\n\\t\\tfunction nextPoint( x, y ) {\\n\\t\\t\\tvar dx = x - x0, dy = y - y0, z = Math.sqrt( dx * dx + dy * dy );\\n\\t\\t\\td3_geo_centroidX1 += z * ( x0 + x ) / 2;\\n\\t\\t\\td3_geo_centroidY1 += z * ( y0 + y ) / 2;\\n\\t\\t\\td3_geo_centroidZ1 += z;\\n\\t\\t\\td3_geo_pathCentroidPoint( x0 = x, y0 = y );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_pathCentroidLineEnd() {\\n\\t\\td3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\\n\\t}\\n\\tfunction d3_geo_pathCentroidRingStart() {\\n\\t\\tvar x00, y00, x0, y0;\\n\\t\\td3_geo_pathCentroid.point = function( x, y ) {\\n\\t\\t\\td3_geo_pathCentroid.point = nextPoint;\\n\\t\\t\\td3_geo_pathCentroidPoint( x00 = x0 = x, y00 = y0 = y );\\n\\t\\t};\\n\\t\\tfunction nextPoint( x, y ) {\\n\\t\\t\\tvar dx = x - x0, dy = y - y0, z = Math.sqrt( dx * dx + dy * dy );\\n\\t\\t\\td3_geo_centroidX1 += z * ( x0 + x ) / 2;\\n\\t\\t\\td3_geo_centroidY1 += z * ( y0 + y ) / 2;\\n\\t\\t\\td3_geo_centroidZ1 += z;\\n\\t\\t\\tz = y0 * x - x0 * y;\\n\\t\\t\\td3_geo_centroidX2 += z * ( x0 + x );\\n\\t\\t\\td3_geo_centroidY2 += z * ( y0 + y );\\n\\t\\t\\td3_geo_centroidZ2 += z * 3;\\n\\t\\t\\td3_geo_pathCentroidPoint( x0 = x, y0 = y );\\n\\t\\t}\\n\\t\\td3_geo_pathCentroid.lineEnd = function() {\\n\\t\\t\\tnextPoint( x00, y00 );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_pathContext( context ) {\\n\\t\\tvar pointRadius = 4.5;\\n\\t\\tvar stream = {\\n\\t\\t\\tpoint: point,\\n\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\tstream.point = pointLineStart;\\n\\t\\t\\t},\\n\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\tstream.lineEnd = lineEndPolygon;\\n\\t\\t\\t},\\n\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\tstream.lineEnd = lineEnd;\\n\\t\\t\\t\\tstream.point = point;\\n\\t\\t\\t},\\n\\t\\t\\tpointRadius: function( _ ) {\\n\\t\\t\\t\\tpointRadius = _;\\n\\t\\t\\t\\treturn stream;\\n\\t\\t\\t},\\n\\t\\t\\tresult: d3_noop\\n\\t\\t};\\n\\t\\tfunction point( x, y ) {\\n\\t\\t\\tcontext.moveTo( x + pointRadius, y );\\n\\t\\t\\tcontext.arc( x, y, pointRadius, 0,  );\\n\\t\\t}\\n\\t\\tfunction pointLineStart( x, y ) {\\n\\t\\t\\tcontext.moveTo( x, y );\\n\\t\\t\\tstream.point = pointLine;\\n\\t\\t}\\n\\t\\tfunction pointLine( x, y ) {\\n\\t\\t\\tcontext.lineTo( x, y );\\n\\t\\t}\\n\\t\\tfunction lineEnd() {\\n\\t\\t\\tstream.point = point;\\n\\t\\t}\\n\\t\\tfunction lineEndPolygon() {\\n\\t\\t\\tcontext.closePath();\\n\\t\\t}\\n\\t\\treturn stream;\\n\\t}\\n\\tfunction d3_geo_resample( project ) {\\n\\t\\tvar 2 = .5, cosMinDistance = Math.cos( 30 * d3_radians ), maxDepth = 16;\\n\\t\\tfunction resample( stream ) {\\n\\t\\t\\treturn ( maxDepth ? resampleRecursive : resampleNone )( stream );\\n\\t\\t}\\n\\t\\tfunction resampleNone( stream ) {\\n\\t\\t\\treturn d3_geo_transformPoint( stream, function( x, y ) {\\n\\t\\t\\t\\tx = project( x, y );\\n\\t\\t\\t\\tstream.point( x[0], x[1] );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tfunction resampleRecursive( stream ) {\\n\\t\\t\\tvar 00, 00, x00, y00, a00, b00, c00, 0, x0, y0, a0, b0, c0;\\n\\t\\t\\tvar resample = {\\n\\t\\t\\t\\tpoint: point,\\n\\t\\t\\t\\tlineStart: lineStart,\\n\\t\\t\\t\\tlineEnd: lineEnd,\\n\\t\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\t\\tstream.polygonStart();\\n\\t\\t\\t\\t\\tresample.lineStart = ringStart;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\t\\tstream.polygonEnd();\\n\\t\\t\\t\\t\\tresample.lineStart = lineStart;\\n\\t\\t\\t\\t}\\n\\t\\t\\t};\\n\\t\\t\\tfunction point( x, y ) {\\n\\t\\t\\t\\tx = project( x, y );\\n\\t\\t\\t\\tstream.point( x[0], x[1] );\\n\\t\\t\\t}\\n\\t\\t\\tfunction lineStart() {\\n\\t\\t\\t\\tx0 = NaN;\\n\\t\\t\\t\\tresample.point = linePoint;\\n\\t\\t\\t\\tstream.lineStart();\\n\\t\\t\\t}\\n\\t\\t\\tfunction linePoint( ,  ) {\\n\\t\\t\\t\\tvar c = d3_geo_cartesian( [ ,  ] ), p = project( ,  );\\n\\t\\t\\t\\tresampleLineTo( x0, y0, 0, a0, b0, c0, x0 = p[0], y0 = p[1], 0 = , a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream );\\n\\t\\t\\t\\tstream.point( x0, y0 );\\n\\t\\t\\t}\\n\\t\\t\\tfunction lineEnd() {\\n\\t\\t\\t\\tresample.point = point;\\n\\t\\t\\t\\tstream.lineEnd();\\n\\t\\t\\t}\\n\\t\\t\\tfunction ringStart() {\\n\\t\\t\\t\\tlineStart();\\n\\t\\t\\t\\tresample.point = ringPoint;\\n\\t\\t\\t\\tresample.lineEnd = ringEnd;\\n\\t\\t\\t}\\n\\t\\t\\tfunction ringPoint( ,  ) {\\n\\t\\t\\t\\tlinePoint( 00 = , 00 =  ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\\n\\t\\t\\t\\tresample.point = linePoint;\\n\\t\\t\\t}\\n\\t\\t\\tfunction ringEnd() {\\n\\t\\t\\t\\tresampleLineTo( x0, y0, 0, a0, b0, c0, x00, y00, 00, a00, b00, c00, maxDepth, stream );\\n\\t\\t\\t\\tresample.lineEnd = lineEnd;\\n\\t\\t\\t\\tlineEnd();\\n\\t\\t\\t}\\n\\t\\t\\treturn resample;\\n\\t\\t}\\n\\t\\tfunction resampleLineTo( x0, y0, 0, a0, b0, c0, x1, y1, 1, a1, b1, c1, depth, stream ) {\\n\\t\\t\\tvar dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\\n\\t\\t\\tif ( d2 > 4 * 2 && depth-- ) {\\n\\t\\t\\t\\tvar a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt( a * a + b * b + c * c ), 2 = Math.asin( c /= m ), 2 = abs( abs( c ) - 1 ) <  || abs( 0 - 1 ) <  ? ( 0 + 1 ) / 2 : Math.atan2( b, a ), p = project( 2, 2 ), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\\n\\t\\t\\t\\tif ( dz * dz / d2 > 2 || abs( ( dx * dx2 + dy * dy2 ) / d2 - .5 ) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance ) {\\n\\t\\t\\t\\t\\tresampleLineTo( x0, y0, 0, a0, b0, c0, x2, y2, 2, a /= m, b /= m, c, depth, stream );\\n\\t\\t\\t\\t\\tstream.point( x2, y2 );\\n\\t\\t\\t\\t\\tresampleLineTo( x2, y2, 2, a, b, c, x1, y1, 1, a1, b1, c1, depth, stream );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tresample.precision = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return Math.sqrt( 2 );\\n\\t\\t\\tmaxDepth = ( 2 = _ * _ ) > 0 && 16;\\n\\t\\t\\treturn resample;\\n\\t\\t};\\n\\t\\treturn resample;\\n\\t}\\n\\td3.geo.path = function() {\\n\\t\\tvar pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\\n\\t\\tfunction path( object ) {\\n\\t\\t\\tif ( object ) {\\n\\t\\t\\t\\tif ( typeof pointRadius === \\\"function\\\" ) contextStream.pointRadius( +pointRadius.apply( this, arguments ) );\\n\\t\\t\\t\\tif ( !cacheStream || !cacheStream.valid ) cacheStream = projectStream( contextStream );\\n\\t\\t\\t\\td3.geo.stream( object, cacheStream );\\n\\t\\t\\t}\\n\\t\\t\\treturn contextStream.result();\\n\\t\\t}\\n\\t\\tpath.area = function( object ) {\\n\\t\\t\\td3_geo_pathAreaSum = 0;\\n\\t\\t\\td3.geo.stream( object, projectStream( d3_geo_pathArea ) );\\n\\t\\t\\treturn d3_geo_pathAreaSum;\\n\\t\\t};\\n\\t\\tpath.centroid = function( object ) {\\n\\t\\t\\td3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\\n\\t\\t\\td3.geo.stream( object, projectStream( d3_geo_pathCentroid ) );\\n\\t\\t\\treturn d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\\n\\t\\t};\\n\\t\\tpath.bounds = function( object ) {\\n\\t\\t\\td3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -( d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity );\\n\\t\\t\\td3.geo.stream( object, projectStream( d3_geo_pathBounds ) );\\n\\t\\t\\treturn [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\\n\\t\\t};\\n\\t\\tpath.projection = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return projection;\\n\\t\\t\\tprojectStream = ( projection = _ ) ? _.stream || d3_geo_pathProjectStream( _ ) : d3_identity;\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\tpath.context = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return context;\\n\\t\\t\\tcontextStream = ( context = _ ) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext( _ );\\n\\t\\t\\tif ( typeof pointRadius !== \\\"function\\\" ) contextStream.pointRadius( pointRadius );\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\tpath.pointRadius = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return pointRadius;\\n\\t\\t\\tpointRadius = typeof _ === \\\"function\\\" ? _ : ( contextStream.pointRadius( +_ ), +_ );\\n\\t\\t\\treturn path;\\n\\t\\t};\\n\\t\\tfunction reset() {\\n\\t\\t\\tcacheStream = null;\\n\\t\\t\\treturn path;\\n\\t\\t}\\n\\t\\treturn path.projection( d3.geo.albersUsa() ).context( null );\\n\\t};\\n\\tfunction d3_geo_pathProjectStream( project ) {\\n\\t\\tvar resample = d3_geo_resample( function( x, y ) {\\n\\t\\t\\treturn project( [ x * d3_degrees, y * d3_degrees ] );\\n\\t\\t} );\\n\\t\\treturn function( stream ) {\\n\\t\\t\\treturn d3_geo_projectionRadians( resample( stream ) );\\n\\t\\t};\\n\\t}\\n\\td3.geo.transform = function( methods ) {\\n\\t\\treturn {\\n\\t\\t\\tstream: function( stream ) {\\n\\t\\t\\t\\tvar transform = new d3_geo_transform( stream );\\n\\t\\t\\t\\tfor ( var k in methods ) transform[k] = methods[k];\\n\\t\\t\\t\\treturn transform;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t};\\n\\tfunction d3_geo_transform( stream ) {\\n\\t\\tthis.stream = stream;\\n\\t}\\n\\td3_geo_transform.prototype = {\\n\\t\\tpoint: function( x, y ) {\\n\\t\\t\\tthis.stream.point( x, y );\\n\\t\\t},\\n\\t\\tsphere: function() {\\n\\t\\t\\tthis.stream.sphere();\\n\\t\\t},\\n\\t\\tlineStart: function() {\\n\\t\\t\\tthis.stream.lineStart();\\n\\t\\t},\\n\\t\\tlineEnd: function() {\\n\\t\\t\\tthis.stream.lineEnd();\\n\\t\\t},\\n\\t\\tpolygonStart: function() {\\n\\t\\t\\tthis.stream.polygonStart();\\n\\t\\t},\\n\\t\\tpolygonEnd: function() {\\n\\t\\t\\tthis.stream.polygonEnd();\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geo_transformPoint( stream, point ) {\\n\\t\\treturn {\\n\\t\\t\\tpoint: point,\\n\\t\\t\\tsphere: function() {\\n\\t\\t\\t\\tstream.sphere();\\n\\t\\t\\t},\\n\\t\\t\\tlineStart: function() {\\n\\t\\t\\t\\tstream.lineStart();\\n\\t\\t\\t},\\n\\t\\t\\tlineEnd: function() {\\n\\t\\t\\t\\tstream.lineEnd();\\n\\t\\t\\t},\\n\\t\\t\\tpolygonStart: function() {\\n\\t\\t\\t\\tstream.polygonStart();\\n\\t\\t\\t},\\n\\t\\t\\tpolygonEnd: function() {\\n\\t\\t\\t\\tstream.polygonEnd();\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\td3.geo.projection = d3_geo_projection;\\n\\td3.geo.projectionMutator = d3_geo_projectionMutator;\\n\\tfunction d3_geo_projection( project ) {\\n\\t\\treturn d3_geo_projectionMutator( function() {\\n\\t\\t\\treturn project;\\n\\t\\t} )();\\n\\t}\\n\\tfunction d3_geo_projectionMutator( projectAt ) {\\n\\t\\tvar project, rotate, projectRotate, projectResample = d3_geo_resample( function( x, y ) {\\n\\t\\t\\t\\tx = project( x, y );\\n\\t\\t\\t\\treturn [ x[0] * k + x, y - x[1] * k ];\\n\\t\\t\\t} ), k = 150, x = 480, y = 250,  = 0,  = 0,  = 0,  = 0,  = 0, x, y, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\\n\\t\\tfunction projection( point ) {\\n\\t\\t\\tpoint = projectRotate( point[0] * d3_radians, point[1] * d3_radians );\\n\\t\\t\\treturn [ point[0] * k + x, y - point[1] * k ];\\n\\t\\t}\\n\\t\\tfunction invert( point ) {\\n\\t\\t\\tpoint = projectRotate.invert( ( point[0] - x ) / k, ( y - point[1] ) / k );\\n\\t\\t\\treturn point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\\n\\t\\t}\\n\\t\\tprojection.stream = function( output ) {\\n\\t\\t\\tif ( stream ) stream.valid = false;\\n\\t\\t\\tstream = d3_geo_projectionRadians( preclip( rotate, projectResample( postclip( output ) ) ) );\\n\\t\\t\\tstream.valid = true;\\n\\t\\t\\treturn stream;\\n\\t\\t};\\n\\t\\tprojection.clipAngle = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return clipAngle;\\n\\t\\t\\tpreclip = _ == null ? ( clipAngle = _, d3_geo_clipAntimeridian ) : d3_geo_clipCircle( ( clipAngle = +_ ) * d3_radians );\\n\\t\\t\\treturn invalidate();\\n\\t\\t};\\n\\t\\tprojection.clipExtent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return clipExtent;\\n\\t\\t\\tclipExtent = _;\\n\\t\\t\\tpostclip = _ ? d3_geo_clipExtent( _[0][0], _[0][1], _[1][0], _[1][1] ) : d3_identity;\\n\\t\\t\\treturn invalidate();\\n\\t\\t};\\n\\t\\tprojection.scale = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return k;\\n\\t\\t\\tk = +_;\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\tprojection.translate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ x, y ];\\n\\t\\t\\tx = +_[0];\\n\\t\\t\\ty = +_[1];\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\tprojection.center = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [  * d3_degrees,  * d3_degrees ];\\n\\t\\t\\t = _[0] % 360 * d3_radians;\\n\\t\\t\\t = _[1] % 360 * d3_radians;\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\tprojection.rotate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [  * d3_degrees,  * d3_degrees,  * d3_degrees ];\\n\\t\\t\\t = _[0] % 360 * d3_radians;\\n\\t\\t\\t = _[1] % 360 * d3_radians;\\n\\t\\t\\t = _.length > 2 ? _[2] % 360 * d3_radians : 0;\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t\\td3.rebind( projection, projectResample, \\\"precision\\\" );\\n\\t\\tfunction reset() {\\n\\t\\t\\tprojectRotate = d3_geo_compose( rotate = d3_geo_rotation( , ,  ), project );\\n\\t\\t\\tvar center = project( ,  );\\n\\t\\t\\tx = x - center[0] * k;\\n\\t\\t\\ty = y + center[1] * k;\\n\\t\\t\\treturn invalidate();\\n\\t\\t}\\n\\t\\tfunction invalidate() {\\n\\t\\t\\tif ( stream ) stream.valid = false, stream = null;\\n\\t\\t\\treturn projection;\\n\\t\\t}\\n\\t\\treturn function() {\\n\\t\\t\\tproject = projectAt.apply( this, arguments );\\n\\t\\t\\tprojection.invert = project.invert && invert;\\n\\t\\t\\treturn reset();\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_projectionRadians( stream ) {\\n\\t\\treturn d3_geo_transformPoint( stream, function( x, y ) {\\n\\t\\t\\tstream.point( x * d3_radians, y * d3_radians );\\n\\t\\t} );\\n\\t}\\n\\tfunction d3_geo_equirectangular( ,  ) {\\n\\t\\treturn [ ,  ];\\n\\t}\\n\\t( d3.geo.equirectangular = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_equirectangular );\\n\\t} ).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\\n\\td3.geo.rotation = function( rotate ) {\\n\\t\\trotate = d3_geo_rotation( rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0 );\\n\\t\\tfunction forward( coordinates ) {\\n\\t\\t\\tcoordinates = rotate( coordinates[0] * d3_radians, coordinates[1] * d3_radians );\\n\\t\\t\\treturn coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\\n\\t\\t}\\n\\t\\tforward.invert = function( coordinates ) {\\n\\t\\t\\tcoordinates = rotate.invert( coordinates[0] * d3_radians, coordinates[1] * d3_radians );\\n\\t\\t\\treturn coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\\n\\t\\t};\\n\\t\\treturn forward;\\n\\t};\\n\\tfunction d3_geo_identityRotation( ,  ) {\\n\\t\\treturn [  >  ?  -  :  < - ?  +  : ,  ];\\n\\t}\\n\\td3_geo_identityRotation.invert = d3_geo_equirectangular;\\n\\tfunction d3_geo_rotation( , ,  ) {\\n\\t\\treturn  ?  ||  ? d3_geo_compose( d3_geo_rotation(  ), d3_geo_rotation( ,  ) ) : d3_geo_rotation(  ) :  ||  ? d3_geo_rotation( ,  ) : d3_geo_identityRotation;\\n\\t}\\n\\tfunction d3_geo_forwardRotation(  ) {\\n\\t\\treturn function( ,  ) {\\n\\t\\t\\treturn  += , [  >  ?  -  :  < - ?  +  : ,  ];\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_rotation(  ) {\\n\\t\\tvar rotation = d3_geo_forwardRotation(  );\\n\\t\\trotation.invert = d3_geo_forwardRotation( - );\\n\\t\\treturn rotation;\\n\\t}\\n\\tfunction d3_geo_rotation( ,  ) {\\n\\t\\tvar cos = Math.cos(  ), sin = Math.sin(  ), cos = Math.cos(  ), sin = Math.sin(  );\\n\\t\\tfunction rotation( ,  ) {\\n\\t\\t\\tvar cos = Math.cos(  ), x = Math.cos(  ) * cos, y = Math.sin(  ) * cos, z = Math.sin(  ), k = z * cos + x * sin;\\n\\t\\t\\treturn [ Math.atan2( y * cos - k * sin, x * cos - z * sin ), d3_asin( k * cos + y * sin ) ];\\n\\t\\t}\\n\\t\\trotation.invert = function( ,  ) {\\n\\t\\t\\tvar cos = Math.cos(  ), x = Math.cos(  ) * cos, y = Math.sin(  ) * cos, z = Math.sin(  ), k = z * cos - y * sin;\\n\\t\\t\\treturn [ Math.atan2( y * cos + z * sin, x * cos + k * sin ), d3_asin( k * cos - x * sin ) ];\\n\\t\\t};\\n\\t\\treturn rotation;\\n\\t}\\n\\td3.geo.circle = function() {\\n\\t\\tvar origin = [ 0, 0 ], angle, precision = 6, interpolate;\\n\\t\\tfunction circle() {\\n\\t\\t\\tvar center = typeof origin === \\\"function\\\" ? origin.apply( this, arguments ) : origin, rotate = d3_geo_rotation( -center[0] * d3_radians, -center[1] * d3_radians, 0 ).invert, ring = [];\\n\\t\\t\\tinterpolate( null, null, 1, {\\n\\t\\t\\t\\tpoint: function( x, y ) {\\n\\t\\t\\t\\t\\tring.push( x = rotate( x, y ) );\\n\\t\\t\\t\\t\\tx[0] *= d3_degrees, x[1] *= d3_degrees;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttype: \\\"Polygon\\\",\\n\\t\\t\\t\\tcoordinates: [ ring ]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tcircle.origin = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return origin;\\n\\t\\t\\torigin = x;\\n\\t\\t\\treturn circle;\\n\\t\\t};\\n\\t\\tcircle.angle = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return angle;\\n\\t\\t\\tinterpolate = d3_geo_circleInterpolate( ( angle = +x ) * d3_radians, precision * d3_radians );\\n\\t\\t\\treturn circle;\\n\\t\\t};\\n\\t\\tcircle.precision = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return precision;\\n\\t\\t\\tinterpolate = d3_geo_circleInterpolate( angle * d3_radians, ( precision = +_ ) * d3_radians );\\n\\t\\t\\treturn circle;\\n\\t\\t};\\n\\t\\treturn circle.angle( 90 );\\n\\t};\\n\\tfunction d3_geo_circleInterpolate( radius, precision ) {\\n\\t\\tvar cr = Math.cos( radius ), sr = Math.sin( radius );\\n\\t\\treturn function( from, to, direction, listener ) {\\n\\t\\t\\tvar step = direction * precision;\\n\\t\\t\\tif ( from != null ) {\\n\\t\\t\\t\\tfrom = d3_geo_circleAngle( cr, from );\\n\\t\\t\\t\\tto = d3_geo_circleAngle( cr, to );\\n\\t\\t\\t\\tif ( direction > 0 ? from < to : from > to ) from += direction * ;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tfrom = radius + direction * ;\\n\\t\\t\\t\\tto = radius - .5 * step;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( var point, t = from; direction > 0 ? t > to : t < to; t -= step ) {\\n\\t\\t\\t\\tlistener.point( ( point = d3_geo_spherical( [ cr, -sr * Math.cos( t ), -sr * Math.sin( t ) ] ) )[0], point[1] );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_circleAngle( cr, point ) {\\n\\t\\tvar a = d3_geo_cartesian( point );\\n\\t\\ta[0] -= cr;\\n\\t\\td3_geo_cartesianNormalize( a );\\n\\t\\tvar angle = d3_acos( -a[1] );\\n\\t\\treturn ( ( -a[2] < 0 ? -angle : angle ) + 2 * Math.PI -  ) % ( 2 * Math.PI );\\n\\t}\\n\\td3.geo.distance = function( a, b ) {\\n\\t\\tvar  = ( b[0] - a[0] ) * d3_radians, 0 = a[1] * d3_radians, 1 = b[1] * d3_radians, sin = Math.sin(  ), cos = Math.cos(  ), sin0 = Math.sin( 0 ), cos0 = Math.cos( 0 ), sin1 = Math.sin( 1 ), cos1 = Math.cos( 1 ), t;\\n\\t\\treturn Math.atan2( Math.sqrt( ( t = cos1 * sin ) * t + ( t = cos0 * sin1 - sin0 * cos1 * cos ) * t ), sin0 * sin1 + cos0 * cos1 * cos );\\n\\t};\\n\\td3.geo.graticule = function() {\\n\\t\\tvar x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\\n\\t\\tfunction graticule() {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttype: \\\"MultiLineString\\\",\\n\\t\\t\\t\\tcoordinates: lines()\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfunction lines() {\\n\\t\\t\\treturn d3.range( Math.ceil( X0 / DX ) * DX, X1, DX ).map( X ).concat( d3.range( Math.ceil( Y0 / DY ) * DY, Y1, DY ).map( Y ) ).concat( d3.range( Math.ceil( x0 / dx ) * dx, x1, dx ).filter( function( x ) {\\n\\t\\t\\t\\treturn abs( x % DX ) > ;\\n\\t\\t\\t} ).map( x ) ).concat( d3.range( Math.ceil( y0 / dy ) * dy, y1, dy ).filter( function( y ) {\\n\\t\\t\\t\\treturn abs( y % DY ) > ;\\n\\t\\t\\t} ).map( y ) );\\n\\t\\t}\\n\\t\\tgraticule.lines = function() {\\n\\t\\t\\treturn lines().map( function( coordinates ) {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\ttype: \\\"LineString\\\",\\n\\t\\t\\t\\t\\tcoordinates: coordinates\\n\\t\\t\\t\\t};\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tgraticule.outline = function() {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttype: \\\"Polygon\\\",\\n\\t\\t\\t\\tcoordinates: [ X( X0 ).concat( Y( Y1 ).slice( 1 ), X( X1 ).reverse().slice( 1 ), Y( Y0 ).reverse().slice( 1 ) ) ]\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tgraticule.extent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return graticule.minorExtent();\\n\\t\\t\\treturn graticule.majorExtent( _ ).minorExtent( _ );\\n\\t\\t};\\n\\t\\tgraticule.majorExtent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ [ X0, Y0 ], [ X1, Y1 ] ];\\n\\t\\t\\tX0 = +_[0][0], X1 = +_[1][0];\\n\\t\\t\\tY0 = +_[0][1], Y1 = +_[1][1];\\n\\t\\t\\tif ( X0 > X1 ) _ = X0, X0 = X1, X1 = _;\\n\\t\\t\\tif ( Y0 > Y1 ) _ = Y0, Y0 = Y1, Y1 = _;\\n\\t\\t\\treturn graticule.precision( precision );\\n\\t\\t};\\n\\t\\tgraticule.minorExtent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ [ x0, y0 ], [ x1, y1 ] ];\\n\\t\\t\\tx0 = +_[0][0], x1 = +_[1][0];\\n\\t\\t\\ty0 = +_[0][1], y1 = +_[1][1];\\n\\t\\t\\tif ( x0 > x1 ) _ = x0, x0 = x1, x1 = _;\\n\\t\\t\\tif ( y0 > y1 ) _ = y0, y0 = y1, y1 = _;\\n\\t\\t\\treturn graticule.precision( precision );\\n\\t\\t};\\n\\t\\tgraticule.step = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return graticule.minorStep();\\n\\t\\t\\treturn graticule.majorStep( _ ).minorStep( _ );\\n\\t\\t};\\n\\t\\tgraticule.majorStep = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ DX, DY ];\\n\\t\\t\\tDX = +_[0], DY = +_[1];\\n\\t\\t\\treturn graticule;\\n\\t\\t};\\n\\t\\tgraticule.minorStep = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return [ dx, dy ];\\n\\t\\t\\tdx = +_[0], dy = +_[1];\\n\\t\\t\\treturn graticule;\\n\\t\\t};\\n\\t\\tgraticule.precision = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return precision;\\n\\t\\t\\tprecision = +_;\\n\\t\\t\\tx = d3_geo_graticuleX( y0, y1, 90 );\\n\\t\\t\\ty = d3_geo_graticuleY( x0, x1, precision );\\n\\t\\t\\tX = d3_geo_graticuleX( Y0, Y1, 90 );\\n\\t\\t\\tY = d3_geo_graticuleY( X0, X1, precision );\\n\\t\\t\\treturn graticule;\\n\\t\\t};\\n\\t\\treturn graticule.majorExtent( [ [ -180, -90 +  ], [ 180, 90 -  ] ] ).minorExtent( [ [ -180, -80 -  ], [ 180, 80 +  ] ] );\\n\\t};\\n\\tfunction d3_geo_graticuleX( y0, y1, dy ) {\\n\\t\\tvar y = d3.range( y0, y1 - , dy ).concat( y1 );\\n\\t\\treturn function( x ) {\\n\\t\\t\\treturn y.map( function( y ) {\\n\\t\\t\\t\\treturn [ x, y ];\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geo_graticuleY( x0, x1, dx ) {\\n\\t\\tvar x = d3.range( x0, x1 - , dx ).concat( x1 );\\n\\t\\treturn function( y ) {\\n\\t\\t\\treturn x.map( function( x ) {\\n\\t\\t\\t\\treturn [ x, y ];\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_source( d ) {\\n\\t\\treturn d.source;\\n\\t}\\n\\tfunction d3_target( d ) {\\n\\t\\treturn d.target;\\n\\t}\\n\\td3.geo.greatArc = function() {\\n\\t\\tvar source = d3_source, source_, target = d3_target, target_;\\n\\t\\tfunction greatArc() {\\n\\t\\t\\treturn {\\n\\t\\t\\t\\ttype: \\\"LineString\\\",\\n\\t\\t\\t\\tcoordinates: [ source_ || source.apply( this, arguments ), target_ || target.apply( this, arguments ) ]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tgreatArc.distance = function() {\\n\\t\\t\\treturn d3.geo.distance( source_ || source.apply( this, arguments ), target_ || target.apply( this, arguments ) );\\n\\t\\t};\\n\\t\\tgreatArc.source = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return source;\\n\\t\\t\\tsource = _, source_ = typeof _ === \\\"function\\\" ? null : _;\\n\\t\\t\\treturn greatArc;\\n\\t\\t};\\n\\t\\tgreatArc.target = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return target;\\n\\t\\t\\ttarget = _, target_ = typeof _ === \\\"function\\\" ? null : _;\\n\\t\\t\\treturn greatArc;\\n\\t\\t};\\n\\t\\tgreatArc.precision = function() {\\n\\t\\t\\treturn arguments.length ? greatArc : 0;\\n\\t\\t};\\n\\t\\treturn greatArc;\\n\\t};\\n\\td3.geo.interpolate = function( source, target ) {\\n\\t\\treturn d3_geo_interpolate( source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians );\\n\\t};\\n\\tfunction d3_geo_interpolate( x0, y0, x1, y1 ) {\\n\\t\\tvar cy0 = Math.cos( y0 ), sy0 = Math.sin( y0 ), cy1 = Math.cos( y1 ), sy1 = Math.sin( y1 ), kx0 = cy0 * Math.cos( x0 ), ky0 = cy0 * Math.sin( x0 ), kx1 = cy1 * Math.cos( x1 ), ky1 = cy1 * Math.sin( x1 ), d = 2 * Math.asin( Math.sqrt( d3_haversin( y1 - y0 ) + cy0 * cy1 * d3_haversin( x1 - x0 ) ) ), k = 1 / Math.sin( d );\\n\\t\\tvar interpolate = d ? function( t ) {\\n\\t\\t\\tvar B = Math.sin( t *= d ) * k, A = Math.sin( d - t ) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\\n\\t\\t\\treturn [ Math.atan2( y, x ) * d3_degrees, Math.atan2( z, Math.sqrt( x * x + y * y ) ) * d3_degrees ];\\n\\t\\t} : function() {\\n\\t\\t\\treturn [ x0 * d3_degrees, y0 * d3_degrees ];\\n\\t\\t};\\n\\t\\tinterpolate.distance = d;\\n\\t\\treturn interpolate;\\n\\t}\\n\\td3.geo.length = function( object ) {\\n\\t\\td3_geo_lengthSum = 0;\\n\\t\\td3.geo.stream( object, d3_geo_length );\\n\\t\\treturn d3_geo_lengthSum;\\n\\t};\\n\\tvar d3_geo_lengthSum;\\n\\tvar d3_geo_length = {\\n\\t\\tsphere: d3_noop,\\n\\t\\tpoint: d3_noop,\\n\\t\\tlineStart: d3_geo_lengthLineStart,\\n\\t\\tlineEnd: d3_noop,\\n\\t\\tpolygonStart: d3_noop,\\n\\t\\tpolygonEnd: d3_noop\\n\\t};\\n\\tfunction d3_geo_lengthLineStart() {\\n\\t\\tvar 0, sin0, cos0;\\n\\t\\td3_geo_length.point = function( ,  ) {\\n\\t\\t\\t0 =  * d3_radians, sin0 = Math.sin(  *= d3_radians ), cos0 = Math.cos(  );\\n\\t\\t\\td3_geo_length.point = nextPoint;\\n\\t\\t};\\n\\t\\td3_geo_length.lineEnd = function() {\\n\\t\\t\\td3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\\n\\t\\t};\\n\\t\\tfunction nextPoint( ,  ) {\\n\\t\\t\\tvar sin = Math.sin(  *= d3_radians ), cos = Math.cos(  ), t = abs( (  *= d3_radians ) - 0 ), cos = Math.cos( t );\\n\\t\\t\\td3_geo_lengthSum += Math.atan2( Math.sqrt( ( t = cos * Math.sin( t ) ) * t + ( t = cos0 * sin - sin0 * cos * cos ) * t ), sin0 * sin + cos0 * cos * cos );\\n\\t\\t\\t0 = , sin0 = sin, cos0 = cos;\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geo_azimuthal( scale, angle ) {\\n\\t\\tfunction azimuthal( ,  ) {\\n\\t\\t\\tvar cos = Math.cos(  ), cos = Math.cos(  ), k = scale( cos * cos );\\n\\t\\t\\treturn [ k * cos * Math.sin(  ), k * Math.sin(  ) ];\\n\\t\\t}\\n\\t\\tazimuthal.invert = function( x, y ) {\\n\\t\\t\\tvar  = Math.sqrt( x * x + y * y ), c = angle(  ), sinc = Math.sin( c ), cosc = Math.cos( c );\\n\\t\\t\\treturn [ Math.atan2( x * sinc,  * cosc ), Math.asin(  && y * sinc /  ) ];\\n\\t\\t};\\n\\t\\treturn azimuthal;\\n\\t}\\n\\tvar d3_geo_azimuthalEqualArea = d3_geo_azimuthal( function( coscos ) {\\n\\t\\treturn Math.sqrt( 2 / ( 1 + coscos ) );\\n\\t}, function(  ) {\\n\\t\\treturn 2 * Math.asin(  / 2 );\\n\\t} );\\n\\t( d3.geo.azimuthalEqualArea = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_azimuthalEqualArea );\\n\\t} ).raw = d3_geo_azimuthalEqualArea;\\n\\tvar d3_geo_azimuthalEquidistant = d3_geo_azimuthal( function( coscos ) {\\n\\t\\tvar c = Math.acos( coscos );\\n\\t\\treturn c && c / Math.sin( c );\\n\\t}, d3_identity );\\n\\t( d3.geo.azimuthalEquidistant = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_azimuthalEquidistant );\\n\\t} ).raw = d3_geo_azimuthalEquidistant;\\n\\tfunction d3_geo_conicConformal( 0, 1 ) {\\n\\t\\tvar cos0 = Math.cos( 0 ), t = function(  ) {\\n\\t\\t\\t\\treturn Math.tan(  / 4 +  / 2 );\\n\\t\\t\\t}, n = 0 === 1 ? Math.sin( 0 ) : Math.log( cos0 / Math.cos( 1 ) ) / Math.log( t( 1 ) / t( 0 ) ), F = cos0 * Math.pow( t( 0 ), n ) / n;\\n\\t\\tif ( !n ) return d3_geo_mercator;\\n\\t\\tfunction forward( ,  ) {\\n\\t\\t\\tif ( F > 0 ) {\\n\\t\\t\\t\\tif (  < -half +  )  = -half + ;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (  > half -  )  = half - ;\\n\\t\\t\\t}\\n\\t\\t\\tvar  = F / Math.pow( t(  ), n );\\n\\t\\t\\treturn [  * Math.sin( n *  ), F -  * Math.cos( n *  ) ];\\n\\t\\t}\\n\\t\\tforward.invert = function( x, y ) {\\n\\t\\t\\tvar 0_y = F - y,  = d3_sgn( n ) * Math.sqrt( x * x + 0_y * 0_y );\\n\\t\\t\\treturn [ Math.atan2( x, 0_y ) / n, 2 * Math.atan( Math.pow( F / , 1 / n ) ) - half ];\\n\\t\\t};\\n\\t\\treturn forward;\\n\\t}\\n\\t( d3.geo.conicConformal = function() {\\n\\t\\treturn d3_geo_conic( d3_geo_conicConformal );\\n\\t} ).raw = d3_geo_conicConformal;\\n\\tfunction d3_geo_conicEquidistant( 0, 1 ) {\\n\\t\\tvar cos0 = Math.cos( 0 ), n = 0 === 1 ? Math.sin( 0 ) : ( cos0 - Math.cos( 1 ) ) / ( 1 - 0 ), G = cos0 / n + 0;\\n\\t\\tif ( abs( n ) <  ) return d3_geo_equirectangular;\\n\\t\\tfunction forward( ,  ) {\\n\\t\\t\\tvar  = G - ;\\n\\t\\t\\treturn [  * Math.sin( n *  ), G -  * Math.cos( n *  ) ];\\n\\t\\t}\\n\\t\\tforward.invert = function( x, y ) {\\n\\t\\t\\tvar 0_y = G - y;\\n\\t\\t\\treturn [ Math.atan2( x, 0_y ) / n, G - d3_sgn( n ) * Math.sqrt( x * x + 0_y * 0_y ) ];\\n\\t\\t};\\n\\t\\treturn forward;\\n\\t}\\n\\t( d3.geo.conicEquidistant = function() {\\n\\t\\treturn d3_geo_conic( d3_geo_conicEquidistant );\\n\\t} ).raw = d3_geo_conicEquidistant;\\n\\tvar d3_geo_gnomonic = d3_geo_azimuthal( function( coscos ) {\\n\\t\\treturn 1 / coscos;\\n\\t}, Math.atan );\\n\\t( d3.geo.gnomonic = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_gnomonic );\\n\\t} ).raw = d3_geo_gnomonic;\\n\\tfunction d3_geo_mercator( ,  ) {\\n\\t\\treturn [ , Math.log( Math.tan(  / 4 +  / 2 ) ) ];\\n\\t}\\n\\td3_geo_mercator.invert = function( x, y ) {\\n\\t\\treturn [ x, 2 * Math.atan( Math.exp( y ) ) - half ];\\n\\t};\\n\\tfunction d3_geo_mercatorProjection( project ) {\\n\\t\\tvar m = d3_geo_projection( project ), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\\n\\t\\tm.scale = function() {\\n\\t\\t\\tvar v = scale.apply( m, arguments );\\n\\t\\t\\treturn v === m ? clipAuto ? m.clipExtent( null ) : m : v;\\n\\t\\t};\\n\\t\\tm.translate = function() {\\n\\t\\t\\tvar v = translate.apply( m, arguments );\\n\\t\\t\\treturn v === m ? clipAuto ? m.clipExtent( null ) : m : v;\\n\\t\\t};\\n\\t\\tm.clipExtent = function( _ ) {\\n\\t\\t\\tvar v = clipExtent.apply( m, arguments );\\n\\t\\t\\tif ( v === m ) {\\n\\t\\t\\t\\tif ( clipAuto = _ == null ) {\\n\\t\\t\\t\\t\\tvar k =  * scale(), t = translate();\\n\\t\\t\\t\\t\\tclipExtent( [ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if ( clipAuto ) {\\n\\t\\t\\t\\tv = null;\\n\\t\\t\\t}\\n\\t\\t\\treturn v;\\n\\t\\t};\\n\\t\\treturn m.clipExtent( null );\\n\\t}\\n\\t( d3.geo.mercator = function() {\\n\\t\\treturn d3_geo_mercatorProjection( d3_geo_mercator );\\n\\t} ).raw = d3_geo_mercator;\\n\\tvar d3_geo_orthographic = d3_geo_azimuthal( function() {\\n\\t\\treturn 1;\\n\\t}, Math.asin );\\n\\t( d3.geo.orthographic = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_orthographic );\\n\\t} ).raw = d3_geo_orthographic;\\n\\tvar d3_geo_stereographic = d3_geo_azimuthal( function( coscos ) {\\n\\t\\treturn 1 / ( 1 + coscos );\\n\\t}, function(  ) {\\n\\t\\treturn 2 * Math.atan(  );\\n\\t} );\\n\\t( d3.geo.stereographic = function() {\\n\\t\\treturn d3_geo_projection( d3_geo_stereographic );\\n\\t} ).raw = d3_geo_stereographic;\\n\\tfunction d3_geo_transverseMercator( ,  ) {\\n\\t\\treturn [ Math.log( Math.tan(  / 4 +  / 2 ) ), - ];\\n\\t}\\n\\td3_geo_transverseMercator.invert = function( x, y ) {\\n\\t\\treturn [ -y, 2 * Math.atan( Math.exp( x ) ) - half ];\\n\\t};\\n\\t( d3.geo.transverseMercator = function() {\\n\\t\\tvar projection = d3_geo_mercatorProjection( d3_geo_transverseMercator ), center = projection.center, rotate = projection.rotate;\\n\\t\\tprojection.center = function( _ ) {\\n\\t\\t\\treturn _ ? center( [ -_[1], _[0] ] ) : ( _ = center(), [ _[1], -_[0] ] );\\n\\t\\t};\\n\\t\\tprojection.rotate = function( _ ) {\\n\\t\\t\\treturn _ ? rotate( [ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ] ) : ( _ = rotate(),\\n\\t\\t\\t[ _[0], _[1], _[2] - 90 ] );\\n\\t\\t};\\n\\t\\treturn rotate( [ 0, 0, 90 ] );\\n\\t} ).raw = d3_geo_transverseMercator;\\n\\td3.geom = {};\\n\\tfunction d3_geom_pointX( d ) {\\n\\t\\treturn d[0];\\n\\t}\\n\\tfunction d3_geom_pointY( d ) {\\n\\t\\treturn d[1];\\n\\t}\\n\\td3.geom.hull = function( vertices ) {\\n\\t\\tvar x = d3_geom_pointX, y = d3_geom_pointY;\\n\\t\\tif ( arguments.length ) return hull( vertices );\\n\\t\\tfunction hull( data ) {\\n\\t\\t\\tif ( data.length < 3 ) return [];\\n\\t\\t\\tvar fx = d3_functor( x ), fy = d3_functor( y ), i, n = data.length, points = [], flippedPoints = [];\\n\\t\\t\\tfor ( i = 0; i < n; i++ ) {\\n\\t\\t\\t\\tpoints.push( [ +fx.call( this, data[i], i ), +fy.call( this, data[i], i ), i ] );\\n\\t\\t\\t}\\n\\t\\t\\tpoints.sort( d3_geom_hullOrder );\\n\\t\\t\\tfor ( i = 0; i < n; i++ ) flippedPoints.push( [ points[i][0], -points[i][1] ] );\\n\\t\\t\\tvar upper = d3_geom_hullUpper( points ), lower = d3_geom_hullUpper( flippedPoints );\\n\\t\\t\\tvar skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\\n\\t\\t\\tfor ( i = upper.length - 1; i >= 0; --i ) polygon.push( data[points[upper[i]][2]] );\\n\\t\\t\\tfor ( i = +skipLeft; i < lower.length - skipRight; ++i ) polygon.push( data[points[lower[i]][2]] );\\n\\t\\t\\treturn polygon;\\n\\t\\t}\\n\\t\\thull.x = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( x = _, hull ) : x;\\n\\t\\t};\\n\\t\\thull.y = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( y = _, hull ) : y;\\n\\t\\t};\\n\\t\\treturn hull;\\n\\t};\\n\\tfunction d3_geom_hullUpper( points ) {\\n\\t\\tvar n = points.length, hull = [ 0, 1 ], hs = 2;\\n\\t\\tfor ( var i = 2; i < n; i++ ) {\\n\\t\\t\\twhile ( hs > 1 && d3_cross2d( points[hull[hs - 2]], points[hull[hs - 1]], points[i] ) <= 0 ) --hs;\\n\\t\\t\\thull[hs++] = i;\\n\\t\\t}\\n\\t\\treturn hull.slice( 0, hs );\\n\\t}\\n\\tfunction d3_geom_hullOrder( a, b ) {\\n\\t\\treturn a[0] - b[0] || a[1] - b[1];\\n\\t}\\n\\td3.geom.polygon = function( coordinates ) {\\n\\t\\td3_subclass( coordinates, d3_geom_polygonPrototype );\\n\\t\\treturn coordinates;\\n\\t};\\n\\tvar d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\\n\\td3_geom_polygonPrototype.area = function() {\\n\\t\\tvar i = -1, n = this.length, a, b = this[n - 1], area = 0;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = this[i];\\n\\t\\t\\tarea += a[1] * b[0] - a[0] * b[1];\\n\\t\\t}\\n\\t\\treturn area * .5;\\n\\t};\\n\\td3_geom_polygonPrototype.centroid = function( k ) {\\n\\t\\tvar i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\\n\\t\\tif ( !arguments.length ) k = -1 / ( 6 * this.area() );\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\ta = b;\\n\\t\\t\\tb = this[i];\\n\\t\\t\\tc = a[0] * b[1] - b[0] * a[1];\\n\\t\\t\\tx += ( a[0] + b[0] ) * c;\\n\\t\\t\\ty += ( a[1] + b[1] ) * c;\\n\\t\\t}\\n\\t\\treturn [ x * k, y * k ];\\n\\t};\\n\\td3_geom_polygonPrototype.clip = function( subject ) {\\n\\t\\tvar input, closed = d3_geom_polygonClosed( subject ), i = -1, n = this.length - d3_geom_polygonClosed( this ), j, m, a = this[n - 1], b, c, d;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\tinput = subject.slice();\\n\\t\\t\\tsubject.length = 0;\\n\\t\\t\\tb = this[i];\\n\\t\\t\\tc = input[( m = input.length - closed ) - 1];\\n\\t\\t\\tj = -1;\\n\\t\\t\\twhile ( ++j < m ) {\\n\\t\\t\\t\\td = input[j];\\n\\t\\t\\t\\tif ( d3_geom_polygonInside( d, a, b ) ) {\\n\\t\\t\\t\\t\\tif ( !d3_geom_polygonInside( c, a, b ) ) {\\n\\t\\t\\t\\t\\t\\tsubject.push( d3_geom_polygonIntersect( c, d, a, b ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsubject.push( d );\\n\\t\\t\\t\\t} else if ( d3_geom_polygonInside( c, a, b ) ) {\\n\\t\\t\\t\\t\\tsubject.push( d3_geom_polygonIntersect( c, d, a, b ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tc = d;\\n\\t\\t\\t}\\n\\t\\t\\tif ( closed ) subject.push( subject[0] );\\n\\t\\t\\ta = b;\\n\\t\\t}\\n\\t\\treturn subject;\\n\\t};\\n\\tfunction d3_geom_polygonInside( p, a, b ) {\\n\\t\\treturn ( b[0] - a[0] ) * ( p[1] - a[1] ) < ( b[1] - a[1] ) * ( p[0] - a[0] );\\n\\t}\\n\\tfunction d3_geom_polygonIntersect( c, d, a, b ) {\\n\\t\\tvar x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = ( x43 * ( y1 - y3 ) - y43 * ( x1 - x3 ) ) / ( y43 * x21 - x43 * y21 );\\n\\t\\treturn [ x1 + ua * x21, y1 + ua * y21 ];\\n\\t}\\n\\tfunction d3_geom_polygonClosed( coordinates ) {\\n\\t\\tvar a = coordinates[0], b = coordinates[coordinates.length - 1];\\n\\t\\treturn !( a[0] - b[0] || a[1] - b[1] );\\n\\t}\\n\\tvar d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\\n\\tfunction d3_geom_voronoiBeach() {\\n\\t\\td3_geom_voronoiRedBlackNode( this );\\n\\t\\tthis.edge = this.site = this.circle = null;\\n\\t}\\n\\tfunction d3_geom_voronoiCreateBeach( site ) {\\n\\t\\tvar beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\\n\\t\\tbeach.site = site;\\n\\t\\treturn beach;\\n\\t}\\n\\tfunction d3_geom_voronoiDetachBeach( beach ) {\\n\\t\\td3_geom_voronoiDetachCircle( beach );\\n\\t\\td3_geom_voronoiBeaches.remove( beach );\\n\\t\\td3_geom_voronoiBeachPool.push( beach );\\n\\t\\td3_geom_voronoiRedBlackNode( beach );\\n\\t}\\n\\tfunction d3_geom_voronoiRemoveBeach( beach ) {\\n\\t\\tvar circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\\n\\t\\t\\t\\tx: x,\\n\\t\\t\\t\\ty: y\\n\\t\\t\\t}, previous = beach.P, next = beach.N, disappearing = [ beach ];\\n\\t\\td3_geom_voronoiDetachBeach( beach );\\n\\t\\tvar lArc = previous;\\n\\t\\twhile ( lArc.circle && abs( x - lArc.circle.x ) <  && abs( y - lArc.circle.cy ) <  ) {\\n\\t\\t\\tprevious = lArc.P;\\n\\t\\t\\tdisappearing.unshift( lArc );\\n\\t\\t\\td3_geom_voronoiDetachBeach( lArc );\\n\\t\\t\\tlArc = previous;\\n\\t\\t}\\n\\t\\tdisappearing.unshift( lArc );\\n\\t\\td3_geom_voronoiDetachCircle( lArc );\\n\\t\\tvar rArc = next;\\n\\t\\twhile ( rArc.circle && abs( x - rArc.circle.x ) <  && abs( y - rArc.circle.cy ) <  ) {\\n\\t\\t\\tnext = rArc.N;\\n\\t\\t\\tdisappearing.push( rArc );\\n\\t\\t\\td3_geom_voronoiDetachBeach( rArc );\\n\\t\\t\\trArc = next;\\n\\t\\t}\\n\\t\\tdisappearing.push( rArc );\\n\\t\\td3_geom_voronoiDetachCircle( rArc );\\n\\t\\tvar nArcs = disappearing.length, iArc;\\n\\t\\tfor ( iArc = 1; iArc < nArcs; ++iArc ) {\\n\\t\\t\\trArc = disappearing[iArc];\\n\\t\\t\\tlArc = disappearing[iArc - 1];\\n\\t\\t\\td3_geom_voronoiSetEdgeEnd( rArc.edge, lArc.site, rArc.site, vertex );\\n\\t\\t}\\n\\t\\tlArc = disappearing[0];\\n\\t\\trArc = disappearing[nArcs - 1];\\n\\t\\trArc.edge = d3_geom_voronoiCreateEdge( lArc.site, rArc.site, null, vertex );\\n\\t\\td3_geom_voronoiAttachCircle( lArc );\\n\\t\\td3_geom_voronoiAttachCircle( rArc );\\n\\t}\\n\\tfunction d3_geom_voronoiAddBeach( site ) {\\n\\t\\tvar x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\\n\\t\\twhile ( node ) {\\n\\t\\t\\tdxl = d3_geom_voronoiLeftBreakPoint( node, directrix ) - x;\\n\\t\\t\\tif ( dxl >  ) node = node.L; else {\\n\\t\\t\\t\\tdxr = x - d3_geom_voronoiRightBreakPoint( node, directrix );\\n\\t\\t\\t\\tif ( dxr >  ) {\\n\\t\\t\\t\\t\\tif ( !node.R ) {\\n\\t\\t\\t\\t\\t\\tlArc = node;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tnode = node.R;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( dxl > - ) {\\n\\t\\t\\t\\t\\t\\tlArc = node.P;\\n\\t\\t\\t\\t\\t\\trArc = node;\\n\\t\\t\\t\\t\\t} else if ( dxr > - ) {\\n\\t\\t\\t\\t\\t\\tlArc = node;\\n\\t\\t\\t\\t\\t\\trArc = node.N;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tlArc = rArc = node;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar newArc = d3_geom_voronoiCreateBeach( site );\\n\\t\\td3_geom_voronoiBeaches.insert( lArc, newArc );\\n\\t\\tif ( !lArc && !rArc ) return;\\n\\t\\tif ( lArc === rArc ) {\\n\\t\\t\\td3_geom_voronoiDetachCircle( lArc );\\n\\t\\t\\trArc = d3_geom_voronoiCreateBeach( lArc.site );\\n\\t\\t\\td3_geom_voronoiBeaches.insert( newArc, rArc );\\n\\t\\t\\tnewArc.edge = rArc.edge = d3_geom_voronoiCreateEdge( lArc.site, newArc.site );\\n\\t\\t\\td3_geom_voronoiAttachCircle( lArc );\\n\\t\\t\\td3_geom_voronoiAttachCircle( rArc );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tif ( !rArc ) {\\n\\t\\t\\tnewArc.edge = d3_geom_voronoiCreateEdge( lArc.site, newArc.site );\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\td3_geom_voronoiDetachCircle( lArc );\\n\\t\\td3_geom_voronoiDetachCircle( rArc );\\n\\t\\tvar lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * ( bx * cy - by * cx ), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\\n\\t\\t\\tx: ( cy * hb - by * hc ) / d + ax,\\n\\t\\t\\ty: ( bx * hc - cx * hb ) / d + ay\\n\\t\\t};\\n\\t\\td3_geom_voronoiSetEdgeEnd( rArc.edge, lSite, rSite, vertex );\\n\\t\\tnewArc.edge = d3_geom_voronoiCreateEdge( lSite, site, null, vertex );\\n\\t\\trArc.edge = d3_geom_voronoiCreateEdge( site, rSite, null, vertex );\\n\\t\\td3_geom_voronoiAttachCircle( lArc );\\n\\t\\td3_geom_voronoiAttachCircle( rArc );\\n\\t}\\n\\tfunction d3_geom_voronoiLeftBreakPoint( arc, directrix ) {\\n\\t\\tvar site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\\n\\t\\tif ( !pby2 ) return rfocx;\\n\\t\\tvar lArc = arc.P;\\n\\t\\tif ( !lArc ) return -Infinity;\\n\\t\\tsite = lArc.site;\\n\\t\\tvar lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\\n\\t\\tif ( !plby2 ) return lfocx;\\n\\t\\tvar hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\\n\\t\\tif ( aby2 ) return ( -b + Math.sqrt( b * b - 2 * aby2 * ( hl * hl / ( -2 * plby2 ) - lfocy + plby2 / 2 + rfocy - pby2 / 2 ) ) ) / aby2 + rfocx;\\n\\t\\treturn ( rfocx + lfocx ) / 2;\\n\\t}\\n\\tfunction d3_geom_voronoiRightBreakPoint( arc, directrix ) {\\n\\t\\tvar rArc = arc.N;\\n\\t\\tif ( rArc ) return d3_geom_voronoiLeftBreakPoint( rArc, directrix );\\n\\t\\tvar site = arc.site;\\n\\t\\treturn site.y === directrix ? site.x : Infinity;\\n\\t}\\n\\tfunction d3_geom_voronoiCell( site ) {\\n\\t\\tthis.site = site;\\n\\t\\tthis.edges = [];\\n\\t}\\n\\td3_geom_voronoiCell.prototype.prepare = function() {\\n\\t\\tvar halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\\n\\t\\twhile ( iHalfEdge-- ) {\\n\\t\\t\\tedge = halfEdges[iHalfEdge].edge;\\n\\t\\t\\tif ( !edge.b || !edge.a ) halfEdges.splice( iHalfEdge, 1 );\\n\\t\\t}\\n\\t\\thalfEdges.sort( d3_geom_voronoiHalfEdgeOrder );\\n\\t\\treturn halfEdges.length;\\n\\t};\\n\\tfunction d3_geom_voronoiCloseCells( extent ) {\\n\\t\\tvar x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\\n\\t\\twhile ( iCell-- ) {\\n\\t\\t\\tcell = cells[iCell];\\n\\t\\t\\tif ( !cell || !cell.prepare() ) continue;\\n\\t\\t\\thalfEdges = cell.edges;\\n\\t\\t\\tnHalfEdges = halfEdges.length;\\n\\t\\t\\tiHalfEdge = 0;\\n\\t\\t\\twhile ( iHalfEdge < nHalfEdges ) {\\n\\t\\t\\t\\tend = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\\n\\t\\t\\t\\tstart = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\\n\\t\\t\\t\\tif ( abs( x3 - x2 ) >  || abs( y3 - y2 ) >  ) {\\n\\t\\t\\t\\t\\thalfEdges.splice( iHalfEdge, 0, new d3_geom_voronoiHalfEdge( d3_geom_voronoiCreateBorderEdge( cell.site, end, abs( x3 - x0 ) <  && y1 - y3 >  ? {\\n\\t\\t\\t\\t\\t\\tx: x0,\\n\\t\\t\\t\\t\\t\\ty: abs( x2 - x0 ) <  ? y2 : y1\\n\\t\\t\\t\\t\\t} : abs( y3 - y1 ) <  && x1 - x3 >  ? {\\n\\t\\t\\t\\t\\t\\tx: abs( y2 - y1 ) <  ? x2 : x1,\\n\\t\\t\\t\\t\\t\\ty: y1\\n\\t\\t\\t\\t\\t} : abs( x3 - x1 ) <  && y3 - y0 >  ? {\\n\\t\\t\\t\\t\\t\\tx: x1,\\n\\t\\t\\t\\t\\t\\ty: abs( x2 - x1 ) <  ? y2 : y0\\n\\t\\t\\t\\t\\t} : abs( y3 - y0 ) <  && x3 - x0 >  ? {\\n\\t\\t\\t\\t\\t\\tx: abs( y2 - y0 ) <  ? x2 : x0,\\n\\t\\t\\t\\t\\t\\ty: y0\\n\\t\\t\\t\\t\\t} : null ), cell.site, null ) );\\n\\t\\t\\t\\t\\t++nHalfEdges;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_voronoiHalfEdgeOrder( a, b ) {\\n\\t\\treturn b.angle - a.angle;\\n\\t}\\n\\tfunction d3_geom_voronoiCircle() {\\n\\t\\td3_geom_voronoiRedBlackNode( this );\\n\\t\\tthis.x = this.y = this.arc = this.site = this.cy = null;\\n\\t}\\n\\tfunction d3_geom_voronoiAttachCircle( arc ) {\\n\\t\\tvar lArc = arc.P, rArc = arc.N;\\n\\t\\tif ( !lArc || !rArc ) return;\\n\\t\\tvar lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\\n\\t\\tif ( lSite === rSite ) return;\\n\\t\\tvar bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\\n\\t\\tvar d = 2 * ( ax * cy - ay * cx );\\n\\t\\tif ( d >= -2 ) return;\\n\\t\\tvar ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = ( cy * ha - ay * hc ) / d, y = ( ax * hc - cx * ha ) / d, cy = y + by;\\n\\t\\tvar circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\\n\\t\\tcircle.arc = arc;\\n\\t\\tcircle.site = cSite;\\n\\t\\tcircle.x = x + bx;\\n\\t\\tcircle.y = cy + Math.sqrt( x * x + y * y );\\n\\t\\tcircle.cy = cy;\\n\\t\\tarc.circle = circle;\\n\\t\\tvar before = null, node = d3_geom_voronoiCircles._;\\n\\t\\twhile ( node ) {\\n\\t\\t\\tif ( circle.y < node.y || circle.y === node.y && circle.x <= node.x ) {\\n\\t\\t\\t\\tif ( node.L ) node = node.L; else {\\n\\t\\t\\t\\t\\tbefore = node.P;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( node.R ) node = node.R; else {\\n\\t\\t\\t\\t\\tbefore = node;\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\td3_geom_voronoiCircles.insert( before, circle );\\n\\t\\tif ( !before ) d3_geom_voronoiFirstCircle = circle;\\n\\t}\\n\\tfunction d3_geom_voronoiDetachCircle( arc ) {\\n\\t\\tvar circle = arc.circle;\\n\\t\\tif ( circle ) {\\n\\t\\t\\tif ( !circle.P ) d3_geom_voronoiFirstCircle = circle.N;\\n\\t\\t\\td3_geom_voronoiCircles.remove( circle );\\n\\t\\t\\td3_geom_voronoiCirclePool.push( circle );\\n\\t\\t\\td3_geom_voronoiRedBlackNode( circle );\\n\\t\\t\\tarc.circle = null;\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_voronoiClipEdges( extent ) {\\n\\t\\tvar edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine( extent[0][0], extent[0][1], extent[1][0], extent[1][1] ), i = edges.length, e;\\n\\t\\twhile ( i-- ) {\\n\\t\\t\\te = edges[i];\\n\\t\\t\\tif ( !d3_geom_voronoiConnectEdge( e, extent ) || !clip( e ) || abs( e.a.x - e.b.x ) <  && abs( e.a.y - e.b.y ) <  ) {\\n\\t\\t\\t\\te.a = e.b = null;\\n\\t\\t\\t\\tedges.splice( i, 1 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_voronoiConnectEdge( edge, extent ) {\\n\\t\\tvar vb = edge.b;\\n\\t\\tif ( vb ) return true;\\n\\t\\tvar va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = ( lx + rx ) / 2, fy = ( ly + ry ) / 2, fm, fb;\\n\\t\\tif ( ry === ly ) {\\n\\t\\t\\tif ( fx < x0 || fx >= x1 ) return;\\n\\t\\t\\tif ( lx > rx ) {\\n\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\tx: fx,\\n\\t\\t\\t\\t\\ty: y0\\n\\t\\t\\t\\t}; else if ( va.y >= y1 ) return;\\n\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\tx: fx,\\n\\t\\t\\t\\t\\ty: y1\\n\\t\\t\\t\\t};\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\tx: fx,\\n\\t\\t\\t\\t\\ty: y1\\n\\t\\t\\t\\t}; else if ( va.y < y0 ) return;\\n\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\tx: fx,\\n\\t\\t\\t\\t\\ty: y0\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\tfm = ( lx - rx ) / ( ry - ly );\\n\\t\\t\\tfb = fy - fm * fx;\\n\\t\\t\\tif ( fm < -1 || fm > 1 ) {\\n\\t\\t\\t\\tif ( lx > rx ) {\\n\\t\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\t\\tx: ( y0 - fb ) / fm,\\n\\t\\t\\t\\t\\t\\ty: y0\\n\\t\\t\\t\\t\\t}; else if ( va.y >= y1 ) return;\\n\\t\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\t\\tx: ( y1 - fb ) / fm,\\n\\t\\t\\t\\t\\t\\ty: y1\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\t\\tx: ( y1 - fb ) / fm,\\n\\t\\t\\t\\t\\t\\ty: y1\\n\\t\\t\\t\\t\\t}; else if ( va.y < y0 ) return;\\n\\t\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\t\\tx: ( y0 - fb ) / fm,\\n\\t\\t\\t\\t\\t\\ty: y0\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( ly < ry ) {\\n\\t\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\t\\tx: x0,\\n\\t\\t\\t\\t\\t\\ty: fm * x0 + fb\\n\\t\\t\\t\\t\\t}; else if ( va.x >= x1 ) return;\\n\\t\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\t\\tx: x1,\\n\\t\\t\\t\\t\\t\\ty: fm * x1 + fb\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( !va ) va = {\\n\\t\\t\\t\\t\\t\\tx: x1,\\n\\t\\t\\t\\t\\t\\ty: fm * x1 + fb\\n\\t\\t\\t\\t\\t}; else if ( va.x < x0 ) return;\\n\\t\\t\\t\\t\\tvb = {\\n\\t\\t\\t\\t\\t\\tx: x0,\\n\\t\\t\\t\\t\\t\\ty: fm * x0 + fb\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tedge.a = va;\\n\\t\\tedge.b = vb;\\n\\t\\treturn true;\\n\\t}\\n\\tfunction d3_geom_voronoiEdge( lSite, rSite ) {\\n\\t\\tthis.l = lSite;\\n\\t\\tthis.r = rSite;\\n\\t\\tthis.a = this.b = null;\\n\\t}\\n\\tfunction d3_geom_voronoiCreateEdge( lSite, rSite, va, vb ) {\\n\\t\\tvar edge = new d3_geom_voronoiEdge( lSite, rSite );\\n\\t\\td3_geom_voronoiEdges.push( edge );\\n\\t\\tif ( va ) d3_geom_voronoiSetEdgeEnd( edge, lSite, rSite, va );\\n\\t\\tif ( vb ) d3_geom_voronoiSetEdgeEnd( edge, rSite, lSite, vb );\\n\\t\\td3_geom_voronoiCells[lSite.i].edges.push( new d3_geom_voronoiHalfEdge( edge, lSite, rSite ) );\\n\\t\\td3_geom_voronoiCells[rSite.i].edges.push( new d3_geom_voronoiHalfEdge( edge, rSite, lSite ) );\\n\\t\\treturn edge;\\n\\t}\\n\\tfunction d3_geom_voronoiCreateBorderEdge( lSite, va, vb ) {\\n\\t\\tvar edge = new d3_geom_voronoiEdge( lSite, null );\\n\\t\\tedge.a = va;\\n\\t\\tedge.b = vb;\\n\\t\\td3_geom_voronoiEdges.push( edge );\\n\\t\\treturn edge;\\n\\t}\\n\\tfunction d3_geom_voronoiSetEdgeEnd( edge, lSite, rSite, vertex ) {\\n\\t\\tif ( !edge.a && !edge.b ) {\\n\\t\\t\\tedge.a = vertex;\\n\\t\\t\\tedge.l = lSite;\\n\\t\\t\\tedge.r = rSite;\\n\\t\\t} else if ( edge.l === rSite ) {\\n\\t\\t\\tedge.b = vertex;\\n\\t\\t} else {\\n\\t\\t\\tedge.a = vertex;\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_voronoiHalfEdge( edge, lSite, rSite ) {\\n\\t\\tvar va = edge.a, vb = edge.b;\\n\\t\\tthis.edge = edge;\\n\\t\\tthis.site = lSite;\\n\\t\\tthis.angle = rSite ? Math.atan2( rSite.y - lSite.y, rSite.x - lSite.x ) : edge.l === lSite ? Math.atan2( vb.x - va.x, va.y - vb.y ) : Math.atan2( va.x - vb.x, vb.y - va.y );\\n\\t}\\n\\td3_geom_voronoiHalfEdge.prototype = {\\n\\t\\tstart: function() {\\n\\t\\t\\treturn this.edge.l === this.site ? this.edge.a : this.edge.b;\\n\\t\\t},\\n\\t\\tend: function() {\\n\\t\\t\\treturn this.edge.l === this.site ? this.edge.b : this.edge.a;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geom_voronoiRedBlackTree() {\\n\\t\\tthis._ = null;\\n\\t}\\n\\tfunction d3_geom_voronoiRedBlackNode( node ) {\\n\\t\\tnode.U = node.C = node.L = node.R = node.P = node.N = null;\\n\\t}\\n\\td3_geom_voronoiRedBlackTree.prototype = {\\n\\t\\tinsert: function( after, node ) {\\n\\t\\t\\tvar parent, grandpa, uncle;\\n\\t\\t\\tif ( after ) {\\n\\t\\t\\t\\tnode.P = after;\\n\\t\\t\\t\\tnode.N = after.N;\\n\\t\\t\\t\\tif ( after.N ) after.N.P = node;\\n\\t\\t\\t\\tafter.N = node;\\n\\t\\t\\t\\tif ( after.R ) {\\n\\t\\t\\t\\t\\tafter = after.R;\\n\\t\\t\\t\\t\\twhile ( after.L ) after = after.L;\\n\\t\\t\\t\\t\\tafter.L = node;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tafter.R = node;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparent = after;\\n\\t\\t\\t} else if ( this._ ) {\\n\\t\\t\\t\\tafter = d3_geom_voronoiRedBlackFirst( this._ );\\n\\t\\t\\t\\tnode.P = null;\\n\\t\\t\\t\\tnode.N = after;\\n\\t\\t\\t\\tafter.P = after.L = node;\\n\\t\\t\\t\\tparent = after;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tnode.P = node.N = null;\\n\\t\\t\\t\\tthis._ = node;\\n\\t\\t\\t\\tparent = null;\\n\\t\\t\\t}\\n\\t\\t\\tnode.L = node.R = null;\\n\\t\\t\\tnode.U = parent;\\n\\t\\t\\tnode.C = true;\\n\\t\\t\\tafter = node;\\n\\t\\t\\twhile ( parent && parent.C ) {\\n\\t\\t\\t\\tgrandpa = parent.U;\\n\\t\\t\\t\\tif ( parent === grandpa.L ) {\\n\\t\\t\\t\\t\\tuncle = grandpa.R;\\n\\t\\t\\t\\t\\tif ( uncle && uncle.C ) {\\n\\t\\t\\t\\t\\t\\tparent.C = uncle.C = false;\\n\\t\\t\\t\\t\\t\\tgrandpa.C = true;\\n\\t\\t\\t\\t\\t\\tafter = grandpa;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif ( after === parent.R ) {\\n\\t\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateLeft( this, parent );\\n\\t\\t\\t\\t\\t\\t\\tafter = parent;\\n\\t\\t\\t\\t\\t\\t\\tparent = after.U;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tparent.C = false;\\n\\t\\t\\t\\t\\t\\tgrandpa.C = true;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateRight( this, grandpa );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tuncle = grandpa.L;\\n\\t\\t\\t\\t\\tif ( uncle && uncle.C ) {\\n\\t\\t\\t\\t\\t\\tparent.C = uncle.C = false;\\n\\t\\t\\t\\t\\t\\tgrandpa.C = true;\\n\\t\\t\\t\\t\\t\\tafter = grandpa;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tif ( after === parent.L ) {\\n\\t\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateRight( this, parent );\\n\\t\\t\\t\\t\\t\\t\\tafter = parent;\\n\\t\\t\\t\\t\\t\\t\\tparent = after.U;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tparent.C = false;\\n\\t\\t\\t\\t\\t\\tgrandpa.C = true;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateLeft( this, grandpa );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tparent = after.U;\\n\\t\\t\\t}\\n\\t\\t\\tthis._.C = false;\\n\\t\\t},\\n\\t\\tremove: function( node ) {\\n\\t\\t\\tif ( node.N ) node.N.P = node.P;\\n\\t\\t\\tif ( node.P ) node.P.N = node.N;\\n\\t\\t\\tnode.N = node.P = null;\\n\\t\\t\\tvar parent = node.U, sibling, left = node.L, right = node.R, next, red;\\n\\t\\t\\tif ( !left ) next = right; else if ( !right ) next = left; else next = d3_geom_voronoiRedBlackFirst( right );\\n\\t\\t\\tif ( parent ) {\\n\\t\\t\\t\\tif ( parent.L === node ) parent.L = next; else parent.R = next;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tthis._ = next;\\n\\t\\t\\t}\\n\\t\\t\\tif ( left && right ) {\\n\\t\\t\\t\\tred = next.C;\\n\\t\\t\\t\\tnext.C = node.C;\\n\\t\\t\\t\\tnext.L = left;\\n\\t\\t\\t\\tleft.U = next;\\n\\t\\t\\t\\tif ( next !== right ) {\\n\\t\\t\\t\\t\\tparent = next.U;\\n\\t\\t\\t\\t\\tnext.U = node.U;\\n\\t\\t\\t\\t\\tnode = next.R;\\n\\t\\t\\t\\t\\tparent.L = node;\\n\\t\\t\\t\\t\\tnext.R = right;\\n\\t\\t\\t\\t\\tright.U = next;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnext.U = parent;\\n\\t\\t\\t\\t\\tparent = next;\\n\\t\\t\\t\\t\\tnode = next.R;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tred = node.C;\\n\\t\\t\\t\\tnode = next;\\n\\t\\t\\t}\\n\\t\\t\\tif ( node ) node.U = parent;\\n\\t\\t\\tif ( red ) return;\\n\\t\\t\\tif ( node && node.C ) {\\n\\t\\t\\t\\tnode.C = false;\\n\\t\\t\\t\\treturn;\\n\\t\\t\\t}\\n\\t\\t\\tdo {\\n\\t\\t\\t\\tif ( node === this._ ) break;\\n\\t\\t\\t\\tif ( node === parent.L ) {\\n\\t\\t\\t\\t\\tsibling = parent.R;\\n\\t\\t\\t\\t\\tif ( sibling.C ) {\\n\\t\\t\\t\\t\\t\\tsibling.C = false;\\n\\t\\t\\t\\t\\t\\tparent.C = true;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateLeft( this, parent );\\n\\t\\t\\t\\t\\t\\tsibling = parent.R;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( sibling.L && sibling.L.C || sibling.R && sibling.R.C ) {\\n\\t\\t\\t\\t\\t\\tif ( !sibling.R || !sibling.R.C ) {\\n\\t\\t\\t\\t\\t\\t\\tsibling.L.C = false;\\n\\t\\t\\t\\t\\t\\t\\tsibling.C = true;\\n\\t\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateRight( this, sibling );\\n\\t\\t\\t\\t\\t\\t\\tsibling = parent.R;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tsibling.C = parent.C;\\n\\t\\t\\t\\t\\t\\tparent.C = sibling.R.C = false;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateLeft( this, parent );\\n\\t\\t\\t\\t\\t\\tnode = this._;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsibling = parent.L;\\n\\t\\t\\t\\t\\tif ( sibling.C ) {\\n\\t\\t\\t\\t\\t\\tsibling.C = false;\\n\\t\\t\\t\\t\\t\\tparent.C = true;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateRight( this, parent );\\n\\t\\t\\t\\t\\t\\tsibling = parent.L;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( sibling.L && sibling.L.C || sibling.R && sibling.R.C ) {\\n\\t\\t\\t\\t\\t\\tif ( !sibling.L || !sibling.L.C ) {\\n\\t\\t\\t\\t\\t\\t\\tsibling.R.C = false;\\n\\t\\t\\t\\t\\t\\t\\tsibling.C = true;\\n\\t\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateLeft( this, sibling );\\n\\t\\t\\t\\t\\t\\t\\tsibling = parent.L;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tsibling.C = parent.C;\\n\\t\\t\\t\\t\\t\\tparent.C = sibling.L.C = false;\\n\\t\\t\\t\\t\\t\\td3_geom_voronoiRedBlackRotateRight( this, parent );\\n\\t\\t\\t\\t\\t\\tnode = this._;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsibling.C = true;\\n\\t\\t\\t\\tnode = parent;\\n\\t\\t\\t\\tparent = parent.U;\\n\\t\\t\\t} while ( !node.C );\\n\\t\\t\\tif ( node ) node.C = false;\\n\\t\\t}\\n\\t};\\n\\tfunction d3_geom_voronoiRedBlackRotateLeft( tree, node ) {\\n\\t\\tvar p = node, q = node.R, parent = p.U;\\n\\t\\tif ( parent ) {\\n\\t\\t\\tif ( parent.L === p ) parent.L = q; else parent.R = q;\\n\\t\\t} else {\\n\\t\\t\\ttree._ = q;\\n\\t\\t}\\n\\t\\tq.U = parent;\\n\\t\\tp.U = q;\\n\\t\\tp.R = q.L;\\n\\t\\tif ( p.R ) p.R.U = p;\\n\\t\\tq.L = p;\\n\\t}\\n\\tfunction d3_geom_voronoiRedBlackRotateRight( tree, node ) {\\n\\t\\tvar p = node, q = node.L, parent = p.U;\\n\\t\\tif ( parent ) {\\n\\t\\t\\tif ( parent.L === p ) parent.L = q; else parent.R = q;\\n\\t\\t} else {\\n\\t\\t\\ttree._ = q;\\n\\t\\t}\\n\\t\\tq.U = parent;\\n\\t\\tp.U = q;\\n\\t\\tp.L = q.R;\\n\\t\\tif ( p.L ) p.L.U = p;\\n\\t\\tq.R = p;\\n\\t}\\n\\tfunction d3_geom_voronoiRedBlackFirst( node ) {\\n\\t\\twhile ( node.L ) node = node.L;\\n\\t\\treturn node;\\n\\t}\\n\\tfunction d3_geom_voronoi( sites, bbox ) {\\n\\t\\tvar site = sites.sort( d3_geom_voronoiVertexOrder ).pop(), x0, y0, circle;\\n\\t\\td3_geom_voronoiEdges = [];\\n\\t\\td3_geom_voronoiCells = new Array( sites.length );\\n\\t\\td3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\\n\\t\\td3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\\n\\t\\twhile ( true ) {\\n\\t\\t\\tcircle = d3_geom_voronoiFirstCircle;\\n\\t\\t\\tif ( site && ( !circle || site.y < circle.y || site.y === circle.y && site.x < circle.x ) ) {\\n\\t\\t\\t\\tif ( site.x !== x0 || site.y !== y0 ) {\\n\\t\\t\\t\\t\\td3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell( site );\\n\\t\\t\\t\\t\\td3_geom_voronoiAddBeach( site );\\n\\t\\t\\t\\t\\tx0 = site.x, y0 = site.y;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsite = sites.pop();\\n\\t\\t\\t} else if ( circle ) {\\n\\t\\t\\t\\td3_geom_voronoiRemoveBeach( circle.arc );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( bbox ) d3_geom_voronoiClipEdges( bbox ), d3_geom_voronoiCloseCells( bbox );\\n\\t\\tvar diagram = {\\n\\t\\t\\tcells: d3_geom_voronoiCells,\\n\\t\\t\\tedges: d3_geom_voronoiEdges\\n\\t\\t};\\n\\t\\td3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\\n\\t\\treturn diagram;\\n\\t}\\n\\tfunction d3_geom_voronoiVertexOrder( a, b ) {\\n\\t\\treturn b.y - a.y || b.x - a.x;\\n\\t}\\n\\td3.geom.voronoi = function( points ) {\\n\\t\\tvar x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\\n\\t\\tif ( points ) return voronoi( points );\\n\\t\\tfunction voronoi( data ) {\\n\\t\\t\\tvar polygons = new Array( data.length ), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\\n\\t\\t\\td3_geom_voronoi( sites( data ), clipExtent ).cells.forEach( function( cell, i ) {\\n\\t\\t\\t\\tvar edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map( function( e ) {\\n\\t\\t\\t\\t\\tvar s = e.start();\\n\\t\\t\\t\\t\\treturn [ s.x, s.y ];\\n\\t\\t\\t\\t} ) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\\n\\t\\t\\t\\tpolygon.point = data[i];\\n\\t\\t\\t} );\\n\\t\\t\\treturn polygons;\\n\\t\\t}\\n\\t\\tfunction sites( data ) {\\n\\t\\t\\treturn data.map( function( d, i ) {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tx: Math.round( fx( d, i ) /  ) * ,\\n\\t\\t\\t\\t\\ty: Math.round( fy( d, i ) /  ) * ,\\n\\t\\t\\t\\t\\ti: i\\n\\t\\t\\t\\t};\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tvoronoi.links = function( data ) {\\n\\t\\t\\treturn d3_geom_voronoi( sites( data ) ).edges.filter( function( edge ) {\\n\\t\\t\\t\\treturn edge.l && edge.r;\\n\\t\\t\\t} ).map( function( edge ) {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tsource: data[edge.l.i],\\n\\t\\t\\t\\t\\ttarget: data[edge.r.i]\\n\\t\\t\\t\\t};\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tvoronoi.triangles = function( data ) {\\n\\t\\t\\tvar triangles = [];\\n\\t\\t\\td3_geom_voronoi( sites( data ) ).cells.forEach( function( cell, i ) {\\n\\t\\t\\t\\tvar site = cell.site, edges = cell.edges.sort( d3_geom_voronoiHalfEdgeOrder ), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\\n\\t\\t\\t\\twhile ( ++j < m ) {\\n\\t\\t\\t\\t\\te0 = e1;\\n\\t\\t\\t\\t\\ts0 = s1;\\n\\t\\t\\t\\t\\te1 = edges[j].edge;\\n\\t\\t\\t\\t\\ts1 = e1.l === site ? e1.r : e1.l;\\n\\t\\t\\t\\t\\tif ( i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea( site, s0, s1 ) < 0 ) {\\n\\t\\t\\t\\t\\t\\ttriangles.push( [ data[i], data[s0.i], data[s1.i] ] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\treturn triangles;\\n\\t\\t};\\n\\t\\tvoronoi.x = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( fx = d3_functor( x = _ ), voronoi ) : x;\\n\\t\\t};\\n\\t\\tvoronoi.y = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( fy = d3_functor( y = _ ), voronoi ) : y;\\n\\t\\t};\\n\\t\\tvoronoi.clipExtent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\\n\\t\\t\\tclipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\\n\\t\\t\\treturn voronoi;\\n\\t\\t};\\n\\t\\tvoronoi.size = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\\n\\t\\t\\treturn voronoi.clipExtent( _ && [ [ 0, 0 ], _ ] );\\n\\t\\t};\\n\\t\\treturn voronoi;\\n\\t};\\n\\tvar d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\\n\\tfunction d3_geom_voronoiTriangleArea( a, b, c ) {\\n\\t\\treturn ( a.x - c.x ) * ( b.y - a.y ) - ( a.x - b.x ) * ( c.y - a.y );\\n\\t}\\n\\td3.geom.delaunay = function( vertices ) {\\n\\t\\treturn d3.geom.voronoi().triangles( vertices );\\n\\t};\\n\\td3.geom.quadtree = function( points, x1, y1, x2, y2 ) {\\n\\t\\tvar x = d3_geom_pointX, y = d3_geom_pointY, compat;\\n\\t\\tif ( compat = arguments.length ) {\\n\\t\\t\\tx = d3_geom_quadtreeCompatX;\\n\\t\\t\\ty = d3_geom_quadtreeCompatY;\\n\\t\\t\\tif ( compat === 3 ) {\\n\\t\\t\\t\\ty2 = y1;\\n\\t\\t\\t\\tx2 = x1;\\n\\t\\t\\t\\ty1 = x1 = 0;\\n\\t\\t\\t}\\n\\t\\t\\treturn quadtree( points );\\n\\t\\t}\\n\\t\\tfunction quadtree( data ) {\\n\\t\\t\\tvar d, fx = d3_functor( x ), fy = d3_functor( y ), xs, ys, i, n, x1_, y1_, x2_, y2_;\\n\\t\\t\\tif ( x1 != null ) {\\n\\t\\t\\t\\tx1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tx2_ = y2_ = -( x1_ = y1_ = Infinity );\\n\\t\\t\\t\\txs = [], ys = [];\\n\\t\\t\\t\\tn = data.length;\\n\\t\\t\\t\\tif ( compat ) for ( i = 0; i < n; ++i ) {\\n\\t\\t\\t\\t\\td = data[i];\\n\\t\\t\\t\\t\\tif ( d.x < x1_ ) x1_ = d.x;\\n\\t\\t\\t\\t\\tif ( d.y < y1_ ) y1_ = d.y;\\n\\t\\t\\t\\t\\tif ( d.x > x2_ ) x2_ = d.x;\\n\\t\\t\\t\\t\\tif ( d.y > y2_ ) y2_ = d.y;\\n\\t\\t\\t\\t\\txs.push( d.x );\\n\\t\\t\\t\\t\\tys.push( d.y );\\n\\t\\t\\t\\t} else for ( i = 0; i < n; ++i ) {\\n\\t\\t\\t\\t\\tvar x_ = +fx( d = data[i], i ), y_ = +fy( d, i );\\n\\t\\t\\t\\t\\tif ( x_ < x1_ ) x1_ = x_;\\n\\t\\t\\t\\t\\tif ( y_ < y1_ ) y1_ = y_;\\n\\t\\t\\t\\t\\tif ( x_ > x2_ ) x2_ = x_;\\n\\t\\t\\t\\t\\tif ( y_ > y2_ ) y2_ = y_;\\n\\t\\t\\t\\t\\txs.push( x_ );\\n\\t\\t\\t\\t\\tys.push( y_ );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvar dx = x2_ - x1_, dy = y2_ - y1_;\\n\\t\\t\\tif ( dx > dy ) y2_ = y1_ + dx; else x2_ = x1_ + dy;\\n\\t\\t\\tfunction insert( n, d, x, y, x1, y1, x2, y2 ) {\\n\\t\\t\\t\\tif ( isNaN( x ) || isNaN( y ) ) return;\\n\\t\\t\\t\\tif ( n.leaf ) {\\n\\t\\t\\t\\t\\tvar nx = n.x, ny = n.y;\\n\\t\\t\\t\\t\\tif ( nx != null ) {\\n\\t\\t\\t\\t\\t\\tif ( abs( nx - x ) + abs( ny - y ) < .01 ) {\\n\\t\\t\\t\\t\\t\\t\\tinsertChild( n, d, x, y, x1, y1, x2, y2 );\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tvar nPoint = n.point;\\n\\t\\t\\t\\t\\t\\t\\tn.x = n.y = n.point = null;\\n\\t\\t\\t\\t\\t\\t\\tinsertChild( n, nPoint, nx, ny, x1, y1, x2, y2 );\\n\\t\\t\\t\\t\\t\\t\\tinsertChild( n, d, x, y, x1, y1, x2, y2 );\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tn.x = x, n.y = y, n.point = d;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tinsertChild( n, d, x, y, x1, y1, x2, y2 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction insertChild( n, d, x, y, x1, y1, x2, y2 ) {\\n\\t\\t\\t\\tvar xm = ( x1 + x2 ) * .5, ym = ( y1 + y2 ) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\\n\\t\\t\\t\\tn.leaf = false;\\n\\t\\t\\t\\tn = n.nodes[i] || ( n.nodes[i] = d3_geom_quadtreeNode() );\\n\\t\\t\\t\\tif ( right ) x1 = xm; else x2 = xm;\\n\\t\\t\\t\\tif ( below ) y1 = ym; else y2 = ym;\\n\\t\\t\\t\\tinsert( n, d, x, y, x1, y1, x2, y2 );\\n\\t\\t\\t}\\n\\t\\t\\tvar root = d3_geom_quadtreeNode();\\n\\t\\t\\troot.add = function( d ) {\\n\\t\\t\\t\\tinsert( root, d, +fx( d, ++i ), +fy( d, i ), x1_, y1_, x2_, y2_ );\\n\\t\\t\\t};\\n\\t\\t\\troot.visit = function( f ) {\\n\\t\\t\\t\\td3_geom_quadtreeVisit( f, root, x1_, y1_, x2_, y2_ );\\n\\t\\t\\t};\\n\\t\\t\\troot.find = function( point ) {\\n\\t\\t\\t\\treturn d3_geom_quadtreeFind( root, point[0], point[1], x1_, y1_, x2_, y2_ );\\n\\t\\t\\t};\\n\\t\\t\\ti = -1;\\n\\t\\t\\tif ( x1 == null ) {\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\tinsert( root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_ );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t--i;\\n\\t\\t\\t} else data.forEach( root.add );\\n\\t\\t\\txs = ys = data = d = null;\\n\\t\\t\\treturn root;\\n\\t\\t}\\n\\t\\tquadtree.x = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( x = _, quadtree ) : x;\\n\\t\\t};\\n\\t\\tquadtree.y = function( _ ) {\\n\\t\\t\\treturn arguments.length ? ( y = _, quadtree ) : y;\\n\\t\\t};\\n\\t\\tquadtree.extent = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\\n\\t\\t\\tif ( _ == null ) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0],\\n\\t\\t\\ty2 = +_[1][1];\\n\\t\\t\\treturn quadtree;\\n\\t\\t};\\n\\t\\tquadtree.size = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\\n\\t\\t\\tif ( _ == null ) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\\n\\t\\t\\treturn quadtree;\\n\\t\\t};\\n\\t\\treturn quadtree;\\n\\t};\\n\\tfunction d3_geom_quadtreeCompatX( d ) {\\n\\t\\treturn d.x;\\n\\t}\\n\\tfunction d3_geom_quadtreeCompatY( d ) {\\n\\t\\treturn d.y;\\n\\t}\\n\\tfunction d3_geom_quadtreeNode() {\\n\\t\\treturn {\\n\\t\\t\\tleaf: true,\\n\\t\\t\\tnodes: [],\\n\\t\\t\\tpoint: null,\\n\\t\\t\\tx: null,\\n\\t\\t\\ty: null\\n\\t\\t};\\n\\t}\\n\\tfunction d3_geom_quadtreeVisit( f, node, x1, y1, x2, y2 ) {\\n\\t\\tif ( !f( node, x1, y1, x2, y2 ) ) {\\n\\t\\t\\tvar sx = ( x1 + x2 ) * .5, sy = ( y1 + y2 ) * .5, children = node.nodes;\\n\\t\\t\\tif ( children[0] ) d3_geom_quadtreeVisit( f, children[0], x1, y1, sx, sy );\\n\\t\\t\\tif ( children[1] ) d3_geom_quadtreeVisit( f, children[1], sx, y1, x2, sy );\\n\\t\\t\\tif ( children[2] ) d3_geom_quadtreeVisit( f, children[2], x1, sy, sx, y2 );\\n\\t\\t\\tif ( children[3] ) d3_geom_quadtreeVisit( f, children[3], sx, sy, x2, y2 );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_geom_quadtreeFind( root, x, y, x0, y0, x3, y3 ) {\\n\\t\\tvar minDistance2 = Infinity, closestPoint;\\n\\t\\t( function find( node, x1, y1, x2, y2 ) {\\n\\t\\t\\tif ( x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0 ) return;\\n\\t\\t\\tif ( point = node.point ) {\\n\\t\\t\\t\\tvar point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\\n\\t\\t\\t\\tif ( distance2 < minDistance2 ) {\\n\\t\\t\\t\\t\\tvar distance = Math.sqrt( minDistance2 = distance2 );\\n\\t\\t\\t\\t\\tx0 = x - distance, y0 = y - distance;\\n\\t\\t\\t\\t\\tx3 = x + distance, y3 = y + distance;\\n\\t\\t\\t\\t\\tclosestPoint = point;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tvar children = node.nodes, xm = ( x1 + x2 ) * .5, ym = ( y1 + y2 ) * .5, right = x >= xm, below = y >= ym;\\n\\t\\t\\tfor ( var i = below << 1 | right, j = i + 4; i < j; ++i ) {\\n\\t\\t\\t\\tif ( node = children[i & 3] ) switch ( i & 3 ) {\\n\\t\\t\\t\\tcase 0:\\n\\t\\t\\t\\t\\tfind( node, x1, y1, xm, ym );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 1:\\n\\t\\t\\t\\t\\tfind( node, xm, y1, x2, ym );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 2:\\n\\t\\t\\t\\t\\tfind( node, x1, ym, xm, y2 );\\n\\t\\t\\t\\t\\tbreak;\\n\\n\\t\\t\\t\\tcase 3:\\n\\t\\t\\t\\t\\tfind( node, xm, ym, x2, y2 );\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t} )( root, x0, y0, x3, y3 );\\n\\t\\treturn closestPoint;\\n\\t}\\n\\td3.interpolateRgb = d3_interpolateRgb;\\n\\tfunction d3_interpolateRgb( a, b ) {\\n\\t\\ta = d3.rgb( a );\\n\\t\\tb = d3.rgb( b );\\n\\t\\tvar ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn \\\"#\\\" + d3_rgb_hex( Math.round( ar + br * t ) ) + d3_rgb_hex( Math.round( ag + bg * t ) ) + d3_rgb_hex( Math.round( ab + bb * t ) );\\n\\t\\t};\\n\\t}\\n\\td3.interpolateObject = d3_interpolateObject;\\n\\tfunction d3_interpolateObject( a, b ) {\\n\\t\\tvar i = {}, c = {}, k;\\n\\t\\tfor ( k in a ) {\\n\\t\\t\\tif ( k in b ) {\\n\\t\\t\\t\\ti[k] = d3_interpolate( a[k], b[k] );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tc[k] = a[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfor ( k in b ) {\\n\\t\\t\\tif ( !( k in a ) ) {\\n\\t\\t\\t\\tc[k] = b[k];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn function( t ) {\\n\\t\\t\\tfor ( k in i ) c[k] = i[k]( t );\\n\\t\\t\\treturn c;\\n\\t\\t};\\n\\t}\\n\\td3.interpolateNumber = d3_interpolateNumber;\\n\\tfunction d3_interpolateNumber( a, b ) {\\n\\t\\ta = +a, b = +b;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn a * ( 1 - t ) + b * t;\\n\\t\\t};\\n\\t}\\n\\td3.interpolateString = d3_interpolateString;\\n\\tfunction d3_interpolateString( a, b ) {\\n\\t\\tvar bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\\n\\t\\ta = a + \\\"\\\", b = b + \\\"\\\";\\n\\t\\twhile ( ( am = d3_interpolate_numberA.exec( a ) ) && ( bm = d3_interpolate_numberB.exec( b ) ) ) {\\n\\t\\t\\tif ( ( bs = bm.index ) > bi ) {\\n\\t\\t\\t\\tbs = b.slice( bi, bs );\\n\\t\\t\\t\\tif ( s[i] ) s[i] += bs; else s[++i] = bs;\\n\\t\\t\\t}\\n\\t\\t\\tif ( ( am = am[0] ) === ( bm = bm[0] ) ) {\\n\\t\\t\\t\\tif ( s[i] ) s[i] += bm; else s[++i] = bm;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ts[++i] = null;\\n\\t\\t\\t\\tq.push( {\\n\\t\\t\\t\\t\\ti: i,\\n\\t\\t\\t\\t\\tx: d3_interpolateNumber( am, bm )\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\tbi = d3_interpolate_numberB.lastIndex;\\n\\t\\t}\\n\\t\\tif ( bi < b.length ) {\\n\\t\\t\\tbs = b.slice( bi );\\n\\t\\t\\tif ( s[i] ) s[i] += bs; else s[++i] = bs;\\n\\t\\t}\\n\\t\\treturn s.length < 2 ? q[0] ? ( b = q[0].x, function( t ) {\\n\\t\\t\\treturn b( t ) + \\\"\\\";\\n\\t\\t} ) : function() {\\n\\t\\t\\treturn b;\\n\\t\\t} : ( b = q.length, function( t ) {\\n\\t\\t\\tfor ( var i = 0, o; i < b; ++i ) s[( o = q[i] ).i] = o.x( t );\\n\\t\\t\\treturn s.join( \\\"\\\" );\\n\\t\\t} );\\n\\t}\\n\\tvar d3_interpolate_numberA = /[-+]?(?:\\\\d+\\\\.?\\\\d*|\\\\.?\\\\d+)(?:[eE][-+]?\\\\d+)?/g, d3_interpolate_numberB = new RegExp( d3_interpolate_numberA.source, \\\"g\\\" );\\n\\td3.interpolate = d3_interpolate;\\n\\tfunction d3_interpolate( a, b ) {\\n\\t\\tvar i = d3.interpolators.length, f;\\n\\t\\twhile ( --i >= 0 && !( f = d3.interpolators[i]( a, b ) ) ) ;\\n\\t\\treturn f;\\n\\t}\\n\\td3.interpolators = [ function( a, b ) {\\n\\t\\tvar t = typeof b;\\n\\t\\treturn ( t === \\\"string\\\" ? d3_rgb_names.has( b.toLowerCase() ) || /^(#|rgb\\\\(|hsl\\\\()/i.test( b ) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray( b ) ? d3_interpolateArray : t === \\\"object\\\" && isNaN( b ) ? d3_interpolateObject : d3_interpolateNumber )( a, b );\\n\\t} ];\\n\\td3.interpolateArray = d3_interpolateArray;\\n\\tfunction d3_interpolateArray( a, b ) {\\n\\t\\tvar x = [], c = [], na = a.length, nb = b.length, n0 = Math.min( a.length, b.length ), i;\\n\\t\\tfor ( i = 0; i < n0; ++i ) x.push( d3_interpolate( a[i], b[i] ) );\\n\\t\\tfor ( ;i < na; ++i ) c[i] = a[i];\\n\\t\\tfor ( ;i < nb; ++i ) c[i] = b[i];\\n\\t\\treturn function( t ) {\\n\\t\\t\\tfor ( i = 0; i < n0; ++i ) c[i] = x[i]( t );\\n\\t\\t\\treturn c;\\n\\t\\t};\\n\\t}\\n\\tvar d3_ease_default = function() {\\n\\t\\treturn d3_identity;\\n\\t};\\n\\tvar d3_ease = d3.map( {\\n\\t\\tlinear: d3_ease_default,\\n\\t\\tpoly: d3_ease_poly,\\n\\t\\tquad: function() {\\n\\t\\t\\treturn d3_ease_quad;\\n\\t\\t},\\n\\t\\tcubic: function() {\\n\\t\\t\\treturn d3_ease_cubic;\\n\\t\\t},\\n\\t\\tsin: function() {\\n\\t\\t\\treturn d3_ease_sin;\\n\\t\\t},\\n\\t\\texp: function() {\\n\\t\\t\\treturn d3_ease_exp;\\n\\t\\t},\\n\\t\\tcircle: function() {\\n\\t\\t\\treturn d3_ease_circle;\\n\\t\\t},\\n\\t\\telastic: d3_ease_elastic,\\n\\t\\tback: d3_ease_back,\\n\\t\\tbounce: function() {\\n\\t\\t\\treturn d3_ease_bounce;\\n\\t\\t}\\n\\t} );\\n\\tvar d3_ease_mode = d3.map( {\\n\\t\\t\\\"in\\\": d3_identity,\\n\\t\\tout: d3_ease_reverse,\\n\\t\\t\\\"in-out\\\": d3_ease_reflect,\\n\\t\\t\\\"out-in\\\": function( f ) {\\n\\t\\t\\treturn d3_ease_reflect( d3_ease_reverse( f ) );\\n\\t\\t}\\n\\t} );\\n\\td3.ease = function( name ) {\\n\\t\\tvar i = name.indexOf( \\\"-\\\" ), t = i >= 0 ? name.slice( 0, i ) : name, m = i >= 0 ? name.slice( i + 1 ) : \\\"in\\\";\\n\\t\\tt = d3_ease.get( t ) || d3_ease_default;\\n\\t\\tm = d3_ease_mode.get( m ) || d3_identity;\\n\\t\\treturn d3_ease_clamp( m( t.apply( null, d3_arraySlice.call( arguments, 1 ) ) ) );\\n\\t};\\n\\tfunction d3_ease_clamp( f ) {\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn t <= 0 ? 0 : t >= 1 ? 1 : f( t );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_reverse( f ) {\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn 1 - f( 1 - t );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_reflect( f ) {\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn .5 * ( t < .5 ? f( 2 * t ) : 2 - f( 2 - 2 * t ) );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_quad( t ) {\\n\\t\\treturn t * t;\\n\\t}\\n\\tfunction d3_ease_cubic( t ) {\\n\\t\\treturn t * t * t;\\n\\t}\\n\\tfunction d3_ease_cubicInOut( t ) {\\n\\t\\tif ( t <= 0 ) return 0;\\n\\t\\tif ( t >= 1 ) return 1;\\n\\t\\tvar t2 = t * t, t3 = t2 * t;\\n\\t\\treturn 4 * ( t < .5 ? t3 : 3 * ( t - t2 ) + t3 - .75 );\\n\\t}\\n\\tfunction d3_ease_poly( e ) {\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn Math.pow( t, e );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_sin( t ) {\\n\\t\\treturn 1 - Math.cos( t * half );\\n\\t}\\n\\tfunction d3_ease_exp( t ) {\\n\\t\\treturn Math.pow( 2, 10 * ( t - 1 ) );\\n\\t}\\n\\tfunction d3_ease_circle( t ) {\\n\\t\\treturn 1 - Math.sqrt( 1 - t * t );\\n\\t}\\n\\tfunction d3_ease_elastic( a, p ) {\\n\\t\\tvar s;\\n\\t\\tif ( arguments.length < 2 ) p = .45;\\n\\t\\tif ( arguments.length ) s = p /  * Math.asin( 1 / a ); else a = 1, s = p / 4;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn 1 + a * Math.pow( 2, -10 * t ) * Math.sin( ( t - s ) *  / p );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_back( s ) {\\n\\t\\tif ( !s ) s = 1.70158;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn t * t * ( ( s + 1 ) * t - s );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_ease_bounce( t ) {\\n\\t\\treturn t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * ( t -= 1.5 / 2.75 ) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * ( t -= 2.25 / 2.75 ) * t + .9375 : 7.5625 * ( t -= 2.625 / 2.75 ) * t + .984375;\\n\\t}\\n\\td3.interpolateHcl = d3_interpolateHcl;\\n\\tfunction d3_interpolateHcl( a, b ) {\\n\\t\\ta = d3.hcl( a );\\n\\t\\tb = d3.hcl( b );\\n\\t\\tvar ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\\n\\t\\tif ( isNaN( bc ) ) bc = 0, ac = isNaN( ac ) ? b.c : ac;\\n\\t\\tif ( isNaN( bh ) ) bh = 0, ah = isNaN( ah ) ? b.h : ah; else if ( bh > 180 ) bh -= 360; else if ( bh < -180 ) bh += 360;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn d3_hcl_lab( ah + bh * t, ac + bc * t, al + bl * t ) + \\\"\\\";\\n\\t\\t};\\n\\t}\\n\\td3.interpolateHsl = d3_interpolateHsl;\\n\\tfunction d3_interpolateHsl( a, b ) {\\n\\t\\ta = d3.hsl( a );\\n\\t\\tb = d3.hsl( b );\\n\\t\\tvar ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\\n\\t\\tif ( isNaN( bs ) ) bs = 0, as = isNaN( as ) ? b.s : as;\\n\\t\\tif ( isNaN( bh ) ) bh = 0, ah = isNaN( ah ) ? b.h : ah; else if ( bh > 180 ) bh -= 360; else if ( bh < -180 ) bh += 360;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn d3_hsl_rgb( ah + bh * t, as + bs * t, al + bl * t ) + \\\"\\\";\\n\\t\\t};\\n\\t}\\n\\td3.interpolateLab = d3_interpolateLab;\\n\\tfunction d3_interpolateLab( a, b ) {\\n\\t\\ta = d3.lab( a );\\n\\t\\tb = d3.lab( b );\\n\\t\\tvar al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn d3_lab_rgb( al + bl * t, aa + ba * t, ab + bb * t ) + \\\"\\\";\\n\\t\\t};\\n\\t}\\n\\td3.interpolateRound = d3_interpolateRound;\\n\\tfunction d3_interpolateRound( a, b ) {\\n\\t\\tb -= a;\\n\\t\\treturn function( t ) {\\n\\t\\t\\treturn Math.round( a + b * t );\\n\\t\\t};\\n\\t}\\n\\td3.transform = function( string ) {\\n\\t\\tvar g = d3_document.createElementNS( d3.ns.prefix.svg, \\\"g\\\" );\\n\\t\\treturn ( d3.transform = function( string ) {\\n\\t\\t\\tif ( string != null ) {\\n\\t\\t\\t\\tg.setAttribute( \\\"transform\\\", string );\\n\\t\\t\\t\\tvar t = g.transform.baseVal.consolidate();\\n\\t\\t\\t}\\n\\t\\t\\treturn new d3_transform( t ? t.matrix : d3_transformIdentity );\\n\\t\\t} )( string );\\n\\t};\\n\\tfunction d3_transform( m ) {\\n\\t\\tvar r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize( r0 ), kz = d3_transformDot( r0, r1 ), ky = d3_transformNormalize( d3_transformCombine( r1, r0, -kz ) ) || 0;\\n\\t\\tif ( r0[0] * r1[1] < r1[0] * r0[1] ) {\\n\\t\\t\\tr0[0] *= -1;\\n\\t\\t\\tr0[1] *= -1;\\n\\t\\t\\tkx *= -1;\\n\\t\\t\\tkz *= -1;\\n\\t\\t}\\n\\t\\tthis.rotate = ( kx ? Math.atan2( r0[1], r0[0] ) : Math.atan2( -r1[0], r1[1] ) ) * d3_degrees;\\n\\t\\tthis.translate = [ m.e, m.f ];\\n\\t\\tthis.scale = [ kx, ky ];\\n\\t\\tthis.skew = ky ? Math.atan2( kz, ky ) * d3_degrees : 0;\\n\\t}\\n\\td3_transform.prototype.toString = function() {\\n\\t\\treturn \\\"translate(\\\" + this.translate + \\\")rotate(\\\" + this.rotate + \\\")skewX(\\\" + this.skew + \\\")scale(\\\" + this.scale + \\\")\\\";\\n\\t};\\n\\tfunction d3_transformDot( a, b ) {\\n\\t\\treturn a[0] * b[0] + a[1] * b[1];\\n\\t}\\n\\tfunction d3_transformNormalize( a ) {\\n\\t\\tvar k = Math.sqrt( d3_transformDot( a, a ) );\\n\\t\\tif ( k ) {\\n\\t\\t\\ta[0] /= k;\\n\\t\\t\\ta[1] /= k;\\n\\t\\t}\\n\\t\\treturn k;\\n\\t}\\n\\tfunction d3_transformCombine( a, b, k ) {\\n\\t\\ta[0] += k * b[0];\\n\\t\\ta[1] += k * b[1];\\n\\t\\treturn a;\\n\\t}\\n\\tvar d3_transformIdentity = {\\n\\t\\ta: 1,\\n\\t\\tb: 0,\\n\\t\\tc: 0,\\n\\t\\td: 1,\\n\\t\\te: 0,\\n\\t\\tf: 0\\n\\t};\\n\\td3.interpolateTransform = d3_interpolateTransform;\\n\\tfunction d3_interpolateTransformPop( s ) {\\n\\t\\treturn s.length ? s.pop() + \\\",\\\" : \\\"\\\";\\n\\t}\\n\\tfunction d3_interpolateTranslate( ta, tb, s, q ) {\\n\\t\\tif ( ta[0] !== tb[0] || ta[1] !== tb[1] ) {\\n\\t\\t\\tvar i = s.push( \\\"translate(\\\", null, \\\",\\\", null, \\\")\\\" );\\n\\t\\t\\tq.push( {\\n\\t\\t\\t\\ti: i - 4,\\n\\t\\t\\t\\tx: d3_interpolateNumber( ta[0], tb[0] )\\n\\t\\t\\t}, {\\n\\t\\t\\t\\ti: i - 2,\\n\\t\\t\\t\\tx: d3_interpolateNumber( ta[1], tb[1] )\\n\\t\\t\\t} );\\n\\t\\t} else if ( tb[0] || tb[1] ) {\\n\\t\\t\\ts.push( \\\"translate(\\\" + tb + \\\")\\\" );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_interpolateRotate( ra, rb, s, q ) {\\n\\t\\tif ( ra !== rb ) {\\n\\t\\t\\tif ( ra - rb > 180 ) rb += 360; else if ( rb - ra > 180 ) ra += 360;\\n\\t\\t\\tq.push( {\\n\\t\\t\\t\\ti: s.push( d3_interpolateTransformPop( s ) + \\\"rotate(\\\", null, \\\")\\\" ) - 2,\\n\\t\\t\\t\\tx: d3_interpolateNumber( ra, rb )\\n\\t\\t\\t} );\\n\\t\\t} else if ( rb ) {\\n\\t\\t\\ts.push( d3_interpolateTransformPop( s ) + \\\"rotate(\\\" + rb + \\\")\\\" );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_interpolateSkew( wa, wb, s, q ) {\\n\\t\\tif ( wa !== wb ) {\\n\\t\\t\\tq.push( {\\n\\t\\t\\t\\ti: s.push( d3_interpolateTransformPop( s ) + \\\"skewX(\\\", null, \\\")\\\" ) - 2,\\n\\t\\t\\t\\tx: d3_interpolateNumber( wa, wb )\\n\\t\\t\\t} );\\n\\t\\t} else if ( wb ) {\\n\\t\\t\\ts.push( d3_interpolateTransformPop( s ) + \\\"skewX(\\\" + wb + \\\")\\\" );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_interpolateScale( ka, kb, s, q ) {\\n\\t\\tif ( ka[0] !== kb[0] || ka[1] !== kb[1] ) {\\n\\t\\t\\tvar i = s.push( d3_interpolateTransformPop( s ) + \\\"scale(\\\", null, \\\",\\\", null, \\\")\\\" );\\n\\t\\t\\tq.push( {\\n\\t\\t\\t\\ti: i - 4,\\n\\t\\t\\t\\tx: d3_interpolateNumber( ka[0], kb[0] )\\n\\t\\t\\t}, {\\n\\t\\t\\t\\ti: i - 2,\\n\\t\\t\\t\\tx: d3_interpolateNumber( ka[1], kb[1] )\\n\\t\\t\\t} );\\n\\t\\t} else if ( kb[0] !== 1 || kb[1] !== 1 ) {\\n\\t\\t\\ts.push( d3_interpolateTransformPop( s ) + \\\"scale(\\\" + kb + \\\")\\\" );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_interpolateTransform( a, b ) {\\n\\t\\tvar s = [], q = [];\\n\\t\\ta = d3.transform( a ), b = d3.transform( b );\\n\\t\\td3_interpolateTranslate( a.translate, b.translate, s, q );\\n\\t\\td3_interpolateRotate( a.rotate, b.rotate, s, q );\\n\\t\\td3_interpolateSkew( a.skew, b.skew, s, q );\\n\\t\\td3_interpolateScale( a.scale, b.scale, s, q );\\n\\t\\ta = b = null;\\n\\t\\treturn function( t ) {\\n\\t\\t\\tvar i = -1, n = q.length, o;\\n\\t\\t\\twhile ( ++i < n ) s[( o = q[i] ).i] = o.x( t );\\n\\t\\t\\treturn s.join( \\\"\\\" );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_uninterpolateNumber( a, b ) {\\n\\t\\tb = ( b -= a = +a ) || 1 / b;\\n\\t\\treturn function( x ) {\\n\\t\\t\\treturn ( x - a ) / b;\\n\\t\\t};\\n\\t}\\n\\tfunction d3_uninterpolateClamp( a, b ) {\\n\\t\\tb = ( b -= a = +a ) || 1 / b;\\n\\t\\treturn function( x ) {\\n\\t\\t\\treturn Math.max( 0, Math.min( 1, ( x - a ) / b ) );\\n\\t\\t};\\n\\t}\\n\\td3.layout = {};\\n\\td3.layout.bundle = function() {\\n\\t\\treturn function( links ) {\\n\\t\\t\\tvar paths = [], i = -1, n = links.length;\\n\\t\\t\\twhile ( ++i < n ) paths.push( d3_layout_bundlePath( links[i] ) );\\n\\t\\t\\treturn paths;\\n\\t\\t};\\n\\t};\\n\\tfunction d3_layout_bundlePath( link ) {\\n\\t\\tvar start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor( start, end ), points = [ start ];\\n\\t\\twhile ( start !== lca ) {\\n\\t\\t\\tstart = start.parent;\\n\\t\\t\\tpoints.push( start );\\n\\t\\t}\\n\\t\\tvar k = points.length;\\n\\t\\twhile ( end !== lca ) {\\n\\t\\t\\tpoints.splice( k, 0, end );\\n\\t\\t\\tend = end.parent;\\n\\t\\t}\\n\\t\\treturn points;\\n\\t}\\n\\tfunction d3_layout_bundleAncestors( node ) {\\n\\t\\tvar ancestors = [], parent = node.parent;\\n\\t\\twhile ( parent != null ) {\\n\\t\\t\\tancestors.push( node );\\n\\t\\t\\tnode = parent;\\n\\t\\t\\tparent = parent.parent;\\n\\t\\t}\\n\\t\\tancestors.push( node );\\n\\t\\treturn ancestors;\\n\\t}\\n\\tfunction d3_layout_bundleLeastCommonAncestor( a, b ) {\\n\\t\\tif ( a === b ) return a;\\n\\t\\tvar aNodes = d3_layout_bundleAncestors( a ), bNodes = d3_layout_bundleAncestors( b ), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\\n\\t\\twhile ( aNode === bNode ) {\\n\\t\\t\\tsharedNode = aNode;\\n\\t\\t\\taNode = aNodes.pop();\\n\\t\\t\\tbNode = bNodes.pop();\\n\\t\\t}\\n\\t\\treturn sharedNode;\\n\\t}\\n\\td3.layout.chord = function() {\\n\\t\\tvar chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\\n\\t\\tfunction relayout() {\\n\\t\\t\\tvar subgroups = {}, groupSums = [], groupIndex = d3.range( n ), subgroupIndex = [], k, x, x0, i, j;\\n\\t\\t\\tchords = [];\\n\\t\\t\\tgroups = [];\\n\\t\\t\\tk = 0, i = -1;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tx = 0, j = -1;\\n\\t\\t\\t\\twhile ( ++j < n ) {\\n\\t\\t\\t\\t\\tx += matrix[i][j];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgroupSums.push( x );\\n\\t\\t\\t\\tsubgroupIndex.push( d3.range( n ) );\\n\\t\\t\\t\\tk += x;\\n\\t\\t\\t}\\n\\t\\t\\tif ( sortGroups ) {\\n\\t\\t\\t\\tgroupIndex.sort( function( a, b ) {\\n\\t\\t\\t\\t\\treturn sortGroups( groupSums[a], groupSums[b] );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\tif ( sortSubgroups ) {\\n\\t\\t\\t\\tsubgroupIndex.forEach( function( d, i ) {\\n\\t\\t\\t\\t\\td.sort( function( a, b ) {\\n\\t\\t\\t\\t\\t\\treturn sortSubgroups( matrix[i][a], matrix[i][b] );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\tk = (  - padding * n ) / k;\\n\\t\\t\\tx = 0, i = -1;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tx0 = x, j = -1;\\n\\t\\t\\t\\twhile ( ++j < n ) {\\n\\t\\t\\t\\t\\tvar di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\\n\\t\\t\\t\\t\\tsubgroups[di + \\\"-\\\" + dj] = {\\n\\t\\t\\t\\t\\t\\tindex: di,\\n\\t\\t\\t\\t\\t\\tsubindex: dj,\\n\\t\\t\\t\\t\\t\\tstartAngle: a0,\\n\\t\\t\\t\\t\\t\\tendAngle: a1,\\n\\t\\t\\t\\t\\t\\tvalue: v\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tgroups[di] = {\\n\\t\\t\\t\\t\\tindex: di,\\n\\t\\t\\t\\t\\tstartAngle: x0,\\n\\t\\t\\t\\t\\tendAngle: x,\\n\\t\\t\\t\\t\\tvalue: groupSums[di]\\n\\t\\t\\t\\t};\\n\\t\\t\\t\\tx += padding;\\n\\t\\t\\t}\\n\\t\\t\\ti = -1;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tj = i - 1;\\n\\t\\t\\t\\twhile ( ++j < n ) {\\n\\t\\t\\t\\t\\tvar source = subgroups[i + \\\"-\\\" + j], target = subgroups[j + \\\"-\\\" + i];\\n\\t\\t\\t\\t\\tif ( source.value || target.value ) {\\n\\t\\t\\t\\t\\t\\tchords.push( source.value < target.value ? {\\n\\t\\t\\t\\t\\t\\t\\tsource: target,\\n\\t\\t\\t\\t\\t\\t\\ttarget: source\\n\\t\\t\\t\\t\\t\\t} : {\\n\\t\\t\\t\\t\\t\\t\\tsource: source,\\n\\t\\t\\t\\t\\t\\t\\ttarget: target\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( sortChords ) resort();\\n\\t\\t}\\n\\t\\tfunction resort() {\\n\\t\\t\\tchords.sort( function( a, b ) {\\n\\t\\t\\t\\treturn sortChords( ( a.source.value + a.target.value ) / 2, ( b.source.value + b.target.value ) / 2 );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tchord.matrix = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return matrix;\\n\\t\\t\\tn = ( matrix = x ) && matrix.length;\\n\\t\\t\\tchords = groups = null;\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.padding = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return padding;\\n\\t\\t\\tpadding = x;\\n\\t\\t\\tchords = groups = null;\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.sortGroups = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return sortGroups;\\n\\t\\t\\tsortGroups = x;\\n\\t\\t\\tchords = groups = null;\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.sortSubgroups = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return sortSubgroups;\\n\\t\\t\\tsortSubgroups = x;\\n\\t\\t\\tchords = null;\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.sortChords = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return sortChords;\\n\\t\\t\\tsortChords = x;\\n\\t\\t\\tif ( chords ) resort();\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.chords = function() {\\n\\t\\t\\tif ( !chords ) relayout();\\n\\t\\t\\treturn chords;\\n\\t\\t};\\n\\t\\tchord.groups = function() {\\n\\t\\t\\tif ( !groups ) relayout();\\n\\t\\t\\treturn groups;\\n\\t\\t};\\n\\t\\treturn chord;\\n\\t};\\n\\td3.layout.force = function() {\\n\\t\\tvar force = {}, event = d3.dispatch( \\\"start\\\", \\\"tick\\\", \\\"end\\\" ), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\\n\\t\\tfunction repulse( node ) {\\n\\t\\t\\treturn function( quad, x1, _, x2 ) {\\n\\t\\t\\t\\tif ( quad.point !== node ) {\\n\\t\\t\\t\\t\\tvar dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\\n\\t\\t\\t\\t\\tif ( dw * dw / theta2 < dn ) {\\n\\t\\t\\t\\t\\t\\tif ( dn < chargeDistance2 ) {\\n\\t\\t\\t\\t\\t\\t\\tvar k = quad.charge / dn;\\n\\t\\t\\t\\t\\t\\t\\tnode.px -= dx * k;\\n\\t\\t\\t\\t\\t\\t\\tnode.py -= dy * k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( quad.point && dn && dn < chargeDistance2 ) {\\n\\t\\t\\t\\t\\t\\tvar k = quad.pointCharge / dn;\\n\\t\\t\\t\\t\\t\\tnode.px -= dx * k;\\n\\t\\t\\t\\t\\t\\tnode.py -= dy * k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn !quad.charge;\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tforce.tick = function() {\\n\\t\\t\\tif ( ( alpha *= .99 ) < .005 ) {\\n\\t\\t\\t\\ttimer = null;\\n\\t\\t\\t\\tevent.end( {\\n\\t\\t\\t\\t\\ttype: \\\"end\\\",\\n\\t\\t\\t\\t\\talpha: alpha = 0\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\treturn true;\\n\\t\\t\\t}\\n\\t\\t\\tvar n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\\n\\t\\t\\tfor ( i = 0; i < m; ++i ) {\\n\\t\\t\\t\\to = links[i];\\n\\t\\t\\t\\ts = o.source;\\n\\t\\t\\t\\tt = o.target;\\n\\t\\t\\t\\tx = t.x - s.x;\\n\\t\\t\\t\\ty = t.y - s.y;\\n\\t\\t\\t\\tif ( l = x * x + y * y ) {\\n\\t\\t\\t\\t\\tl = alpha * strengths[i] * ( ( l = Math.sqrt( l ) ) - distances[i] ) / l;\\n\\t\\t\\t\\t\\tx *= l;\\n\\t\\t\\t\\t\\ty *= l;\\n\\t\\t\\t\\t\\tt.x -= x * ( k = s.weight + t.weight ? s.weight / ( s.weight + t.weight ) : .5 );\\n\\t\\t\\t\\t\\tt.y -= y * k;\\n\\t\\t\\t\\t\\ts.x += x * ( k = 1 - k );\\n\\t\\t\\t\\t\\ts.y += y * k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( k = alpha * gravity ) {\\n\\t\\t\\t\\tx = size[0] / 2;\\n\\t\\t\\t\\ty = size[1] / 2;\\n\\t\\t\\t\\ti = -1;\\n\\t\\t\\t\\tif ( k ) while ( ++i < n ) {\\n\\t\\t\\t\\t\\to = nodes[i];\\n\\t\\t\\t\\t\\to.x += ( x - o.x ) * k;\\n\\t\\t\\t\\t\\to.y += ( y - o.y ) * k;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( charge ) {\\n\\t\\t\\t\\td3_layout_forceAccumulate( q = d3.geom.quadtree( nodes ), alpha, charges );\\n\\t\\t\\t\\ti = -1;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\tif ( !( o = nodes[i] ).fixed ) {\\n\\t\\t\\t\\t\\t\\tq.visit( repulse( o ) );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ti = -1;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\to = nodes[i];\\n\\t\\t\\t\\tif ( o.fixed ) {\\n\\t\\t\\t\\t\\to.x = o.px;\\n\\t\\t\\t\\t\\to.y = o.py;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\to.x -= ( o.px - ( o.px = o.x ) ) * friction;\\n\\t\\t\\t\\t\\to.y -= ( o.py - ( o.py = o.y ) ) * friction;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tevent.tick( {\\n\\t\\t\\t\\ttype: \\\"tick\\\",\\n\\t\\t\\t\\talpha: alpha\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tforce.nodes = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return nodes;\\n\\t\\t\\tnodes = x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.links = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return links;\\n\\t\\t\\tlinks = x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.linkDistance = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return linkDistance;\\n\\t\\t\\tlinkDistance = typeof x === \\\"function\\\" ? x : +x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.distance = force.linkDistance;\\n\\t\\tforce.linkStrength = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return linkStrength;\\n\\t\\t\\tlinkStrength = typeof x === \\\"function\\\" ? x : +x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.friction = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return friction;\\n\\t\\t\\tfriction = +x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.charge = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return charge;\\n\\t\\t\\tcharge = typeof x === \\\"function\\\" ? x : +x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.chargeDistance = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return Math.sqrt( chargeDistance2 );\\n\\t\\t\\tchargeDistance2 = x * x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.gravity = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return gravity;\\n\\t\\t\\tgravity = +x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.theta = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return Math.sqrt( theta2 );\\n\\t\\t\\ttheta2 = x * x;\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.alpha = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return alpha;\\n\\t\\t\\tx = +x;\\n\\t\\t\\tif ( alpha ) {\\n\\t\\t\\t\\tif ( x > 0 ) {\\n\\t\\t\\t\\t\\talpha = x;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttimer.c = null, timer.t = NaN, timer = null;\\n\\t\\t\\t\\t\\tevent.end( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"end\\\",\\n\\t\\t\\t\\t\\t\\talpha: alpha = 0\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if ( x > 0 ) {\\n\\t\\t\\t\\tevent.start( {\\n\\t\\t\\t\\t\\ttype: \\\"start\\\",\\n\\t\\t\\t\\t\\talpha: alpha = x\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\ttimer = d3_timer( force.tick );\\n\\t\\t\\t}\\n\\t\\t\\treturn force;\\n\\t\\t};\\n\\t\\tforce.start = function() {\\n\\t\\t\\tvar i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\\n\\t\\t\\tfor ( i = 0; i < n; ++i ) {\\n\\t\\t\\t\\t( o = nodes[i] ).index = i;\\n\\t\\t\\t\\to.weight = 0;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( i = 0; i < m; ++i ) {\\n\\t\\t\\t\\to = links[i];\\n\\t\\t\\t\\tif ( typeof o.source == \\\"number\\\" ) o.source = nodes[o.source];\\n\\t\\t\\t\\tif ( typeof o.target == \\\"number\\\" ) o.target = nodes[o.target];\\n\\t\\t\\t\\t++o.source.weight;\\n\\t\\t\\t\\t++o.target.weight;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( i = 0; i < n; ++i ) {\\n\\t\\t\\t\\to = nodes[i];\\n\\t\\t\\t\\tif ( isNaN( o.x ) ) o.x = position( \\\"x\\\", w );\\n\\t\\t\\t\\tif ( isNaN( o.y ) ) o.y = position( \\\"y\\\", h );\\n\\t\\t\\t\\tif ( isNaN( o.px ) ) o.px = o.x;\\n\\t\\t\\t\\tif ( isNaN( o.py ) ) o.py = o.y;\\n\\t\\t\\t}\\n\\t\\t\\tdistances = [];\\n\\t\\t\\tif ( typeof linkDistance === \\\"function\\\" ) for ( i = 0; i < m; ++i ) distances[i] = +linkDistance.call( this, links[i], i ); else for ( i = 0; i < m; ++i ) distances[i] = linkDistance;\\n\\t\\t\\tstrengths = [];\\n\\t\\t\\tif ( typeof linkStrength === \\\"function\\\" ) for ( i = 0; i < m; ++i ) strengths[i] = +linkStrength.call( this, links[i], i ); else for ( i = 0; i < m; ++i ) strengths[i] = linkStrength;\\n\\t\\t\\tcharges = [];\\n\\t\\t\\tif ( typeof charge === \\\"function\\\" ) for ( i = 0; i < n; ++i ) charges[i] = +charge.call( this, nodes[i], i ); else for ( i = 0; i < n; ++i ) charges[i] = charge;\\n\\t\\t\\tfunction position( dimension, size ) {\\n\\t\\t\\t\\tif ( !neighbors ) {\\n\\t\\t\\t\\t\\tneighbors = new Array( n );\\n\\t\\t\\t\\t\\tfor ( j = 0; j < n; ++j ) {\\n\\t\\t\\t\\t\\t\\tneighbors[j] = [];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tfor ( j = 0; j < m; ++j ) {\\n\\t\\t\\t\\t\\t\\tvar o = links[j];\\n\\t\\t\\t\\t\\t\\tneighbors[o.source.index].push( o.target );\\n\\t\\t\\t\\t\\t\\tneighbors[o.target.index].push( o.source );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tvar candidates = neighbors[i], j = -1, l = candidates.length, x;\\n\\t\\t\\t\\twhile ( ++j < l ) if ( !isNaN( x = candidates[j][dimension] ) ) return x;\\n\\t\\t\\t\\treturn Math.random() * size;\\n\\t\\t\\t}\\n\\t\\t\\treturn force.resume();\\n\\t\\t};\\n\\t\\tforce.resume = function() {\\n\\t\\t\\treturn force.alpha( .1 );\\n\\t\\t};\\n\\t\\tforce.stop = function() {\\n\\t\\t\\treturn force.alpha( 0 );\\n\\t\\t};\\n\\t\\tforce.drag = function() {\\n\\t\\t\\tif ( !drag ) drag = d3.behavior.drag().origin( d3_identity ).on( \\\"dragstart.force\\\", d3_layout_forceDragstart ).on( \\\"drag.force\\\", dragmove ).on( \\\"dragend.force\\\", d3_layout_forceDragend );\\n\\t\\t\\tif ( !arguments.length ) return drag;\\n\\t\\t\\tthis.on( \\\"mouseover.force\\\", d3_layout_forceMouseover ).on( \\\"mouseout.force\\\", d3_layout_forceMouseout ).call( drag );\\n\\t\\t};\\n\\t\\tfunction dragmove( d ) {\\n\\t\\t\\td.px = d3.event.x, d.py = d3.event.y;\\n\\t\\t\\tforce.resume();\\n\\t\\t}\\n\\t\\treturn d3.rebind( force, event, \\\"on\\\" );\\n\\t};\\n\\tfunction d3_layout_forceDragstart( d ) {\\n\\t\\td.fixed |= 2;\\n\\t}\\n\\tfunction d3_layout_forceDragend( d ) {\\n\\t\\td.fixed &= ~6;\\n\\t}\\n\\tfunction d3_layout_forceMouseover( d ) {\\n\\t\\td.fixed |= 4;\\n\\t\\td.px = d.x, d.py = d.y;\\n\\t}\\n\\tfunction d3_layout_forceMouseout( d ) {\\n\\t\\td.fixed &= ~4;\\n\\t}\\n\\tfunction d3_layout_forceAccumulate( quad, alpha, charges ) {\\n\\t\\tvar cx = 0, cy = 0;\\n\\t\\tquad.charge = 0;\\n\\t\\tif ( !quad.leaf ) {\\n\\t\\t\\tvar nodes = quad.nodes, n = nodes.length, i = -1, c;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tc = nodes[i];\\n\\t\\t\\t\\tif ( c == null ) continue;\\n\\t\\t\\t\\td3_layout_forceAccumulate( c, alpha, charges );\\n\\t\\t\\t\\tquad.charge += c.charge;\\n\\t\\t\\t\\tcx += c.charge * c.cx;\\n\\t\\t\\t\\tcy += c.charge * c.cy;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( quad.point ) {\\n\\t\\t\\tif ( !quad.leaf ) {\\n\\t\\t\\t\\tquad.point.x += Math.random() - .5;\\n\\t\\t\\t\\tquad.point.y += Math.random() - .5;\\n\\t\\t\\t}\\n\\t\\t\\tvar k = alpha * charges[quad.point.index];\\n\\t\\t\\tquad.charge += quad.pointCharge = k;\\n\\t\\t\\tcx += k * quad.point.x;\\n\\t\\t\\tcy += k * quad.point.y;\\n\\t\\t}\\n\\t\\tquad.cx = cx / quad.charge;\\n\\t\\tquad.cy = cy / quad.charge;\\n\\t}\\n\\tvar d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\\n\\td3.layout.hierarchy = function() {\\n\\t\\tvar sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\\n\\t\\tfunction hierarchy( root ) {\\n\\t\\t\\tvar stack = [ root ], nodes = [], node;\\n\\t\\t\\troot.depth = 0;\\n\\t\\t\\twhile ( ( node = stack.pop() ) != null ) {\\n\\t\\t\\t\\tnodes.push( node );\\n\\t\\t\\t\\tif ( ( childs = children.call( hierarchy, node, node.depth ) ) && ( n = childs.length ) ) {\\n\\t\\t\\t\\t\\tvar n, childs, child;\\n\\t\\t\\t\\t\\twhile ( --n >= 0 ) {\\n\\t\\t\\t\\t\\t\\tstack.push( child = childs[n] );\\n\\t\\t\\t\\t\\t\\tchild.parent = node;\\n\\t\\t\\t\\t\\t\\tchild.depth = node.depth + 1;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( value ) node.value = 0;\\n\\t\\t\\t\\t\\tnode.children = childs;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( value ) node.value = +value.call( hierarchy, node, node.depth ) || 0;\\n\\t\\t\\t\\t\\tdelete node.children;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( node ) {\\n\\t\\t\\t\\tvar childs, parent;\\n\\t\\t\\t\\tif ( sort && ( childs = node.children ) ) childs.sort( sort );\\n\\t\\t\\t\\tif ( value && ( parent = node.parent ) ) parent.value += node.value;\\n\\t\\t\\t} );\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\thierarchy.sort = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return sort;\\n\\t\\t\\tsort = x;\\n\\t\\t\\treturn hierarchy;\\n\\t\\t};\\n\\t\\thierarchy.children = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return children;\\n\\t\\t\\tchildren = x;\\n\\t\\t\\treturn hierarchy;\\n\\t\\t};\\n\\t\\thierarchy.value = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return value;\\n\\t\\t\\tvalue = x;\\n\\t\\t\\treturn hierarchy;\\n\\t\\t};\\n\\t\\thierarchy.revalue = function( root ) {\\n\\t\\t\\tif ( value ) {\\n\\t\\t\\t\\td3_layout_hierarchyVisitBefore( root, function( node ) {\\n\\t\\t\\t\\t\\tif ( node.children ) node.value = 0;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( node ) {\\n\\t\\t\\t\\t\\tvar parent;\\n\\t\\t\\t\\t\\tif ( !node.children ) node.value = +value.call( hierarchy, node, node.depth ) || 0;\\n\\t\\t\\t\\t\\tif ( parent = node.parent ) parent.value += node.value;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\treturn root;\\n\\t\\t};\\n\\t\\treturn hierarchy;\\n\\t};\\n\\tfunction d3_layout_hierarchyRebind( object, hierarchy ) {\\n\\t\\td3.rebind( object, hierarchy, \\\"sort\\\", \\\"children\\\", \\\"value\\\" );\\n\\t\\tobject.nodes = object;\\n\\t\\tobject.links = d3_layout_hierarchyLinks;\\n\\t\\treturn object;\\n\\t}\\n\\tfunction d3_layout_hierarchyVisitBefore( node, callback ) {\\n\\t\\tvar nodes = [ node ];\\n\\t\\twhile ( ( node = nodes.pop() ) != null ) {\\n\\t\\t\\tcallback( node );\\n\\t\\t\\tif ( ( children = node.children ) && ( n = children.length ) ) {\\n\\t\\t\\t\\tvar n, children;\\n\\t\\t\\t\\twhile ( --n >= 0 ) nodes.push( children[n] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\tfunction d3_layout_hierarchyVisitAfter( node, callback ) {\\n\\t\\tvar nodes = [ node ], nodes2 = [];\\n\\t\\twhile ( ( node = nodes.pop() ) != null ) {\\n\\t\\t\\tnodes2.push( node );\\n\\t\\t\\tif ( ( children = node.children ) && ( n = children.length ) ) {\\n\\t\\t\\t\\tvar i = -1, n, children;\\n\\t\\t\\t\\twhile ( ++i < n ) nodes.push( children[i] );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile ( ( node = nodes2.pop() ) != null ) {\\n\\t\\t\\tcallback( node );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_layout_hierarchyChildren( d ) {\\n\\t\\treturn d.children;\\n\\t}\\n\\tfunction d3_layout_hierarchyValue( d ) {\\n\\t\\treturn d.value;\\n\\t}\\n\\tfunction d3_layout_hierarchySort( a, b ) {\\n\\t\\treturn b.value - a.value;\\n\\t}\\n\\tfunction d3_layout_hierarchyLinks( nodes ) {\\n\\t\\treturn d3.merge( nodes.map( function( parent ) {\\n\\t\\t\\treturn ( parent.children || [] ).map( function( child ) {\\n\\t\\t\\t\\treturn {\\n\\t\\t\\t\\t\\tsource: parent,\\n\\t\\t\\t\\t\\ttarget: child\\n\\t\\t\\t\\t};\\n\\t\\t\\t} );\\n\\t\\t} ) );\\n\\t}\\n\\td3.layout.partition = function() {\\n\\t\\tvar hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\\n\\t\\tfunction position( node, x, dx, dy ) {\\n\\t\\t\\tvar children = node.children;\\n\\t\\t\\tnode.x = x;\\n\\t\\t\\tnode.y = node.depth * dy;\\n\\t\\t\\tnode.dx = dx;\\n\\t\\t\\tnode.dy = dy;\\n\\t\\t\\tif ( children && ( n = children.length ) ) {\\n\\t\\t\\t\\tvar i = -1, n, c, d;\\n\\t\\t\\t\\tdx = node.value ? dx / node.value : 0;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\tposition( c = children[i], x, d = c.value * dx, dy );\\n\\t\\t\\t\\t\\tx += d;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction depth( node ) {\\n\\t\\t\\tvar children = node.children, d = 0;\\n\\t\\t\\tif ( children && ( n = children.length ) ) {\\n\\t\\t\\t\\tvar i = -1, n;\\n\\t\\t\\t\\twhile ( ++i < n ) d = Math.max( d, depth( children[i] ) );\\n\\t\\t\\t}\\n\\t\\t\\treturn 1 + d;\\n\\t\\t}\\n\\t\\tfunction partition( d, i ) {\\n\\t\\t\\tvar nodes = hierarchy.call( this, d, i );\\n\\t\\t\\tposition( nodes[0], 0, size[0], size[1] / depth( nodes[0] ) );\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\tpartition.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = x;\\n\\t\\t\\treturn partition;\\n\\t\\t};\\n\\t\\treturn d3_layout_hierarchyRebind( partition, hierarchy );\\n\\t};\\n\\td3.layout.pie = function() {\\n\\t\\tvar value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = , padAngle = 0;\\n\\t\\tfunction pie( data ) {\\n\\t\\t\\tvar n = data.length, values = data.map( function( d, i ) {\\n\\t\\t\\t\\t\\treturn +value.call( pie, d, i );\\n\\t\\t\\t\\t} ), a = +( typeof startAngle === \\\"function\\\" ? startAngle.apply( this, arguments ) : startAngle ), da = ( typeof endAngle === \\\"function\\\" ? endAngle.apply( this, arguments ) : endAngle ) - a, p = Math.min( Math.abs( da ) / n, +( typeof padAngle === \\\"function\\\" ? padAngle.apply( this, arguments ) : padAngle ) ), pa = p * ( da < 0 ? -1 : 1 ), sum = d3.sum( values ), k = sum ? ( da - n * pa ) / sum : 0, index = d3.range( n ), arcs = [], v;\\n\\t\\t\\tif ( sort != null ) index.sort( sort === d3_layout_pieSortByValue ? function( i, j ) {\\n\\t\\t\\t\\treturn values[j] - values[i];\\n\\t\\t\\t} : function( i, j ) {\\n\\t\\t\\t\\treturn sort( data[i], data[j] );\\n\\t\\t\\t} );\\n\\t\\t\\tindex.forEach( function( i ) {\\n\\t\\t\\t\\tarcs[i] = {\\n\\t\\t\\t\\t\\tdata: data[i],\\n\\t\\t\\t\\t\\tvalue: v = values[i],\\n\\t\\t\\t\\t\\tstartAngle: a,\\n\\t\\t\\t\\t\\tendAngle: a += v * k + pa,\\n\\t\\t\\t\\t\\tpadAngle: p\\n\\t\\t\\t\\t};\\n\\t\\t\\t} );\\n\\t\\t\\treturn arcs;\\n\\t\\t}\\n\\t\\tpie.value = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return value;\\n\\t\\t\\tvalue = _;\\n\\t\\t\\treturn pie;\\n\\t\\t};\\n\\t\\tpie.sort = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return sort;\\n\\t\\t\\tsort = _;\\n\\t\\t\\treturn pie;\\n\\t\\t};\\n\\t\\tpie.startAngle = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return startAngle;\\n\\t\\t\\tstartAngle = _;\\n\\t\\t\\treturn pie;\\n\\t\\t};\\n\\t\\tpie.endAngle = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return endAngle;\\n\\t\\t\\tendAngle = _;\\n\\t\\t\\treturn pie;\\n\\t\\t};\\n\\t\\tpie.padAngle = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return padAngle;\\n\\t\\t\\tpadAngle = _;\\n\\t\\t\\treturn pie;\\n\\t\\t};\\n\\t\\treturn pie;\\n\\t};\\n\\tvar d3_layout_pieSortByValue = {};\\n\\td3.layout.stack = function() {\\n\\t\\tvar values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\\n\\t\\tfunction stack( data, index ) {\\n\\t\\t\\tif ( !( n = data.length ) ) return data;\\n\\t\\t\\tvar series = data.map( function( d, i ) {\\n\\t\\t\\t\\treturn values.call( stack, d, i );\\n\\t\\t\\t} );\\n\\t\\t\\tvar points = series.map( function( d ) {\\n\\t\\t\\t\\treturn d.map( function( v, i ) {\\n\\t\\t\\t\\t\\treturn [ x.call( stack, v, i ), y.call( stack, v, i ) ];\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} );\\n\\t\\t\\tvar orders = order.call( stack, points, index );\\n\\t\\t\\tseries = d3.permute( series, orders );\\n\\t\\t\\tpoints = d3.permute( points, orders );\\n\\t\\t\\tvar offsets = offset.call( stack, points, index );\\n\\t\\t\\tvar m = series[0].length, n, i, j, o;\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) {\\n\\t\\t\\t\\tout.call( stack, series[0][j], o = offsets[j], points[0][j][1] );\\n\\t\\t\\t\\tfor ( i = 1; i < n; ++i ) {\\n\\t\\t\\t\\t\\tout.call( stack, series[i][j], o += points[i - 1][j][1], points[i][j][1] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn data;\\n\\t\\t}\\n\\t\\tstack.values = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return values;\\n\\t\\t\\tvalues = x;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\tstack.order = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return order;\\n\\t\\t\\torder = typeof x === \\\"function\\\" ? x : d3_layout_stackOrders.get( x ) || d3_layout_stackOrderDefault;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\tstack.offset = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return offset;\\n\\t\\t\\toffset = typeof x === \\\"function\\\" ? x : d3_layout_stackOffsets.get( x ) || d3_layout_stackOffsetZero;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\tstack.x = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return x;\\n\\t\\t\\tx = z;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\tstack.y = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return y;\\n\\t\\t\\ty = z;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\tstack.out = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return out;\\n\\t\\t\\tout = z;\\n\\t\\t\\treturn stack;\\n\\t\\t};\\n\\t\\treturn stack;\\n\\t};\\n\\tfunction d3_layout_stackX( d ) {\\n\\t\\treturn d.x;\\n\\t}\\n\\tfunction d3_layout_stackY( d ) {\\n\\t\\treturn d.y;\\n\\t}\\n\\tfunction d3_layout_stackOut( d, y0, y ) {\\n\\t\\td.y0 = y0;\\n\\t\\td.y = y;\\n\\t}\\n\\tvar d3_layout_stackOrders = d3.map( {\\n\\t\\t\\\"inside-out\\\": function( data ) {\\n\\t\\t\\tvar n = data.length, i, j, max = data.map( d3_layout_stackMaxIndex ), sums = data.map( d3_layout_stackReduceSum ), index = d3.range( n ).sort( function( a, b ) {\\n\\t\\t\\t\\t\\treturn max[a] - max[b];\\n\\t\\t\\t\\t} ), top = 0, bottom = 0, tops = [], bottoms = [];\\n\\t\\t\\tfor ( i = 0; i < n; ++i ) {\\n\\t\\t\\t\\tj = index[i];\\n\\t\\t\\t\\tif ( top < bottom ) {\\n\\t\\t\\t\\t\\ttop += sums[j];\\n\\t\\t\\t\\t\\ttops.push( j );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tbottom += sums[j];\\n\\t\\t\\t\\t\\tbottoms.push( j );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn bottoms.reverse().concat( tops );\\n\\t\\t},\\n\\t\\treverse: function( data ) {\\n\\t\\t\\treturn d3.range( data.length ).reverse();\\n\\t\\t},\\n\\t\\t\\\"default\\\": d3_layout_stackOrderDefault\\n\\t} );\\n\\tvar d3_layout_stackOffsets = d3.map( {\\n\\t\\tsilhouette: function( data ) {\\n\\t\\t\\tvar n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) {\\n\\t\\t\\t\\tfor ( i = 0, o = 0; i < n; i++ ) o += data[i][j][1];\\n\\t\\t\\t\\tif ( o > max ) max = o;\\n\\t\\t\\t\\tsums.push( o );\\n\\t\\t\\t}\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) {\\n\\t\\t\\t\\ty0[j] = ( max - sums[j] ) / 2;\\n\\t\\t\\t}\\n\\t\\t\\treturn y0;\\n\\t\\t},\\n\\t\\twiggle: function( data ) {\\n\\t\\t\\tvar n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\\n\\t\\t\\ty0[0] = o = o0 = 0;\\n\\t\\t\\tfor ( j = 1; j < m; ++j ) {\\n\\t\\t\\t\\tfor ( i = 0, s1 = 0; i < n; ++i ) s1 += data[i][j][1];\\n\\t\\t\\t\\tfor ( i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i ) {\\n\\t\\t\\t\\t\\tfor ( k = 0, s3 = ( data[i][j][1] - data[i][j - 1][1] ) / ( 2 * dx ); k < i; ++k ) {\\n\\t\\t\\t\\t\\t\\ts3 += ( data[k][j][1] - data[k][j - 1][1] ) / dx;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ts2 += s3 * data[i][j][1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ty0[j] = o -= s1 ? s2 / s1 * dx : 0;\\n\\t\\t\\t\\tif ( o < o0 ) o0 = o;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) y0[j] -= o0;\\n\\t\\t\\treturn y0;\\n\\t\\t},\\n\\t\\texpand: function( data ) {\\n\\t\\t\\tvar n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) {\\n\\t\\t\\t\\tfor ( i = 0, o = 0; i < n; i++ ) o += data[i][j][1];\\n\\t\\t\\t\\tif ( o ) for ( i = 0; i < n; i++ ) data[i][j][1] /= o; else for ( i = 0; i < n; i++ ) data[i][j][1] = k;\\n\\t\\t\\t}\\n\\t\\t\\tfor ( j = 0; j < m; ++j ) y0[j] = 0;\\n\\t\\t\\treturn y0;\\n\\t\\t},\\n\\t\\tzero: d3_layout_stackOffsetZero\\n\\t} );\\n\\tfunction d3_layout_stackOrderDefault( data ) {\\n\\t\\treturn d3.range( data.length );\\n\\t}\\n\\tfunction d3_layout_stackOffsetZero( data ) {\\n\\t\\tvar j = -1, m = data[0].length, y0 = [];\\n\\t\\twhile ( ++j < m ) y0[j] = 0;\\n\\t\\treturn y0;\\n\\t}\\n\\tfunction d3_layout_stackMaxIndex( array ) {\\n\\t\\tvar i = 1, j = 0, v = array[0][1], k, n = array.length;\\n\\t\\tfor ( ;i < n; ++i ) {\\n\\t\\t\\tif ( ( k = array[i][1] ) > v ) {\\n\\t\\t\\t\\tj = i;\\n\\t\\t\\t\\tv = k;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn j;\\n\\t}\\n\\tfunction d3_layout_stackReduceSum( d ) {\\n\\t\\treturn d.reduce( d3_layout_stackSum, 0 );\\n\\t}\\n\\tfunction d3_layout_stackSum( p, d ) {\\n\\t\\treturn p + d[1];\\n\\t}\\n\\td3.layout.histogram = function() {\\n\\t\\tvar frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\\n\\t\\tfunction histogram( data, i ) {\\n\\t\\t\\tvar bins = [], values = data.map( valuer, this ), range = ranger.call( this, values, i ), thresholds = binner.call( this, range, values, i ), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\\n\\t\\t\\twhile ( ++i < m ) {\\n\\t\\t\\t\\tbin = bins[i] = [];\\n\\t\\t\\t\\tbin.dx = thresholds[i + 1] - ( bin.x = thresholds[i] );\\n\\t\\t\\t\\tbin.y = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ( m > 0 ) {\\n\\t\\t\\t\\ti = -1;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\tx = values[i];\\n\\t\\t\\t\\t\\tif ( x >= range[0] && x <= range[1] ) {\\n\\t\\t\\t\\t\\t\\tbin = bins[d3.bisect( thresholds, x, 1, m ) - 1];\\n\\t\\t\\t\\t\\t\\tbin.y += k;\\n\\t\\t\\t\\t\\t\\tbin.push( data[i] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn bins;\\n\\t\\t}\\n\\t\\thistogram.value = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return valuer;\\n\\t\\t\\tvaluer = x;\\n\\t\\t\\treturn histogram;\\n\\t\\t};\\n\\t\\thistogram.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return ranger;\\n\\t\\t\\tranger = d3_functor( x );\\n\\t\\t\\treturn histogram;\\n\\t\\t};\\n\\t\\thistogram.bins = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return binner;\\n\\t\\t\\tbinner = typeof x === \\\"number\\\" ? function( range ) {\\n\\t\\t\\t\\treturn d3_layout_histogramBinFixed( range, x );\\n\\t\\t\\t} : d3_functor( x );\\n\\t\\t\\treturn histogram;\\n\\t\\t};\\n\\t\\thistogram.frequency = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return frequency;\\n\\t\\t\\tfrequency = !!x;\\n\\t\\t\\treturn histogram;\\n\\t\\t};\\n\\t\\treturn histogram;\\n\\t};\\n\\tfunction d3_layout_histogramBinSturges( range, values ) {\\n\\t\\treturn d3_layout_histogramBinFixed( range, Math.ceil( Math.log( values.length ) / Math.LN2 + 1 ) );\\n\\t}\\n\\tfunction d3_layout_histogramBinFixed( range, n ) {\\n\\t\\tvar x = -1, b = +range[0], m = ( range[1] - b ) / n, f = [];\\n\\t\\twhile ( ++x <= n ) f[x] = m * x + b;\\n\\t\\treturn f;\\n\\t}\\n\\tfunction d3_layout_histogramRange( values ) {\\n\\t\\treturn [ d3.min( values ), d3.max( values ) ];\\n\\t}\\n\\td3.layout.pack = function() {\\n\\t\\tvar hierarchy = d3.layout.hierarchy().sort( d3_layout_packSort ), padding = 0, size = [ 1, 1 ], radius;\\n\\t\\tfunction pack( d, i ) {\\n\\t\\t\\tvar nodes = hierarchy.call( this, d, i ), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \\\"function\\\" ? radius : function() {\\n\\t\\t\\t\\treturn radius;\\n\\t\\t\\t};\\n\\t\\t\\troot.x = root.y = 0;\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( d ) {\\n\\t\\t\\t\\td.r = +r( d.value );\\n\\t\\t\\t} );\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root, d3_layout_packSiblings );\\n\\t\\t\\tif ( padding ) {\\n\\t\\t\\t\\tvar dr = padding * ( radius ? 1 : Math.max( 2 * root.r / w, 2 * root.r / h ) ) / 2;\\n\\t\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( d ) {\\n\\t\\t\\t\\t\\td.r += dr;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\td3_layout_hierarchyVisitAfter( root, d3_layout_packSiblings );\\n\\t\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( d ) {\\n\\t\\t\\t\\t\\td.r -= dr;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\td3_layout_packTransform( root, w / 2, h / 2, radius ? 1 : 1 / Math.max( 2 * root.r / w, 2 * root.r / h ) );\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\tpack.size = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = _;\\n\\t\\t\\treturn pack;\\n\\t\\t};\\n\\t\\tpack.radius = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return radius;\\n\\t\\t\\tradius = _ == null || typeof _ === \\\"function\\\" ? _ : +_;\\n\\t\\t\\treturn pack;\\n\\t\\t};\\n\\t\\tpack.padding = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return padding;\\n\\t\\t\\tpadding = +_;\\n\\t\\t\\treturn pack;\\n\\t\\t};\\n\\t\\treturn d3_layout_hierarchyRebind( pack, hierarchy );\\n\\t};\\n\\tfunction d3_layout_packSort( a, b ) {\\n\\t\\treturn a.value - b.value;\\n\\t}\\n\\tfunction d3_layout_packInsert( a, b ) {\\n\\t\\tvar c = a._pack_next;\\n\\t\\ta._pack_next = b;\\n\\t\\tb._pack_prev = a;\\n\\t\\tb._pack_next = c;\\n\\t\\tc._pack_prev = b;\\n\\t}\\n\\tfunction d3_layout_packSplice( a, b ) {\\n\\t\\ta._pack_next = b;\\n\\t\\tb._pack_prev = a;\\n\\t}\\n\\tfunction d3_layout_packIntersects( a, b ) {\\n\\t\\tvar dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\\n\\t\\treturn .999 * dr * dr > dx * dx + dy * dy;\\n\\t}\\n\\tfunction d3_layout_packSiblings( node ) {\\n\\t\\tif ( !( nodes = node.children ) || !( n = nodes.length ) ) return;\\n\\t\\tvar nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\\n\\t\\tfunction bound( node ) {\\n\\t\\t\\txMin = Math.min( node.x - node.r, xMin );\\n\\t\\t\\txMax = Math.max( node.x + node.r, xMax );\\n\\t\\t\\tyMin = Math.min( node.y - node.r, yMin );\\n\\t\\t\\tyMax = Math.max( node.y + node.r, yMax );\\n\\t\\t}\\n\\t\\tnodes.forEach( d3_layout_packLink );\\n\\t\\ta = nodes[0];\\n\\t\\ta.x = -a.r;\\n\\t\\ta.y = 0;\\n\\t\\tbound( a );\\n\\t\\tif ( n > 1 ) {\\n\\t\\t\\tb = nodes[1];\\n\\t\\t\\tb.x = b.r;\\n\\t\\t\\tb.y = 0;\\n\\t\\t\\tbound( b );\\n\\t\\t\\tif ( n > 2 ) {\\n\\t\\t\\t\\tc = nodes[2];\\n\\t\\t\\t\\td3_layout_packPlace( a, b, c );\\n\\t\\t\\t\\tbound( c );\\n\\t\\t\\t\\td3_layout_packInsert( a, c );\\n\\t\\t\\t\\ta._pack_prev = c;\\n\\t\\t\\t\\td3_layout_packInsert( c, b );\\n\\t\\t\\t\\tb = a._pack_next;\\n\\t\\t\\t\\tfor ( i = 3; i < n; i++ ) {\\n\\t\\t\\t\\t\\td3_layout_packPlace( a, b, c = nodes[i] );\\n\\t\\t\\t\\t\\tvar isect = 0, s1 = 1, s2 = 1;\\n\\t\\t\\t\\t\\tfor ( j = b._pack_next; j !== b; j = j._pack_next, s1++ ) {\\n\\t\\t\\t\\t\\t\\tif ( d3_layout_packIntersects( j, c ) ) {\\n\\t\\t\\t\\t\\t\\t\\tisect = 1;\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( isect == 1 ) {\\n\\t\\t\\t\\t\\t\\tfor ( k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++ ) {\\n\\t\\t\\t\\t\\t\\t\\tif ( d3_layout_packIntersects( k, c ) ) {\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tif ( isect ) {\\n\\t\\t\\t\\t\\t\\tif ( s1 < s2 || s1 == s2 && b.r < a.r ) d3_layout_packSplice( a, b = j ); else d3_layout_packSplice( a = k, b );\\n\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\td3_layout_packInsert( a, c );\\n\\t\\t\\t\\t\\t\\tb = c;\\n\\t\\t\\t\\t\\t\\tbound( c );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvar cx = ( xMin + xMax ) / 2, cy = ( yMin + yMax ) / 2, cr = 0;\\n\\t\\tfor ( i = 0; i < n; i++ ) {\\n\\t\\t\\tc = nodes[i];\\n\\t\\t\\tc.x -= cx;\\n\\t\\t\\tc.y -= cy;\\n\\t\\t\\tcr = Math.max( cr, c.r + Math.sqrt( c.x * c.x + c.y * c.y ) );\\n\\t\\t}\\n\\t\\tnode.r = cr;\\n\\t\\tnodes.forEach( d3_layout_packUnlink );\\n\\t}\\n\\tfunction d3_layout_packLink( node ) {\\n\\t\\tnode._pack_next = node._pack_prev = node;\\n\\t}\\n\\tfunction d3_layout_packUnlink( node ) {\\n\\t\\tdelete node._pack_next;\\n\\t\\tdelete node._pack_prev;\\n\\t}\\n\\tfunction d3_layout_packTransform( node, x, y, k ) {\\n\\t\\tvar children = node.children;\\n\\t\\tnode.x = x += k * node.x;\\n\\t\\tnode.y = y += k * node.y;\\n\\t\\tnode.r *= k;\\n\\t\\tif ( children ) {\\n\\t\\t\\tvar i = -1, n = children.length;\\n\\t\\t\\twhile ( ++i < n ) d3_layout_packTransform( children[i], x, y, k );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_layout_packPlace( a, b, c ) {\\n\\t\\tvar db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\\n\\t\\tif ( db && ( dx || dy ) ) {\\n\\t\\t\\tvar da = b.r + c.r, dc = dx * dx + dy * dy;\\n\\t\\t\\tda *= da;\\n\\t\\t\\tdb *= db;\\n\\t\\t\\tvar x = .5 + ( db - da ) / ( 2 * dc ), y = Math.sqrt( Math.max( 0, 2 * da * ( db + dc ) - ( db -= dc ) * db - da * da ) ) / ( 2 * dc );\\n\\t\\t\\tc.x = a.x + x * dx + y * dy;\\n\\t\\t\\tc.y = a.y + x * dy - y * dx;\\n\\t\\t} else {\\n\\t\\t\\tc.x = a.x + db;\\n\\t\\t\\tc.y = a.y;\\n\\t\\t}\\n\\t}\\n\\td3.layout.tree = function() {\\n\\t\\tvar hierarchy = d3.layout.hierarchy().sort( null ).value( null ), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\\n\\t\\tfunction tree( d, i ) {\\n\\t\\t\\tvar nodes = hierarchy.call( this, d, i ), root0 = nodes[0], root1 = wrapTree( root0 );\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root1, firstWalk ), root1.parent.m = -root1.z;\\n\\t\\t\\td3_layout_hierarchyVisitBefore( root1, secondWalk );\\n\\t\\t\\tif ( nodeSize ) d3_layout_hierarchyVisitBefore( root0, sizeNode ); else {\\n\\t\\t\\t\\tvar left = root0, right = root0, bottom = root0;\\n\\t\\t\\t\\td3_layout_hierarchyVisitBefore( root0, function( node ) {\\n\\t\\t\\t\\t\\tif ( node.x < left.x ) left = node;\\n\\t\\t\\t\\t\\tif ( node.x > right.x ) right = node;\\n\\t\\t\\t\\t\\tif ( node.depth > bottom.depth ) bottom = node;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t\\tvar tx = separation( left, right ) / 2 - left.x, kx = size[0] / ( right.x + separation( right, left ) / 2 + tx ), ky = size[1] / ( bottom.depth || 1 );\\n\\t\\t\\t\\td3_layout_hierarchyVisitBefore( root0, function( node ) {\\n\\t\\t\\t\\t\\tnode.x = ( node.x + tx ) * kx;\\n\\t\\t\\t\\t\\tnode.y = node.depth * ky;\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\tfunction wrapTree( root0 ) {\\n\\t\\t\\tvar root1 = {\\n\\t\\t\\t\\t\\tA: null,\\n\\t\\t\\t\\t\\tchildren: [ root0 ]\\n\\t\\t\\t\\t}, queue = [ root1 ], node1;\\n\\t\\t\\twhile ( ( node1 = queue.pop() ) != null ) {\\n\\t\\t\\t\\tfor ( var children = node1.children, child, i = 0, n = children.length; i < n; ++i ) {\\n\\t\\t\\t\\t\\tqueue.push( ( children[i] = child = {\\n\\t\\t\\t\\t\\t\\t_: children[i],\\n\\t\\t\\t\\t\\t\\tparent: node1,\\n\\t\\t\\t\\t\\t\\tchildren: ( child = children[i].children ) && child.slice() || [],\\n\\t\\t\\t\\t\\t\\tA: null,\\n\\t\\t\\t\\t\\t\\ta: null,\\n\\t\\t\\t\\t\\t\\tz: 0,\\n\\t\\t\\t\\t\\t\\tm: 0,\\n\\t\\t\\t\\t\\t\\tc: 0,\\n\\t\\t\\t\\t\\t\\ts: 0,\\n\\t\\t\\t\\t\\t\\tt: null,\\n\\t\\t\\t\\t\\t\\ti: i\\n\\t\\t\\t\\t\\t} ).a = child );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn root1.children[0];\\n\\t\\t}\\n\\t\\tfunction firstWalk( v ) {\\n\\t\\t\\tvar children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\\n\\t\\t\\tif ( children.length ) {\\n\\t\\t\\t\\td3_layout_treeShift( v );\\n\\t\\t\\t\\tvar midpoint = ( children[0].z + children[children.length - 1].z ) / 2;\\n\\t\\t\\t\\tif ( w ) {\\n\\t\\t\\t\\t\\tv.z = w.z + separation( v._, w._ );\\n\\t\\t\\t\\t\\tv.m = v.z - midpoint;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tv.z = midpoint;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if ( w ) {\\n\\t\\t\\t\\tv.z = w.z + separation( v._, w._ );\\n\\t\\t\\t}\\n\\t\\t\\tv.parent.A = apportion( v, w, v.parent.A || siblings[0] );\\n\\t\\t}\\n\\t\\tfunction secondWalk( v ) {\\n\\t\\t\\tv._.x = v.z + v.parent.m;\\n\\t\\t\\tv.m += v.parent.m;\\n\\t\\t}\\n\\t\\tfunction apportion( v, w, ancestor ) {\\n\\t\\t\\tif ( w ) {\\n\\t\\t\\t\\tvar vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\\n\\t\\t\\t\\twhile ( vim = d3_layout_treeRight( vim ), vip = d3_layout_treeLeft( vip ), vim && vip ) {\\n\\t\\t\\t\\t\\tvom = d3_layout_treeLeft( vom );\\n\\t\\t\\t\\t\\tvop = d3_layout_treeRight( vop );\\n\\t\\t\\t\\t\\tvop.a = v;\\n\\t\\t\\t\\t\\tshift = vim.z + sim - vip.z - sip + separation( vim._, vip._ );\\n\\t\\t\\t\\t\\tif ( shift > 0 ) {\\n\\t\\t\\t\\t\\t\\td3_layout_treeMove( d3_layout_treeAncestor( vim, v, ancestor ), v, shift );\\n\\t\\t\\t\\t\\t\\tsip += shift;\\n\\t\\t\\t\\t\\t\\tsop += shift;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tsim += vim.m;\\n\\t\\t\\t\\t\\tsip += vip.m;\\n\\t\\t\\t\\t\\tsom += vom.m;\\n\\t\\t\\t\\t\\tsop += vop.m;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( vim && !d3_layout_treeRight( vop ) ) {\\n\\t\\t\\t\\t\\tvop.t = vim;\\n\\t\\t\\t\\t\\tvop.m += sim - sop;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( vip && !d3_layout_treeLeft( vom ) ) {\\n\\t\\t\\t\\t\\tvom.t = vip;\\n\\t\\t\\t\\t\\tvom.m += sip - som;\\n\\t\\t\\t\\t\\tancestor = v;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn ancestor;\\n\\t\\t}\\n\\t\\tfunction sizeNode( node ) {\\n\\t\\t\\tnode.x *= size[0];\\n\\t\\t\\tnode.y = node.depth * size[1];\\n\\t\\t}\\n\\t\\ttree.separation = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return separation;\\n\\t\\t\\tseparation = x;\\n\\t\\t\\treturn tree;\\n\\t\\t};\\n\\t\\ttree.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return nodeSize ? null : size;\\n\\t\\t\\tnodeSize = ( size = x ) == null ? sizeNode : null;\\n\\t\\t\\treturn tree;\\n\\t\\t};\\n\\t\\ttree.nodeSize = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return nodeSize ? size : null;\\n\\t\\t\\tnodeSize = ( size = x ) == null ? null : sizeNode;\\n\\t\\t\\treturn tree;\\n\\t\\t};\\n\\t\\treturn d3_layout_hierarchyRebind( tree, hierarchy );\\n\\t};\\n\\tfunction d3_layout_treeSeparation( a, b ) {\\n\\t\\treturn a.parent == b.parent ? 1 : 2;\\n\\t}\\n\\tfunction d3_layout_treeLeft( v ) {\\n\\t\\tvar children = v.children;\\n\\t\\treturn children.length ? children[0] : v.t;\\n\\t}\\n\\tfunction d3_layout_treeRight( v ) {\\n\\t\\tvar children = v.children, n;\\n\\t\\treturn ( n = children.length ) ? children[n - 1] : v.t;\\n\\t}\\n\\tfunction d3_layout_treeMove( wm, wp, shift ) {\\n\\t\\tvar change = shift / ( wp.i - wm.i );\\n\\t\\twp.c -= change;\\n\\t\\twp.s += shift;\\n\\t\\twm.c += change;\\n\\t\\twp.z += shift;\\n\\t\\twp.m += shift;\\n\\t}\\n\\tfunction d3_layout_treeShift( v ) {\\n\\t\\tvar shift = 0, change = 0, children = v.children, i = children.length, w;\\n\\t\\twhile ( --i >= 0 ) {\\n\\t\\t\\tw = children[i];\\n\\t\\t\\tw.z += shift;\\n\\t\\t\\tw.m += shift;\\n\\t\\t\\tshift += w.s + ( change += w.c );\\n\\t\\t}\\n\\t}\\n\\tfunction d3_layout_treeAncestor( vim, v, ancestor ) {\\n\\t\\treturn vim.a.parent === v.parent ? vim.a : ancestor;\\n\\t}\\n\\td3.layout.cluster = function() {\\n\\t\\tvar hierarchy = d3.layout.hierarchy().sort( null ).value( null ), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\\n\\t\\tfunction cluster( d, i ) {\\n\\t\\t\\tvar nodes = hierarchy.call( this, d, i ), root = nodes[0], previousNode, x = 0;\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root, function( node ) {\\n\\t\\t\\t\\tvar children = node.children;\\n\\t\\t\\t\\tif ( children && children.length ) {\\n\\t\\t\\t\\t\\tnode.x = d3_layout_clusterX( children );\\n\\t\\t\\t\\t\\tnode.y = d3_layout_clusterY( children );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tnode.x = previousNode ? x += separation( node, previousNode ) : 0;\\n\\t\\t\\t\\t\\tnode.y = 0;\\n\\t\\t\\t\\t\\tpreviousNode = node;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tvar left = d3_layout_clusterLeft( root ), right = d3_layout_clusterRight( root ), x0 = left.x - separation( left, right ) / 2, x1 = right.x + separation( right, left ) / 2;\\n\\t\\t\\td3_layout_hierarchyVisitAfter( root, nodeSize ? function( node ) {\\n\\t\\t\\t\\tnode.x = ( node.x - root.x ) * size[0];\\n\\t\\t\\t\\tnode.y = ( root.y - node.y ) * size[1];\\n\\t\\t\\t} : function( node ) {\\n\\t\\t\\t\\tnode.x = ( node.x - x0 ) / ( x1 - x0 ) * size[0];\\n\\t\\t\\t\\tnode.y = ( 1 - ( root.y ? node.y / root.y : 1 ) ) * size[1];\\n\\t\\t\\t} );\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\tcluster.separation = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return separation;\\n\\t\\t\\tseparation = x;\\n\\t\\t\\treturn cluster;\\n\\t\\t};\\n\\t\\tcluster.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return nodeSize ? null : size;\\n\\t\\t\\tnodeSize = ( size = x ) == null;\\n\\t\\t\\treturn cluster;\\n\\t\\t};\\n\\t\\tcluster.nodeSize = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return nodeSize ? size : null;\\n\\t\\t\\tnodeSize = ( size = x ) != null;\\n\\t\\t\\treturn cluster;\\n\\t\\t};\\n\\t\\treturn d3_layout_hierarchyRebind( cluster, hierarchy );\\n\\t};\\n\\tfunction d3_layout_clusterY( children ) {\\n\\t\\treturn 1 + d3.max( children, function( child ) {\\n\\t\\t\\treturn child.y;\\n\\t\\t} );\\n\\t}\\n\\tfunction d3_layout_clusterX( children ) {\\n\\t\\treturn children.reduce( function( x, child ) {\\n\\t\\t\\treturn x + child.x;\\n\\t\\t}, 0 ) / children.length;\\n\\t}\\n\\tfunction d3_layout_clusterLeft( node ) {\\n\\t\\tvar children = node.children;\\n\\t\\treturn children && children.length ? d3_layout_clusterLeft( children[0] ) : node;\\n\\t}\\n\\tfunction d3_layout_clusterRight( node ) {\\n\\t\\tvar children = node.children, n;\\n\\t\\treturn children && ( n = children.length ) ? d3_layout_clusterRight( children[n - 1] ) : node;\\n\\t}\\n\\td3.layout.treemap = function() {\\n\\t\\tvar hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \\\"squarify\\\", ratio = .5 * ( 1 + Math.sqrt( 5 ) );\\n\\t\\tfunction scale( children, k ) {\\n\\t\\t\\tvar i = -1, n = children.length, child, area;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tarea = ( child = children[i] ).value * ( k < 0 ? 0 : k );\\n\\t\\t\\t\\tchild.area = isNaN( area ) || area <= 0 ? 0 : area;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction squarify( node ) {\\n\\t\\t\\tvar children = node.children;\\n\\t\\t\\tif ( children && children.length ) {\\n\\t\\t\\t\\tvar rect = pad( node ), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \\\"slice\\\" ? rect.dx : mode === \\\"dice\\\" ? rect.dy : mode === \\\"slice-dice\\\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min( rect.dx, rect.dy ), n;\\n\\t\\t\\t\\tscale( remaining, rect.dx * rect.dy / node.value );\\n\\t\\t\\t\\trow.area = 0;\\n\\t\\t\\t\\twhile ( ( n = remaining.length ) > 0 ) {\\n\\t\\t\\t\\t\\trow.push( child = remaining[n - 1] );\\n\\t\\t\\t\\t\\trow.area += child.area;\\n\\t\\t\\t\\t\\tif ( mode !== \\\"squarify\\\" || ( score = worst( row, u ) ) <= best ) {\\n\\t\\t\\t\\t\\t\\tremaining.pop();\\n\\t\\t\\t\\t\\t\\tbest = score;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\trow.area -= row.pop().area;\\n\\t\\t\\t\\t\\t\\tposition( row, u, rect, false );\\n\\t\\t\\t\\t\\t\\tu = Math.min( rect.dx, rect.dy );\\n\\t\\t\\t\\t\\t\\trow.length = row.area = 0;\\n\\t\\t\\t\\t\\t\\tbest = Infinity;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( row.length ) {\\n\\t\\t\\t\\t\\tposition( row, u, rect, true );\\n\\t\\t\\t\\t\\trow.length = row.area = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchildren.forEach( squarify );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction stickify( node ) {\\n\\t\\t\\tvar children = node.children;\\n\\t\\t\\tif ( children && children.length ) {\\n\\t\\t\\t\\tvar rect = pad( node ), remaining = children.slice(), child, row = [];\\n\\t\\t\\t\\tscale( remaining, rect.dx * rect.dy / node.value );\\n\\t\\t\\t\\trow.area = 0;\\n\\t\\t\\t\\twhile ( child = remaining.pop() ) {\\n\\t\\t\\t\\t\\trow.push( child );\\n\\t\\t\\t\\t\\trow.area += child.area;\\n\\t\\t\\t\\t\\tif ( child.z != null ) {\\n\\t\\t\\t\\t\\t\\tposition( row, child.z ? rect.dx : rect.dy, rect, !remaining.length );\\n\\t\\t\\t\\t\\t\\trow.length = row.area = 0;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tchildren.forEach( stickify );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction worst( row, u ) {\\n\\t\\t\\tvar s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( !( r = row[i].area ) ) continue;\\n\\t\\t\\t\\tif ( r < rmin ) rmin = r;\\n\\t\\t\\t\\tif ( r > rmax ) rmax = r;\\n\\t\\t\\t}\\n\\t\\t\\ts *= s;\\n\\t\\t\\tu *= u;\\n\\t\\t\\treturn s ? Math.max( u * rmax * ratio / s, s / ( u * rmin * ratio ) ) : Infinity;\\n\\t\\t}\\n\\t\\tfunction position( row, u, rect, flush ) {\\n\\t\\t\\tvar i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round( row.area / u ) : 0, o;\\n\\t\\t\\tif ( u == rect.dx ) {\\n\\t\\t\\t\\tif ( flush || v > rect.dy ) v = rect.dy;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\to = row[i];\\n\\t\\t\\t\\t\\to.x = x;\\n\\t\\t\\t\\t\\to.y = y;\\n\\t\\t\\t\\t\\to.dy = v;\\n\\t\\t\\t\\t\\tx += o.dx = Math.min( rect.x + rect.dx - x, v ? round( o.area / v ) : 0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\to.z = true;\\n\\t\\t\\t\\to.dx += rect.x + rect.dx - x;\\n\\t\\t\\t\\trect.y += v;\\n\\t\\t\\t\\trect.dy -= v;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ( flush || v > rect.dx ) v = rect.dx;\\n\\t\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\t\\to = row[i];\\n\\t\\t\\t\\t\\to.x = x;\\n\\t\\t\\t\\t\\to.y = y;\\n\\t\\t\\t\\t\\to.dx = v;\\n\\t\\t\\t\\t\\ty += o.dy = Math.min( rect.y + rect.dy - y, v ? round( o.area / v ) : 0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\to.z = false;\\n\\t\\t\\t\\to.dy += rect.y + rect.dy - y;\\n\\t\\t\\t\\trect.x += v;\\n\\t\\t\\t\\trect.dx -= v;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfunction treemap( d ) {\\n\\t\\t\\tvar nodes = stickies || hierarchy( d ), root = nodes[0];\\n\\t\\t\\troot.x = root.y = 0;\\n\\t\\t\\tif ( root.value ) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\\n\\t\\t\\tif ( stickies ) hierarchy.revalue( root );\\n\\t\\t\\tscale( [ root ], root.dx * root.dy / root.value );\\n\\t\\t\\t( stickies ? stickify : squarify )( root );\\n\\t\\t\\tif ( sticky ) stickies = nodes;\\n\\t\\t\\treturn nodes;\\n\\t\\t}\\n\\t\\ttreemap.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = x;\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\ttreemap.padding = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return padding;\\n\\t\\t\\tfunction padFunction( node ) {\\n\\t\\t\\t\\tvar p = x.call( treemap, node, node.depth );\\n\\t\\t\\t\\treturn p == null ? d3_layout_treemapPadNull( node ) : d3_layout_treemapPad( node, typeof p === \\\"number\\\" ? [ p, p, p, p ] : p );\\n\\t\\t\\t}\\n\\t\\t\\tfunction padConstant( node ) {\\n\\t\\t\\t\\treturn d3_layout_treemapPad( node, x );\\n\\t\\t\\t}\\n\\t\\t\\tvar type;\\n\\t\\t\\tpad = ( padding = x ) == null ? d3_layout_treemapPadNull : ( type = typeof x ) === \\\"function\\\" ? padFunction : type === \\\"number\\\" ? ( x = [ x, x, x, x ],\\n\\t\\t\\tpadConstant ) : padConstant;\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\ttreemap.round = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return round != Number;\\n\\t\\t\\tround = x ? Math.round : Number;\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\ttreemap.sticky = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return sticky;\\n\\t\\t\\tsticky = x;\\n\\t\\t\\tstickies = null;\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\ttreemap.ratio = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return ratio;\\n\\t\\t\\tratio = x;\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\ttreemap.mode = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return mode;\\n\\t\\t\\tmode = x + \\\"\\\";\\n\\t\\t\\treturn treemap;\\n\\t\\t};\\n\\t\\treturn d3_layout_hierarchyRebind( treemap, hierarchy );\\n\\t};\\n\\tfunction d3_layout_treemapPadNull( node ) {\\n\\t\\treturn {\\n\\t\\t\\tx: node.x,\\n\\t\\t\\ty: node.y,\\n\\t\\t\\tdx: node.dx,\\n\\t\\t\\tdy: node.dy\\n\\t\\t};\\n\\t}\\n\\tfunction d3_layout_treemapPad( node, padding ) {\\n\\t\\tvar x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\\n\\t\\tif ( dx < 0 ) {\\n\\t\\t\\tx += dx / 2;\\n\\t\\t\\tdx = 0;\\n\\t\\t}\\n\\t\\tif ( dy < 0 ) {\\n\\t\\t\\ty += dy / 2;\\n\\t\\t\\tdy = 0;\\n\\t\\t}\\n\\t\\treturn {\\n\\t\\t\\tx: x,\\n\\t\\t\\ty: y,\\n\\t\\t\\tdx: dx,\\n\\t\\t\\tdy: dy\\n\\t\\t};\\n\\t}\\n\\td3.random = {\\n\\t\\tnormal: function( ,  ) {\\n\\t\\t\\tvar n = arguments.length;\\n\\t\\t\\tif ( n < 2 )  = 1;\\n\\t\\t\\tif ( n < 1 )  = 0;\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\tvar x, y, r;\\n\\t\\t\\t\\tdo {\\n\\t\\t\\t\\t\\tx = Math.random() * 2 - 1;\\n\\t\\t\\t\\t\\ty = Math.random() * 2 - 1;\\n\\t\\t\\t\\t\\tr = x * x + y * y;\\n\\t\\t\\t\\t} while ( !r || r > 1 );\\n\\t\\t\\t\\treturn  +  * x * Math.sqrt( -2 * Math.log( r ) / r );\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tlogNormal: function() {\\n\\t\\t\\tvar random = d3.random.normal.apply( d3, arguments );\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\treturn Math.exp( random() );\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tbates: function( m ) {\\n\\t\\t\\tvar random = d3.random.irwinHall( m );\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\treturn random() / m;\\n\\t\\t\\t};\\n\\t\\t},\\n\\t\\tirwinHall: function( m ) {\\n\\t\\t\\treturn function() {\\n\\t\\t\\t\\tfor ( var s = 0, j = 0; j < m; j++ ) s += Math.random();\\n\\t\\t\\t\\treturn s;\\n\\t\\t\\t};\\n\\t\\t}\\n\\t};\\n\\td3.scale = {};\\n\\tfunction d3_scaleExtent( domain ) {\\n\\t\\tvar start = domain[0], stop = domain[domain.length - 1];\\n\\t\\treturn start < stop ? [ start, stop ] : [ stop, start ];\\n\\t}\\n\\tfunction d3_scaleRange( scale ) {\\n\\t\\treturn scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent( scale.range() );\\n\\t}\\n\\tfunction d3_scale_bilinear( domain, range, uninterpolate, interpolate ) {\\n\\t\\tvar u = uninterpolate( domain[0], domain[1] ), i = interpolate( range[0], range[1] );\\n\\t\\treturn function( x ) {\\n\\t\\t\\treturn i( u( x ) );\\n\\t\\t};\\n\\t}\\n\\tfunction d3_scale_nice( domain, nice ) {\\n\\t\\tvar i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\\n\\t\\tif ( x1 < x0 ) {\\n\\t\\t\\tdx = i0, i0 = i1, i1 = dx;\\n\\t\\t\\tdx = x0, x0 = x1, x1 = dx;\\n\\t\\t}\\n\\t\\tdomain[i0] = nice.floor( x0 );\\n\\t\\tdomain[i1] = nice.ceil( x1 );\\n\\t\\treturn domain;\\n\\t}\\n\\tfunction d3_scale_niceStep( step ) {\\n\\t\\treturn step ? {\\n\\t\\t\\tfloor: function( x ) {\\n\\t\\t\\t\\treturn Math.floor( x / step ) * step;\\n\\t\\t\\t},\\n\\t\\t\\tceil: function( x ) {\\n\\t\\t\\t\\treturn Math.ceil( x / step ) * step;\\n\\t\\t\\t}\\n\\t\\t} : d3_scale_niceIdentity;\\n\\t}\\n\\tvar d3_scale_niceIdentity = {\\n\\t\\tfloor: d3_identity,\\n\\t\\tceil: d3_identity\\n\\t};\\n\\tfunction d3_scale_polylinear( domain, range, uninterpolate, interpolate ) {\\n\\t\\tvar u = [], i = [], j = 0, k = Math.min( domain.length, range.length ) - 1;\\n\\t\\tif ( domain[k] < domain[0] ) {\\n\\t\\t\\tdomain = domain.slice().reverse();\\n\\t\\t\\trange = range.slice().reverse();\\n\\t\\t}\\n\\t\\twhile ( ++j <= k ) {\\n\\t\\t\\tu.push( uninterpolate( domain[j - 1], domain[j] ) );\\n\\t\\t\\ti.push( interpolate( range[j - 1], range[j] ) );\\n\\t\\t}\\n\\t\\treturn function( x ) {\\n\\t\\t\\tvar j = d3.bisect( domain, x, 1, k ) - 1;\\n\\t\\t\\treturn i[j]( u[j]( x ) );\\n\\t\\t};\\n\\t}\\n\\td3.scale.linear = function() {\\n\\t\\treturn d3_scale_linear( [ 0, 1 ], [ 0, 1 ], d3_interpolate, false );\\n\\t};\\n\\tfunction d3_scale_linear( domain, range, interpolate, clamp ) {\\n\\t\\tvar output, input;\\n\\t\\tfunction rescale() {\\n\\t\\t\\tvar linear = Math.min( domain.length, range.length ) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\\n\\t\\t\\toutput = linear( domain, range, uninterpolate, interpolate );\\n\\t\\t\\tinput = linear( range, domain, uninterpolate, d3_interpolate );\\n\\t\\t\\treturn scale;\\n\\t\\t}\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn output( x );\\n\\t\\t}\\n\\t\\tscale.invert = function( y ) {\\n\\t\\t\\treturn input( y );\\n\\t\\t};\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tdomain = x.map( Number );\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return range;\\n\\t\\t\\trange = x;\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.rangeRound = function( x ) {\\n\\t\\t\\treturn scale.range( x ).interpolate( d3_interpolateRound );\\n\\t\\t};\\n\\t\\tscale.clamp = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return clamp;\\n\\t\\t\\tclamp = x;\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.interpolate = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return interpolate;\\n\\t\\t\\tinterpolate = x;\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.ticks = function( m ) {\\n\\t\\t\\treturn d3_scale_linearTicks( domain, m );\\n\\t\\t};\\n\\t\\tscale.tickFormat = function( m, format ) {\\n\\t\\t\\treturn d3_scale_linearTickFormat( domain, m, format );\\n\\t\\t};\\n\\t\\tscale.nice = function( m ) {\\n\\t\\t\\td3_scale_linearNice( domain, m );\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_linear( domain, range, interpolate, clamp );\\n\\t\\t};\\n\\t\\treturn rescale();\\n\\t}\\n\\tfunction d3_scale_linearRebind( scale, linear ) {\\n\\t\\treturn d3.rebind( scale, linear, \\\"range\\\", \\\"rangeRound\\\", \\\"interpolate\\\", \\\"clamp\\\" );\\n\\t}\\n\\tfunction d3_scale_linearNice( domain, m ) {\\n\\t\\td3_scale_nice( domain, d3_scale_niceStep( d3_scale_linearTickRange( domain, m )[2] ) );\\n\\t\\td3_scale_nice( domain, d3_scale_niceStep( d3_scale_linearTickRange( domain, m )[2] ) );\\n\\t\\treturn domain;\\n\\t}\\n\\tfunction d3_scale_linearTickRange( domain, m ) {\\n\\t\\tif ( m == null ) m = 10;\\n\\t\\tvar extent = d3_scaleExtent( domain ), span = extent[1] - extent[0], step = Math.pow( 10, Math.floor( Math.log( span / m ) / Math.LN10 ) ), err = m / span * step;\\n\\t\\tif ( err <= .15 ) step *= 10; else if ( err <= .35 ) step *= 5; else if ( err <= .75 ) step *= 2;\\n\\t\\textent[0] = Math.ceil( extent[0] / step ) * step;\\n\\t\\textent[1] = Math.floor( extent[1] / step ) * step + step * .5;\\n\\t\\textent[2] = step;\\n\\t\\treturn extent;\\n\\t}\\n\\tfunction d3_scale_linearTicks( domain, m ) {\\n\\t\\treturn d3.range.apply( d3, d3_scale_linearTickRange( domain, m ) );\\n\\t}\\n\\tfunction d3_scale_linearTickFormat( domain, m, format ) {\\n\\t\\tvar range = d3_scale_linearTickRange( domain, m );\\n\\t\\tif ( format ) {\\n\\t\\t\\tvar match = d3_format_re.exec( format );\\n\\t\\t\\tmatch.shift();\\n\\t\\t\\tif ( match[8] === \\\"s\\\" ) {\\n\\t\\t\\t\\tvar prefix = d3.formatPrefix( Math.max( abs( range[0] ), abs( range[1] ) ) );\\n\\t\\t\\t\\tif ( !match[7] ) match[7] = \\\".\\\" + d3_scale_linearPrecision( prefix.scale( range[2] ) );\\n\\t\\t\\t\\tmatch[8] = \\\"f\\\";\\n\\t\\t\\t\\tformat = d3.format( match.join( \\\"\\\" ) );\\n\\t\\t\\t\\treturn function( d ) {\\n\\t\\t\\t\\t\\treturn format( prefix.scale( d ) ) + prefix.symbol;\\n\\t\\t\\t\\t};\\n\\t\\t\\t}\\n\\t\\t\\tif ( !match[7] ) match[7] = \\\".\\\" + d3_scale_linearFormatPrecision( match[8], range );\\n\\t\\t\\tformat = match.join( \\\"\\\" );\\n\\t\\t} else {\\n\\t\\t\\tformat = \\\",.\\\" + d3_scale_linearPrecision( range[2] ) + \\\"f\\\";\\n\\t\\t}\\n\\t\\treturn d3.format( format );\\n\\t}\\n\\tvar d3_scale_linearFormatSignificant = {\\n\\t\\ts: 1,\\n\\t\\tg: 1,\\n\\t\\tp: 1,\\n\\t\\tr: 1,\\n\\t\\te: 1\\n\\t};\\n\\tfunction d3_scale_linearPrecision( value ) {\\n\\t\\treturn -Math.floor( Math.log( value ) / Math.LN10 + .01 );\\n\\t}\\n\\tfunction d3_scale_linearFormatPrecision( type, range ) {\\n\\t\\tvar p = d3_scale_linearPrecision( range[2] );\\n\\t\\treturn type in d3_scale_linearFormatSignificant ? Math.abs( p - d3_scale_linearPrecision( Math.max( abs( range[0] ), abs( range[1] ) ) ) ) + +( type !== \\\"e\\\" ) : p - ( type === \\\"%\\\" ) * 2;\\n\\t}\\n\\td3.scale.log = function() {\\n\\t\\treturn d3_scale_log( d3.scale.linear().domain( [ 0, 1 ] ), 10, true, [ 1, 10 ] );\\n\\t};\\n\\tfunction d3_scale_log( linear, base, positive, domain ) {\\n\\t\\tfunction log( x ) {\\n\\t\\t\\treturn ( positive ? Math.log( x < 0 ? 0 : x ) : -Math.log( x > 0 ? 0 : -x ) ) / Math.log( base );\\n\\t\\t}\\n\\t\\tfunction pow( x ) {\\n\\t\\t\\treturn positive ? Math.pow( base, x ) : -Math.pow( base, -x );\\n\\t\\t}\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn linear( log( x ) );\\n\\t\\t}\\n\\t\\tscale.invert = function( x ) {\\n\\t\\t\\treturn pow( linear.invert( x ) );\\n\\t\\t};\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tpositive = x[0] >= 0;\\n\\t\\t\\tlinear.domain( ( domain = x.map( Number ) ).map( log ) );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.base = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return base;\\n\\t\\t\\tbase = +_;\\n\\t\\t\\tlinear.domain( domain.map( log ) );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.nice = function() {\\n\\t\\t\\tvar niced = d3_scale_nice( domain.map( log ), positive ? Math : d3_scale_logNiceNegative );\\n\\t\\t\\tlinear.domain( niced );\\n\\t\\t\\tdomain = niced.map( pow );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.ticks = function() {\\n\\t\\t\\tvar extent = d3_scaleExtent( domain ), ticks = [], u = extent[0], v = extent[1], i = Math.floor( log( u ) ), j = Math.ceil( log( v ) ), n = base % 1 ? 2 : base;\\n\\t\\t\\tif ( isFinite( j - i ) ) {\\n\\t\\t\\t\\tif ( positive ) {\\n\\t\\t\\t\\t\\tfor ( ;i < j; i++ ) for ( var k = 1; k < n; k++ ) ticks.push( pow( i ) * k );\\n\\t\\t\\t\\t\\tticks.push( pow( i ) );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tticks.push( pow( i ) );\\n\\t\\t\\t\\t\\tfor ( ;i++ < j; ) for ( var k = n - 1; k > 0; k-- ) ticks.push( pow( i ) * k );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor ( i = 0; ticks[i] < u; i++ ) {}\\n\\t\\t\\t\\tfor ( j = ticks.length; ticks[j - 1] > v; j-- ) {}\\n\\t\\t\\t\\tticks = ticks.slice( i, j );\\n\\t\\t\\t}\\n\\t\\t\\treturn ticks;\\n\\t\\t};\\n\\t\\tscale.tickFormat = function( n, format ) {\\n\\t\\t\\tif ( !arguments.length ) return d3_scale_logFormat;\\n\\t\\t\\tif ( arguments.length < 2 ) format = d3_scale_logFormat; else if ( typeof format !== \\\"function\\\" ) format = d3.format( format );\\n\\t\\t\\tvar k = Math.max( 1, base * n / scale.ticks().length );\\n\\t\\t\\treturn function( d ) {\\n\\t\\t\\t\\tvar i = d / pow( Math.round( log( d ) ) );\\n\\t\\t\\t\\tif ( i * base < base - .5 ) i *= base;\\n\\t\\t\\t\\treturn i <= k ? format( d ) : \\\"\\\";\\n\\t\\t\\t};\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_log( linear.copy(), base, positive, domain );\\n\\t\\t};\\n\\t\\treturn d3_scale_linearRebind( scale, linear );\\n\\t}\\n\\tvar d3_scale_logFormat = d3.format( \\\".0e\\\" ), d3_scale_logNiceNegative = {\\n\\t\\tfloor: function( x ) {\\n\\t\\t\\treturn -Math.ceil( -x );\\n\\t\\t},\\n\\t\\tceil: function( x ) {\\n\\t\\t\\treturn -Math.floor( -x );\\n\\t\\t}\\n\\t};\\n\\td3.scale.pow = function() {\\n\\t\\treturn d3_scale_pow( d3.scale.linear(), 1, [ 0, 1 ] );\\n\\t};\\n\\tfunction d3_scale_pow( linear, exponent, domain ) {\\n\\t\\tvar powp = d3_scale_powPow( exponent ), powb = d3_scale_powPow( 1 / exponent );\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn linear( powp( x ) );\\n\\t\\t}\\n\\t\\tscale.invert = function( x ) {\\n\\t\\t\\treturn powb( linear.invert( x ) );\\n\\t\\t};\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tlinear.domain( ( domain = x.map( Number ) ).map( powp ) );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.ticks = function( m ) {\\n\\t\\t\\treturn d3_scale_linearTicks( domain, m );\\n\\t\\t};\\n\\t\\tscale.tickFormat = function( m, format ) {\\n\\t\\t\\treturn d3_scale_linearTickFormat( domain, m, format );\\n\\t\\t};\\n\\t\\tscale.nice = function( m ) {\\n\\t\\t\\treturn scale.domain( d3_scale_linearNice( domain, m ) );\\n\\t\\t};\\n\\t\\tscale.exponent = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return exponent;\\n\\t\\t\\tpowp = d3_scale_powPow( exponent = x );\\n\\t\\t\\tpowb = d3_scale_powPow( 1 / exponent );\\n\\t\\t\\tlinear.domain( domain.map( powp ) );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_pow( linear.copy(), exponent, domain );\\n\\t\\t};\\n\\t\\treturn d3_scale_linearRebind( scale, linear );\\n\\t}\\n\\tfunction d3_scale_powPow( e ) {\\n\\t\\treturn function( x ) {\\n\\t\\t\\treturn x < 0 ? -Math.pow( -x, e ) : Math.pow( x, e );\\n\\t\\t};\\n\\t}\\n\\td3.scale.sqrt = function() {\\n\\t\\treturn d3.scale.pow().exponent( .5 );\\n\\t};\\n\\td3.scale.ordinal = function() {\\n\\t\\treturn d3_scale_ordinal( [], {\\n\\t\\t\\tt: \\\"range\\\",\\n\\t\\t\\ta: [ [] ]\\n\\t\\t} );\\n\\t};\\n\\tfunction d3_scale_ordinal( domain, ranger ) {\\n\\t\\tvar index, range, rangeBand;\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn range[( ( index.get( x ) || ( ranger.t === \\\"range\\\" ? index.set( x, domain.push( x ) ) : NaN ) ) - 1 ) % range.length];\\n\\t\\t}\\n\\t\\tfunction steps( start, step ) {\\n\\t\\t\\treturn d3.range( domain.length ).map( function( i ) {\\n\\t\\t\\t\\treturn start + step * i;\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tdomain = [];\\n\\t\\t\\tindex = new d3_Map();\\n\\t\\t\\tvar i = -1, n = x.length, xi;\\n\\t\\t\\twhile ( ++i < n ) if ( !index.has( xi = x[i] ) ) index.set( xi, domain.push( xi ) );\\n\\t\\t\\treturn scale[ranger.t].apply( scale, ranger.a );\\n\\t\\t};\\n\\t\\tscale.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return range;\\n\\t\\t\\trange = x;\\n\\t\\t\\trangeBand = 0;\\n\\t\\t\\tranger = {\\n\\t\\t\\t\\tt: \\\"range\\\",\\n\\t\\t\\t\\ta: arguments\\n\\t\\t\\t};\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.rangePoints = function( x, padding ) {\\n\\t\\t\\tif ( arguments.length < 2 ) padding = 0;\\n\\t\\t\\tvar start = x[0], stop = x[1], step = domain.length < 2 ? ( start = ( start + stop ) / 2,\\n\\t\\t\\t0 ) : ( stop - start ) / ( domain.length - 1 + padding );\\n\\t\\t\\trange = steps( start + step * padding / 2, step );\\n\\t\\t\\trangeBand = 0;\\n\\t\\t\\tranger = {\\n\\t\\t\\t\\tt: \\\"rangePoints\\\",\\n\\t\\t\\t\\ta: arguments\\n\\t\\t\\t};\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.rangeRoundPoints = function( x, padding ) {\\n\\t\\t\\tif ( arguments.length < 2 ) padding = 0;\\n\\t\\t\\tvar start = x[0], stop = x[1], step = domain.length < 2 ? ( start = stop = Math.round( ( start + stop ) / 2 ),\\n\\t\\t\\t0 ) : ( stop - start ) / ( domain.length - 1 + padding ) | 0;\\n\\t\\t\\trange = steps( start + Math.round( step * padding / 2 + ( stop - start - ( domain.length - 1 + padding ) * step ) / 2 ), step );\\n\\t\\t\\trangeBand = 0;\\n\\t\\t\\tranger = {\\n\\t\\t\\t\\tt: \\\"rangeRoundPoints\\\",\\n\\t\\t\\t\\ta: arguments\\n\\t\\t\\t};\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.rangeBands = function( x, padding, outerPadding ) {\\n\\t\\t\\tif ( arguments.length < 2 ) padding = 0;\\n\\t\\t\\tif ( arguments.length < 3 ) outerPadding = padding;\\n\\t\\t\\tvar reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = ( stop - start ) / ( domain.length - padding + 2 * outerPadding );\\n\\t\\t\\trange = steps( start + step * outerPadding, step );\\n\\t\\t\\tif ( reverse ) range.reverse();\\n\\t\\t\\trangeBand = step * ( 1 - padding );\\n\\t\\t\\tranger = {\\n\\t\\t\\t\\tt: \\\"rangeBands\\\",\\n\\t\\t\\t\\ta: arguments\\n\\t\\t\\t};\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.rangeRoundBands = function( x, padding, outerPadding ) {\\n\\t\\t\\tif ( arguments.length < 2 ) padding = 0;\\n\\t\\t\\tif ( arguments.length < 3 ) outerPadding = padding;\\n\\t\\t\\tvar reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor( ( stop - start ) / ( domain.length - padding + 2 * outerPadding ) );\\n\\t\\t\\trange = steps( start + Math.round( ( stop - start - ( domain.length - padding ) * step ) / 2 ), step );\\n\\t\\t\\tif ( reverse ) range.reverse();\\n\\t\\t\\trangeBand = Math.round( step * ( 1 - padding ) );\\n\\t\\t\\tranger = {\\n\\t\\t\\t\\tt: \\\"rangeRoundBands\\\",\\n\\t\\t\\t\\ta: arguments\\n\\t\\t\\t};\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.rangeBand = function() {\\n\\t\\t\\treturn rangeBand;\\n\\t\\t};\\n\\t\\tscale.rangeExtent = function() {\\n\\t\\t\\treturn d3_scaleExtent( ranger.a[0] );\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_ordinal( domain, ranger );\\n\\t\\t};\\n\\t\\treturn scale.domain( domain );\\n\\t}\\n\\td3.scale.category10 = function() {\\n\\t\\treturn d3.scale.ordinal().range( d3_category10 );\\n\\t};\\n\\td3.scale.category20 = function() {\\n\\t\\treturn d3.scale.ordinal().range( d3_category20 );\\n\\t};\\n\\td3.scale.category20b = function() {\\n\\t\\treturn d3.scale.ordinal().range( d3_category20b );\\n\\t};\\n\\td3.scale.category20c = function() {\\n\\t\\treturn d3.scale.ordinal().range( d3_category20c );\\n\\t};\\n\\tvar d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map( d3_rgbString );\\n\\tvar d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map( d3_rgbString );\\n\\tvar d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map( d3_rgbString );\\n\\tvar d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map( d3_rgbString );\\n\\td3.scale.quantile = function() {\\n\\t\\treturn d3_scale_quantile( [], [] );\\n\\t};\\n\\tfunction d3_scale_quantile( domain, range ) {\\n\\t\\tvar thresholds;\\n\\t\\tfunction rescale() {\\n\\t\\t\\tvar k = 0, q = range.length;\\n\\t\\t\\tthresholds = [];\\n\\t\\t\\twhile ( ++k < q ) thresholds[k - 1] = d3.quantile( domain, k / q );\\n\\t\\t\\treturn scale;\\n\\t\\t}\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\tif ( !isNaN( x = +x ) ) return range[d3.bisect( thresholds, x )];\\n\\t\\t}\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tdomain = x.map( d3_number ).filter( d3_numeric ).sort( d3_ascending );\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return range;\\n\\t\\t\\trange = x;\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.quantiles = function() {\\n\\t\\t\\treturn thresholds;\\n\\t\\t};\\n\\t\\tscale.invertExtent = function( y ) {\\n\\t\\t\\ty = range.indexOf( y );\\n\\t\\t\\treturn y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_quantile( domain, range );\\n\\t\\t};\\n\\t\\treturn rescale();\\n\\t}\\n\\td3.scale.quantize = function() {\\n\\t\\treturn d3_scale_quantize( 0, 1, [ 0, 1 ] );\\n\\t};\\n\\tfunction d3_scale_quantize( x0, x1, range ) {\\n\\t\\tvar kx, i;\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn range[Math.max( 0, Math.min( i, Math.floor( kx * ( x - x0 ) ) ) )];\\n\\t\\t}\\n\\t\\tfunction rescale() {\\n\\t\\t\\tkx = range.length / ( x1 - x0 );\\n\\t\\t\\ti = range.length - 1;\\n\\t\\t\\treturn scale;\\n\\t\\t}\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return [ x0, x1 ];\\n\\t\\t\\tx0 = +x[0];\\n\\t\\t\\tx1 = +x[x.length - 1];\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return range;\\n\\t\\t\\trange = x;\\n\\t\\t\\treturn rescale();\\n\\t\\t};\\n\\t\\tscale.invertExtent = function( y ) {\\n\\t\\t\\ty = range.indexOf( y );\\n\\t\\t\\ty = y < 0 ? NaN : y / kx + x0;\\n\\t\\t\\treturn [ y, y + 1 / kx ];\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_quantize( x0, x1, range );\\n\\t\\t};\\n\\t\\treturn rescale();\\n\\t}\\n\\td3.scale.threshold = function() {\\n\\t\\treturn d3_scale_threshold( [ .5 ], [ 0, 1 ] );\\n\\t};\\n\\tfunction d3_scale_threshold( domain, range ) {\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\tif ( x <= x ) return range[d3.bisect( domain, x )];\\n\\t\\t}\\n\\t\\tscale.domain = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tdomain = _;\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.range = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return range;\\n\\t\\t\\trange = _;\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tscale.invertExtent = function( y ) {\\n\\t\\t\\ty = range.indexOf( y );\\n\\t\\t\\treturn [ domain[y - 1], domain[y] ];\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_scale_threshold( domain, range );\\n\\t\\t};\\n\\t\\treturn scale;\\n\\t}\\n\\td3.scale.identity = function() {\\n\\t\\treturn d3_scale_identity( [ 0, 1 ] );\\n\\t};\\n\\tfunction d3_scale_identity( domain ) {\\n\\t\\tfunction identity( x ) {\\n\\t\\t\\treturn +x;\\n\\t\\t}\\n\\t\\tidentity.invert = identity;\\n\\t\\tidentity.domain = identity.range = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return domain;\\n\\t\\t\\tdomain = x.map( identity );\\n\\t\\t\\treturn identity;\\n\\t\\t};\\n\\t\\tidentity.ticks = function( m ) {\\n\\t\\t\\treturn d3_scale_linearTicks( domain, m );\\n\\t\\t};\\n\\t\\tidentity.tickFormat = function( m, format ) {\\n\\t\\t\\treturn d3_scale_linearTickFormat( domain, m, format );\\n\\t\\t};\\n\\t\\tidentity.copy = function() {\\n\\t\\t\\treturn d3_scale_identity( domain );\\n\\t\\t};\\n\\t\\treturn identity;\\n\\t}\\n\\td3.svg = {};\\n\\tfunction d3_zero() {\\n\\t\\treturn 0;\\n\\t}\\n\\td3.svg.arc = function() {\\n\\t\\tvar innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\\n\\t\\tfunction arc() {\\n\\t\\t\\tvar r0 = Math.max( 0, +innerRadius.apply( this, arguments ) ), r1 = Math.max( 0, +outerRadius.apply( this, arguments ) ), a0 = startAngle.apply( this, arguments ) - half, a1 = endAngle.apply( this, arguments ) - half, da = Math.abs( a1 - a0 ), cw = a0 > a1 ? 0 : 1;\\n\\t\\t\\tif ( r1 < r0 ) rc = r1, r1 = r0, r0 = rc;\\n\\t\\t\\tif ( da >=  ) return circleSegment( r1, cw ) + ( r0 ? circleSegment( r0, 1 - cw ) : \\\"\\\" ) + \\\"Z\\\";\\n\\t\\t\\tvar rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\\n\\t\\t\\tif ( ap = ( +padAngle.apply( this, arguments ) || 0 ) / 2 ) {\\n\\t\\t\\t\\trp = padRadius === d3_svg_arcAuto ? Math.sqrt( r0 * r0 + r1 * r1 ) : +padRadius.apply( this, arguments );\\n\\t\\t\\t\\tif ( !cw ) p1 *= -1;\\n\\t\\t\\t\\tif ( r1 ) p1 = d3_asin( rp / r1 * Math.sin( ap ) );\\n\\t\\t\\t\\tif ( r0 ) p0 = d3_asin( rp / r0 * Math.sin( ap ) );\\n\\t\\t\\t}\\n\\t\\t\\tif ( r1 ) {\\n\\t\\t\\t\\tx0 = r1 * Math.cos( a0 + p1 );\\n\\t\\t\\t\\ty0 = r1 * Math.sin( a0 + p1 );\\n\\t\\t\\t\\tx1 = r1 * Math.cos( a1 - p1 );\\n\\t\\t\\t\\ty1 = r1 * Math.sin( a1 - p1 );\\n\\t\\t\\t\\tvar l1 = Math.abs( a1 - a0 - 2 * p1 ) <=  ? 0 : 1;\\n\\t\\t\\t\\tif ( p1 && d3_svg_arcSweep( x0, y0, x1, y1 ) === cw ^ l1 ) {\\n\\t\\t\\t\\t\\tvar h1 = ( a0 + a1 ) / 2;\\n\\t\\t\\t\\t\\tx0 = r1 * Math.cos( h1 );\\n\\t\\t\\t\\t\\ty0 = r1 * Math.sin( h1 );\\n\\t\\t\\t\\t\\tx1 = y1 = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tx0 = y0 = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ( r0 ) {\\n\\t\\t\\t\\tx2 = r0 * Math.cos( a1 - p0 );\\n\\t\\t\\t\\ty2 = r0 * Math.sin( a1 - p0 );\\n\\t\\t\\t\\tx3 = r0 * Math.cos( a0 + p0 );\\n\\t\\t\\t\\ty3 = r0 * Math.sin( a0 + p0 );\\n\\t\\t\\t\\tvar l0 = Math.abs( a0 - a1 + 2 * p0 ) <=  ? 0 : 1;\\n\\t\\t\\t\\tif ( p0 && d3_svg_arcSweep( x2, y2, x3, y3 ) === 1 - cw ^ l0 ) {\\n\\t\\t\\t\\t\\tvar h0 = ( a0 + a1 ) / 2;\\n\\t\\t\\t\\t\\tx2 = r0 * Math.cos( h0 );\\n\\t\\t\\t\\t\\ty2 = r0 * Math.sin( h0 );\\n\\t\\t\\t\\t\\tx3 = y3 = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tx2 = y2 = 0;\\n\\t\\t\\t}\\n\\t\\t\\tif ( da >  && ( rc = Math.min( Math.abs( r1 - r0 ) / 2, +cornerRadius.apply( this, arguments ) ) ) > .001 ) {\\n\\t\\t\\t\\tcr = r0 < r1 ^ cw ? 0 : 1;\\n\\t\\t\\t\\tvar rc1 = rc, rc0 = rc;\\n\\t\\t\\t\\tif ( da <  ) {\\n\\t\\t\\t\\t\\tvar oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect( [ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ] ), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin( Math.acos( ( ax * bx + ay * by ) / ( Math.sqrt( ax * ax + ay * ay ) * Math.sqrt( bx * bx + by * by ) ) ) / 2 ), lc = Math.sqrt( oc[0] * oc[0] + oc[1] * oc[1] );\\n\\t\\t\\t\\t\\trc0 = Math.min( rc, ( r0 - lc ) / ( kc - 1 ) );\\n\\t\\t\\t\\t\\trc1 = Math.min( rc, ( r1 - lc ) / ( kc + 1 ) );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( x1 != null ) {\\n\\t\\t\\t\\t\\tvar t30 = d3_svg_arcCornerTangents( x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw ), t12 = d3_svg_arcCornerTangents( [ x1, y1 ], [ x2, y2 ], r1, rc1, cw );\\n\\t\\t\\t\\t\\tif ( rc === rc1 ) {\\n\\t\\t\\t\\t\\t\\tpath.push( \\\"M\\\", t30[0], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 0,\\\", cr, \\\" \\\", t30[1], \\\"A\\\", r1, \\\",\\\", r1, \\\" 0 \\\", 1 - cw ^ d3_svg_arcSweep( t30[1][0], t30[1][1], t12[1][0], t12[1][1] ), \\\",\\\", cw, \\\" \\\", t12[1], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 0,\\\", cr, \\\" \\\", t12[0] );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpath.push( \\\"M\\\", t30[0], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 1,\\\", cr, \\\" \\\", t12[0] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpath.push( \\\"M\\\", x0, \\\",\\\", y0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( x3 != null ) {\\n\\t\\t\\t\\t\\tvar t03 = d3_svg_arcCornerTangents( [ x0, y0 ], [ x3, y3 ], r0, -rc0, cw ), t21 = d3_svg_arcCornerTangents( [ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw );\\n\\t\\t\\t\\t\\tif ( rc === rc0 ) {\\n\\t\\t\\t\\t\\t\\tpath.push( \\\"L\\\", t21[0], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t21[1], \\\"A\\\", r0, \\\",\\\", r0, \\\" 0 \\\", cw ^ d3_svg_arcSweep( t21[1][0], t21[1][1], t03[1][0], t03[1][1] ), \\\",\\\", 1 - cw, \\\" \\\", t03[1], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t03[0] );\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tpath.push( \\\"L\\\", t21[0], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t03[0] );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpath.push( \\\"L\\\", x2, \\\",\\\", y2 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tpath.push( \\\"M\\\", x0, \\\",\\\", y0 );\\n\\t\\t\\t\\tif ( x1 != null ) path.push( \\\"A\\\", r1, \\\",\\\", r1, \\\" 0 \\\", l1, \\\",\\\", cw, \\\" \\\", x1, \\\",\\\", y1 );\\n\\t\\t\\t\\tpath.push( \\\"L\\\", x2, \\\",\\\", y2 );\\n\\t\\t\\t\\tif ( x3 != null ) path.push( \\\"A\\\", r0, \\\",\\\", r0, \\\" 0 \\\", l0, \\\",\\\", 1 - cw, \\\" \\\", x3, \\\",\\\", y3 );\\n\\t\\t\\t}\\n\\t\\t\\tpath.push( \\\"Z\\\" );\\n\\t\\t\\treturn path.join( \\\"\\\" );\\n\\t\\t}\\n\\t\\tfunction circleSegment( r1, cw ) {\\n\\t\\t\\treturn \\\"M0,\\\" + r1 + \\\"A\\\" + r1 + \\\",\\\" + r1 + \\\" 0 1,\\\" + cw + \\\" 0,\\\" + -r1 + \\\"A\\\" + r1 + \\\",\\\" + r1 + \\\" 0 1,\\\" + cw + \\\" 0,\\\" + r1;\\n\\t\\t}\\n\\t\\tarc.innerRadius = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return innerRadius;\\n\\t\\t\\tinnerRadius = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.outerRadius = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return outerRadius;\\n\\t\\t\\touterRadius = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.cornerRadius = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return cornerRadius;\\n\\t\\t\\tcornerRadius = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.padRadius = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return padRadius;\\n\\t\\t\\tpadRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.startAngle = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return startAngle;\\n\\t\\t\\tstartAngle = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.endAngle = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return endAngle;\\n\\t\\t\\tendAngle = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.padAngle = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return padAngle;\\n\\t\\t\\tpadAngle = d3_functor( v );\\n\\t\\t\\treturn arc;\\n\\t\\t};\\n\\t\\tarc.centroid = function() {\\n\\t\\t\\tvar r = ( +innerRadius.apply( this, arguments ) + +outerRadius.apply( this, arguments ) ) / 2, a = ( +startAngle.apply( this, arguments ) + +endAngle.apply( this, arguments ) ) / 2 - half;\\n\\t\\t\\treturn [ Math.cos( a ) * r, Math.sin( a ) * r ];\\n\\t\\t};\\n\\t\\treturn arc;\\n\\t};\\n\\tvar d3_svg_arcAuto = \\\"auto\\\";\\n\\tfunction d3_svg_arcInnerRadius( d ) {\\n\\t\\treturn d.innerRadius;\\n\\t}\\n\\tfunction d3_svg_arcOuterRadius( d ) {\\n\\t\\treturn d.outerRadius;\\n\\t}\\n\\tfunction d3_svg_arcStartAngle( d ) {\\n\\t\\treturn d.startAngle;\\n\\t}\\n\\tfunction d3_svg_arcEndAngle( d ) {\\n\\t\\treturn d.endAngle;\\n\\t}\\n\\tfunction d3_svg_arcPadAngle( d ) {\\n\\t\\treturn d && d.padAngle;\\n\\t}\\n\\tfunction d3_svg_arcSweep( x0, y0, x1, y1 ) {\\n\\t\\treturn ( x0 - x1 ) * y0 - ( y0 - y1 ) * x0 > 0 ? 0 : 1;\\n\\t}\\n\\tfunction d3_svg_arcCornerTangents( p0, p1, r1, rc, cw ) {\\n\\t\\tvar x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = ( cw ? rc : -rc ) / Math.sqrt( x01 * x01 + y01 * y01 ), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = ( x1 + x2 ) / 2, y3 = ( y1 + y2 ) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = ( dy < 0 ? -1 : 1 ) * Math.sqrt( Math.max( 0, r * r * d2 - D * D ) ), cx0 = ( D * dy - dx * d ) / d2, cy0 = ( -D * dx - dy * d ) / d2, cx1 = ( D * dy + dx * d ) / d2, cy1 = ( -D * dx + dy * d ) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\\n\\t\\tif ( dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1 ) cx0 = cx1, cy0 = cy1;\\n\\t\\treturn [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\\n\\t}\\n\\tfunction d3_svg_line( projection ) {\\n\\t\\tvar x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\\n\\t\\tfunction line( data ) {\\n\\t\\t\\tvar segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor( x ), fy = d3_functor( y );\\n\\t\\t\\tfunction segment() {\\n\\t\\t\\t\\tsegments.push( \\\"M\\\", interpolate( projection( points ), tension ) );\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( defined.call( this, d = data[i], i ) ) {\\n\\t\\t\\t\\t\\tpoints.push( [ +fx.call( this, d, i ), +fy.call( this, d, i ) ] );\\n\\t\\t\\t\\t} else if ( points.length ) {\\n\\t\\t\\t\\t\\tsegment();\\n\\t\\t\\t\\t\\tpoints = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( points.length ) segment();\\n\\t\\t\\treturn segments.length ? segments.join( \\\"\\\" ) : null;\\n\\t\\t}\\n\\t\\tline.x = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x;\\n\\t\\t\\tx = _;\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t\\tline.y = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return y;\\n\\t\\t\\ty = _;\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t\\tline.defined = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return defined;\\n\\t\\t\\tdefined = _;\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t\\tline.interpolate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return interpolateKey;\\n\\t\\t\\tif ( typeof _ === \\\"function\\\" ) interpolateKey = interpolate = _; else interpolateKey = ( interpolate = d3_svg_lineInterpolators.get( _ ) || d3_svg_lineLinear ).key;\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t\\tline.tension = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return tension;\\n\\t\\t\\ttension = _;\\n\\t\\t\\treturn line;\\n\\t\\t};\\n\\t\\treturn line;\\n\\t}\\n\\td3.svg.line = function() {\\n\\t\\treturn d3_svg_line( d3_identity );\\n\\t};\\n\\tvar d3_svg_lineInterpolators = d3.map( {\\n\\t\\tlinear: d3_svg_lineLinear,\\n\\t\\t\\\"linear-closed\\\": d3_svg_lineLinearClosed,\\n\\t\\tstep: d3_svg_lineStep,\\n\\t\\t\\\"step-before\\\": d3_svg_lineStepBefore,\\n\\t\\t\\\"step-after\\\": d3_svg_lineStepAfter,\\n\\t\\tbasis: d3_svg_lineBasis,\\n\\t\\t\\\"basis-open\\\": d3_svg_lineBasisOpen,\\n\\t\\t\\\"basis-closed\\\": d3_svg_lineBasisClosed,\\n\\t\\tbundle: d3_svg_lineBundle,\\n\\t\\tcardinal: d3_svg_lineCardinal,\\n\\t\\t\\\"cardinal-open\\\": d3_svg_lineCardinalOpen,\\n\\t\\t\\\"cardinal-closed\\\": d3_svg_lineCardinalClosed,\\n\\t\\tmonotone: d3_svg_lineMonotone\\n\\t} );\\n\\td3_svg_lineInterpolators.forEach( function( key, value ) {\\n\\t\\tvalue.key = key;\\n\\t\\tvalue.closed = /-closed$/.test( key );\\n\\t} );\\n\\tfunction d3_svg_lineLinear( points ) {\\n\\t\\treturn points.length > 1 ? points.join( \\\"L\\\" ) : points + \\\"Z\\\";\\n\\t}\\n\\tfunction d3_svg_lineLinearClosed( points ) {\\n\\t\\treturn points.join( \\\"L\\\" ) + \\\"Z\\\";\\n\\t}\\n\\tfunction d3_svg_lineStep( points ) {\\n\\t\\tvar i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n\\t\\twhile ( ++i < n ) path.push( \\\"H\\\", ( p[0] + ( p = points[i] )[0] ) / 2, \\\"V\\\", p[1] );\\n\\t\\tif ( n > 1 ) path.push( \\\"H\\\", p[0] );\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineStepBefore( points ) {\\n\\t\\tvar i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n\\t\\twhile ( ++i < n ) path.push( \\\"V\\\", ( p = points[i] )[1], \\\"H\\\", p[0] );\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineStepAfter( points ) {\\n\\t\\tvar i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n\\t\\twhile ( ++i < n ) path.push( \\\"H\\\", ( p = points[i] )[0], \\\"V\\\", p[1] );\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineCardinalOpen( points, tension ) {\\n\\t\\treturn points.length < 4 ? d3_svg_lineLinear( points ) : points[1] + d3_svg_lineHermite( points.slice( 1, -1 ), d3_svg_lineCardinalTangents( points, tension ) );\\n\\t}\\n\\tfunction d3_svg_lineCardinalClosed( points, tension ) {\\n\\t\\treturn points.length < 3 ? d3_svg_lineLinearClosed( points ) : points[0] + d3_svg_lineHermite( ( points.push( points[0] ),\\n\\t\\tpoints ), d3_svg_lineCardinalTangents( [ points[points.length - 2] ].concat( points, [ points[1] ] ), tension ) );\\n\\t}\\n\\tfunction d3_svg_lineCardinal( points, tension ) {\\n\\t\\treturn points.length < 3 ? d3_svg_lineLinear( points ) : points[0] + d3_svg_lineHermite( points, d3_svg_lineCardinalTangents( points, tension ) );\\n\\t}\\n\\tfunction d3_svg_lineHermite( points, tangents ) {\\n\\t\\tif ( tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2 ) {\\n\\t\\t\\treturn d3_svg_lineLinear( points );\\n\\t\\t}\\n\\t\\tvar quad = points.length != tangents.length, path = \\\"\\\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\\n\\t\\tif ( quad ) {\\n\\t\\t\\tpath += \\\"Q\\\" + ( p[0] - t0[0] * 2 / 3 ) + \\\",\\\" + ( p[1] - t0[1] * 2 / 3 ) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n\\t\\t\\tp0 = points[1];\\n\\t\\t\\tpi = 2;\\n\\t\\t}\\n\\t\\tif ( tangents.length > 1 ) {\\n\\t\\t\\tt = tangents[1];\\n\\t\\t\\tp = points[pi];\\n\\t\\t\\tpi++;\\n\\t\\t\\tpath += \\\"C\\\" + ( p0[0] + t0[0] ) + \\\",\\\" + ( p0[1] + t0[1] ) + \\\",\\\" + ( p[0] - t[0] ) + \\\",\\\" + ( p[1] - t[1] ) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n\\t\\t\\tfor ( var i = 2; i < tangents.length; i++, pi++ ) {\\n\\t\\t\\t\\tp = points[pi];\\n\\t\\t\\t\\tt = tangents[i];\\n\\t\\t\\t\\tpath += \\\"S\\\" + ( p[0] - t[0] ) + \\\",\\\" + ( p[1] - t[1] ) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( quad ) {\\n\\t\\t\\tvar lp = points[pi];\\n\\t\\t\\tpath += \\\"Q\\\" + ( p[0] + t[0] * 2 / 3 ) + \\\",\\\" + ( p[1] + t[1] * 2 / 3 ) + \\\",\\\" + lp[0] + \\\",\\\" + lp[1];\\n\\t\\t}\\n\\t\\treturn path;\\n\\t}\\n\\tfunction d3_svg_lineCardinalTangents( points, tension ) {\\n\\t\\tvar tangents = [], a = ( 1 - tension ) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\tp0 = p1;\\n\\t\\t\\tp1 = p2;\\n\\t\\t\\tp2 = points[i];\\n\\t\\t\\ttangents.push( [ a * ( p2[0] - p0[0] ), a * ( p2[1] - p0[1] ) ] );\\n\\t\\t}\\n\\t\\treturn tangents;\\n\\t}\\n\\tfunction d3_svg_lineBasis( points ) {\\n\\t\\tif ( points.length < 3 ) return d3_svg_lineLinear( points );\\n\\t\\tvar i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, ( pi = points[1] )[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \\\",\\\", y0, \\\"L\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier3, px ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier3, py ) ];\\n\\t\\tpoints.push( points[n - 1] );\\n\\t\\twhile ( ++i <= n ) {\\n\\t\\t\\tpi = points[i];\\n\\t\\t\\tpx.shift();\\n\\t\\t\\tpx.push( pi[0] );\\n\\t\\t\\tpy.shift();\\n\\t\\t\\tpy.push( pi[1] );\\n\\t\\t\\td3_svg_lineBasisBezier( path, px, py );\\n\\t\\t}\\n\\t\\tpoints.pop();\\n\\t\\tpath.push( \\\"L\\\", pi );\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineBasisOpen( points ) {\\n\\t\\tif ( points.length < 4 ) return d3_svg_lineLinear( points );\\n\\t\\tvar path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\\n\\t\\twhile ( ++i < 3 ) {\\n\\t\\t\\tpi = points[i];\\n\\t\\t\\tpx.push( pi[0] );\\n\\t\\t\\tpy.push( pi[1] );\\n\\t\\t}\\n\\t\\tpath.push( d3_svg_lineDot4( d3_svg_lineBasisBezier3, px ) + \\\",\\\" + d3_svg_lineDot4( d3_svg_lineBasisBezier3, py ) );\\n\\t\\t--i;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\tpi = points[i];\\n\\t\\t\\tpx.shift();\\n\\t\\t\\tpx.push( pi[0] );\\n\\t\\t\\tpy.shift();\\n\\t\\t\\tpy.push( pi[1] );\\n\\t\\t\\td3_svg_lineBasisBezier( path, px, py );\\n\\t\\t}\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineBasisClosed( points ) {\\n\\t\\tvar path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\\n\\t\\twhile ( ++i < 4 ) {\\n\\t\\t\\tpi = points[i % n];\\n\\t\\t\\tpx.push( pi[0] );\\n\\t\\t\\tpy.push( pi[1] );\\n\\t\\t}\\n\\t\\tpath = [ d3_svg_lineDot4( d3_svg_lineBasisBezier3, px ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier3, py ) ];\\n\\t\\t--i;\\n\\t\\twhile ( ++i < m ) {\\n\\t\\t\\tpi = points[i % n];\\n\\t\\t\\tpx.shift();\\n\\t\\t\\tpx.push( pi[0] );\\n\\t\\t\\tpy.shift();\\n\\t\\t\\tpy.push( pi[1] );\\n\\t\\t\\td3_svg_lineBasisBezier( path, px, py );\\n\\t\\t}\\n\\t\\treturn path.join( \\\"\\\" );\\n\\t}\\n\\tfunction d3_svg_lineBundle( points, tension ) {\\n\\t\\tvar n = points.length - 1;\\n\\t\\tif ( n ) {\\n\\t\\t\\tvar x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\\n\\t\\t\\twhile ( ++i <= n ) {\\n\\t\\t\\t\\tp = points[i];\\n\\t\\t\\t\\tt = i / n;\\n\\t\\t\\t\\tp[0] = tension * p[0] + ( 1 - tension ) * ( x0 + t * dx );\\n\\t\\t\\t\\tp[1] = tension * p[1] + ( 1 - tension ) * ( y0 + t * dy );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_svg_lineBasis( points );\\n\\t}\\n\\tfunction d3_svg_lineDot4( a, b ) {\\n\\t\\treturn a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\\n\\t}\\n\\tvar d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\\n\\tfunction d3_svg_lineBasisBezier( path, x, y ) {\\n\\t\\tpath.push( \\\"C\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier1, x ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier1, y ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier2, x ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier2, y ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier3, x ), \\\",\\\", d3_svg_lineDot4( d3_svg_lineBasisBezier3, y ) );\\n\\t}\\n\\tfunction d3_svg_lineSlope( p0, p1 ) {\\n\\t\\treturn ( p1[1] - p0[1] ) / ( p1[0] - p0[0] );\\n\\t}\\n\\tfunction d3_svg_lineFiniteDifferences( points ) {\\n\\t\\tvar i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope( p0, p1 );\\n\\t\\twhile ( ++i < j ) {\\n\\t\\t\\tm[i] = ( d + ( d = d3_svg_lineSlope( p0 = p1, p1 = points[i + 1] ) ) ) / 2;\\n\\t\\t}\\n\\t\\tm[i] = d;\\n\\t\\treturn m;\\n\\t}\\n\\tfunction d3_svg_lineMonotoneTangents( points ) {\\n\\t\\tvar tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences( points ), i = -1, j = points.length - 1;\\n\\t\\twhile ( ++i < j ) {\\n\\t\\t\\td = d3_svg_lineSlope( points[i], points[i + 1] );\\n\\t\\t\\tif ( abs( d ) <  ) {\\n\\t\\t\\t\\tm[i] = m[i + 1] = 0;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ta = m[i] / d;\\n\\t\\t\\t\\tb = m[i + 1] / d;\\n\\t\\t\\t\\ts = a * a + b * b;\\n\\t\\t\\t\\tif ( s > 9 ) {\\n\\t\\t\\t\\t\\ts = d * 3 / Math.sqrt( s );\\n\\t\\t\\t\\t\\tm[i] = s * a;\\n\\t\\t\\t\\t\\tm[i + 1] = s * b;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\ti = -1;\\n\\t\\twhile ( ++i <= j ) {\\n\\t\\t\\ts = ( points[Math.min( j, i + 1 )][0] - points[Math.max( 0, i - 1 )][0] ) / ( 6 * ( 1 + m[i] * m[i] ) );\\n\\t\\t\\ttangents.push( [ s || 0, m[i] * s || 0 ] );\\n\\t\\t}\\n\\t\\treturn tangents;\\n\\t}\\n\\tfunction d3_svg_lineMonotone( points ) {\\n\\t\\treturn points.length < 3 ? d3_svg_lineLinear( points ) : points[0] + d3_svg_lineHermite( points, d3_svg_lineMonotoneTangents( points ) );\\n\\t}\\n\\td3.svg.line.radial = function() {\\n\\t\\tvar line = d3_svg_line( d3_svg_lineRadial );\\n\\t\\tline.radius = line.x, delete line.x;\\n\\t\\tline.angle = line.y, delete line.y;\\n\\t\\treturn line;\\n\\t};\\n\\tfunction d3_svg_lineRadial( points ) {\\n\\t\\tvar point, i = -1, n = points.length, r, a;\\n\\t\\twhile ( ++i < n ) {\\n\\t\\t\\tpoint = points[i];\\n\\t\\t\\tr = point[0];\\n\\t\\t\\ta = point[1] - half;\\n\\t\\t\\tpoint[0] = r * Math.cos( a );\\n\\t\\t\\tpoint[1] = r * Math.sin( a );\\n\\t\\t}\\n\\t\\treturn points;\\n\\t}\\n\\tfunction d3_svg_area( projection ) {\\n\\t\\tvar x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \\\"L\\\", tension = .7;\\n\\t\\tfunction area( data ) {\\n\\t\\t\\tvar segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor( x0 ), fy0 = d3_functor( y0 ), fx1 = x0 === x1 ? function() {\\n\\t\\t\\t\\t\\treturn x;\\n\\t\\t\\t\\t} : d3_functor( x1 ), fy1 = y0 === y1 ? function() {\\n\\t\\t\\t\\t\\treturn y;\\n\\t\\t\\t\\t} : d3_functor( y1 ), x, y;\\n\\t\\t\\tfunction segment() {\\n\\t\\t\\t\\tsegments.push( \\\"M\\\", interpolate( projection( points1 ), tension ), L, interpolateReverse( projection( points0.reverse() ), tension ), \\\"Z\\\" );\\n\\t\\t\\t}\\n\\t\\t\\twhile ( ++i < n ) {\\n\\t\\t\\t\\tif ( defined.call( this, d = data[i], i ) ) {\\n\\t\\t\\t\\t\\tpoints0.push( [ x = +fx0.call( this, d, i ), y = +fy0.call( this, d, i ) ] );\\n\\t\\t\\t\\t\\tpoints1.push( [ +fx1.call( this, d, i ), +fy1.call( this, d, i ) ] );\\n\\t\\t\\t\\t} else if ( points0.length ) {\\n\\t\\t\\t\\t\\tsegment();\\n\\t\\t\\t\\t\\tpoints0 = [];\\n\\t\\t\\t\\t\\tpoints1 = [];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif ( points0.length ) segment();\\n\\t\\t\\treturn segments.length ? segments.join( \\\"\\\" ) : null;\\n\\t\\t}\\n\\t\\tarea.x = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x1;\\n\\t\\t\\tx0 = x1 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.x0 = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x0;\\n\\t\\t\\tx0 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.x1 = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return x1;\\n\\t\\t\\tx1 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.y = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return y1;\\n\\t\\t\\ty0 = y1 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.y0 = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return y0;\\n\\t\\t\\ty0 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.y1 = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return y1;\\n\\t\\t\\ty1 = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.defined = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return defined;\\n\\t\\t\\tdefined = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.interpolate = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return interpolateKey;\\n\\t\\t\\tif ( typeof _ === \\\"function\\\" ) interpolateKey = interpolate = _; else interpolateKey = ( interpolate = d3_svg_lineInterpolators.get( _ ) || d3_svg_lineLinear ).key;\\n\\t\\t\\tinterpolateReverse = interpolate.reverse || interpolate;\\n\\t\\t\\tL = interpolate.closed ? \\\"M\\\" : \\\"L\\\";\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\tarea.tension = function( _ ) {\\n\\t\\t\\tif ( !arguments.length ) return tension;\\n\\t\\t\\ttension = _;\\n\\t\\t\\treturn area;\\n\\t\\t};\\n\\t\\treturn area;\\n\\t}\\n\\td3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\\n\\td3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\\n\\td3.svg.area = function() {\\n\\t\\treturn d3_svg_area( d3_identity );\\n\\t};\\n\\td3.svg.area.radial = function() {\\n\\t\\tvar area = d3_svg_area( d3_svg_lineRadial );\\n\\t\\tarea.radius = area.x, delete area.x;\\n\\t\\tarea.innerRadius = area.x0, delete area.x0;\\n\\t\\tarea.outerRadius = area.x1, delete area.x1;\\n\\t\\tarea.angle = area.y, delete area.y;\\n\\t\\tarea.startAngle = area.y0, delete area.y0;\\n\\t\\tarea.endAngle = area.y1, delete area.y1;\\n\\t\\treturn area;\\n\\t};\\n\\td3.svg.chord = function() {\\n\\t\\tvar source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\\n\\t\\tfunction chord( d, i ) {\\n\\t\\t\\tvar s = subgroup( this, source, d, i ), t = subgroup( this, target, d, i );\\n\\t\\t\\treturn \\\"M\\\" + s.p0 + arc( s.r, s.p1, s.a1 - s.a0 ) + ( equals( s, t ) ? curve( s.r, s.p1, s.r, s.p0 ) : curve( s.r, s.p1, t.r, t.p0 ) + arc( t.r, t.p1, t.a1 - t.a0 ) + curve( t.r, t.p1, s.r, s.p0 ) ) + \\\"Z\\\";\\n\\t\\t}\\n\\t\\tfunction subgroup( self, f, d, i ) {\\n\\t\\t\\tvar subgroup = f.call( self, d, i ), r = radius.call( self, subgroup, i ), a0 = startAngle.call( self, subgroup, i ) - half, a1 = endAngle.call( self, subgroup, i ) - half;\\n\\t\\t\\treturn {\\n\\t\\t\\t\\tr: r,\\n\\t\\t\\t\\ta0: a0,\\n\\t\\t\\t\\ta1: a1,\\n\\t\\t\\t\\tp0: [ r * Math.cos( a0 ), r * Math.sin( a0 ) ],\\n\\t\\t\\t\\tp1: [ r * Math.cos( a1 ), r * Math.sin( a1 ) ]\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfunction equals( a, b ) {\\n\\t\\t\\treturn a.a0 == b.a0 && a.a1 == b.a1;\\n\\t\\t}\\n\\t\\tfunction arc( r, p, a ) {\\n\\t\\t\\treturn \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 \\\" + +( a >  ) + \\\",1 \\\" + p;\\n\\t\\t}\\n\\t\\tfunction curve( r0, p0, r1, p1 ) {\\n\\t\\t\\treturn \\\"Q 0,0 \\\" + p1;\\n\\t\\t}\\n\\t\\tchord.radius = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return radius;\\n\\t\\t\\tradius = d3_functor( v );\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.source = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return source;\\n\\t\\t\\tsource = d3_functor( v );\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.target = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return target;\\n\\t\\t\\ttarget = d3_functor( v );\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.startAngle = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return startAngle;\\n\\t\\t\\tstartAngle = d3_functor( v );\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\tchord.endAngle = function( v ) {\\n\\t\\t\\tif ( !arguments.length ) return endAngle;\\n\\t\\t\\tendAngle = d3_functor( v );\\n\\t\\t\\treturn chord;\\n\\t\\t};\\n\\t\\treturn chord;\\n\\t};\\n\\tfunction d3_svg_chordRadius( d ) {\\n\\t\\treturn d.radius;\\n\\t}\\n\\td3.svg.diagonal = function() {\\n\\t\\tvar source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\\n\\t\\tfunction diagonal( d, i ) {\\n\\t\\t\\tvar p0 = source.call( this, d, i ), p3 = target.call( this, d, i ), m = ( p0.y + p3.y ) / 2, p = [ p0, {\\n\\t\\t\\t\\tx: p0.x,\\n\\t\\t\\t\\ty: m\\n\\t\\t\\t}, {\\n\\t\\t\\t\\tx: p3.x,\\n\\t\\t\\t\\ty: m\\n\\t\\t\\t}, p3 ];\\n\\t\\t\\tp = p.map( projection );\\n\\t\\t\\treturn \\\"M\\\" + p[0] + \\\"C\\\" + p[1] + \\\" \\\" + p[2] + \\\" \\\" + p[3];\\n\\t\\t}\\n\\t\\tdiagonal.source = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return source;\\n\\t\\t\\tsource = d3_functor( x );\\n\\t\\t\\treturn diagonal;\\n\\t\\t};\\n\\t\\tdiagonal.target = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return target;\\n\\t\\t\\ttarget = d3_functor( x );\\n\\t\\t\\treturn diagonal;\\n\\t\\t};\\n\\t\\tdiagonal.projection = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return projection;\\n\\t\\t\\tprojection = x;\\n\\t\\t\\treturn diagonal;\\n\\t\\t};\\n\\t\\treturn diagonal;\\n\\t};\\n\\tfunction d3_svg_diagonalProjection( d ) {\\n\\t\\treturn [ d.x, d.y ];\\n\\t}\\n\\td3.svg.diagonal.radial = function() {\\n\\t\\tvar diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\\n\\t\\tdiagonal.projection = function( x ) {\\n\\t\\t\\treturn arguments.length ? projection_( d3_svg_diagonalRadialProjection( projection = x ) ) : projection;\\n\\t\\t};\\n\\t\\treturn diagonal;\\n\\t};\\n\\tfunction d3_svg_diagonalRadialProjection( projection ) {\\n\\t\\treturn function() {\\n\\t\\t\\tvar d = projection.apply( this, arguments ), r = d[0], a = d[1] - half;\\n\\t\\t\\treturn [ r * Math.cos( a ), r * Math.sin( a ) ];\\n\\t\\t};\\n\\t}\\n\\td3.svg.symbol = function() {\\n\\t\\tvar type = d3_svg_symbolType, size = d3_svg_symbolSize;\\n\\t\\tfunction symbol( d, i ) {\\n\\t\\t\\treturn ( d3_svg_symbols.get( type.call( this, d, i ) ) || d3_svg_symbolCircle )( size.call( this, d, i ) );\\n\\t\\t}\\n\\t\\tsymbol.type = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return type;\\n\\t\\t\\ttype = d3_functor( x );\\n\\t\\t\\treturn symbol;\\n\\t\\t};\\n\\t\\tsymbol.size = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return size;\\n\\t\\t\\tsize = d3_functor( x );\\n\\t\\t\\treturn symbol;\\n\\t\\t};\\n\\t\\treturn symbol;\\n\\t};\\n\\tfunction d3_svg_symbolSize() {\\n\\t\\treturn 64;\\n\\t}\\n\\tfunction d3_svg_symbolType() {\\n\\t\\treturn \\\"circle\\\";\\n\\t}\\n\\tfunction d3_svg_symbolCircle( size ) {\\n\\t\\tvar r = Math.sqrt( size /  );\\n\\t\\treturn \\\"M0,\\\" + r + \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 1,1 0,\\\" + -r + \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 1,1 0,\\\" + r + \\\"Z\\\";\\n\\t}\\n\\tvar d3_svg_symbols = d3.map( {\\n\\t\\tcircle: d3_svg_symbolCircle,\\n\\t\\tcross: function( size ) {\\n\\t\\t\\tvar r = Math.sqrt( size / 5 ) / 2;\\n\\t\\t\\treturn \\\"M\\\" + -3 * r + \\\",\\\" + -r + \\\"H\\\" + -r + \\\"V\\\" + -3 * r + \\\"H\\\" + r + \\\"V\\\" + -r + \\\"H\\\" + 3 * r + \\\"V\\\" + r + \\\"H\\\" + r + \\\"V\\\" + 3 * r + \\\"H\\\" + -r + \\\"V\\\" + r + \\\"H\\\" + -3 * r + \\\"Z\\\";\\n\\t\\t},\\n\\t\\tdiamond: function( size ) {\\n\\t\\t\\tvar ry = Math.sqrt( size / ( 2 * d3_svg_symbolTan30 ) ), rx = ry * d3_svg_symbolTan30;\\n\\t\\t\\treturn \\\"M0,\\\" + -ry + \\\"L\\\" + rx + \\\",0\\\" + \\\" 0,\\\" + ry + \\\" \\\" + -rx + \\\",0\\\" + \\\"Z\\\";\\n\\t\\t},\\n\\t\\tsquare: function( size ) {\\n\\t\\t\\tvar r = Math.sqrt( size ) / 2;\\n\\t\\t\\treturn \\\"M\\\" + -r + \\\",\\\" + -r + \\\"L\\\" + r + \\\",\\\" + -r + \\\" \\\" + r + \\\",\\\" + r + \\\" \\\" + -r + \\\",\\\" + r + \\\"Z\\\";\\n\\t\\t},\\n\\t\\t\\\"triangle-down\\\": function( size ) {\\n\\t\\t\\tvar rx = Math.sqrt( size / d3_svg_symbolSqrt3 ), ry = rx * d3_svg_symbolSqrt3 / 2;\\n\\t\\t\\treturn \\\"M0,\\\" + ry + \\\"L\\\" + rx + \\\",\\\" + -ry + \\\" \\\" + -rx + \\\",\\\" + -ry + \\\"Z\\\";\\n\\t\\t},\\n\\t\\t\\\"triangle-up\\\": function( size ) {\\n\\t\\t\\tvar rx = Math.sqrt( size / d3_svg_symbolSqrt3 ), ry = rx * d3_svg_symbolSqrt3 / 2;\\n\\t\\t\\treturn \\\"M0,\\\" + -ry + \\\"L\\\" + rx + \\\",\\\" + ry + \\\" \\\" + -rx + \\\",\\\" + ry + \\\"Z\\\";\\n\\t\\t}\\n\\t} );\\n\\td3.svg.symbolTypes = d3_svg_symbols.keys();\\n\\tvar d3_svg_symbolSqrt3 = Math.sqrt( 3 ), d3_svg_symbolTan30 = Math.tan( 30 * d3_radians );\\n\\td3_selectionPrototype.transition = function( name ) {\\n\\t\\tvar id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace( name ), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\\n\\t\\t\\ttime: Date.now(),\\n\\t\\t\\tease: d3_ease_cubicInOut,\\n\\t\\t\\tdelay: 0,\\n\\t\\t\\tduration: 250\\n\\t\\t};\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tfor ( var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) d3_transitionNode( node, i, ns, id, transition );\\n\\t\\t\\t\\tsubgroup.push( node );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_transition( subgroups, ns, id );\\n\\t};\\n\\td3_selectionPrototype.interrupt = function( name ) {\\n\\t\\treturn this.each( name == null ? d3_selection_interrupt : d3_selection_interruptNS( d3_transitionNamespace( name ) ) );\\n\\t};\\n\\tvar d3_selection_interrupt = d3_selection_interruptNS( d3_transitionNamespace() );\\n\\tfunction d3_selection_interruptNS( ns ) {\\n\\t\\treturn function() {\\n\\t\\t\\tvar lock, activeId, active;\\n\\t\\t\\tif ( ( lock = this[ns] ) && ( active = lock[activeId = lock.active] ) ) {\\n\\t\\t\\t\\tactive.timer.c = null;\\n\\t\\t\\t\\tactive.timer.t = NaN;\\n\\t\\t\\t\\tif ( --lock.count ) delete lock[activeId]; else delete this[ns];\\n\\t\\t\\t\\tlock.active += .5;\\n\\t\\t\\t\\tactive.event && active.event.interrupt.call( this, this.__data__, active.index );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t}\\n\\tfunction d3_transition( groups, ns, id ) {\\n\\t\\td3_subclass( groups, d3_transitionPrototype );\\n\\t\\tgroups.namespace = ns;\\n\\t\\tgroups.id = id;\\n\\t\\treturn groups;\\n\\t}\\n\\tvar d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\\n\\td3_transitionPrototype.call = d3_selectionPrototype.call;\\n\\td3_transitionPrototype.empty = d3_selectionPrototype.empty;\\n\\td3_transitionPrototype.node = d3_selectionPrototype.node;\\n\\td3_transitionPrototype.size = d3_selectionPrototype.size;\\n\\td3.transition = function( selection, name ) {\\n\\t\\treturn selection && selection.transition ? d3_transitionInheritId ? selection.transition( name ) : selection : d3.selection().transition( selection );\\n\\t};\\n\\td3.transition.prototype = d3_transitionPrototype;\\n\\td3_transitionPrototype.select = function( selector ) {\\n\\t\\tvar id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\\n\\t\\tselector = d3_selection_selector( selector );\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tfor ( var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( ( node = group[i] ) && ( subnode = selector.call( node, node.__data__, i, j ) ) ) {\\n\\t\\t\\t\\t\\tif ( \\\"__data__\\\" in node ) subnode.__data__ = node.__data__;\\n\\t\\t\\t\\t\\td3_transitionNode( subnode, i, ns, id, node[ns][id] );\\n\\t\\t\\t\\t\\tsubgroup.push( subnode );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tsubgroup.push( null );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_transition( subgroups, ns, id );\\n\\t};\\n\\td3_transitionPrototype.selectAll = function( selector ) {\\n\\t\\tvar id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\\n\\t\\tselector = d3_selection_selectorAll( selector );\\n\\t\\tfor ( var j = -1, m = this.length; ++j < m; ) {\\n\\t\\t\\tfor ( var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\ttransition = node[ns][id];\\n\\t\\t\\t\\t\\tsubnodes = selector.call( node, node.__data__, i, j );\\n\\t\\t\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\t\\t\\tfor ( var k = -1, o = subnodes.length; ++k < o; ) {\\n\\t\\t\\t\\t\\t\\tif ( subnode = subnodes[k] ) d3_transitionNode( subnode, k, ns, id, transition );\\n\\t\\t\\t\\t\\t\\tsubgroup.push( subnode );\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_transition( subgroups, ns, id );\\n\\t};\\n\\td3_transitionPrototype.filter = function( filter ) {\\n\\t\\tvar subgroups = [], subgroup, group, node;\\n\\t\\tif ( typeof filter !== \\\"function\\\" ) filter = d3_selection_filter( filter );\\n\\t\\tfor ( var j = 0, m = this.length; j < m; j++ ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tfor ( var group = this[j], i = 0, n = group.length; i < n; i++ ) {\\n\\t\\t\\t\\tif ( ( node = group[i] ) && filter.call( node, node.__data__, i, j ) ) {\\n\\t\\t\\t\\t\\tsubgroup.push( node );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_transition( subgroups, this.namespace, this.id );\\n\\t};\\n\\td3_transitionPrototype.tween = function( name, tween ) {\\n\\t\\tvar id = this.id, ns = this.namespace;\\n\\t\\tif ( arguments.length < 2 ) return this.node()[ns][id].tween.get( name );\\n\\t\\treturn d3_selection_each( this, tween == null ? function( node ) {\\n\\t\\t\\tnode[ns][id].tween.remove( name );\\n\\t\\t} : function( node ) {\\n\\t\\t\\tnode[ns][id].tween.set( name, tween );\\n\\t\\t} );\\n\\t};\\n\\tfunction d3_transition_tween( groups, name, value, tween ) {\\n\\t\\tvar id = groups.id, ns = groups.namespace;\\n\\t\\treturn d3_selection_each( groups, typeof value === \\\"function\\\" ? function( node, i, j ) {\\n\\t\\t\\tnode[ns][id].tween.set( name, tween( value.call( node, node.__data__, i, j ) ) );\\n\\t\\t} : ( value = tween( value ), function( node ) {\\n\\t\\t\\tnode[ns][id].tween.set( name, value );\\n\\t\\t} ) );\\n\\t}\\n\\td3_transitionPrototype.attr = function( nameNS, value ) {\\n\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\tfor ( value in nameNS ) this.attr( value, nameNS[value] );\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\t\\tvar interpolate = nameNS == \\\"transform\\\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify( nameNS );\\n\\t\\tfunction attrNull() {\\n\\t\\t\\tthis.removeAttribute( name );\\n\\t\\t}\\n\\t\\tfunction attrNullNS() {\\n\\t\\t\\tthis.removeAttributeNS( name.space, name.local );\\n\\t\\t}\\n\\t\\tfunction attrTween( b ) {\\n\\t\\t\\treturn b == null ? attrNull : ( b += \\\"\\\", function() {\\n\\t\\t\\t\\tvar a = this.getAttribute( name ), i;\\n\\t\\t\\t\\treturn a !== b && ( i = interpolate( a, b ), function( t ) {\\n\\t\\t\\t\\t\\tthis.setAttribute( name, i( t ) );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tfunction attrTweenNS( b ) {\\n\\t\\t\\treturn b == null ? attrNullNS : ( b += \\\"\\\", function() {\\n\\t\\t\\t\\tvar a = this.getAttributeNS( name.space, name.local ), i;\\n\\t\\t\\t\\treturn a !== b && ( i = interpolate( a, b ), function( t ) {\\n\\t\\t\\t\\t\\tthis.setAttributeNS( name.space, name.local, i( t ) );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\treturn d3_transition_tween( this, \\\"attr.\\\" + nameNS, value, name.local ? attrTweenNS : attrTween );\\n\\t};\\n\\td3_transitionPrototype.attrTween = function( nameNS, tween ) {\\n\\t\\tvar name = d3.ns.qualify( nameNS );\\n\\t\\tfunction attrTween( d, i ) {\\n\\t\\t\\tvar f = tween.call( this, d, i, this.getAttribute( name ) );\\n\\t\\t\\treturn f && function( t ) {\\n\\t\\t\\t\\tthis.setAttribute( name, f( t ) );\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\tfunction attrTweenNS( d, i ) {\\n\\t\\t\\tvar f = tween.call( this, d, i, this.getAttributeNS( name.space, name.local ) );\\n\\t\\t\\treturn f && function( t ) {\\n\\t\\t\\t\\tthis.setAttributeNS( name.space, name.local, f( t ) );\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\treturn this.tween( \\\"attr.\\\" + nameNS, name.local ? attrTweenNS : attrTween );\\n\\t};\\n\\td3_transitionPrototype.style = function( name, value, priority ) {\\n\\t\\tvar n = arguments.length;\\n\\t\\tif ( n < 3 ) {\\n\\t\\t\\tif ( typeof name !== \\\"string\\\" ) {\\n\\t\\t\\t\\tif ( n < 2 ) value = \\\"\\\";\\n\\t\\t\\t\\tfor ( priority in name ) this.style( priority, name[priority], value );\\n\\t\\t\\t\\treturn this;\\n\\t\\t\\t}\\n\\t\\t\\tpriority = \\\"\\\";\\n\\t\\t}\\n\\t\\tfunction styleNull() {\\n\\t\\t\\tthis.style.removeProperty( name );\\n\\t\\t}\\n\\t\\tfunction styleString( b ) {\\n\\t\\t\\treturn b == null ? styleNull : ( b += \\\"\\\", function() {\\n\\t\\t\\t\\tvar a = d3_window( this ).getComputedStyle( this, null ).getPropertyValue( name ), i;\\n\\t\\t\\t\\treturn a !== b && ( i = d3_interpolate( a, b ), function( t ) {\\n\\t\\t\\t\\t\\tthis.style.setProperty( name, i( t ), priority );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\treturn d3_transition_tween( this, \\\"style.\\\" + name, value, styleString );\\n\\t};\\n\\td3_transitionPrototype.styleTween = function( name, tween, priority ) {\\n\\t\\tif ( arguments.length < 3 ) priority = \\\"\\\";\\n\\t\\tfunction styleTween( d, i ) {\\n\\t\\t\\tvar f = tween.call( this, d, i, d3_window( this ).getComputedStyle( this, null ).getPropertyValue( name ) );\\n\\t\\t\\treturn f && function( t ) {\\n\\t\\t\\t\\tthis.style.setProperty( name, f( t ), priority );\\n\\t\\t\\t};\\n\\t\\t}\\n\\t\\treturn this.tween( \\\"style.\\\" + name, styleTween );\\n\\t};\\n\\td3_transitionPrototype.text = function( value ) {\\n\\t\\treturn d3_transition_tween( this, \\\"text\\\", value, d3_transition_text );\\n\\t};\\n\\tfunction d3_transition_text( b ) {\\n\\t\\tif ( b == null ) b = \\\"\\\";\\n\\t\\treturn function() {\\n\\t\\t\\tthis.textContent = b;\\n\\t\\t};\\n\\t}\\n\\td3_transitionPrototype.remove = function() {\\n\\t\\tvar ns = this.namespace;\\n\\t\\treturn this.each( \\\"end.transition\\\", function() {\\n\\t\\t\\tvar p;\\n\\t\\t\\tif ( this[ns].count < 2 && ( p = this.parentNode ) ) p.removeChild( this );\\n\\t\\t} );\\n\\t};\\n\\td3_transitionPrototype.ease = function( value ) {\\n\\t\\tvar id = this.id, ns = this.namespace;\\n\\t\\tif ( arguments.length < 1 ) return this.node()[ns][id].ease;\\n\\t\\tif ( typeof value !== \\\"function\\\" ) value = d3.ease.apply( d3, arguments );\\n\\t\\treturn d3_selection_each( this, function( node ) {\\n\\t\\t\\tnode[ns][id].ease = value;\\n\\t\\t} );\\n\\t};\\n\\td3_transitionPrototype.delay = function( value ) {\\n\\t\\tvar id = this.id, ns = this.namespace;\\n\\t\\tif ( arguments.length < 1 ) return this.node()[ns][id].delay;\\n\\t\\treturn d3_selection_each( this, typeof value === \\\"function\\\" ? function( node, i, j ) {\\n\\t\\t\\tnode[ns][id].delay = +value.call( node, node.__data__, i, j );\\n\\t\\t} : ( value = +value, function( node ) {\\n\\t\\t\\tnode[ns][id].delay = value;\\n\\t\\t} ) );\\n\\t};\\n\\td3_transitionPrototype.duration = function( value ) {\\n\\t\\tvar id = this.id, ns = this.namespace;\\n\\t\\tif ( arguments.length < 1 ) return this.node()[ns][id].duration;\\n\\t\\treturn d3_selection_each( this, typeof value === \\\"function\\\" ? function( node, i, j ) {\\n\\t\\t\\tnode[ns][id].duration = Math.max( 1, value.call( node, node.__data__, i, j ) );\\n\\t\\t} : ( value = Math.max( 1, value ), function( node ) {\\n\\t\\t\\tnode[ns][id].duration = value;\\n\\t\\t} ) );\\n\\t};\\n\\td3_transitionPrototype.each = function( type, listener ) {\\n\\t\\tvar id = this.id, ns = this.namespace;\\n\\t\\tif ( arguments.length < 2 ) {\\n\\t\\t\\tvar inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\\n\\t\\t\\ttry {\\n\\t\\t\\t\\td3_transitionInheritId = id;\\n\\t\\t\\t\\td3_selection_each( this, function( node, i, j ) {\\n\\t\\t\\t\\t\\td3_transitionInherit = node[ns][id];\\n\\t\\t\\t\\t\\ttype.call( node, node.__data__, i, j );\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} finally {\\n\\t\\t\\t\\td3_transitionInherit = inherit;\\n\\t\\t\\t\\td3_transitionInheritId = inheritId;\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\td3_selection_each( this, function( node ) {\\n\\t\\t\\t\\tvar transition = node[ns][id];\\n\\t\\t\\t\\t( transition.event || ( transition.event = d3.dispatch( \\\"start\\\", \\\"end\\\", \\\"interrupt\\\" ) ) ).on( type, listener );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t};\\n\\td3_transitionPrototype.transition = function() {\\n\\t\\tvar id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\\n\\t\\tfor ( var j = 0, m = this.length; j < m; j++ ) {\\n\\t\\t\\tsubgroups.push( subgroup = [] );\\n\\t\\t\\tfor ( var group = this[j], i = 0, n = group.length; i < n; i++ ) {\\n\\t\\t\\t\\tif ( node = group[i] ) {\\n\\t\\t\\t\\t\\ttransition = node[ns][id0];\\n\\t\\t\\t\\t\\td3_transitionNode( node, i, ns, id1, {\\n\\t\\t\\t\\t\\t\\ttime: transition.time,\\n\\t\\t\\t\\t\\t\\tease: transition.ease,\\n\\t\\t\\t\\t\\t\\tdelay: transition.delay + transition.duration,\\n\\t\\t\\t\\t\\t\\tduration: transition.duration\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsubgroup.push( node );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn d3_transition( subgroups, ns, id1 );\\n\\t};\\n\\tfunction d3_transitionNamespace( name ) {\\n\\t\\treturn name == null ? \\\"__transition__\\\" : \\\"__transition_\\\" + name + \\\"__\\\";\\n\\t}\\n\\tfunction d3_transitionNode( node, i, ns, id, inherit ) {\\n\\t\\tvar lock = node[ns] || ( node[ns] = {\\n\\t\\t\\t\\tactive: 0,\\n\\t\\t\\t\\tcount: 0\\n\\t\\t\\t} ), transition = lock[id], time, timer, duration, ease, tweens;\\n\\t\\tfunction schedule( elapsed ) {\\n\\t\\t\\tvar delay = transition.delay;\\n\\t\\t\\ttimer.t = delay + time;\\n\\t\\t\\tif ( delay <= elapsed ) return start( elapsed - delay );\\n\\t\\t\\ttimer.c = start;\\n\\t\\t}\\n\\t\\tfunction start( elapsed ) {\\n\\t\\t\\tvar activeId = lock.active, active = lock[activeId];\\n\\t\\t\\tif ( active ) {\\n\\t\\t\\t\\tactive.timer.c = null;\\n\\t\\t\\t\\tactive.timer.t = NaN;\\n\\t\\t\\t\\t--lock.count;\\n\\t\\t\\t\\tdelete lock[activeId];\\n\\t\\t\\t\\tactive.event && active.event.interrupt.call( node, node.__data__, active.index );\\n\\t\\t\\t}\\n\\t\\t\\tfor ( var cancelId in lock ) {\\n\\t\\t\\t\\tif ( +cancelId < id ) {\\n\\t\\t\\t\\t\\tvar cancel = lock[cancelId];\\n\\t\\t\\t\\t\\tcancel.timer.c = null;\\n\\t\\t\\t\\t\\tcancel.timer.t = NaN;\\n\\t\\t\\t\\t\\t--lock.count;\\n\\t\\t\\t\\t\\tdelete lock[cancelId];\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\ttimer.c = tick;\\n\\t\\t\\td3_timer( function() {\\n\\t\\t\\t\\tif ( timer.c && tick( elapsed || 1 ) ) {\\n\\t\\t\\t\\t\\ttimer.c = null;\\n\\t\\t\\t\\t\\ttimer.t = NaN;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}, 0, time );\\n\\t\\t\\tlock.active = id;\\n\\t\\t\\ttransition.event && transition.event.start.call( node, node.__data__, i );\\n\\t\\t\\ttweens = [];\\n\\t\\t\\ttransition.tween.forEach( function( key, value ) {\\n\\t\\t\\t\\tif ( value = value.call( node, node.__data__, i ) ) {\\n\\t\\t\\t\\t\\ttweens.push( value );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t\\tease = transition.ease;\\n\\t\\t\\tduration = transition.duration;\\n\\t\\t}\\n\\t\\tfunction tick( elapsed ) {\\n\\t\\t\\tvar t = elapsed / duration, e = ease( t ), n = tweens.length;\\n\\t\\t\\twhile ( n > 0 ) {\\n\\t\\t\\t\\ttweens[--n].call( node, e );\\n\\t\\t\\t}\\n\\t\\t\\tif ( t >= 1 ) {\\n\\t\\t\\t\\ttransition.event && transition.event.end.call( node, node.__data__, i );\\n\\t\\t\\t\\tif ( --lock.count ) delete lock[id]; else delete node[ns];\\n\\t\\t\\t\\treturn 1;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif ( !transition ) {\\n\\t\\t\\ttime = inherit.time;\\n\\t\\t\\ttimer = d3_timer( schedule, 0, time );\\n\\t\\t\\ttransition = lock[id] = {\\n\\t\\t\\t\\ttween: new d3_Map(),\\n\\t\\t\\t\\ttime: time,\\n\\t\\t\\t\\ttimer: timer,\\n\\t\\t\\t\\tdelay: inherit.delay,\\n\\t\\t\\t\\tduration: inherit.duration,\\n\\t\\t\\t\\tease: inherit.ease,\\n\\t\\t\\t\\tindex: i\\n\\t\\t\\t};\\n\\t\\t\\tinherit = null;\\n\\t\\t\\t++lock.count;\\n\\t\\t}\\n\\t}\\n\\td3.svg.axis = function() {\\n\\t\\tvar scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\\n\\t\\tfunction axis( g ) {\\n\\t\\t\\tg.each( function() {\\n\\t\\t\\t\\tvar g = d3.select( this );\\n\\t\\t\\t\\tvar scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\\n\\t\\t\\t\\tvar ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply( scale1, tickArguments_ ) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply( scale1, tickArguments_ ) : d3_identity : tickFormat_, tick = g.selectAll( \\\".tick\\\" ).data( ticks, scale1 ), tickEnter = tick.enter().insert( \\\"g\\\", \\\".domain\\\" ).attr( \\\"class\\\", \\\"tick\\\" ).style( \\\"opacity\\\",  ), tickExit = d3.transition( tick.exit() ).style( \\\"opacity\\\",  ).remove(), tickUpdate = d3.transition( tick.order() ).style( \\\"opacity\\\", 1 ), tickSpacing = Math.max( innerTickSize, 0 ) + tickPadding, tickTransform;\\n\\t\\t\\t\\tvar range = d3_scaleRange( scale1 ), path = g.selectAll( \\\".domain\\\" ).data( [ 0 ] ), pathUpdate = ( path.enter().append( \\\"path\\\" ).attr( \\\"class\\\", \\\"domain\\\" ),\\n\\t\\t\\t\\td3.transition( path ) );\\n\\t\\t\\t\\ttickEnter.append( \\\"line\\\" );\\n\\t\\t\\t\\ttickEnter.append( \\\"text\\\" );\\n\\t\\t\\t\\tvar lineEnter = tickEnter.select( \\\"line\\\" ), lineUpdate = tickUpdate.select( \\\"line\\\" ), text = tick.select( \\\"text\\\" ).text( tickFormat ), textEnter = tickEnter.select( \\\"text\\\" ), textUpdate = tickUpdate.select( \\\"text\\\" ), sign = orient === \\\"top\\\" || orient === \\\"left\\\" ? -1 : 1, x1, x2, y1, y2;\\n\\t\\t\\t\\tif ( orient === \\\"bottom\\\" || orient === \\\"top\\\" ) {\\n\\t\\t\\t\\t\\ttickTransform = d3_svg_axisX, x1 = \\\"x\\\", y1 = \\\"y\\\", x2 = \\\"x2\\\", y2 = \\\"y2\\\";\\n\\t\\t\\t\\t\\ttext.attr( \\\"dy\\\", sign < 0 ? \\\"0em\\\" : \\\".71em\\\" ).style( \\\"text-anchor\\\", \\\"middle\\\" );\\n\\t\\t\\t\\t\\tpathUpdate.attr( \\\"d\\\", \\\"M\\\" + range[0] + \\\",\\\" + sign * outerTickSize + \\\"V0H\\\" + range[1] + \\\"V\\\" + sign * outerTickSize );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttickTransform = d3_svg_axisY, x1 = \\\"y\\\", y1 = \\\"x\\\", x2 = \\\"y2\\\", y2 = \\\"x2\\\";\\n\\t\\t\\t\\t\\ttext.attr( \\\"dy\\\", \\\".32em\\\" ).style( \\\"text-anchor\\\", sign < 0 ? \\\"end\\\" : \\\"start\\\" );\\n\\t\\t\\t\\t\\tpathUpdate.attr( \\\"d\\\", \\\"M\\\" + sign * outerTickSize + \\\",\\\" + range[0] + \\\"H0V\\\" + range[1] + \\\"H\\\" + sign * outerTickSize );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlineEnter.attr( y2, sign * innerTickSize );\\n\\t\\t\\t\\ttextEnter.attr( y1, sign * tickSpacing );\\n\\t\\t\\t\\tlineUpdate.attr( x2, 0 ).attr( y2, sign * innerTickSize );\\n\\t\\t\\t\\ttextUpdate.attr( x1, 0 ).attr( y1, sign * tickSpacing );\\n\\t\\t\\t\\tif ( scale1.rangeBand ) {\\n\\t\\t\\t\\t\\tvar x = scale1, dx = x.rangeBand() / 2;\\n\\t\\t\\t\\t\\tscale0 = scale1 = function( d ) {\\n\\t\\t\\t\\t\\t\\treturn x( d ) + dx;\\n\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t} else if ( scale0.rangeBand ) {\\n\\t\\t\\t\\t\\tscale0 = scale1;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\ttickExit.call( tickTransform, scale1, scale0 );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\ttickEnter.call( tickTransform, scale0, scale1 );\\n\\t\\t\\t\\ttickUpdate.call( tickTransform, scale1, scale1 );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\taxis.scale = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return scale;\\n\\t\\t\\tscale = x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.orient = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return orient;\\n\\t\\t\\torient = x in d3_svg_axisOrients ? x + \\\"\\\" : d3_svg_axisDefaultOrient;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.ticks = function() {\\n\\t\\t\\tif ( !arguments.length ) return tickArguments_;\\n\\t\\t\\ttickArguments_ = d3_array( arguments );\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.tickValues = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return tickValues;\\n\\t\\t\\ttickValues = x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.tickFormat = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return tickFormat_;\\n\\t\\t\\ttickFormat_ = x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.tickSize = function( x ) {\\n\\t\\t\\tvar n = arguments.length;\\n\\t\\t\\tif ( !n ) return innerTickSize;\\n\\t\\t\\tinnerTickSize = +x;\\n\\t\\t\\touterTickSize = +arguments[n - 1];\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.innerTickSize = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return innerTickSize;\\n\\t\\t\\tinnerTickSize = +x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.outerTickSize = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return outerTickSize;\\n\\t\\t\\touterTickSize = +x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.tickPadding = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return tickPadding;\\n\\t\\t\\ttickPadding = +x;\\n\\t\\t\\treturn axis;\\n\\t\\t};\\n\\t\\taxis.tickSubdivide = function() {\\n\\t\\t\\treturn arguments.length && axis;\\n\\t\\t};\\n\\t\\treturn axis;\\n\\t};\\n\\tvar d3_svg_axisDefaultOrient = \\\"bottom\\\", d3_svg_axisOrients = {\\n\\t\\ttop: 1,\\n\\t\\tright: 1,\\n\\t\\tbottom: 1,\\n\\t\\tleft: 1\\n\\t};\\n\\tfunction d3_svg_axisX( selection, x0, x1 ) {\\n\\t\\tselection.attr( \\\"transform\\\", function( d ) {\\n\\t\\t\\tvar v0 = x0( d );\\n\\t\\t\\treturn \\\"translate(\\\" + ( isFinite( v0 ) ? v0 : x1( d ) ) + \\\",0)\\\";\\n\\t\\t} );\\n\\t}\\n\\tfunction d3_svg_axisY( selection, y0, y1 ) {\\n\\t\\tselection.attr( \\\"transform\\\", function( d ) {\\n\\t\\t\\tvar v0 = y0( d );\\n\\t\\t\\treturn \\\"translate(0,\\\" + ( isFinite( v0 ) ? v0 : y1( d ) ) + \\\")\\\";\\n\\t\\t} );\\n\\t}\\n\\td3.svg.brush = function() {\\n\\t\\tvar event = d3_eventDispatch( brush, \\\"brushstart\\\", \\\"brush\\\", \\\"brushend\\\" ), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\\n\\t\\tfunction brush( g ) {\\n\\t\\t\\tg.each( function() {\\n\\t\\t\\t\\tvar g = d3.select( this ).style( \\\"pointer-events\\\", \\\"all\\\" ).style( \\\"-webkit-tap-highlight-color\\\", \\\"rgba(0,0,0,0)\\\" ).on( \\\"mousedown.brush\\\", brushstart ).on( \\\"touchstart.brush\\\", brushstart );\\n\\t\\t\\t\\tvar background = g.selectAll( \\\".background\\\" ).data( [ 0 ] );\\n\\t\\t\\t\\tbackground.enter().append( \\\"rect\\\" ).attr( \\\"class\\\", \\\"background\\\" ).style( \\\"visibility\\\", \\\"hidden\\\" ).style( \\\"cursor\\\", \\\"crosshair\\\" );\\n\\t\\t\\t\\tg.selectAll( \\\".extent\\\" ).data( [ 0 ] ).enter().append( \\\"rect\\\" ).attr( \\\"class\\\", \\\"extent\\\" ).style( \\\"cursor\\\", \\\"move\\\" );\\n\\t\\t\\t\\tvar resize = g.selectAll( \\\".resize\\\" ).data( resizes, d3_identity );\\n\\t\\t\\t\\tresize.exit().remove();\\n\\t\\t\\t\\tresize.enter().append( \\\"g\\\" ).attr( \\\"class\\\", function( d ) {\\n\\t\\t\\t\\t\\treturn \\\"resize \\\" + d;\\n\\t\\t\\t\\t} ).style( \\\"cursor\\\", function( d ) {\\n\\t\\t\\t\\t\\treturn d3_svg_brushCursor[d];\\n\\t\\t\\t\\t} ).append( \\\"rect\\\" ).attr( \\\"x\\\", function( d ) {\\n\\t\\t\\t\\t\\treturn /[ew]$/.test( d ) ? -3 : null;\\n\\t\\t\\t\\t} ).attr( \\\"y\\\", function( d ) {\\n\\t\\t\\t\\t\\treturn /^[ns]/.test( d ) ? -3 : null;\\n\\t\\t\\t\\t} ).attr( \\\"width\\\", 6 ).attr( \\\"height\\\", 6 ).style( \\\"visibility\\\", \\\"hidden\\\" );\\n\\t\\t\\t\\tresize.style( \\\"display\\\", brush.empty() ? \\\"none\\\" : null );\\n\\t\\t\\t\\tvar gUpdate = d3.transition( g ), backgroundUpdate = d3.transition( background ), range;\\n\\t\\t\\t\\tif ( x ) {\\n\\t\\t\\t\\t\\trange = d3_scaleRange( x );\\n\\t\\t\\t\\t\\tbackgroundUpdate.attr( \\\"x\\\", range[0] ).attr( \\\"width\\\", range[1] - range[0] );\\n\\t\\t\\t\\t\\tredrawX( gUpdate );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( y ) {\\n\\t\\t\\t\\t\\trange = d3_scaleRange( y );\\n\\t\\t\\t\\t\\tbackgroundUpdate.attr( \\\"y\\\", range[0] ).attr( \\\"height\\\", range[1] - range[0] );\\n\\t\\t\\t\\t\\tredrawY( gUpdate );\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tredraw( gUpdate );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tbrush.event = function( g ) {\\n\\t\\t\\tg.each( function() {\\n\\t\\t\\t\\tvar event_ = event.of( this, arguments ), extent1 = {\\n\\t\\t\\t\\t\\t\\tx: xExtent,\\n\\t\\t\\t\\t\\t\\ty: yExtent,\\n\\t\\t\\t\\t\\t\\ti: xExtentDomain,\\n\\t\\t\\t\\t\\t\\tj: yExtentDomain\\n\\t\\t\\t\\t\\t}, extent0 = this.__chart__ || extent1;\\n\\t\\t\\t\\tthis.__chart__ = extent1;\\n\\t\\t\\t\\tif ( d3_transitionInheritId ) {\\n\\t\\t\\t\\t\\td3.select( this ).transition().each( \\\"start.brush\\\", function() {\\n\\t\\t\\t\\t\\t\\txExtentDomain = extent0.i;\\n\\t\\t\\t\\t\\t\\tyExtentDomain = extent0.j;\\n\\t\\t\\t\\t\\t\\txExtent = extent0.x;\\n\\t\\t\\t\\t\\t\\tyExtent = extent0.y;\\n\\t\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\t\\ttype: \\\"brushstart\\\"\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} ).tween( \\\"brush:brush\\\", function() {\\n\\t\\t\\t\\t\\t\\tvar xi = d3_interpolateArray( xExtent, extent1.x ), yi = d3_interpolateArray( yExtent, extent1.y );\\n\\t\\t\\t\\t\\t\\txExtentDomain = yExtentDomain = null;\\n\\t\\t\\t\\t\\t\\treturn function( t ) {\\n\\t\\t\\t\\t\\t\\t\\txExtent = extent1.x = xi( t );\\n\\t\\t\\t\\t\\t\\t\\tyExtent = extent1.y = yi( t );\\n\\t\\t\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\t\\t\\ttype: \\\"brush\\\",\\n\\t\\t\\t\\t\\t\\t\\t\\tmode: \\\"resize\\\"\\n\\t\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\t};\\n\\t\\t\\t\\t\\t} ).each( \\\"end.brush\\\", function() {\\n\\t\\t\\t\\t\\t\\txExtentDomain = extent1.i;\\n\\t\\t\\t\\t\\t\\tyExtentDomain = extent1.j;\\n\\t\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\t\\ttype: \\\"brush\\\",\\n\\t\\t\\t\\t\\t\\t\\tmode: \\\"resize\\\"\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\t\\ttype: \\\"brushend\\\"\\n\\t\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"brushstart\\\"\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"brush\\\",\\n\\t\\t\\t\\t\\t\\tmode: \\\"resize\\\"\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"brushend\\\"\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t};\\n\\t\\tfunction redraw( g ) {\\n\\t\\t\\tg.selectAll( \\\".resize\\\" ).attr( \\\"transform\\\", function( d ) {\\n\\t\\t\\t\\treturn \\\"translate(\\\" + xExtent[+/e$/.test( d )] + \\\",\\\" + yExtent[+/^s/.test( d )] + \\\")\\\";\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t\\tfunction redrawX( g ) {\\n\\t\\t\\tg.select( \\\".extent\\\" ).attr( \\\"x\\\", xExtent[0] );\\n\\t\\t\\tg.selectAll( \\\".extent,.n>rect,.s>rect\\\" ).attr( \\\"width\\\", xExtent[1] - xExtent[0] );\\n\\t\\t}\\n\\t\\tfunction redrawY( g ) {\\n\\t\\t\\tg.select( \\\".extent\\\" ).attr( \\\"y\\\", yExtent[0] );\\n\\t\\t\\tg.selectAll( \\\".extent,.e>rect,.w>rect\\\" ).attr( \\\"height\\\", yExtent[1] - yExtent[0] );\\n\\t\\t}\\n\\t\\tfunction brushstart() {\\n\\t\\t\\tvar target = this, eventTarget = d3.select( d3.event.target ), event_ = event.of( target, arguments ), g = d3.select( target ), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test( resizing ) && x, resizingY = !/^(e|w)$/.test( resizing ) && y, dragging = eventTarget.classed( \\\"extent\\\" ), dragRestore = d3_event_dragSuppress( target ), center, origin = d3.mouse( target ), offset;\\n\\t\\t\\tvar w = d3.select( d3_window( target ) ).on( \\\"keydown.brush\\\", keydown ).on( \\\"keyup.brush\\\", keyup );\\n\\t\\t\\tif ( d3.event.changedTouches ) {\\n\\t\\t\\t\\tw.on( \\\"touchmove.brush\\\", brushmove ).on( \\\"touchend.brush\\\", brushend );\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tw.on( \\\"mousemove.brush\\\", brushmove ).on( \\\"mouseup.brush\\\", brushend );\\n\\t\\t\\t}\\n\\t\\t\\tg.interrupt().selectAll( \\\"*\\\" ).interrupt();\\n\\t\\t\\tif ( dragging ) {\\n\\t\\t\\t\\torigin[0] = xExtent[0] - origin[0];\\n\\t\\t\\t\\torigin[1] = yExtent[0] - origin[1];\\n\\t\\t\\t} else if ( resizing ) {\\n\\t\\t\\t\\tvar ex = +/w$/.test( resizing ), ey = +/^n/.test( resizing );\\n\\t\\t\\t\\toffset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\\n\\t\\t\\t\\torigin[0] = xExtent[ex];\\n\\t\\t\\t\\torigin[1] = yExtent[ey];\\n\\t\\t\\t} else if ( d3.event.altKey ) center = origin.slice();\\n\\t\\t\\tg.style( \\\"pointer-events\\\", \\\"none\\\" ).selectAll( \\\".resize\\\" ).style( \\\"display\\\", null );\\n\\t\\t\\td3.select( \\\"body\\\" ).style( \\\"cursor\\\", eventTarget.style( \\\"cursor\\\" ) );\\n\\t\\t\\tevent_( {\\n\\t\\t\\t\\ttype: \\\"brushstart\\\"\\n\\t\\t\\t} );\\n\\t\\t\\tbrushmove();\\n\\t\\t\\tfunction keydown() {\\n\\t\\t\\t\\tif ( d3.event.keyCode == 32 ) {\\n\\t\\t\\t\\t\\tif ( !dragging ) {\\n\\t\\t\\t\\t\\t\\tcenter = null;\\n\\t\\t\\t\\t\\t\\torigin[0] -= xExtent[1];\\n\\t\\t\\t\\t\\t\\torigin[1] -= yExtent[1];\\n\\t\\t\\t\\t\\t\\tdragging = 2;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\td3_eventPreventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction keyup() {\\n\\t\\t\\t\\tif ( d3.event.keyCode == 32 && dragging == 2 ) {\\n\\t\\t\\t\\t\\torigin[0] += xExtent[1];\\n\\t\\t\\t\\t\\torigin[1] += yExtent[1];\\n\\t\\t\\t\\t\\tdragging = 0;\\n\\t\\t\\t\\t\\td3_eventPreventDefault();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction brushmove() {\\n\\t\\t\\t\\tvar point = d3.mouse( target ), moved = false;\\n\\t\\t\\t\\tif ( offset ) {\\n\\t\\t\\t\\t\\tpoint[0] += offset[0];\\n\\t\\t\\t\\t\\tpoint[1] += offset[1];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( !dragging ) {\\n\\t\\t\\t\\t\\tif ( d3.event.altKey ) {\\n\\t\\t\\t\\t\\t\\tif ( !center ) center = [ ( xExtent[0] + xExtent[1] ) / 2, ( yExtent[0] + yExtent[1] ) / 2 ];\\n\\t\\t\\t\\t\\t\\torigin[0] = xExtent[+( point[0] < center[0] )];\\n\\t\\t\\t\\t\\t\\torigin[1] = yExtent[+( point[1] < center[1] )];\\n\\t\\t\\t\\t\\t} else center = null;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( resizingX && move1( point, x, 0 ) ) {\\n\\t\\t\\t\\t\\tredrawX( g );\\n\\t\\t\\t\\t\\tmoved = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( resizingY && move1( point, y, 1 ) ) {\\n\\t\\t\\t\\t\\tredrawY( g );\\n\\t\\t\\t\\t\\tmoved = true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( moved ) {\\n\\t\\t\\t\\t\\tredraw( g );\\n\\t\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\t\\ttype: \\\"brush\\\",\\n\\t\\t\\t\\t\\t\\tmode: dragging ? \\\"move\\\" : \\\"resize\\\"\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction move1( point, scale, i ) {\\n\\t\\t\\t\\tvar range = d3_scaleRange( scale ), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\\n\\t\\t\\t\\tif ( dragging ) {\\n\\t\\t\\t\\t\\tr0 -= position;\\n\\t\\t\\t\\t\\tr1 -= size + position;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tmin = ( i ? yClamp : xClamp ) ? Math.max( r0, Math.min( r1, point[i] ) ) : point[i];\\n\\t\\t\\t\\tif ( dragging ) {\\n\\t\\t\\t\\t\\tmax = ( min += position ) + size;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tif ( center ) position = Math.max( r0, Math.min( r1, 2 * center[i] - min ) );\\n\\t\\t\\t\\t\\tif ( position < min ) {\\n\\t\\t\\t\\t\\t\\tmax = min;\\n\\t\\t\\t\\t\\t\\tmin = position;\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tmax = position;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( extent[0] != min || extent[1] != max ) {\\n\\t\\t\\t\\t\\tif ( i ) yExtentDomain = null; else xExtentDomain = null;\\n\\t\\t\\t\\t\\textent[0] = min;\\n\\t\\t\\t\\t\\textent[1] = max;\\n\\t\\t\\t\\t\\treturn true;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tfunction brushend() {\\n\\t\\t\\t\\tbrushmove();\\n\\t\\t\\t\\tg.style( \\\"pointer-events\\\", \\\"all\\\" ).selectAll( \\\".resize\\\" ).style( \\\"display\\\", brush.empty() ? \\\"none\\\" : null );\\n\\t\\t\\t\\td3.select( \\\"body\\\" ).style( \\\"cursor\\\", null );\\n\\t\\t\\t\\tw.on( \\\"mousemove.brush\\\", null ).on( \\\"mouseup.brush\\\", null ).on( \\\"touchmove.brush\\\", null ).on( \\\"touchend.brush\\\", null ).on( \\\"keydown.brush\\\", null ).on( \\\"keyup.brush\\\", null );\\n\\t\\t\\t\\tdragRestore();\\n\\t\\t\\t\\tevent_( {\\n\\t\\t\\t\\t\\ttype: \\\"brushend\\\"\\n\\t\\t\\t\\t} );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tbrush.x = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return x;\\n\\t\\t\\tx = z;\\n\\t\\t\\tresizes = d3_svg_brushResizes[!x << 1 | !y];\\n\\t\\t\\treturn brush;\\n\\t\\t};\\n\\t\\tbrush.y = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return y;\\n\\t\\t\\ty = z;\\n\\t\\t\\tresizes = d3_svg_brushResizes[!x << 1 | !y];\\n\\t\\t\\treturn brush;\\n\\t\\t};\\n\\t\\tbrush.clamp = function( z ) {\\n\\t\\t\\tif ( !arguments.length ) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\\n\\t\\t\\tif ( x && y ) xClamp = !!z[0], yClamp = !!z[1]; else if ( x ) xClamp = !!z; else if ( y ) yClamp = !!z;\\n\\t\\t\\treturn brush;\\n\\t\\t};\\n\\t\\tbrush.extent = function( z ) {\\n\\t\\t\\tvar x0, x1, y0, y1, t;\\n\\t\\t\\tif ( !arguments.length ) {\\n\\t\\t\\t\\tif ( x ) {\\n\\t\\t\\t\\t\\tif ( xExtentDomain ) {\\n\\t\\t\\t\\t\\t\\tx0 = xExtentDomain[0], x1 = xExtentDomain[1];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tx0 = xExtent[0], x1 = xExtent[1];\\n\\t\\t\\t\\t\\t\\tif ( x.invert ) x0 = x.invert( x0 ), x1 = x.invert( x1 );\\n\\t\\t\\t\\t\\t\\tif ( x1 < x0 ) t = x0, x0 = x1, x1 = t;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif ( y ) {\\n\\t\\t\\t\\t\\tif ( yExtentDomain ) {\\n\\t\\t\\t\\t\\t\\ty0 = yExtentDomain[0], y1 = yExtentDomain[1];\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\ty0 = yExtent[0], y1 = yExtent[1];\\n\\t\\t\\t\\t\\t\\tif ( y.invert ) y0 = y.invert( y0 ), y1 = y.invert( y1 );\\n\\t\\t\\t\\t\\t\\tif ( y1 < y0 ) t = y0, y0 = y1, y1 = t;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\\n\\t\\t\\t}\\n\\t\\t\\tif ( x ) {\\n\\t\\t\\t\\tx0 = z[0], x1 = z[1];\\n\\t\\t\\t\\tif ( y ) x0 = x0[0], x1 = x1[0];\\n\\t\\t\\t\\txExtentDomain = [ x0, x1 ];\\n\\t\\t\\t\\tif ( x.invert ) x0 = x( x0 ), x1 = x( x1 );\\n\\t\\t\\t\\tif ( x1 < x0 ) t = x0, x0 = x1, x1 = t;\\n\\t\\t\\t\\tif ( x0 != xExtent[0] || x1 != xExtent[1] ) xExtent = [ x0, x1 ];\\n\\t\\t\\t}\\n\\t\\t\\tif ( y ) {\\n\\t\\t\\t\\ty0 = z[0], y1 = z[1];\\n\\t\\t\\t\\tif ( x ) y0 = y0[1], y1 = y1[1];\\n\\t\\t\\t\\tyExtentDomain = [ y0, y1 ];\\n\\t\\t\\t\\tif ( y.invert ) y0 = y( y0 ), y1 = y( y1 );\\n\\t\\t\\t\\tif ( y1 < y0 ) t = y0, y0 = y1, y1 = t;\\n\\t\\t\\t\\tif ( y0 != yExtent[0] || y1 != yExtent[1] ) yExtent = [ y0, y1 ];\\n\\t\\t\\t}\\n\\t\\t\\treturn brush;\\n\\t\\t};\\n\\t\\tbrush.clear = function() {\\n\\t\\t\\tif ( !brush.empty() ) {\\n\\t\\t\\t\\txExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\\n\\t\\t\\t\\txExtentDomain = yExtentDomain = null;\\n\\t\\t\\t}\\n\\t\\t\\treturn brush;\\n\\t\\t};\\n\\t\\tbrush.empty = function() {\\n\\t\\t\\treturn !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\\n\\t\\t};\\n\\t\\treturn d3.rebind( brush, event, \\\"on\\\" );\\n\\t};\\n\\tvar d3_svg_brushCursor = {\\n\\t\\tn: \\\"ns-resize\\\",\\n\\t\\te: \\\"ew-resize\\\",\\n\\t\\ts: \\\"ns-resize\\\",\\n\\t\\tw: \\\"ew-resize\\\",\\n\\t\\tnw: \\\"nwse-resize\\\",\\n\\t\\tne: \\\"nesw-resize\\\",\\n\\t\\tse: \\\"nwse-resize\\\",\\n\\t\\tsw: \\\"nesw-resize\\\"\\n\\t};\\n\\tvar d3_svg_brushResizes = [ [ \\\"n\\\", \\\"e\\\", \\\"s\\\", \\\"w\\\", \\\"nw\\\", \\\"ne\\\", \\\"se\\\", \\\"sw\\\" ], [ \\\"e\\\", \\\"w\\\" ], [ \\\"n\\\", \\\"s\\\" ], [] ];\\n\\tvar d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\\n\\tvar d3_time_formatUtc = d3_time_format.utc;\\n\\tvar d3_time_formatIso = d3_time_formatUtc( \\\"%Y-%m-%dT%H:%M:%S.%LZ\\\" );\\n\\td3_time_format.iso = Date.prototype.toISOString && +new Date( \\\"2000-01-01T00:00:00.000Z\\\" ) ? d3_time_formatIsoNative : d3_time_formatIso;\\n\\tfunction d3_time_formatIsoNative( date ) {\\n\\t\\treturn date.toISOString();\\n\\t}\\n\\td3_time_formatIsoNative.parse = function( string ) {\\n\\t\\tvar date = new Date( string );\\n\\t\\treturn isNaN( date ) ? null : date;\\n\\t};\\n\\td3_time_formatIsoNative.toString = d3_time_formatIso.toString;\\n\\td3_time.second = d3_time_interval( function( date ) {\\n\\t\\treturn new d3_date( Math.floor( date / 1e3 ) * 1e3 );\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setTime( date.getTime() + Math.floor( offset ) * 1e3 );\\n\\t}, function( date ) {\\n\\t\\treturn date.getSeconds();\\n\\t} );\\n\\td3_time.seconds = d3_time.second.range;\\n\\td3_time.seconds.utc = d3_time.second.utc.range;\\n\\td3_time.minute = d3_time_interval( function( date ) {\\n\\t\\treturn new d3_date( Math.floor( date / 6e4 ) * 6e4 );\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setTime( date.getTime() + Math.floor( offset ) * 6e4 );\\n\\t}, function( date ) {\\n\\t\\treturn date.getMinutes();\\n\\t} );\\n\\td3_time.minutes = d3_time.minute.range;\\n\\td3_time.minutes.utc = d3_time.minute.utc.range;\\n\\td3_time.hour = d3_time_interval( function( date ) {\\n\\t\\tvar timezone = date.getTimezoneOffset() / 60;\\n\\t\\treturn new d3_date( ( Math.floor( date / 36e5 - timezone ) + timezone ) * 36e5 );\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setTime( date.getTime() + Math.floor( offset ) * 36e5 );\\n\\t}, function( date ) {\\n\\t\\treturn date.getHours();\\n\\t} );\\n\\td3_time.hours = d3_time.hour.range;\\n\\td3_time.hours.utc = d3_time.hour.utc.range;\\n\\td3_time.month = d3_time_interval( function( date ) {\\n\\t\\tdate = d3_time.day( date );\\n\\t\\tdate.setDate( 1 );\\n\\t\\treturn date;\\n\\t}, function( date, offset ) {\\n\\t\\tdate.setMonth( date.getMonth() + offset );\\n\\t}, function( date ) {\\n\\t\\treturn date.getMonth();\\n\\t} );\\n\\td3_time.months = d3_time.month.range;\\n\\td3_time.months.utc = d3_time.month.utc.range;\\n\\tfunction d3_time_scale( linear, methods, format ) {\\n\\t\\tfunction scale( x ) {\\n\\t\\t\\treturn linear( x );\\n\\t\\t}\\n\\t\\tscale.invert = function( x ) {\\n\\t\\t\\treturn d3_time_scaleDate( linear.invert( x ) );\\n\\t\\t};\\n\\t\\tscale.domain = function( x ) {\\n\\t\\t\\tif ( !arguments.length ) return linear.domain().map( d3_time_scaleDate );\\n\\t\\t\\tlinear.domain( x );\\n\\t\\t\\treturn scale;\\n\\t\\t};\\n\\t\\tfunction tickMethod( extent, count ) {\\n\\t\\t\\tvar span = extent[1] - extent[0], target = span / count, i = d3.bisect( d3_time_scaleSteps, target );\\n\\t\\t\\treturn i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange( extent.map( function( d ) {\\n\\t\\t\\t\\treturn d / 31536e6;\\n\\t\\t\\t} ), count )[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange( extent, count )[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\\n\\t\\t}\\n\\t\\tscale.nice = function( interval, skip ) {\\n\\t\\t\\tvar domain = scale.domain(), extent = d3_scaleExtent( domain ), method = interval == null ? tickMethod( extent, 10 ) : typeof interval === \\\"number\\\" && tickMethod( extent, interval );\\n\\t\\t\\tif ( method ) interval = method[0], skip = method[1];\\n\\t\\t\\tfunction skipped( date ) {\\n\\t\\t\\t\\treturn !isNaN( date ) && !interval.range( date, d3_time_scaleDate( +date + 1 ), skip ).length;\\n\\t\\t\\t}\\n\\t\\t\\treturn scale.domain( d3_scale_nice( domain, skip > 1 ? {\\n\\t\\t\\t\\tfloor: function( date ) {\\n\\t\\t\\t\\t\\twhile ( skipped( date = interval.floor( date ) ) ) date = d3_time_scaleDate( date - 1 );\\n\\t\\t\\t\\t\\treturn date;\\n\\t\\t\\t\\t},\\n\\t\\t\\t\\tceil: function( date ) {\\n\\t\\t\\t\\t\\twhile ( skipped( date = interval.ceil( date ) ) ) date = d3_time_scaleDate( +date + 1 );\\n\\t\\t\\t\\t\\treturn date;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} : interval ) );\\n\\t\\t};\\n\\t\\tscale.ticks = function( interval, skip ) {\\n\\t\\t\\tvar extent = d3_scaleExtent( scale.domain() ), method = interval == null ? tickMethod( extent, 10 ) : typeof interval === \\\"number\\\" ? tickMethod( extent, interval ) : !interval.range && [ {\\n\\t\\t\\t\\trange: interval\\n\\t\\t\\t}, skip ];\\n\\t\\t\\tif ( method ) interval = method[0], skip = method[1];\\n\\t\\t\\treturn interval.range( extent[0], d3_time_scaleDate( +extent[1] + 1 ), skip < 1 ? 1 : skip );\\n\\t\\t};\\n\\t\\tscale.tickFormat = function() {\\n\\t\\t\\treturn format;\\n\\t\\t};\\n\\t\\tscale.copy = function() {\\n\\t\\t\\treturn d3_time_scale( linear.copy(), methods, format );\\n\\t\\t};\\n\\t\\treturn d3_scale_linearRebind( scale, linear );\\n\\t}\\n\\tfunction d3_time_scaleDate( t ) {\\n\\t\\treturn new Date( t );\\n\\t}\\n\\tvar d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\\n\\tvar d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\\n\\tvar d3_time_scaleLocalFormat = d3_time_format.multi( [ [ \\\".%L\\\", function( d ) {\\n\\t\\treturn d.getMilliseconds();\\n\\t} ], [ \\\":%S\\\", function( d ) {\\n\\t\\treturn d.getSeconds();\\n\\t} ], [ \\\"%I:%M\\\", function( d ) {\\n\\t\\treturn d.getMinutes();\\n\\t} ], [ \\\"%I %p\\\", function( d ) {\\n\\t\\treturn d.getHours();\\n\\t} ], [ \\\"%a %d\\\", function( d ) {\\n\\t\\treturn d.getDay() && d.getDate() != 1;\\n\\t} ], [ \\\"%b %d\\\", function( d ) {\\n\\t\\treturn d.getDate() != 1;\\n\\t} ], [ \\\"%B\\\", function( d ) {\\n\\t\\treturn d.getMonth();\\n\\t} ], [ \\\"%Y\\\", d3_true ] ] );\\n\\tvar d3_time_scaleMilliseconds = {\\n\\t\\trange: function( start, stop, step ) {\\n\\t\\t\\treturn d3.range( Math.ceil( start / step ) * step, +stop, step ).map( d3_time_scaleDate );\\n\\t\\t},\\n\\t\\tfloor: d3_identity,\\n\\t\\tceil: d3_identity\\n\\t};\\n\\td3_time_scaleLocalMethods.year = d3_time.year;\\n\\td3_time.scale = function() {\\n\\t\\treturn d3_time_scale( d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat );\\n\\t};\\n\\tvar d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map( function( m ) {\\n\\t\\treturn [ m[0].utc, m[1] ];\\n\\t} );\\n\\tvar d3_time_scaleUtcFormat = d3_time_formatUtc.multi( [ [ \\\".%L\\\", function( d ) {\\n\\t\\treturn d.getUTCMilliseconds();\\n\\t} ], [ \\\":%S\\\", function( d ) {\\n\\t\\treturn d.getUTCSeconds();\\n\\t} ], [ \\\"%I:%M\\\", function( d ) {\\n\\t\\treturn d.getUTCMinutes();\\n\\t} ], [ \\\"%I %p\\\", function( d ) {\\n\\t\\treturn d.getUTCHours();\\n\\t} ], [ \\\"%a %d\\\", function( d ) {\\n\\t\\treturn d.getUTCDay() && d.getUTCDate() != 1;\\n\\t} ], [ \\\"%b %d\\\", function( d ) {\\n\\t\\treturn d.getUTCDate() != 1;\\n\\t} ], [ \\\"%B\\\", function( d ) {\\n\\t\\treturn d.getUTCMonth();\\n\\t} ], [ \\\"%Y\\\", d3_true ] ] );\\n\\td3_time_scaleUtcMethods.year = d3_time.year.utc;\\n\\td3_time.scale.utc = function() {\\n\\t\\treturn d3_time_scale( d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat );\\n\\t};\\n\\td3.text = d3_xhrType( function( request ) {\\n\\t\\treturn request.responseText;\\n\\t} );\\n\\td3.json = function( url, callback ) {\\n\\t\\treturn d3_xhr( url, \\\"application/json\\\", d3_json, callback );\\n\\t};\\n\\tfunction d3_json( request ) {\\n\\t\\treturn JSON.parse( request.responseText );\\n\\t}\\n\\td3.html = function( url, callback ) {\\n\\t\\treturn d3_xhr( url, \\\"text/html\\\", d3_html, callback );\\n\\t};\\n\\tfunction d3_html( request ) {\\n\\t\\tvar range = d3_document.createRange();\\n\\t\\trange.selectNode( d3_document.body );\\n\\t\\treturn range.createContextualFragment( request.responseText );\\n\\t}\\n\\td3.xml = d3_xhrType( function( request ) {\\n\\t\\treturn request.responseXML;\\n\\t} );\\n\\tif ( typeof define === \\\"function\\\" && define.amd ) this.d3 = d3, define( d3 ); else if ( typeof module === \\\"object\\\" && module.exports ) module.exports = d3; else this.d3 = d3;\\n}();\"","module.exports = \"( function( global, factory ) {\\n\\tif ( typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\" ) {\\n\\t\\tmodule.exports = global.document? factory( global, true ): factory( global );\\n\\t} else {\\n\\t\\tfactory( global );\\n\\t}\\n}( typeof window !== \\\"undefined\\\" ? window: this, function( window, noGlobal ) {\\n\\t\\\"use strict\\\";\\n\\tvar uv = {};\\n\\n\\tuv.util = {};\\n\\n\\t/**\\n* Utility method to extend prototype for JavaScript classes, to act like inheritance\\n* @param  {Class} f Original class which is being extended\\n* @return {Prototype}   Prototype containing the functions from the super class\\n*/\\n\\tuv.util.inherits = function ( f ) {\\n\\t\\tfunction G() {}\\n\\t\\tG.prototype = f.prototype || f;\\n\\t\\treturn new G();\\n\\t};\\n\\n\\t/**\\n* Utility method to return a unique identification id\\n* @return {number} Timestamp in ms is returned as a unique id\\n*/\\n\\tuv.util.getUniqueId = function () {\\n\\t\\treturn new Date().getTime();\\n\\t};\\n\\n\\tuv.util.getMax = function ( graphdef, classification ) {\\n\\t\\tswitch ( classification ) {\\n\\t\\tcase 'stepup':\\n\\t\\t\\treturn this.getStepMaxValue( graphdef );\\n\\t\\tcase 'normal':\\n\\t\\t\\treturn this.getMaxValue( graphdef );\\n\\t\\tcase 'percent':\\n\\t\\t\\treturn 100;\\n\\t\\tcase 'waterfall':\\n\\t\\t\\treturn this.getWaterfallMaxValue( graphdef );\\n\\t\\tdefault:\\n\\t\\t\\tconsole.error( \\\"Unknown classification for chart\\\", classification );\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n*\\n*/\\n\\tuv.util.getMaxValue = function ( graphdef ) {\\n\\t\\treturn d3.max( graphdef.categories.map( function ( d ) {\\n\\t\\t\\treturn d3.max( graphdef.dataset[d].map( function ( d ) {\\n\\t\\t\\t\\treturn d.value;\\n\\t\\t\\t} ) );\\n\\t\\t} ) );\\n\\t};\\n\\n\\tuv.util.getStepMaxValue = function ( graphdef ) {\\n\\t\\tvar sumMap = graphdef.dataset[graphdef.categories[0]].map( function () {return 0; } ),\\n\\t\\t\\tmaxMap = sumMap.map( function () { return 0; } );\\n\\n\\t\\tgraphdef.categories.map( function ( d ) {\\n\\t\\t\\tgraphdef.dataset[d].map( function ( d, i ) {\\n\\t\\t\\t\\tif ( d.resetSum === true ) {\\n\\t\\t\\t\\t\\tsumMap[i] = 0;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tsumMap[i] += d.value;\\n\\t\\t\\t\\tmaxMap[i] = d3.max( [sumMap[i], maxMap[i]] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\n\\t\\treturn d3.max( maxMap );\\n\\t};\\n\\n\\tuv.util.getWaterfallMaxValue = function( graphdef ) {\\n\\t\\tvar sumMap = graphdef.categories.map( function() {return 0;} );\\n\\t\\tgraphdef.categories.map( function ( d, i ) {\\n\\t\\t\\tvar localMax = 0;\\n\\t\\t\\tgraphdef.dataset[d].map( function( d ) {\\n\\t\\t\\t\\tlocalMax += d.value;\\n\\t\\t\\t\\tif( sumMap[i] < localMax ) {\\n\\t\\t\\t\\t\\tsumMap[i] = localMax;\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\n\\t\\treturn d3.max( sumMap );\\n\\t};\\n\\n\\tuv.util.getMin = function ( graphdef, classification ) {\\n\\t\\tswitch ( classification ) {\\n\\t\\tcase 'normal':\\n\\t\\t\\treturn this.getMinValue( graphdef );\\n\\t\\tcase 'stepup':\\n\\t\\t\\treturn this.getStepMinValue( graphdef );\\n\\t\\tdefault:\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\t}\\n\\n\\t/**\\n*\\n*/\\n\\tuv.util.getMinValue = function ( graphdef ) {\\n\\t\\treturn d3.min( [0, d3.min( graphdef.categories.map( function ( d ) {\\n\\t\\t\\treturn d3.min( graphdef.dataset[d].map( function ( d ) {\\n\\t\\t\\t\\treturn d.value;\\n\\t\\t\\t} ) );\\n\\t\\t} ) )\\n\\t\\t] );\\n\\t};\\n\\n\\tuv.util.getStepMinValue = function ( graphdef ) {\\n\\t\\tvar sumMap = graphdef.dataset[graphdef.categories[0]].map( function () {return 0; } ),\\n\\t\\t\\tminMap = sumMap.map( function () { return 0; } );\\n\\n\\t\\tgraphdef.categories.map( function ( d ) {\\n\\t\\t\\tgraphdef.dataset[d].map( function ( d, i ) {\\n\\t\\t\\t\\tsumMap[i] += d.value;\\n\\t\\t\\t\\tminMap[i] = d3.min( [sumMap[i], minMap[i]] );\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\n\\t\\treturn d3.min( minMap );\\n\\t}\\n\\n\\tuv.util.getSumUpArray = function ( graphdef ) {\\n\\t\\tvar sumMap = graphdef.dataset[graphdef.categories[0]].map( function () {return 0; } );\\n\\t\\tgraphdef.categories.map( function ( d ) {\\n\\t\\t\\tgraphdef.dataset[d].map( function ( d, i ) {\\n\\t\\t\\t\\tsumMap[i] += d.value;\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\n\\t\\treturn sumMap;\\n\\t};\\n\\n\\tuv.util.getPercentage = function ( value, total ) {\\n\\t\\treturn value* 100 / total;\\n\\t};\\n\\n\\tuv.util.getDataArray = function ( graphdef ) {\\n\\t\\treturn graphdef.categories.map( function ( d ) { return graphdef.dataset[d]; } );\\n\\t};\\n\\n\\tuv.util.getTabularArray = function ( graphdef ) {\\n\\t\\tvar table = [], i, j, catlen, len, arr = [];\\n\\t\\tfor ( i = 0, len = graphdef.dataset[graphdef.categories[0]].length; i < len; i = i + 1 ) {\\n\\t\\t\\tarr = [];\\n\\t\\t\\tarr.push( graphdef.dataset[graphdef.categories[0]][i].name );\\n\\t\\t\\tfor ( j = 0, catlen = graphdef.categories.length; j < catlen; j = j + 1 ) {\\n\\t\\t\\t\\tarr.push( graphdef.dataset[graphdef.categories[j]][i].value );\\n\\t\\t\\t}\\n\\t\\t\\ttable.push( arr );\\n\\t\\t}\\n\\t\\treturn table;\\n\\t};\\n\\n\\tuv.util.getLabelArray = function ( graphdef, idx ) {\\n\\t\\treturn graphdef.dataset[graphdef.categories[idx ? idx : 0]].map( function ( d ) { return d.name; } );\\n\\t};\\n\\n\\tuv.util.getCategoryArray = function ( graphdef ) {\\n\\t\\treturn graphdef.categories.map( function ( d ) { return d; } );\\n\\t};\\n\\n\\tuv.util.getCategoryData = function ( graphdef, categories ) {\\n\\t\\treturn categories.map( function ( d ) {\\n\\t\\t\\treturn graphdef.dataset[d].map( function ( d ) {\\n\\t\\t\\t\\treturn d.value;\\n\\t\\t\\t} );\\n\\t\\t} );\\n\\t};\\n\\n\\tuv.util.transposeData = function ( graphdef ) {\\n\\t\\tvar dataset = {}, i, j, length, jlength, resetSum,\\n\\t\\t\\tname, label, value, categories = graphdef.dataset[graphdef.categories[0]].map( function ( d ) { return d.name; } );\\n\\n\\t\\tfor ( i = 0, length = categories.length; i < length; i = i + 1 ) {\\n\\t\\t\\tdataset[categories[i]] = [];\\n\\t\\t}\\n\\n\\t\\tfor ( i = 0, length = graphdef.categories.length; i < length; i = i + 1 ) {\\n\\t\\t\\tname = graphdef.categories[i];\\n\\t\\t\\tfor ( j = 0, jlength = graphdef.dataset[name].length; j < jlength; j = j + 1 ) {\\n\\t\\t\\t\\tlabel = graphdef.dataset[name][j].name;\\n\\t\\t\\t\\tvalue = graphdef.dataset[name][j].value;\\n\\t\\t\\t\\tresetSum = graphdef.dataset[name][j].resetSum;\\n\\t\\t\\t\\tdataset[label].push( { 'name' : name, 'value' : value, 'resetSum': resetSum } );\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tgraphdef.categories = categories;\\n\\t\\tgraphdef.dataset = dataset;\\n\\t};\\n\\n\\tuv.util.getPascalCasedName = function ( name ) {\\n\\t\\treturn name.substring( 0, 1 ).toUpperCase() + name.substring( 1 );\\n\\t};\\n\\n\\tuv.util.getColorBand = function ( config, index ) {\\n\\t\\tvar len = 0,\\n\\t\\t\\tpalette = config.graph.palette || 'Default';\\n\\n\\t\\tif ( config.graph.custompalette && config.graph.custompalette.length !== 0 ) {\\n\\t\\t\\tlen = config.graph.custompalette.length;\\n\\t\\t\\treturn config.graph.custompalette[index % len];\\n\\t\\t} else {\\n\\t\\t\\tlen = uv.palette[config.graph.palette].length;\\n\\t\\t\\treturn uv.palette[config.graph.palette][index % len];\\n\\t\\t}\\n\\t};\\n\\n\\t/**\\n* This function finds regular expressions other than Alphabets, Numbers,\\n* \\\"_\\\" and \\\"-\\\" and replaces it with \\\"-\\\".\\n* @param  {string} name The string which needs to be formatted\\n* @return {string}      Returns the formatted String\\n*/\\n\\tuv.util.formatClassName = function( name ){\\n\\t\\tvar returnName = name.trim().replace( /[^A-Za-z0-9_\\\\-]/g,\\\"-\\\" ).toLowerCase();\\n\\t\\treturn returnName;\\n\\t};\\n\\n\\tuv.util.svgToPng = function ( downloadElmtRef, callback ) {\\n\\t\\tif ( this.isCanvasSupported() ) {\\n\\t\\t\\tvar svgContent = d3.select( downloadElmtRef.frame.node().parentNode ).html();\\n\\t\\t\\tvar canvas = document.createElement( 'canvas' );\\n\\t\\t\\tvar ctx = canvas.getContext( \\\"2d\\\" );\\n\\t\\t\\tcanvas.setAttribute( 'width',d3.select( downloadElmtRef.frame.node() ).attr( 'width' ) );\\n\\t\\t\\tcanvas.setAttribute( 'height',d3.select( downloadElmtRef.frame.node() ).attr( 'height' ) );\\n\\t\\t\\tctx.drawSvg( svgContent );\\n\\t\\t\\tcanvas.toBlob( function( blob ) {\\n\\t\\t\\t\\t//saveAs(blob, \\\"png_download\\\"+Math.ceil(Math.random()*100000)+\\\".png\\\");\\n\\t\\t\\t\\tvar a = document.createElement( \\\"a\\\" );\\n\\t\\t\\t\\tdocument.body.appendChild( a );\\n\\t\\t\\t\\ta.style = \\\"display: none\\\";\\n\\t\\t\\t\\tvar url = window.URL.createObjectURL( blob );\\n\\t\\t\\t\\ta.href = url;\\n\\t\\t\\t\\ta.download = \\\"png_download\\\"+Math.ceil( Math.random()*100000 )+\\\".png\\\";\\n\\t\\t\\t\\ta.click();\\n\\t\\t\\t\\t//window.URL.revokeObjectURL(url);\\n\\t\\t\\t}, \\\"image/png\\\" );\\n\\t\\t\\tcallback.call();\\n\\t\\t} else {\\n\\t\\t\\tconsole.log( 'uvCharts: Download feature is not supported in this version of browser' );\\n\\t\\t}\\n\\t};\\n\\n\\tuv.util.isDownloadSupported = function() {\\n\\t\\tvar canvas = document.createElement( 'canvas' );\\n\\t\\tvar ctx = canvas.getContext( \\\"2d\\\" );\\n\\t\\treturn typeof( ctx.drawSvg ) === 'function' && typeof( canvas.toBlob ) === 'function';\\n\\t};\\n\\n\\tuv.util.isCanvasSupported = function () {\\n\\t\\tvar elem = document.createElement( 'canvas' );\\n\\t\\treturn !!( elem.getContext && elem.getContext( '2d' ) );\\n\\t};\\n\\n\\t/**\\n* This function waits till the end of the transition and then call the callback\\n* function which is passed as an argument\\n* @param  {transition}   transition It's the current transition\\n* @param  {Function} callback   function which is called at the end of\\n*                               transition\\n*/\\n\\tuv.util.endAll = function ( transition, callback ){\\n\\t\\tvar n = 0;\\n\\t\\ttransition.each( function() { ++n; } ).each( \\\"end\\\", function() {\\n\\t\\t\\tif ( !--n ) {\\n\\t\\t\\t\\tcallback.apply( this, arguments );\\n\\t\\t\\t}\\n\\t\\t} );\\n\\t};\\n\\n\\t/**\\n* This function returns all class names of the element including new class name.\\n* Useful in cases where we need to avoid over-writting of classes.\\n* @param  {} self this referring to svgElement\\n* @param  {String} name new class name to be added\\n* @return {String}      All class names as string.\\n*/\\n\\tuv.util.getClassName = function( self, name ) {\\n\\t\\tvar formattedName = uv.util.formatClassName( name );\\n\\t\\tif( !d3.select( self ).attr( 'class' ) ) {\\n\\t\\t\\treturn formattedName;\\n\\t\\t}\\n\\t\\tif( d3.select( self ).attr( 'class' ).split( ' ' ).indexOf( formattedName ) !== -1 ) {\\n\\t\\t\\treturn d3.select( self ).attr( 'class' );\\n\\t\\t}\\n\\t\\treturn d3.select( self ).attr( 'class' ) + \\\" \\\" + formattedName;\\n\\t};\\n\\n\\t/**\\n* Returns specified value of given data object if integer, else returns formatted value considering precision.\\n* @param  self\\n* @param  {Number} d    data object\\n* @return {Strinig}     value with precision\\n*/\\n\\tuv.util.getLabelValue = function( self, d ) {\\n\\t\\t// if(typeof d.value !== 'number') return null;\\n\\t\\tif ( self.config.label.formatter !== undefined ) {\\n\\t\\t\\treturn self.config.label.formatter( d.value );\\n\\t\\t}\\n\\n\\t\\tvar val = ( d.value % 1 === 0 ) ? d.value : d.value.toFixed( self.config.label.precision );\\n\\t\\treturn self.config.label.prefix + String( val ) + self.config.label.suffix;\\n\\t};\\n\\n\\tuv.util._deepClone = function( target, src ) {\\n\\t\\tif( typeof src === 'object' ) {\\n\\t\\t\\tvar isEmpty = true;\\n\\t\\t\\tfor( var key in src ) {\\n\\t\\t\\t\\tisEmpty = false;\\n\\t\\t\\t\\tif( src.hasOwnProperty( key ) ) {\\n\\t\\t\\t\\t\\tif( target === undefined ) {\\n\\t\\t\\t\\t\\t\\ttarget = Array.isArray( src ) ? [] : {};\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ttarget[key] = uv.util._deepClone( target[key], src[key] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\tif( isEmpty ){\\n\\t\\t\\t\\ttarget = Array.isArray( src ) ? [] : {};\\n\\t\\t\\t}\\n\\t\\t} else {\\n\\t\\t\\ttarget = src;\\n\\t\\t}\\n\\t\\treturn target;\\n\\t};\\n\\n\\n\\t/**\\n* Extends properies of rest of the arguments to the first argument.\\n* @param  {Object} target\\n* @param  {Object} argument1\\n* @param  {Object} argumentN\\n* @return target object\\n*/\\n\\tuv.util.extend = function() {\\n\\t\\tif( arguments[0] === undefined || arguments[0] === null ) {\\n\\t\\t\\treturn arguments[0];\\n\\t\\t}\\n\\t\\tfor( var i=1; i<arguments.length; i++ ) {\\n\\t\\t\\tfor( var key in arguments[i] ) {\\n\\t\\t\\t\\tif( arguments[i].hasOwnProperty( key ) ) {\\n\\t\\t\\t\\t\\targuments[0][key] = uv.util._deepClone( arguments[0][key], arguments[i][key] );\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn arguments[0];\\n\\t};\\n\\n\\t/**\\n* This method returns tool tip text value if config option show tooltiptext is true else returns empty string.\\n* The text is as per the format specified using %c, %l, %v for category, label and values respectively.\\n* Default format is - %c [%l] : %v\\n* @param   self\\n* @param  {String} category\\n* @param  {String} label\\n* @param  {String} value\\n* @return {[String]}  tool tip text with specified format.\\n*/\\n\\tuv.util.getTooltipText = function( self, category, label, value ) {\\n\\t\\tif( !self.config.tooltip.show ) {\\n\\t\\t\\treturn '';\\n\\t\\t}\\n\\t\\tvar format = self.config.tooltip.format;\\n\\t\\tif( format === '' ) {\\n\\t\\t\\treturn category + ' [' + label + '] : ' + uv.util.getLabelValue( value );\\n\\t\\t}\\n\\t\\treturn format.replace( /%c/gi, category ).replace( /%l/gi, label ).replace( /%v/gi, uv.util.getLabelValue( self, value ) );\\n\\t};\\n\\n\\tuv.config = {\\n\\t\\tgraph: {\\n\\t\\t\\tpalette: 'Default',\\n\\t\\t\\tbgcolor: '#FFFFFF',\\n\\t\\t\\torientation: 'Horizontal',\\n\\t\\t\\tmax: 0,\\n\\t\\t\\tmin: 0,\\n\\t\\t\\tcustompalette: [],\\n\\t\\t\\topacity: 1,\\n\\t\\t\\tresponsive: false,\\n\\t\\t\\talign: 'xMinYMin',\\n\\t\\t\\tmeetOrSlice: 'meet'\\n\\t\\t},\\n\\n\\t\\tmeta: {\\n\\t\\t\\tposition: '#uv-div',\\n\\t\\t\\tcaption: '',\\n\\t\\t\\tsubcaption: '',\\n\\t\\t\\thlabel: '',\\n\\t\\t\\tvlabel: '',\\n\\t\\t\\thsublabel: '',\\n\\t\\t\\tvsublabel: '',\\n\\t\\t\\tisDownloadable: false,\\n\\t\\t\\tdownloadLabel: 'Download'\\n\\t\\t},\\n\\n\\t\\tdimension: {\\n\\t\\t\\twidth: 400,\\n\\t\\t\\theight: 400\\n\\t\\t},\\n\\n\\t\\tmargin: {\\n\\t\\t\\ttop: 50,\\n\\t\\t\\tbottom: 150,\\n\\t\\t\\tleft: 100,\\n\\t\\t\\tright: 100\\n\\t\\t},\\n\\n\\t\\tframe: {\\n\\t\\t\\tbgcolor: '#FFFFFF'\\n\\t\\t},\\n\\n\\t\\taxis: {\\n\\t\\t\\tticks: 8,\\n\\t\\t\\tsubticks: 2,\\n\\t\\t\\tpadding: 5,\\n\\t\\t\\tminor: -10,\\n\\t\\t\\tstrokecolor: '#000000',\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '14',\\n\\t\\t\\tfontweight: 'bold',\\n\\t\\t\\tshowticks: true,\\n\\t\\t\\tshowsubticks: true,\\n\\t\\t\\tshowtext: true,\\n\\t\\t\\tshowhortext: true,\\n\\t\\t\\tshowvertext: true,\\n\\t\\t\\topacity: 0.1\\n\\t\\t},\\n\\n\\t\\tlabel: {\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '11',\\n\\t\\t\\tfontweight: 'normal',\\n\\t\\t\\tstrokecolor: '#000000',\\n\\t\\t\\tshowlabel: true,\\n\\t\\t\\tprecision: 2,\\n\\t\\t\\tprefix: '',\\n\\t\\t\\tsuffix: '',\\n\\t\\t\\tformatter: undefined\\n\\t\\t},\\n\\n\\t\\ttooltip: {\\n\\t\\t\\tshow: true,\\n\\t\\t\\tformat: '%c [%l]: %v'\\n\\t\\t},\\n\\n\\t\\tscale: {\\n\\t\\t\\ttype: 'linear',\\n\\t\\t\\tordinality: 0.2\\n\\t\\t},\\n\\n\\t\\tbar: {\\n\\t\\t\\tstrokecolor: 'none',\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '10',\\n\\t\\t\\tfontweight: 'bold',\\n\\t\\t\\ttextcolor: '#000'\\n\\t\\t},\\n\\n\\t\\tline: {\\n\\t\\t\\tinterpolation: 'linear',\\n\\t\\t\\tshowcircles: true,\\n\\t\\t\\tcircleradius: 3.5,\\n\\t\\t\\tcircleopacity: 0.6,\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize : '10',\\n\\t\\t\\tfontweight: 'bold',\\n\\t\\t\\ttextcolor: '#000',\\n\\t\\t\\tstrokewidth: 1.5,\\n\\t\\t\\tstrokeopacity: 1\\n\\t\\t},\\n\\n\\t\\tarea: {\\n\\t\\t\\tinterpolation: 'cardinal',\\n\\t\\t\\toffset: 'zero',\\n\\t\\t\\topacity: 0.2\\n\\t\\t},\\n\\n\\t\\tpie: {\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '14',\\n\\t\\t\\tfontweight: 'normal',\\n\\t\\t\\tfontvariant: 'small-caps',\\n\\t\\t\\tfontfill: '#FFFFFF',\\n\\t\\t\\tstrokecolor: '#FFFFFF',\\n\\t\\t\\tstrokewidth: 1\\n\\t\\t},\\n\\n\\t\\tdonut: {\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '14',\\n\\t\\t\\tfontweight: 'normal',\\n\\t\\t\\tfontvariant: 'small-caps',\\n\\t\\t\\tfontfill: '#000',\\n\\t\\t\\tfactor: 0.4,\\n\\t\\t\\tstrokecolor: '#FFFFFF',\\n\\t\\t\\tstrokewidth: 1\\n\\t\\t},\\n\\n\\t\\tcaption: {\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '14',\\n\\t\\t\\tfontweight: 'bold',\\n\\t\\t\\tfontvariant: 'small-caps',\\n\\t\\t\\ttextdecoration: 'none',\\n\\t\\t\\thovercolor: '#696969',\\n\\t\\t\\tstrokecolor: '#0000FF',\\n\\t\\t\\ttextanchor: 'middle',\\n\\t\\t\\tcursor: 'pointer'\\n\\t\\t},\\n\\n\\t\\tsubCaption: {\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '9',\\n\\t\\t\\tfontweight: 'normal',\\n\\t\\t\\tfontvariant: 'normal',\\n\\t\\t\\ttextdecoration: 'none',\\n\\t\\t\\ttextanchor: 'middle'\\n\\t\\t},\\n\\n\\t\\tlegend: {\\n\\t\\t\\tposition: 'bottom',\\n\\t\\t\\tfontfamily: 'Arial',\\n\\t\\t\\tfontsize: '11',\\n\\t\\t\\tfontweight: 'normal',\\n\\t\\t\\tcolor: \\\"#000000\\\",\\n\\t\\t\\tstrokewidth: 0.15,\\n\\t\\t\\ttextmargin: 15,\\n\\t\\t\\tsymbolsize: 10,\\n\\t\\t\\tinactivecolor: '#DDD',\\n\\t\\t\\tlegendstart: 0,\\n\\t\\t\\tlegendtype: 'categories',\\n\\t\\t\\tshowlegends: true,\\n\\t\\t},\\n\\n\\t\\teffects: {\\n\\t\\t\\thovercolor: '#FF0000',\\n\\t\\t\\tstrokecolor: 'none',\\n\\t\\t\\ttextcolor: '#000000',\\n\\t\\t\\tduration: 800,\\n\\t\\t\\thover: 400,\\n\\t\\t\\tshowhovertext: false\\n\\t\\t}\\n\\t};\\n\\n\\tuv.constants = {};\\n\\n\\tuv.constants.classes = {\\n\\t\\tuv : 'uv',\\n\\t\\tpos : 'uv-div',\\n\\t\\tframe : 'uv-frame',\\n\\t\\tpanel : 'uv-panel',\\n\\t\\tbg : 'uv-chart-bg',\\n\\t\\tchart : 'uv-chart',\\n\\t\\taxes : 'uv-axes',\\n\\t\\tlegend : 'uv-legend',\\n\\t\\tframebg : 'uv-frame-bg',\\n\\t\\thoraxis : 'uv-hor-axis',\\n\\t\\tveraxis : 'uv-ver-axis',\\n\\t\\tcaption : 'uv-caption',\\n\\t\\tcaptiontext : 'uv-caption-text',\\n\\t\\tsubcaption : 'uv-subcaption',\\n\\t\\tsubcaptiontext : 'uv-subcaption-text',\\n\\t\\taxeslabelgroup : 'uv-axes-label-group',\\n\\t\\taxeslabel : 'uv-axes-label',\\n\\t\\taxessublabel : 'uv-axes-sub-label',\\n\\t\\tlegendsign : 'uv-legend-sign',\\n\\t\\tlegendlabel : 'uv-legend-label',\\n\\t\\thoverbg : 'uv-hover-bg',\\n\\t\\tarc : 'uv-arc-',\\n\\t\\tareapath : 'uv-areapath-',\\n\\t\\tlinepath :'uv-linepath-',\\n\\t\\tarea : 'uv-area-',\\n\\t\\tline : 'uv-line-',\\n\\t\\tdot : 'uv-dot',\\n\\t\\tchartdiv : 'uv-chart-div',\\n\\t\\tcircleticks : 'circle-ticks',\\n\\t\\tdownload : 'uv-download-options'\\n\\t};\\n\\n\\tuv.constants.downloads = {\\n\\t\\tdownloadLabel: 'Download'\\n\\t};\\n\\n\\tuv.types = {};\\n\\n\\tuv.addChart = function ( type, functionName ) {\\n\\t\\tuv.types[type] = functionName;\\n\\t};\\n\\n\\tuv.addChart( 'bar','BarGraph' );\\n\\tuv.addChart( 'line','LineGraph' );\\n\\tuv.addChart( 'stackedbar','StackedBarGraph' );\\n\\tuv.addChart( 'stepupbar','StepUpBarGraph' );\\n\\tuv.addChart( 'area','AreaGraph' );\\n\\tuv.addChart( 'stackedarea','StackedAreaGraph' );\\n\\tuv.addChart( 'percentbar','PercentBarGraph' );\\n\\tuv.addChart( 'percentarea','PercentAreaGraph' );\\n\\tuv.addChart( 'pie','PieGraph' );\\n\\tuv.addChart( 'donut','DonutGraph' );\\n\\tuv.addChart( 'waterfall','WaterfallGraph' );\\n\\tuv.addChart( 'polararea','PolarAreaGraph' );\\n\\n\\tuv.chart = function ( type, graphdef, config ) {\\n\\t\\ttype = type.toLowerCase()\\n\\t\\tif ( uv.types[type] !== undefined ) {\\n\\t\\t\\treturn new uv[uv.types[type]]( graphdef, config );\\n\\t\\t}\\n\\t};\\n\\n\\tuv.effects = {};\\n\\n\\tuv.effects.bar = {};\\n\\tuv.effects.bar.mouseover = function ( graph, idx ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx],\\n\\t\\t\\tlabel = graph.labels[idx];\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( 'rect.cr-' + uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', config.effects.hovercolor )\\n\\t\\t\\t\\t.style( 'stroke', config.effects.strokecolor );\\n\\n\\t\\t\\tif( config.effects.showhovertext ){\\n\\t\\t\\t\\tgraph.frame.selectAll( 'text.cr-' + uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t\\t.style( 'fill', config.effects.textcolor )\\n\\t\\t\\t\\t\\t.style( 'opacity', 1 );\\n\\t\\t\\t}\\n\\t\\t};\\n\\n\\t\\tif( config.legend.legendtype === 'categories' ){\\n\\t\\t\\tgraph.effects[category].mouseover = effect;\\n\\t\\t}else{\\n\\t\\t\\tgraph.effects[label].mouseover = effect;\\n\\t\\t}\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.bar.mouseout = function ( graph, idx, defColor ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx],\\n\\t\\t\\tbarColor = uv.util.getColorBand( graph.config, idx ),\\n\\t\\t\\ttextColor = defColor || uv.util.getColorBand( graph.config, idx ),\\n\\t\\t\\tlabel = graph.labels[idx];\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( 'rect.cr-' + uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', barColor )\\n\\t\\t\\t\\t.style( 'stroke', 'none' );\\n\\n\\t\\t\\tgraph.frame.selectAll( 'text.cr-' + uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', graph.config.label.showlabel ? textColor : 'none' );\\n\\t\\t};\\n\\n\\t\\tif( config.legend.legendtype === 'categories' ){\\n\\t\\t\\tgraph.effects[category].mouseout = effect;\\n\\t\\t}else{\\n\\t\\t\\tgraph.effects[label].mouseout = effect;\\n\\t\\t}\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.area = {};\\n\\tuv.effects.area.mouseover = function ( graph, idx ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx];\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).select( 'path.' + uv.constants.classes.area + uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill',config.effects.hovercolor );\\n\\t\\t};\\n\\n\\t\\tgraph.effects[category].mouseover = effect;\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.area.mouseout = function ( graph, idx ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx];\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( '.cge-'+ uv.util.formatClassName( category ) ).select( 'path.'+ uv.constants.classes.area + uv.util.formatClassName( category ) );\\n\\t\\t\\tgraph.frame.selectAll( '.cge-'+uv.util.formatClassName( category ) ).select( 'path.' + uv.constants.classes.area +uv.util.formatClassName( category ) )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill',uv.util.getColorBand( config,idx ) );\\n\\t\\t};\\n\\n\\t\\tgraph.effects[category].mouseout = effect;\\n\\t\\treturn effect;\\n\\t};\\n\\n\\n\\tuv.effects.line = {};\\n\\tuv.effects.line.mouseover = function ( graph, idx ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx];\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).selectAll( 'circle' )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', config.effects.hovercolor )\\n\\t\\t\\t\\t.style( 'fill-opacity', 1 )\\n\\t\\t\\t\\t.style( 'stroke', config.effects.hovercolor );\\n\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).select( 'path' )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'stroke', config.effects.hovercolor );\\n\\n\\t\\t\\tif( config.effects.showhovertext ){\\n\\t\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).selectAll( 'text' )\\n\\t\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t\\t.style( 'fill', config.effects.textcolor );\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\tgraph.effects[category].mouseover = effect;\\n\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.line.mouseout = function ( graph, idx, defColor ) {\\n\\t\\tvar config = graph.config,\\n\\t\\t\\tcategory = graph.categories[idx],\\n\\t\\t\\tcolor = defColor || uv.util.getColorBand( graph.config, idx );\\n\\n\\t\\tvar effect = function () {\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).selectAll( 'circle' )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t\\t.style( 'fill-opacity', 0.6 )\\n\\t\\t\\t\\t.style( 'stroke', '#fff' );\\n\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).select( 'path' )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'stroke', color );\\n\\n\\t\\t\\tgraph.frame.selectAll( '.cge-' + uv.util.formatClassName( category ) ).selectAll( 'text' )\\n\\t\\t\\t\\t.transition().duration( config.effects.hover )\\n\\t\\t\\t\\t.style( 'fill', graph.config.label.showlabel ? color : 'none' );\\n\\n\\t\\t};\\n\\t\\tgraph.effects[category].mouseout = effect;\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.caption = {};\\n\\tuv.effects.caption.mouseover = function ( config ) {\\n\\t\\treturn function () {\\n\\t\\t\\td3.select( this.parentNode.parentNode ).select( '.' + uv.constants.classes.hoverbg )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.style( 'fill', config.caption.hovercolor );\\n\\t\\t};\\n\\t};\\n\\n\\tuv.effects.caption.mouseout = function ( config ) {\\n\\t\\treturn function () {\\n\\t\\t\\td3.select( this.parentNode.parentNode ).select( '.' + uv.constants.classes.hoverbg )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.style( 'fill', config.graph.bgcolor );\\n\\t\\t};\\n\\t};\\n\\n\\tuv.effects.donut = {};\\n\\tuv.effects.donut.mouseover = function ( center, arcfunc, config, d ) {\\n\\t\\treturn function ( d ) {\\n\\t\\t\\tvar dev = {\\n\\t\\t\\t\\tx : arcfunc.centroid( d )[0] / 5,\\n\\t\\t\\t\\ty : arcfunc.centroid( d )[1] / 5\\n\\t\\t\\t};\\n\\n\\t\\t\\td3.select( this.parentNode )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.attr( 'transform', 'translate(' + ( center.x + dev.x ) + ',' + ( center.y + dev.y ) + ')' );\\n\\t\\t};\\n\\t};\\n\\n\\tuv.effects.donut.mouseout = function ( center, config ) {\\n\\t\\treturn function () {\\n\\t\\t\\td3.select( this.parentNode )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.attr( 'transform', 'translate(' + center.x + ',' + center.y + ')' );\\n\\t\\t};\\n\\t};\\n\\n\\tuv.effects.pie = {};\\n\\tuv.effects.pie.mouseover = function ( graph ,center, arcfunc, config ) {\\n\\t\\tvar effect =  function ( d ) {\\n\\t\\t\\tvar dev = {\\n\\t\\t\\t\\tx : arcfunc.centroid( d )[0] / 5,\\n\\t\\t\\t\\ty : arcfunc.centroid( d )[1] / 5\\n\\t\\t\\t};\\n\\t\\t\\td3.select( this.parentNode )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.attr( 'transform', 'translate(' + ( center.x + dev.x ) + ',' + ( center.y + dev.y ) + ')' );\\n\\t\\t};\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.pie.mouseout = function ( graph, center, config ) {\\n\\t\\tvar effect =  function () {\\n\\t\\t\\td3.select( this.parentNode )\\n\\t\\t\\t\\t.transition().duration( config.effects.duration )\\n\\t\\t\\t\\t.attr( 'transform', 'translate(' + center.x + ',' + center.y + ')' );\\n\\t\\t};\\n\\t\\treturn effect;\\n\\t};\\n\\n\\tuv.effects.legend = {};\\n\\tuv.effects.legend.mouseover = function ( self, idx ) {\\n\\t\\tif( self.config.legend.legendtype === 'categories' ){\\n\\t\\t\\treturn self.effects.group[self.categories[idx]].mouseover;\\n\\t\\t}else{\\n\\t\\t\\treturn self.effects.group[self.labels[idx]].mouseover;\\n\\t\\t}\\n\\t};\\n\\n\\tuv.effects.legend.mouseout = function ( self, idx ) {\\n\\t\\tif( self.config.legend.legendtype === 'categories' ){\\n\\t\\t\\treturn self.effects.group[self.categories[idx]].mouseout;\\n\\t\\t}else{\\n\\t\\t\\treturn self.effects.group[self.labels[idx]].mouseout;\\n\\t\\t}\\n\\t};\\n\\n\\tuv.effects.legend.click = function ( i, ctx, graph ) {\\n\\t\\tvar disabled = ( d3.select( ctx ).attr( 'disabled' ) === 'false' ) ? false : true;\\n\\t\\tgraph.toggleGraphGroup( i );\\n\\t\\td3.select( ctx ).select( 'rect' ).style( 'fill', disabled ? uv.util.getColorBand( graph.config, i ) : uv.config.legend.inactivecolor );\\n\\t\\td3.select( ctx ).select( 'text' ).style( 'fill', disabled ? null : uv.config.legend.inactivecolor );\\n\\t\\td3.select( ctx ).attr( 'disabled', disabled ? 'false' : 'true' );\\n\\t};\\n\\n\\tuv.palette = {\\n\\t\\t'Default': ['#00BBC9', '#EC63AB', '#AA8AE4', '#83CE44', '#ff8f25', '#009EAA', '#CA4F7F', '#9C70C0', '#6BAF3B'],\\n\\t\\t'OldDefault' : ['#7E6DA1', '#C2CF30', '#FF8900', '#FE2600', '#E3003F', '#8E1E5F', '#FE2AC2', '#CCF030', '#9900EC', '#3A1AA8', '#3932FE', '#3276FF', '#35B9F6', '#42BC6A', '#91E0CB'],\\n\\t\\t'Plain' : ['#B1EB68', '#B1B9B5', '#FFA16C', '#9B64E7', '#CEE113', '#2F9CFA', '#CA6877', '#EC3D8C', '#9CC66D', '#C73640', '#7D9532', '#B064DC' ],\\n\\t\\t'Android' : ['#33B5E5', '#AA66CC', '#99CC00', '#FFBB33', '#FF4444', '#0099CC', '#9933CC', '#669900', '#FF8800', '#CC0000'],\\n\\t\\t'Soft' : [ '#9ED8D2', '#FFD478', '#F16D9A', '#A8D59D', '#FDC180', '#F05133', '#EDED8A', '#F6A0A5', '#9F218B' ],\\n\\t\\t'Simple' : [ '#FF8181', '#FFB081', '#FFE081', '#EFFF81', '#BFFF81', '#90FF81', '#81FFA2', '#81FFD1', '#9681FF', '#C281FF', '#FF81DD' ],\\n\\t\\t'Egypt' : [ '#3A3E04','#784818','#FCFCA8','#C03C0C','#F0A830','#A8783C','#FCFCFC','#FCE460','#540C00','#C0C084','#3C303C','#1EA34A','#606C54','#F06048' ],\\n\\t\\t'Olive' : [ '#18240C','#3C6C18','#60A824','#90D824','#A8CC60','#789C60','#CCF030','#B4CCA8','#D8F078','#40190D','#E4F0CC' ],\\n\\t\\t'Candid' : [ '#AF5E14','#81400C','#E5785D','#FEBFBF','#A66363','#C7B752','#EFF1A7','#83ADB7','#528F98','#BCEDF5','#446B3D','#8BD96F','#E4FFB9' ],\\n\\t\\t'Sulphide' : [ '#594440','#0392A7','#FFC343','#E2492F','#007257','#B0BC4A','#2E5493','#7C2738','#FF538B','#A593A1','#EBBA86','#E2D9CA' ],\\n\\t\\t'Lint' : ['#A8A878','#F0D89C','#60909C','#242418','#E49C30','#54483C','#306090','#C06C00','#C0C0C0','#847854','#6C3C00','#9C3C3C','#183C60','#FCCC00','#840000','#FCFCFC']\\n\\t};\\n\\n\\t/**\\n* uv.Graph is an abstract class of sorts which serves as the base for all other graphs. Instances of it wouldnt be anything except bare bones needed to create a chart.\\n* id          - unique id corresponding to the graph, created using current timestamp {#TODO: needs improved logic}\\n* graphdef    - definition of the graph, containing data on which the visualization is built\\n* config      - configuration of the graph, affecting the visual styling of the graph\\n* frame      - <svg> element acting as the parent graph container\\n* panel      - <g> element containing everything else, making it easier to move all elements across the svg\\n* bg          - <rect> element which acts as the background for the graph\\n* effects    - object containing functions which cause the various interactions on the graph\\n* labels      - labels from the dataset provided\\n* categories  - categories from the dataset provided\\n* axes        - object containing axes related stuff: group, func, scale, axis, line, label\\n*\\n*/\\n\\tuv.Graph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tself.id = uv.util.getUniqueId();\\n\\t\\tself.graphdef = null;\\n\\t\\tself.config = null;\\n\\n\\t\\tself.frame = null;\\n\\t\\tself.panel = null;\\n\\t\\tself.chart = null;\\n\\t\\tself.bg = null;\\n\\t\\tself.effects = {};\\n\\t\\tself.axes = {\\n\\t\\t\\thor: { group: null, scale : null, func: null, axis : null, line : null, label : null },\\n\\t\\t\\tver: { group: null, scale : null, func: null, axis : null, line : null, label : null },\\n\\t\\t\\tmeta: { min: null, max: null }\\n\\t\\t};\\n\\n\\t\\tself.labels = null;\\n\\t\\tself.categories = null;\\n\\n\\t\\tself.graphdef = graphdef;\\n\\t\\tself.config = uv.util.extend( {}, uv.config, config );\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* As the name suggests, this function initializes graph object construction based on the config and graphdef\\n* @param  {Object} graphdef Definition of the graph, take a look at constants.js for complete documentation\\n* @param  {Object} config   Configuration of the graph, take a look at config.js for complete documentation\\n* @return {Object}          The graph object itself, to support method chaining\\n*\\n* #TODO: Remove dependency on jQuery/$\\n*/\\n\\tuv.Graph.prototype.init = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.max()\\n\\t\\t\\t.min()\\n\\t\\t\\t.position( self.config.meta.position || 'body' )\\n\\t\\t\\t.setDimensions()\\n\\t\\t\\t.setFrame()\\n\\t\\t\\t.setPanel()\\n\\t\\t\\t.setBackground()\\n\\t\\t\\t.setCaption()\\n\\t\\t\\t.setSubCaption()\\n\\t\\t\\t.setMetadata()\\n\\t\\t\\t.setHorizontalAxis()\\n\\t\\t\\t.setVerticalAxis()\\n\\t\\t\\t.setEffectsObject();\\n\\n\\t\\tif( self.config.meta.isDownloadable ){\\n\\t\\t\\tself.setDownloadOptions();\\n\\t\\t}\\n\\t\\tif( self.config.legend.showlegends ){\\n\\t\\t\\tself.setLegend();\\n\\t\\t}\\n\\n\\t\\treturn self;\\n\\t};\\n\\n\\t/**\\n* Sets the dimensions of the graphs, namely height, width and margins: left, right, top and bottom\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setDimensions = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.height( self.config.dimension.height )\\n\\t\\t\\t.width( self.config.dimension.width )\\n\\t\\t\\t.top( self.config.margin.top )\\n\\t\\t\\t.bottom( self.config.margin.bottom )\\n\\t\\t\\t.left( self.config.margin.left )\\n\\t\\t\\t.right( self.config.margin.right );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* This function downloads the graph in png format.\\n*\\n*/\\n\\tuv.Graph.prototype.setDownloadOptions = function () {\\n\\t\\tif ( uv.util.isDownloadSupported() ) {\\n\\t\\t\\tvar self = this;\\n\\t\\t\\tself.download = self.panel.append( 'g' ).classed( uv.constants.classes.download, true );\\n\\t\\t\\tself.download.append( 'text' ).classed( uv.constants.classes.download, true )\\n\\t\\t\\t\\t.text( self.config.meta.downloadLabel )\\n\\t\\t\\t\\t.attr( 'y', -self.config.margin.top / 2 )\\n\\t\\t\\t\\t.attr( 'x', self.config.dimension.width-25 )\\n\\t\\t\\t\\t.attr( 'text-anchor', self.config.caption.textanchor )\\n\\t\\t\\t\\t.style( 'font-family', self.config.caption.fontfamily )\\n\\t\\t\\t\\t.style( 'font-size', '12' )\\n\\t\\t\\t\\t.style( 'cursor', self.config.caption.cursor )\\n\\t\\t\\t\\t.style( 'stroke', self.config.caption.strokecolor )\\n\\t\\t\\t\\t.style( 'text-decoration', 'underline' )\\n\\t\\t\\t\\t.on( 'mouseover', function() {\\n\\t\\t\\t\\t\\tvar dnldBtn = d3.select( this );\\n\\t\\t\\t\\t\\tdnldBtn.style( 'color','#0000FF' );\\n\\t\\t\\t\\t} )\\n\\t\\t\\t\\t.on( 'mouseout', function() {\\n\\t\\t\\t\\t\\tvar dnldBtn = d3.select( this );\\n\\t\\t\\t\\t\\tdnldBtn.style( 'color','#8D8D8D' );\\n\\t\\t\\t\\t} )\\n\\t\\t\\t\\t.on( 'click', function () {\\n\\t\\t\\t\\t\\tvar dnldBtn = d3.select( this );\\n\\t\\t\\t\\t\\tdnldBtn.style( 'display','none' );\\n\\t\\t\\t\\t\\tuv.util.svgToPng( self, function() {\\n\\t\\t\\t\\t\\t\\tdnldBtn.style( 'display',null );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t} );\\n\\t\\t}\\n\\t};\\n\\n\\n\\t/**\\n* Sets the main <svg> element which contains rest of the graph elements\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setFrame = function () {\\n\\t\\tvar self = this;\\n\\t\\tif ( !self.frame ) {\\n\\t\\t\\tself.frame = d3.select( self.position() || 'body' ).append( 'div' )\\n\\t\\t\\t\\t.classed( uv.constants.classes.chartdiv, true )\\n\\t\\t\\t\\t.style( 'display','inline-block' )\\n\\t\\t\\t\\t.style( 'width', '100%' )\\n\\t\\t\\t\\t.style( 'height', '100%' )\\n\\t\\t\\t\\t.append( 'svg' );\\n\\t\\t}\\n\\n\\t\\tself.frame.attr( 'id', uv.constants.classes.uv + '-' + self.id )\\n\\t\\t\\t.classed( uv.constants.classes.frame, true );\\n\\n\\t\\tif ( self.config.graph.responsive === true ) {\\n\\t\\t\\tself.frame.attr( 'width', '100%' )\\n\\t\\t\\t\\t.attr( 'height', '100%' )\\n\\t\\t\\t\\t.attr( 'preserveAspectRatio', self.config.graph.align + ' ' + self.config.graph.meetOrSlice )\\n\\t\\t\\t\\t.attr( 'viewBox', '0 0 ' + ( self.width() + self.left() + self.right() ) + ' ' + ( self.height() + self.top() + self.bottom() ) );\\n\\t\\t} else {\\n\\t\\t\\tself.frame.attr( 'width', self.width() + self.left() + self.right() )\\n\\t\\t\\t\\t.attr( 'height', self.height() + self.top() + self.bottom() );\\n\\t\\t}\\n\\n\\t\\tself.frame.append( 'rect' ).classed( uv.constants.classes.framebg, true )\\n\\t\\t\\t.attr( 'width', self.width() + self.left() + self.right() )\\n\\t\\t\\t.attr( 'height', self.height() + self.top() + self.bottom() )\\n\\t\\t\\t.style( 'fill', self.config.frame.bgcolor );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the <g> element which serves as the base position for the graph elements\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setPanel = function () {\\n\\t\\tvar self = this;\\n\\t\\tif ( !self.panel ) {\\n\\t\\t\\tself.panel = self.frame.append( 'g' );\\n\\t\\t}\\n\\n\\t\\tself.panel.attr( 'id', uv.constants.classes.panel + '-' + self.id )\\n\\t\\t\\t.classed( uv.constants.classes.panel, true )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.left() + ',' + self.top() + ')' );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the <rect> element which serves as the background for the chart\\n* @param {String} color Color code for the background, set to config value if not specified\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setBackground = function ( color ) {\\n\\t\\tvar self = this;\\n\\t\\tif ( !self.bg ) {\\n\\t\\t\\tself.bg = self.panel.append( 'rect' ).classed( uv.constants.classes.bg, true )\\n\\t\\t\\t\\t.attr( 'height', self.height() )\\n\\t\\t\\t\\t.attr( 'width', self.width() );\\n\\t\\t}\\n\\t\\tself.bg.style( 'fill', color || self.config.graph.bgcolor );\\n\\n\\t\\tself.chart = self.panel.append( 'g' ).classed( uv.constants.classes.chart, true )\\n\\t\\t\\t.style( 'opacity', self.config.graph.opacity );\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the caption for the graph\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setCaption = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.caption = self.panel.append( 'g' ).classed( uv.constants.classes.caption, true );\\n\\n\\t\\tself.caption.append( 'text' ).classed( uv.constants.classes.captiontext, true )\\n\\t\\t\\t.text( self.config.meta.caption )\\n\\t\\t\\t.attr( 'y', -self.config.margin.top / 2 )\\n\\t\\t\\t.attr( 'x', self.config.dimension.width / 2 )\\n\\t\\t\\t.attr( 'text-anchor', self.config.caption.textanchor )\\n\\t\\t\\t.style( 'font-family', self.config.caption.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.caption.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.caption.fontweight )\\n\\t\\t\\t.style( 'font-variant', self.config.caption.fontvariant )\\n\\t\\t\\t.style( 'text-decoration', self.config.caption.textdecoration )\\n\\t\\t\\t.on( 'mouseover', uv.effects.caption.mouseover( self.config ) )\\n\\t\\t\\t.on( 'mouseout', uv.effects.caption.mouseout( self.config ) );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\n\\t/**\\n* Sets the subcaption for the graph\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setSubCaption = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.subCaption = self.panel.append( 'g' ).classed( uv.constants.classes.subcaption, true );\\n\\n\\t\\tself.subCaption.append( 'text' ).classed( uv.constants.classes.subcaptiontext, true )\\n\\t\\t\\t.text( self.config.meta.subcaption )\\n\\t\\t\\t.attr( 'y', -self.config.margin.top / 2 + 1*self.config.caption.fontsize )\\n\\t\\t\\t.attr( 'x', self.config.dimension.width / 2 )\\n\\t\\t\\t.attr( 'text-anchor', self.config.caption.textanchor )\\n\\t\\t\\t.style( 'font-family', self.config.subCaption.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.subCaption.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.subCaption.fontweight )\\n\\t\\t\\t.style( 'font-variant', self.config.subCaption.fontvariant )\\n\\t\\t\\t.style( 'text-decoration', self.config.subCaption.textdecoration );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\n\\t/**\\n* Sets the metadata for the graph, this includes the labels and the categories\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setMetadata = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.labels = uv.util.getLabelArray( self.graphdef );\\n\\t\\tself.categories = uv.util.getCategoryArray( self.graphdef );\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the Horizontal Axis functions but doesnt render it yet\\n* return {Object}      The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setHorizontalAxis = function () {\\n\\t\\tvar self = this;\\n\\t\\tvar graphdef = self.graphdef;\\n\\t\\tif ( !self.axes.hor.group ) {\\n\\t\\t\\tself.axes.hor.group = self.panel.append( 'g' ).classed( uv.constants.classes.horaxis, true )\\n\\t\\t\\t\\t.attr( 'transform', 'translate(0,' + self.height() + ')' )\\n\\t\\t\\t\\t.style( 'shape-rendering','crispEdges' );\\n\\t\\t}\\n\\n\\t\\tif ( self.config.graph.orientation === 'Horizontal' ) {\\n\\t\\t\\tself.axes.hor.scale  = d3.scale[self.config.scale.type]()\\n\\t\\t\\t\\t.domain( [self.config.scale.type === 'log' ? 1: self.min(), self.max()] )\\n\\t\\t\\t\\t.range( [0, self.width()] );\\n\\n\\t\\t\\tif ( self.axes.hor.scale.nice ) {\\n\\t\\t\\t\\tself.axes.hor.scale.nice();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( !self.config.axis.showsubticks ){\\n\\t\\t\\t\\tself.config.axis.subticks = 0;\\n\\t\\t\\t}\\n\\t\\t\\tself.axes.hor.func = d3.svg.axis()\\n\\t\\t\\t\\t.scale( self.axes.hor.scale )\\n\\t\\t\\t\\t.ticks( self.config.axis.ticks )\\n\\t\\t\\t\\t.tickSize( -self.height(), self.config.axis.minor, 0 )\\n\\t\\t\\t\\t.tickPadding( self.config.axis.padding )\\n\\t\\t\\t\\t.tickSubdivide( self.config.axis.subticks )\\n\\t\\t\\t\\t.orient( 'bottom' );\\n\\n\\t\\t} else {\\n\\t\\t\\tself.axes.hor.scale = d3.scale.ordinal()\\n\\t\\t\\t\\t.rangeRoundBands( [0, self.width()], self.config.scale.ordinality );\\n\\n\\t\\t\\tself.axes.hor.func = d3.svg.axis()\\n\\t\\t\\t\\t.scale( self.axes.hor.scale )\\n\\t\\t\\t\\t.tickPadding( self.config.axis.padding )\\n\\t\\t\\t\\t.orient( 'bottom' );\\n\\n\\t\\t\\tif( !self.config.axis.showtext || !self.config.axis.showhortext ) {\\n\\t\\t\\t\\tself.axes.hor.func.tickSize( 0 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif( !self.config.axis.showtext || !self.config.axis.showhortext ) {\\n\\t\\t\\tself.axes.hor.func.tickFormat( function ( d ) { return ''; } );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the Vertical axis functions, but doesnt render it yet\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setVerticalAxis = function () {\\n\\t\\tvar self = this;\\n\\t\\tvar graphdef = self.graphdef;\\n\\t\\tif ( !self.axes.ver.group ) {\\n\\t\\t\\tself.axes.ver.group = self.panel.append( 'g' ).classed( uv.constants.classes.veraxis, true )\\n\\t\\t\\t\\t.style( 'shape-rendering','crispEdges' );\\n\\t\\t}\\n\\n\\t\\tif ( self.config.graph.orientation === 'Vertical' ) {\\n\\t\\t\\tself.axes.ver.scale  = d3.scale[self.config.scale.type]()\\n\\t\\t\\t\\t.domain( [self.max(), self.config.scale.type === 'log' ? 1 : self.min()] )\\n\\t\\t\\t\\t.range( [0, self.height()] );\\n\\n\\t\\t\\tif ( self.axes.ver.scale.nice ) {\\n\\t\\t\\t\\tself.axes.ver.scale.nice();\\n\\t\\t\\t}\\n\\n\\t\\t\\tif( !self.config.axis.showsubticks ){\\n\\t\\t\\t\\tself.config.axis.subticks = 0;\\n\\t\\t\\t}\\n\\t\\t\\tself.axes.ver.func = d3.svg.axis()\\n\\t\\t\\t\\t.scale( self.axes.ver.scale )\\n\\t\\t\\t\\t.ticks( self.config.axis.ticks )\\n\\t\\t\\t\\t.tickSize( -self.width(), self.config.axis.minor, 0 )\\n\\t\\t\\t\\t.tickPadding( self.config.axis.padding )\\n\\t\\t\\t\\t.tickSubdivide( self.config.axis.subticks )\\n\\t\\t\\t\\t.orient( 'left' );\\n\\n\\n\\t\\t} else {\\n\\t\\t\\tself.axes.ver.scale = d3.scale.ordinal()\\n\\t\\t\\t\\t.rangeRoundBands( [0, self.height()], self.config.scale.ordinality );\\n\\n\\t\\t\\tself.axes.ver.func = d3.svg.axis()\\n\\t\\t\\t\\t.scale( self.axes.ver.scale )\\n\\t\\t\\t\\t.tickPadding( self.config.axis.padding )\\n\\t\\t\\t\\t.orient( 'left' );\\n\\n\\t\\t\\tif( !self.config.axis.showtext || !self.config.axis.showvertext ){\\n\\t\\t\\t\\tself.axes.ver.func.tickSize( 0 );\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tif( !self.config.axis.showtext || !self.config.axis.showvertext ) {\\n\\t\\t\\tself.axes.ver.func.tickFormat( function ( d ) { return ''; } );\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Creates placeholders for functions which cause the various animations across the graph to be able invoke it from other places\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setEffectsObject = function () {\\n\\t\\tvar self = this;\\n\\t\\tvar effectArray = ( self.config.legend.legendtype === 'categories' ) ? self.categories : self.labels;\\n\\t\\tfor ( var i = 0; i < effectArray.length ; i++ ) {\\n\\t\\t\\tself.effects[effectArray[i]] = {};\\n\\t\\t}\\n\\t\\treturn self;\\n\\t};\\n\\n\\t/**\\n* Draws the horizontal axis within the frame based on the orientation and functions already created\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.drawHorizontalAxis = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.axes.hor.axis = self.axes.hor.group.append( 'g' )\\n\\t\\t\\t.style( 'font-family', self.config.label.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.label.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.label.fontweight )\\n\\t\\t\\t.call( self.axes.hor.func );\\n\\n\\t\\tif ( self.config.axis.showticks ) {\\n\\t\\t\\tself.axes.hor.axis.selectAll( 'line' ).style( 'stroke', self.config.axis.strokecolor )\\n\\t\\t\\t\\t.style( 'opacity', self.config.axis.opacity );\\n\\t\\t}\\n\\t\\tself.axes.hor.axis.selectAll( 'path' ).style( 'fill','none' );\\n\\n\\t\\tself.axes.hor.line = self.panel.append( 'line' )\\n\\t\\t\\t.classed( uv.constants.classes.horaxis, true )\\n\\t\\t\\t.attr( 'y1', self.config.graph.orientation === 'Horizontal' ? self.height() : self.axes.ver.scale( 0 ) )\\n\\t\\t\\t.attr( 'y2', self.config.graph.orientation === 'Horizontal' ? self.height() : self.axes.ver.scale( 0 ) )\\n\\t\\t\\t.attr( 'x1', '0' )\\n\\t\\t\\t.attr( 'x2', self.width() )\\n\\t\\t\\t.style( 'stroke', self.config.axis.strokecolor );\\n\\n\\t\\tself.axes.hor.label = self.axes.hor.group.append( 'g' )\\n\\t\\t\\t.classed( uv.constants.classes.axeslabelgroup, true )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.width()/2 + ',' + ( 1*self.config.margin.bottom/4 + 1*self.config.label.fontsize ) + ')' );\\n\\n\\t\\tself.axes.hor.label.append( 'text' )\\n\\t\\t\\t.attr( 'display','block' )\\n\\t\\t\\t.classed( uv.constants.classes.axeslabel, true ).classed( 'cal', true )\\n\\t\\t\\t.attr( 'text-anchor','middle' )\\n\\t\\t\\t.style( 'font-size', self.config.axis.fontsize )\\n\\t\\t\\t.style( 'font-family', self.config.axis.fontfamily )\\n\\t\\t\\t.text( self.config.meta.hlabel );\\n\\n\\t\\tself.axes.hor.label.append( 'text' )\\n\\t\\t\\t.attr( 'display','block' )\\n\\t\\t\\t.attr( 'y', 1*self.config.axis.fontsize )\\n\\t\\t\\t.attr( uv.constants.classes.axessublabel, true ).classed( 'casl', true )\\n\\t\\t\\t.attr( 'text-anchor','middle' )\\n\\t\\t\\t.style( 'font-size', self.config.axis.fontsize - 2 )\\n\\t\\t\\t.style( 'font-family', self.config.axis.fontfamily )\\n\\t\\t\\t.text( self.config.meta.hsublabel );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Draws the vertical axis within the frame based on the orientation and functions already created\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.drawVerticalAxis = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.axes.ver.axis = self.axes.ver.group.append( 'g' )\\n\\t\\t\\t.classed( uv.constants.classes.axes, true )\\n\\t\\t\\t.style( 'font-family', self.config.label.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.label.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.label.fontweight )\\n\\t\\t\\t.call( self.axes.ver.func );\\n\\n\\t\\tif ( self.config.axis.showticks ) {\\n\\t\\t\\tself.axes.ver.axis.selectAll( 'line' ).style( 'stroke', self.config.axis.strokecolor )\\n\\t\\t\\t\\t.style( 'opacity', self.config.axis.opacity );\\n\\t\\t}\\n\\t\\tself.axes.ver.axis.selectAll( 'path' ).style( 'fill','none' );\\n\\n\\t\\tself.axes.ver.line = self.panel.append( 'line' )\\n\\t\\t\\t.classed( uv.constants.classes.veraxis, true )\\n\\t\\t\\t.attr( 'x1', self.config.graph.orientation === 'Horizontal'? self.axes.hor.scale( 0 ): 0 )\\n\\t\\t\\t.attr( 'x2', self.config.graph.orientation === 'Horizontal'? self.axes.hor.scale( 0 ): 0 )\\n\\t\\t\\t.attr( 'y1', 0 )\\n\\t\\t\\t.attr( 'y2', self.height() )\\n\\t\\t\\t.style( 'stroke', self.config.axis.strokecolor );\\n\\n\\t\\tself.axes.ver.label = self.axes.ver.group.append( 'g' )\\n\\t\\t\\t.attr( 'transform', 'translate(' + -4*self.config.margin.left/5 + ',' + self.height()/2 + ')rotate(270)' );\\n\\n\\t\\tself.axes.ver.label.append( 'text' ).classed( uv.constants.classes.axeslabel, true )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cal', true )\\n\\t\\t\\t.style( 'font-family', self.config.axis.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.axis.fontsize )\\n\\t\\t\\t.text( self.config.meta.vlabel );\\n\\n\\t\\tself.axes.ver.label.append( 'text' ).classed( uv.constants.classes.axessublabel, true )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.attr( 'y', +self.config.axis.fontsize )\\n\\t\\t\\t.classed( 'casl', true )\\n\\t\\t\\t.style( 'font-family', self.config.axis.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.axis.fontsize - 2 )\\n\\t\\t\\t.text( self.config.meta.vsublabel );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Sets the legend and related interactions for the graph based on the configuration\\n* @return {Object}  The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.setLegend = function () {\\n\\t\\tvar self = this;\\n\\n\\t\\tvar legendgroup = self.panel.append( 'g' ).classed( uv.constants.classes.legend, true )\\n\\t\\t\\t.attr( 'transform', function( d, i ){\\n\\t\\t\\t\\tif( self.config.legend.position === 'right' ){\\n\\t\\t\\t\\t\\treturn 'translate(' + self.width() + ', 10)';\\n\\t\\t\\t\\t}else if( self.config.legend.position === 'bottom' ){\\n\\t\\t\\t\\t\\tvar pos =  self.height() + self.config.margin.bottom/2 + Number( self.config.axis.fontsize );\\n\\t\\t\\t\\t\\treturn 'translate(0, ' + pos +  ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\n\\t\\tself.legends = legendgroup.selectAll( 'g' ).data(\\n\\t\\t\\t( self.config.legend.legendtype === 'categories' ) ? self.categories:self.labels\\n\\t\\t);\\n\\n\\n\\t\\tself.legends.enter().append( 'g' )\\n\\t\\t\\t.attr( 'transform', function ( d, i ) {\\n\\t\\t\\t\\tif( self.config.legend.position === 'right' ){\\n\\t\\t\\t\\t\\treturn 'translate(10,' + 10* ( 2* i - 1 ) + ')';\\n\\t\\t\\t\\t}else if( self.config.legend.position === 'bottom' ){\\n\\t\\t\\t\\t\\tvar hPos = 100*i - self.config.dimension.width*self.config.legend.legendstart;\\n\\t\\t\\t\\t\\tvar vPos = 20*self.config.legend.legendstart;\\n\\t\\t\\t\\t\\tif( hPos >= self.config.dimension.width ){\\n\\t\\t\\t\\t\\t\\tself.config.legend.legendstart = self.config.legend.legendstart + 1;\\n\\t\\t\\t\\t\\t\\thPos = 100*i - self.config.dimension.width*self.config.legend.legendstart;\\n\\t\\t\\t\\t\\t\\tvPos = 20*self.config.legend.legendstart;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn 'translate(' + hPos + ',' + vPos + ')';\\n\\t\\t\\t\\t}\\n\\t\\t\\t} )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\tvar className = ( self.config.legend.legendtype === 'categories' ) ? self.categories[i]:self.labels[i];\\n\\t\\t\\t\\treturn uv.util.getClassName( this, 'cl-' + className );\\n\\t\\t\\t} )\\n\\t\\t\\t.attr( 'disabled', 'false' )\\n\\t\\t\\t.on( 'mouseover', function ( d, i ) {\\n\\t\\t\\t\\tif ( self.effects[d].mouseover && typeof self.effects[d].mouseover === 'function' ) {\\n\\t\\t\\t\\t\\tself.effects[d].mouseover();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} )\\n\\t\\t\\t.on( 'mouseout', function ( d, i ) {\\n\\t\\t\\t\\tif ( self.effects[d].mouseout && typeof self.effects[d].mouseout === 'function' ) {\\n\\t\\t\\t\\t\\tself.effects[d].mouseout();\\n\\t\\t\\t\\t}\\n\\t\\t\\t} )\\n\\t\\t\\t.on( 'click', function ( d, i ) {\\n\\t\\t\\t\\tuv.effects.legend.click( i, this, self );\\n\\t\\t\\t} );\\n\\n\\t\\tself.legends.append( 'rect' ).classed( uv.constants.classes.legendsign, true )\\n\\t\\t\\t.attr( 'height', self.config.legend.symbolsize )\\n\\t\\t\\t.attr( 'width', self.config.legend.symbolsize )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( self.config, i ); } )\\n\\t\\t\\t.style( 'stroke', 'none' );\\n\\n\\t\\tself.legends.append( 'text' ).classed( uv.constants.classes.legendlabel, true )\\n\\t\\t\\t.text( function ( d, i ) { return ( self.config.legend.legendtype === 'categories' ) ? self.categories[i]:self.labels[i]; } )\\n\\t\\t\\t.attr( 'dx', self.config.legend.textmargin )\\n\\t\\t\\t.attr( 'dy', '.71em' )\\n\\t\\t\\t.attr( 'text-anchor', 'start' )\\n\\t\\t\\t.style( 'stroke', self.config.legend.color )\\n\\t\\t\\t.style( 'fill', self.config.legend.color )\\n\\t\\t\\t.style( 'stroke-width', self.config.legend.strokewidth )\\n\\t\\t\\t.style( 'font-family', self.config.legend.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.legend.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.legend.fontweight );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Finalizes stuff related to graph, used in conjuction with init to setup all the generic graph stuff\\n* @param  {Boolean} isLoggable Specifies whether the graph object should be logged or not, for debug purpose only\\n* @return {Object}             The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.finalize = function ( isLoggable ) {\\n\\t\\tvar self = this;\\n\\t\\tself.drawHorizontalAxis()\\n\\t\\t\\t.drawVerticalAxis();\\n\\t\\t//  .setLegend();\\n\\n\\t\\t// Cursor for text is unset from text to normal\\n\\t\\tself.frame.selectAll( 'text' ).style( 'cursor', 'default' );\\n\\n\\t\\t//Log Graph object if flag set to truthy value\\n\\t\\tif ( isLoggable ) {\\n\\t\\t\\tconsole.log( self );\\n\\t\\t}\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/*\\n* Functions to remove individual elements of an graph\\n*/\\n\\n\\t/**\\n* Removes the entire graph object\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.remove = function () {\\n\\t\\tthis.frame.remove();\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Removes the caption component of the graph\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.removeCaption = function () {\\n\\t\\tthis.caption.remove();\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/**\\n* Removes the legend component of the graph\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\n\\tuv.Graph.prototype.removeLegend = function () {\\n\\t\\tif ( this.legends[0] ) {\\n\\t\\t\\tthis.legends[0].parentNode.remove();\\n\\t\\t}\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.Graph.prototype.removePanel = function () {\\n\\t\\tthis.panel.remove();\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.Graph.prototype.removeHorAxis = function () {\\n\\t\\tthis.panel.selectAll( 'g.' + uv.constants.classes.horaxis + \\\" >*\\\" ).remove();\\n\\t\\tthis.panel.selectAll( 'line.' + uv.constants.classes.horaxis ).remove();\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.Graph.prototype.removeVerAxis = function () {\\n\\t\\tthis.panel.selectAll( 'g.' + uv.constants.classes.veraxis + \\\" >*\\\" ).remove();\\n\\t\\tthis.panel.selectAll( 'line.' + uv.constants.classes.veraxis ).remove();\\n\\t\\treturn this;\\n\\t};\\n\\n\\t/*\\n* Setters and getters for various common properties of the graph\\n*/\\n\\n\\tuv.Graph.prototype.width = function ( w ) {\\n\\t\\tif ( w ) {\\n\\t\\t\\tthis.config.dimension.width = w;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.dimension.width;\\n\\t};\\n\\n\\tuv.Graph.prototype.height = function ( h ) {\\n\\t\\tif ( h ) {\\n\\t\\t\\tthis.config.dimension.height = h;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.dimension.height;\\n\\t};\\n\\n\\tuv.Graph.prototype.top = function ( t ) {\\n\\t\\tif ( t ) {\\n\\t\\t\\tthis.config.margin.top = t;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.margin.top;\\n\\t};\\n\\n\\tuv.Graph.prototype.bottom = function ( b ) {\\n\\t\\tif ( b ) {\\n\\t\\t\\tthis.config.margin.bottom = b;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.margin.bottom;\\n\\t};\\n\\n\\tuv.Graph.prototype.left = function ( l ) {\\n\\t\\tif ( l ) {\\n\\t\\t\\tthis.config.margin.left = l;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.margin.left;\\n\\t};\\n\\n\\tuv.Graph.prototype.right = function ( r ) {\\n\\t\\tif ( r ) {\\n\\t\\t\\tthis.config.margin.right = r;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.margin.right;\\n\\t};\\n\\n\\tuv.Graph.prototype.position = function ( pos ) {\\n\\t\\tif ( pos ) {\\n\\t\\t\\tthis.config.meta.position = pos;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.meta.position;\\n\\t};\\n\\n\\tuv.Graph.prototype.caption = function ( caption ) {\\n\\t\\tif ( caption ) {\\n\\t\\t\\tthis.config.meta.caption = caption;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.meta.caption;\\n\\t};\\n\\n\\tuv.Graph.prototype.subCaption = function ( subCaption ) {\\n\\t\\tif ( subCaption ) {\\n\\t\\t\\tthis.config.meta.subCaption = subCaption;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.meta.caption;\\n\\t};\\n\\n\\tuv.Graph.prototype.isDownloadable = function ( isDownload ) {\\n\\t\\tif ( isDownload ) {\\n\\t\\t\\tthis.config.meta.isDownload = isDownload;\\n\\t\\t\\treturn this;\\n\\t\\t}\\n\\n\\t\\treturn this.config.meta.isDownload;\\n\\t};\\n\\n\\tuv.Graph.prototype.max = function () {\\n\\t\\tif ( this.axes.meta.max !== null ) {\\n\\t\\t\\treturn this.axes.meta.max;\\n\\t\\t}\\n\\n\\t\\tthis.axes.meta.max = uv.util.getMax( this.graphdef, this.graphdef.stepup );\\n\\t\\treturn this;\\n\\t}\\n\\n\\tuv.Graph.prototype.min = function () {\\n\\t\\tif ( this.axes.meta.min !== null ) {\\n\\t\\t\\treturn this.axes.meta.min;\\n\\t\\t}\\n\\n\\t\\tthis.axes.meta.min = uv.util.getMin( this.graphdef, this.graphdef.stepup );\\n\\t\\treturn this;\\n\\t}\\n\\n\\t/* Additional Graph functions*/\\n\\tuv.Graph.prototype.toggleGraphGroup = function ( i ) {\\n\\t\\tvar self = this, category = self.categories[i],\\n\\t\\t\\tstate = self.frame.select( 'g.cge-' + uv.util.formatClassName( category ) ).style( 'display' ),\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, i );\\n\\n\\t\\tself.frame.selectAll( 'g.cge-' + uv.util.formatClassName( category ) ).style( 'display', ( state === 'none' )? null : 'none' );\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.AreaGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.areagroups = [];\\n\\t\\tself.dataset = uv.util.getDataArray( self.graphdef );\\n\\n\\t\\tvar areagroup, areapath, areafunc, idx, len,\\n\\t\\t\\tdomainData = self.graphdef.dataset[self.graphdef.categories[0]];\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( domainData.map( function ( d ) { return d.name; } ) );\\n\\n\\t\\tfor ( idx = 0, len = self.dataset.length; idx < len; idx = idx + 1 ) {\\n\\t\\t\\tareapath = self.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t\\t.append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true ).datum( self.dataset[idx] );\\n\\t\\t\\tareagroup = { path: areapath, linefunc: undefined, areafunc: undefined, line: undefined, area: undefined };\\n\\t\\t\\tself['draw' + self.config.graph.orientation + 'Area']( areagroup, idx );\\n\\t\\t\\tself.areagroups.push( areagroup );\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.AreaGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.AreaGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.AreaGraph.prototype.drawHorizontalArea = function ( areagroup, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx );\\n\\n\\t\\tself.axes.ver.scale.rangePoints( [0, self.height()] );\\n\\n\\t\\tareagroup.linefunc = d3.svg.line()\\n\\t\\t\\t.x( function ( d ) { return self.axes.hor.scale( d.value ); } )\\n\\t\\t\\t.y( function ( d ) { return self.axes.ver.scale( d.name ) + self.axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t.interpolate( self.config.area.interpolation );\\n\\n\\t\\tareagroup.areafunc = d3.svg.area()\\n\\t\\t\\t.x0( self.axes.hor.scale( 0 ) )\\n\\t\\t\\t.x1( areagroup.linefunc.x() )\\n\\t\\t\\t.y( areagroup.linefunc.y() )\\n\\t\\t\\t.interpolate( self.config.area.interpolation );\\n\\n\\t\\tareagroup.area = areagroup.path.append( 'svg:path' )\\n\\t\\t\\t.classed( uv.constants.classes.areapath + idx, true )\\n\\t\\t\\t.attr( 'd', areagroup.areafunc )\\n\\t\\t\\t.style( 'opacity', self.config.area.opacity )\\n\\t\\t\\t.style( '-moz-opacity', self.config.area.opacity )\\n\\t\\t\\t.style( 'fill', color );\\n\\n\\t\\tareagroup.line = areagroup.path.append( 'svg:path' )\\n\\t\\t\\t.classed( uv.constants.classes.linepath + idx, true )\\n\\t\\t\\t.attr( 'd', areagroup.linefunc )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' );\\n\\n\\t\\tareagroup.path.selectAll( '.' + uv.constants.classes.dot )\\n\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t.enter().append( 'circle' )\\n\\t\\t\\t.classed( uv.constants.classes.dot, true )\\n\\t\\t\\t.attr( 'cx', areagroup.linefunc.x() )\\n\\t\\t\\t.attr( 'cy', areagroup.linefunc.y() )\\n\\t\\t\\t.attr( 'r', 3.5 )\\n\\t\\t\\t.style( 'fill', 'white' );\\n\\t};\\n\\n\\tuv.AreaGraph.prototype.drawVerticalArea = function ( areagroup, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx );\\n\\n\\t\\tself.axes.hor.scale.rangePoints( [0, self.width()] );\\n\\n\\t\\tareagroup.linefunc = d3.svg.line()\\n\\t\\t\\t.x( function ( d ) { return self.axes.hor.scale( d.name ) + self.axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t.y( function ( d ) { return self.axes.ver.scale( d.value ); } )\\n\\t\\t\\t.interpolate( self.config.area.interpolation );\\n\\n\\t\\tareagroup.areafunc = d3.svg.area()\\n\\t\\t\\t.x( areagroup.linefunc.x() )\\n\\t\\t\\t.y0( areagroup.linefunc.y() )\\n\\t\\t\\t.y1( self.axes.ver.scale( 0 ) )\\n\\t\\t\\t.interpolate( self.config.area.interpolation );\\n\\n\\t\\tareagroup.area = areagroup.path.append( 'svg:path' )\\n\\t\\t\\t.classed( uv.constants.classes.areapath + idx, true )\\n\\t\\t\\t.attr( 'd', areagroup.areafunc )\\n\\t\\t\\t.style( 'opacity', self.config.area.opacity )\\n\\t\\t\\t.style( '-moz-opacity', self.config.area.opacity )\\n\\t\\t\\t.style( 'fill', color );\\n\\n\\t\\tareagroup.line = areagroup.path.append( 'svg:path' )\\n\\t\\t\\t.classed( uv.constants.classes.linepath + idx, true )\\n\\t\\t\\t.attr( 'd', areagroup.linefunc )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' );\\n\\n\\t\\tareagroup.path.selectAll( '.' + uv.constants.classes.dot )\\n\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t.enter().append( 'circle' )\\n\\t\\t\\t.classed( uv.constants.classes.dot, true )\\n\\t\\t\\t.attr( 'cx', areagroup.linefunc.x() )\\n\\t\\t\\t.attr( 'cy', areagroup.linefunc.y() )\\n\\t\\t\\t.attr( 'r', 3.5 )\\n\\t\\t\\t.style( 'fill', 'white' );\\n\\t};\\n\\n\\t/**\\n* A normal 2d bar chart capable of being rendered in horizontal and vertical manner\\n* @param {Object} graphdef Definition of the graph being rendered\\n* @param {Object} config   Configuration of the graph being rendered\\n*/\\n\\tuv.BarGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.bargroups = {};\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( self.labels );\\n\\n\\t\\tvar idx, length = self.categories.length, category;\\n\\t\\tfor ( idx = 0; idx < length; idx = idx + 1 ) {\\n\\t\\t\\tcategory = self.categories[idx];\\n\\t\\t\\tself.bargroups[category] = self.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( category ), true );\\n\\t\\t\\tself['draw' + self.config.graph.orientation + 'Bars']( idx );\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.BarGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.BarGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.BarGraph.prototype.drawHorizontalBars = function ( idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tlen = self.categories.length;\\n\\n\\t\\tvar bars = self.bargroups[self.categories[idx]].selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter()\\n\\t\\t\\t.append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'transform', function ( d ) { if ( d.value < 0 ) return 'scale(-1,1)'; } );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.classed( uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'height', self.axes.ver.scale.rangeBand() / len )\\n\\t\\t\\t.attr( 'x', function ( d ) {\\n\\t\\t\\t\\treturn ( d.value < 0 ) ? ( -self.axes.hor.scale( 0 ) ) : self.axes.hor.scale( 0 );\\n\\t\\t\\t} )\\n\\t\\t\\t.attr( 'y', function ( d ) {return self.axes.ver.scale( d.name ); } )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.style( 'stroke', self.config.bar.strokecolor )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( function ( d, i ) { return i * self.config.effects.duration; } )\\n\\t\\t\\t.attr( 'width', function ( d ) { return self.axes.hor.scale( Math.abs( d.value ) ) - self.axes.hor.scale( 0 ); } )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t\\tif ( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'click', function( _d ){\\n\\t\\t\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [_d] );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'text' )\\n\\t\\t\\t.attr( 'x', function( d ) { return self.axes.hor.scale( 0 ); } )\\n\\t\\t\\t.attr( 'y', function( d ) { return self.axes.ver.scale( d.name ) + ( self.axes.ver.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'dx', function ( d ) { return ( d.value < 0 )? '-20px': '4px' } )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'start' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.style( 'transform', function ( d ) { return d.value < 0? 'scale(-1,1)': 'scale(1,1)'; } )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( function ( d, i ) { return i * self.config.effects.duration; } )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'x', function ( d ) { return self.axes.hor.scale( d.value ); } );\\n\\n\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tself.bargroups[self.categories[idx]].attr( 'transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')' );\\n\\t};\\n\\n\\tuv.BarGraph.prototype.drawVerticalBars = function ( idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tlen = self.categories.length;\\n\\n\\t\\tvar bars = self.bargroups[self.categories[idx]].selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter()\\n\\t\\t\\t.append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'transform', function ( d ) { if ( d.value < 0 ) return 'scale(1, -1)'; } );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.classed( uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'height', 0 )\\n\\t\\t\\t.attr( 'width', self.axes.hor.scale.rangeBand() / len )\\n\\t\\t\\t.attr( 'x', function ( d ) { return self.axes.hor.scale( d.name ); } )\\n\\t\\t\\t.attr( 'y', function ( d ) { return ( d.value < 0? -1: 1 ) * ( self.height() - self.axes.ver.scale( 0 ) ); } )\\n\\t\\t\\t.style( 'stroke', self.config.bar.strokecolor ).style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'height', function ( d ) { return Math.abs( self.axes.ver.scale( 0 ) - self.axes.ver.scale( d.value ) ); } )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t\\tif( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'click', function( _d ){\\n\\t\\t\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [_d] );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\n\\n\\t\\tbars.append( 'text' ).attr( 'transform', function ( d ) { return ( d.value < 0 ) ? 'scale(1,1)': 'scale(1,-1)'; } )\\n\\t\\t\\t.attr( 'x', function( d ) { return self.axes.hor.scale( d.name ) + ( self.axes.hor.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'y', function( d ) { return self.height() - self.axes.ver.scale( 0 ) } )\\n\\t\\t\\t.attr( 'dx', 0 )\\n\\t\\t\\t.attr( 'dy', function ( d ) { return d.value < 0 ? '2em' : '.35em' } )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'y', function ( d ) { return -( self.height() - self.axes.ver.scale( d.value ) ) - 10; } );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\n\\t\\tself.bargroups[self.categories[idx]].attr( 'transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + self.height() + ') scale(1,-1)' );\\n\\t};\\n\\n\\tuv.DonutGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.radius = Math.min( self.height(), self.width() ) * 2 / 5;\\n\\t\\tself.center = {\\n\\t\\t\\tx : self.width() / 2,\\n\\t\\t\\ty : self.height() / 2\\n\\t\\t};\\n\\n\\t\\tself.category = graphdef.categories[0];\\n\\n\\t\\tvar data = uv.util.getCategoryData( self.graphdef, [self.category] ),\\n\\t\\t\\tarcfunc = d3.svg.arc().innerRadius( self.radius * self.config.donut.factor ).outerRadius( self.radius ),\\n\\t\\t\\tlayout = d3.layout.pie();\\n\\n\\t\\tself.chart.data( data );\\n\\t\\tself.arcs = self.chart.selectAll( 'g.arc' )\\n\\t\\t\\t.data( layout ).enter()\\n\\t\\t\\t.append( 'g' ).classed( uv.constants.classes.arc + uv.util.formatClassName( self.category ), true )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.center.x + ',' + self.center.y + ')' );\\n\\n\\t\\tself.arcs.append( 'path' )\\n\\t\\t\\t.attr( 'd', arcfunc )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( self.config, i ); } )\\n\\t\\t\\t.style( 'stroke', self.config.donut.strokecolor )\\n\\t\\t\\t.style( 'stroke-width', self.config.donut.strokewidth )\\n\\t\\t\\t.on( 'mouseover', uv.effects.donut.mouseover( self.center, arcfunc, self.config ) )\\n\\t\\t\\t.on( 'mouseout', uv.effects.donut.mouseout( self.center, self.config ) )\\n\\n\\t\\tif ( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\tself.arcs.on( 'click', function ( d ) {\\n\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [d] );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\n\\t\\tself.arcs.append( 'text' )\\n\\t\\t\\t.attr( 'transform', function ( d ) { return 'translate(' + arcfunc.centroid( d ) + ')'; } )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.donut.fontfill : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.donut.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.donut.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.donut.fontweight )\\n\\t\\t\\t.style( 'font-variant', self.config.donut.fontvariant )\\n\\t\\t\\t.text( function ( d ) { return uv.util.getLabelValue( self, d ); } );\\n\\n\\t\\tself.arcs.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.category, self.labels[i], d );} );\\n\\n\\t};\\n\\n\\tuv.DonutGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.DonutGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\tself.config.legend.legendtype = 'labels';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.LineGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.linegroups = {};\\n\\t\\tself.dataset = uv.util.getDataArray( self.graphdef );\\n\\n\\t\\tvar linegroup, linepath, linefunc, idx, len = self.categories.length,\\n\\t\\t\\tdomainData = self.labels;\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( domainData );\\n\\n\\t\\tfor ( idx = 0; idx < len; idx = idx + 1 ) {\\n\\t\\t\\tlinepath = self.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t\\t.append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true ).datum( self.dataset[idx] );\\n\\t\\t\\tlinegroup = {\\n\\t\\t\\t\\tpath: linepath,\\n\\t\\t\\t\\tfunc: undefined\\n\\t\\t\\t};\\n\\n\\t\\t\\tself['draw' + self.config.graph.orientation + 'Lines']( linegroup, idx );\\n\\t\\t\\tself.linegroups[self.categories[idx]] = linegroup;\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.LineGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.LineGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\tself.config.scale.ordinality = 0;\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.LineGraph.prototype.drawHorizontalLines = function ( linegroup, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\taxes = self.axes,\\n\\t\\t\\tconfig = self.config,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx );\\n\\n\\t\\tself.axes.ver.scale.rangePoints( [0, self.height()] );\\n\\n\\t\\tlinegroup.func = d3.svg.line()\\n\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.value ); } )\\n\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.name ) + axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t.interpolate( uv.config.line.interpolation );\\n\\n\\t\\tlinegroup.path.append( 'path' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'd', linegroup.func )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke', color )\\n\\t\\t\\t.style( 'stroke-width', self.config.line.strokewidth )\\n\\t\\t\\t.style( 'stroke-opacity', self.config.line.strokeopacity )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( 3 * self.config.effects.duration )\\n\\t\\t\\t.delay( 2 * idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'stroke-opacity', 1 )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'path' ).on( 'mouseover', uv.effects.line.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'path' ).on( 'mouseout', uv.effects.line.mouseout( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'circle' ).on( 'mouseover', uv.effects.line.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'circle' ).on( 'mouseout', uv.effects.line.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\t\\tif ( self.config.line.showcircles ) {\\n\\t\\t\\tlinegroup.path.selectAll( 'circle' )\\n\\t\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t\\t.enter().append( 'circle' )\\n\\t\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t\\t.attr( 'cx', linegroup.func.x() )\\n\\t\\t\\t\\t.attr( 'cy', linegroup.func.y() )\\n\\t\\t\\t\\t.attr( 'r', self.config.line.circleradius )\\n\\t\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t\\t.style( 'fill-opacity', self.config.line.circleopacity )\\n\\t\\t\\t\\t.style( 'stroke', '#fff' )\\n\\t\\t\\t\\t.append( 'svg:title' )\\n\\t\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\t\\t}\\n\\n\\t\\tlinegroup.path.selectAll( 'text' )\\n\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t.enter().append( 'text' )\\n\\t\\t\\t.attr( 'x', function ( d ) { return axes.hor.scale( d.value ); } )\\n\\t\\t\\t.attr( 'y', function( d ) { return axes.ver.scale( d.name ) + axes.ver.scale.rangeBand()/2; } )\\n\\t\\t\\t.attr( 'dx', 10 )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'start' )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.line.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.line.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.line.fontweight )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( 3 * self.config.effects.duration )\\n\\t\\t\\t.delay( 2 * idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.LineGraph.prototype.drawVerticalLines = function ( linegroup, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\taxes = self.axes,\\n\\t\\t\\tconfig = self.config,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx );\\n\\n\\t\\tself.axes.hor.scale.rangePoints( [0, self.width()] );\\n\\n\\t\\tlinegroup.func = d3.svg.line()\\n\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.name ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.value ); } )\\n\\t\\t\\t.interpolate( uv.config.line.interpolation );\\n\\n\\t\\tlinegroup.path.append( 'path' )\\n\\t\\t\\t.attr( 'd', linegroup.func )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke', color )\\n\\t\\t\\t.style( 'stroke-width', self.config.line.strokewidth )\\n\\t\\t\\t.style( 'stroke-opacity', self.config.line.strokeopacity )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( 2 * idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'stroke-opacity', 1 )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'path' ).on( 'mouseover', uv.effects.line.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'path' ).on( 'mouseout', uv.effects.line.mouseout( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'circle' ).on( 'mouseover', uv.effects.line.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'circle' ).on( 'mouseout', uv.effects.line.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\t\\tif ( self.config.line.showcircles ) {\\n\\t\\t\\tlinegroup.path.selectAll( 'circle' )\\n\\t\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t\\t.enter().append( 'circle' )\\n\\t\\t\\t\\t.attr( 'cx', linegroup.func.x() )\\n\\t\\t\\t\\t.attr( 'cy', linegroup.func.y() )\\n\\t\\t\\t\\t.attr( 'r', self.config.line.circleradius )\\n\\t\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t\\t.style( 'fill-opacity', self.config.line.circleopacity )\\n\\t\\t\\t\\t.style( 'stroke', '#fff' )\\n\\t\\t\\t\\t.append( 'svg:title' )\\n\\t\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\t\\t}\\n\\n\\t\\tlinegroup.path.selectAll( 'text' )\\n\\t\\t\\t.data( self.dataset[idx] )\\n\\t\\t\\t.enter().append( 'text' )\\n\\t\\t\\t.attr( 'x', function ( d ) { return axes.hor.scale( d.name ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t.attr( 'y', function ( d ) { return axes.ver.scale( d.value ) - 20; } )\\n\\t\\t\\t.attr( 'dx', 0 )\\n\\t\\t\\t.attr( 'dy', '.71em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.line.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.line.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.line.fontweight )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( 3 * self.config.effects.duration )\\n\\t\\t\\t.delay( 2 * idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 );\\n\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.PercentAreaGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tvar stacklayout = d3.layout.stack().offset( 'zero' )(\\n\\t\\t\\tself.categories.map( function ( d ) {\\n\\t\\t\\t\\treturn graphdef.dataset[d].map( function ( d ) {\\n\\t\\t\\t\\t\\treturn {x: d.name, y: +d.value};\\n\\t\\t\\t\\t} );\\n\\t\\t\\t} )\\n\\t\\t);\\n\\n\\t\\tvar areagroup, areapath, areafunc,\\n\\t\\t\\tdomainData = self.labels,\\n\\t\\t\\tcategories = self.categories;\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( domainData );\\n\\t\\tself.areagroup = self.chart.selectAll( 'g.areagroup' ).data( stacklayout ).enter().append( 'g' )\\n\\t\\t\\t.attr( 'class', function ( d,i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, 'cge-' + self.categories[i] );\\n\\t\\t\\t} );\\n\\n\\t\\tself['draw' + self.config.graph.orientation + 'Area']();\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.PercentAreaGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.PercentAreaGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'percent';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.PercentAreaGraph.prototype.drawHorizontalArea = function () {\\n\\t\\tvar self = this, axes = self.axes,\\n\\t\\t\\tcategories = self.categories,\\n\\t\\t\\tconfig = self.config,\\n\\t\\t\\tsumMap = uv.util.getSumUpArray( self.graphdef );\\n\\n\\t\\taxes.ver.scale.rangePoints( [0, self.height()] );\\n\\n\\t\\tfor( var i = 0; i < categories.length; i = i + 1 ) {\\n\\t\\t\\tuv.effects.area.mouseover( self, i );\\n\\t\\t\\tuv.effects.area.mouseout( self,i );\\n\\t\\t}\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.area + uv.util.formatClassName( categories[i] ) );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( config, i ); } )\\n\\t\\t\\t.attr( 'd', d3.svg.area()\\n\\t\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.x ) + axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.x0( function ( d, i ) { return axes.hor.scale( uv.util.getPercentage( d.y0, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.x1( function ( d, i ) { return axes.hor.scale( uv.util.getPercentage( d.y0 + d.y, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t)\\n\\t\\t\\t.on( 'mouseover', function ( d,i ) { self.effects[categories[i]].mouseover(); } )\\n\\t\\t\\t.on( 'mouseout', function ( d,i ) { self.effects[categories[i]].mouseout(); } );\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.line + uv.util.formatClassName( categories[i] ) );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke-width', 2 )\\n\\t\\t\\t.attr( 'd', d3.svg.line()\\n\\t\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.x ) + axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.x( function ( d, i ) { return axes.hor.scale( uv.util.getPercentage( d.y0 + d.y, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t);\\n\\t};\\n\\n\\tuv.PercentAreaGraph.prototype.drawVerticalArea = function () {\\n\\t\\tvar self = this, axes = self.axes,\\n\\t\\t\\tcategories = self.categories,\\n\\t\\t\\tconfig = self.config,\\n\\t\\t\\tsumMap = uv.util.getSumUpArray( self.graphdef );\\n\\n\\t\\taxes.hor.scale.rangePoints( [0, self.width()] );\\n\\n\\t\\tfor( var i = 0; i < categories.length; i = i + 1 ){\\n\\t\\t\\tuv.effects.area.mouseover( self, i );\\n\\t\\t\\tuv.effects.area.mouseout( self,i );\\n\\t\\t}\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.area + uv.util.formatClassName( categories[i] ) );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( config, i ); } )\\n\\t\\t\\t.attr( 'd', d3.svg.area()\\n\\t\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.x ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.y0( function ( d, i ) { return axes.ver.scale( uv.util.getPercentage( d.y0, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.y1( function ( d, i ) { return axes.ver.scale( uv.util.getPercentage( d.y0 + d.y, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t)\\n\\t\\t\\t.on( 'mouseover', function ( d,i ) {self.effects[categories[i]].mouseover(); } )\\n\\t\\t\\t.on( 'mouseout', function ( d,i ) { self.effects[categories[i]].mouseout(); } );\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.line + uv.util.formatClassName( categories[i] ) );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke-width', 2 )\\n\\t\\t\\t.attr( 'd', d3.svg.line()\\n\\t\\t\\t\\t.x( function ( d, i ) { return axes.hor.scale( d.x ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.y( function ( d, i ) { return axes.ver.scale( uv.util.getPercentage( d.y0 + d.y, sumMap[i] ) ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t);\\n\\t};\\n\\n\\tuv.PercentBarGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.bargroups = [];\\n\\n\\t\\tvar bargroup, bars, idx, len, color,\\n\\t\\t\\tdomainData = self.labels,\\n\\t\\t\\tcsum = domainData.map( function ( d ) {return 0; } ),\\n\\t\\t\\ttsum = domainData.map( function ( d ) {return 0; } );\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( domainData );\\n\\n\\t\\tfor ( idx = 0, len = self.categories.length; idx < len; idx = idx + 1 ) {\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx );\\n\\t\\t\\tbargroup = self.chart.append( 'g' ).classed( 'cg-' + self.categories[idx], true );\\n\\t\\t\\tbars = bargroup.selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\n\\t\\t\\tself['draw' + uv.util.getPascalCasedName( self.config.graph.orientation ) + 'Bars']( bars, csum, tsum, idx );\\n\\n\\t\\t\\tif ( self.config.graph.orientation === 'Vertical' ) {\\n\\t\\t\\t\\tbargroup.attr( 'transform', 'translate(0,' + 2 * self.height() + ') scale(1,-1)' );\\n\\t\\t\\t}\\n\\n\\t\\t\\tself.bargroups.push( bargroup );\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.PercentBarGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.PercentBarGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'percent';\\n\\t\\tself.config.scale.ordinality = 0;\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.PercentBarGraph.prototype.drawHorizontalBars = function ( bars, csum, tsum, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\taxes = this.axes,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tconfig = this.config,\\n\\t\\t\\tsumMap = uv.util.getSumUpArray( this.graphdef );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', axes.ver.scale.rangeBand() )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.attr( 'x', function ( d, i ) { var value = axes.hor.scale( uv.util.getPercentage( csum[i], sumMap[i] ) ); csum[i] += d.value; return value; } )\\n\\t\\t\\t.attr( 'y', function ( d ) {return axes.ver.scale( d.name ); } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'width', function ( d, i ) { return axes.hor.scale( uv.util.getPercentage( d.value, sumMap[i] ) );} )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t} );\\n\\n\\n\\t\\tbars.append( 'text' )\\n\\t\\t\\t.attr( 'y', function( d ) { return axes.ver.scale( d.name ) + axes.ver.scale.rangeBand()/2; } )\\n\\t\\t\\t.attr( 'dx', 0 )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'end' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none' )\\n\\t\\t\\t.style( 'font-family', this.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', this.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', this.config.bar.fontweight )\\n\\t\\t\\t.text( function( d, i ) { return ( axes.hor.scale( uv.util.getPercentage( csum[i], sumMap[i] ) ) > 15 ) ? String( Math.round( uv.util.getPercentage( d.value, sumMap[i] ) ) ) : null; } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'x', function ( d, i ) { tsum[i] += d.value; return axes.hor.scale( uv.util.getPercentage( tsum[i], sumMap[i] ) ) - 5; } );\\n\\t};\\n\\n\\tuv.PercentBarGraph.prototype.drawVerticalBars = function ( bars, csum, tsum, idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\theight = this.height(),\\n\\t\\t\\taxes = this.axes,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tconfig = this.config,\\n\\t\\t\\tsumMap = uv.util.getSumUpArray( this.graphdef );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', 0 )\\n\\t\\t\\t.attr( 'width', axes.hor.scale.rangeBand() )\\n\\t\\t\\t.attr( 'x', function ( d ) { return axes.hor.scale( d.name ); } )\\n\\t\\t\\t.attr( 'y', function ( d, i ) { var value = axes.ver.scale( uv.util.getPercentage( csum[i], sumMap[i] ) ); csum[i] -= d.value; return value; } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'height', function ( d, i ) { return height - axes.ver.scale( uv.util.getPercentage( d.value, sumMap[i] ) ); } )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'text' ).attr( 'transform','scale(1,-1)' )\\n\\t\\t\\t.attr( 'x', function( d ) { return axes.hor.scale( d.name ) + axes.hor.scale.rangeBand()/2; } )\\n\\t\\t\\t.attr( 'y', -height + 5 )\\n\\t\\t\\t.attr( 'dy', '.71em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none' )\\n\\t\\t\\t.style( 'font-family', this.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', this.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', this.config.bar.fontweight )\\n\\t\\t\\t.text( function( d, i ) { return ( height - axes.ver.scale( uv.util.getPercentage( d.value, sumMap[i] ) ) > 15 ) ? String( Math.round( uv.util.getPercentage( d.value, sumMap[i] ) ) ) : null; } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'y', function ( d, i ) { tsum[i] += d.value; return -( 2*height - axes.ver.scale( uv.util.getPercentage( tsum[i], sumMap[i] ) ) ) + 5; } );\\n\\t};\\n\\n\\tuv.PieGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.radius = Math.min( self.height(), self.width() ) * 2 / 5;\\n\\t\\tself.center = {\\n\\t\\t\\tx : self.width() / 2,\\n\\t\\t\\ty : self.height() / 2\\n\\t\\t};\\n\\n\\t\\tself.category = graphdef.categories[0];\\n\\n\\t\\tvar data = uv.util.getCategoryData( self.graphdef, [self.category] ),\\n\\t\\t\\tarcfunc = d3.svg.arc().innerRadius( 0 ).outerRadius( self.radius ),\\n\\t\\t\\tlayout = d3.layout.pie();\\n\\n\\t\\tself.chart.data( data );\\n\\t\\tself.arcs = self.chart.selectAll( 'g.arc' )\\n\\t\\t\\t.data( layout ).enter()\\n\\t\\t\\t.append( 'g' ).classed( uv.constants.classes.arc + uv.util.formatClassName( self.category ), true )\\n\\t\\t\\t.attr( 'class', function ( d, i ){\\n\\t\\t\\t\\treturn uv.util.getClassName( this, 'cge-' + self.labels[i] );\\n\\t\\t\\t} )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.center.x + ',' + self.center.y + ')' );\\n\\n\\t\\tself.arcs.append( 'path' )\\n\\t\\t\\t.attr( 'd', arcfunc )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( self.config, i ); } )\\n\\t\\t\\t.style( 'stroke', self.config.pie.strokecolor )\\n\\t\\t\\t.style( 'stroke-width', self.config.pie.strokewidth )\\n\\t\\t\\t.on( 'mouseover', uv.effects.pie.mouseover( self, self.center, arcfunc, self.config ) )\\n\\t\\t\\t.on( 'mouseout', uv.effects.pie.mouseout( self, self.center, self.config ) );\\n\\n\\t\\tself.arcs.append( 'text' )\\n\\t\\t\\t.attr( 'transform', function ( d ) { return 'translate(' + arcfunc.centroid( d ) + ')'; } )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.pie.fontfill : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.pie.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.pie.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.pie.fontweight )\\n\\t\\t\\t.style( 'font-variant', self.config.pie.fontvariant )\\n\\t\\t\\t.text( function ( d ) { return uv.util.getLabelValue( self, d ); } );\\n\\n\\t\\tself.arcs.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.category, self.labels[i], d );} );\\n\\n\\t\\tif ( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\tself.arcs.on( 'click', function ( d ) {\\n\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [d] );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t};\\n\\n\\tuv.PieGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.PieGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\tself.config.legend.legendtype = 'labels';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.PolarAreaGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.maxRadius = Math.min( self.height(), self.width() ) * 2/5;\\n\\t\\tself.center = {\\n\\t\\t\\tx : self.width() / 2,\\n\\t\\t\\ty : self.height() / 2\\n\\t\\t};\\n\\n\\t\\tself.category = self.categories[0];\\n\\n\\t\\tvar data = uv.util.getCategoryData( self.graphdef, [self.category] ),\\n\\t\\t\\tdataMap = data[0].map( function( d,i ){ return d; } ),\\n\\t\\t\\tlayout = d3.layout.pie().value( function( d ){return self.max()/ data[0].length; } ),\\n\\t\\t\\ttickRadius = [],\\n\\t\\t\\tarcfuncs = d3.svg.arc().innerRadius( 0 )\\n\\t\\t\\t\\t.outerRadius( function( d,i ){return ( ( dataMap[i] * self.maxRadius ) / self.max() );} );\\n\\n\\t\\tfor ( var i=1; i<=self.config.axis.ticks; i++ ) {\\n\\t\\t\\ttickRadius[i] = ( self.maxRadius/self.config.axis.ticks ) * i;\\n\\t\\t}\\n\\n\\t\\tself.chart.data( data );\\n\\t\\tself.arcs = self.chart.selectAll( 'g.arc' )\\n\\t\\t\\t.data( layout ).enter()\\n\\t\\t\\t.append( 'g' ).classed( uv.constants.classes.arc + uv.util.formatClassName( self.category ), true )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.center.x + ',' + self.center.y + ')' );\\n\\n\\t\\tself.arcs.append( 'path' )\\n\\t\\t\\t.attr( 'd', arcfuncs )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( self.config, i );} )\\n\\t\\t\\t.style( 'stroke', self.config.pie.strokecolor )\\n\\t\\t\\t.style( 'stroke-width', self.config.pie.strokewidth );\\n\\n\\t\\t/*self.arcs.append('text')\\n      .attr('transform', function (d, i) { return 'translate(' + arcfuncs.centroid(d) + ')'; })\\n      .attr('dy', '.35em')\\n      .attr('text-anchor', 'middle')\\n      .style('fill', self.config.pie.fontfill)\\n      .style('font-family', self.config.pie.fontfamily)\\n      .style('font-size', self.config.pie.fontsize)\\n      .style('font-weight', self.config.pie.fontweight)\\n      .style('font-variant', self.config.pie.fontvariant)\\n      .text(function (d) { return uv.util.getLabelValue(self, d); }); */\\n\\n\\t\\tself.arcs.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.category, self.labels[i], d );} );\\n\\n\\t\\tself.chart.selectAll( '.' + uv.constants.classes.circleticks )\\n\\t\\t\\t.data( tickRadius )\\n\\t\\t\\t.enter().append( 'svg:g' ).classed( uv.constants.classes.circleticks, true )\\n\\t\\t\\t.append( \\\"svg:circle\\\" )\\n\\t\\t\\t.attr( \\\"r\\\", function ( d, i ) { return d; } )\\n\\t\\t\\t.style( \\\"stroke\\\", self.config.axis.strokecolor )\\n\\t\\t\\t.style( \\\"opacity\\\", self.config.axis.opacity )\\n\\t\\t\\t.style( \\\"fill\\\", \\\"none\\\" )\\n\\t\\t\\t.attr( 'transform', 'translate(' + self.center.x + ',' + self.center.y + ')' );\\n\\n\\t\\tif ( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\tself.arcs.on( 'click', function ( d ) {\\n\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [d] );\\n\\t\\t\\t} );\\n\\t\\t}\\n\\t};\\n\\n\\tuv.PolarAreaGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.PolarAreaGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'normal';\\n\\t\\tself.config.legend.legendtype = 'labels';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.StackedAreaGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tvar stacklayout = d3.layout.stack().offset( self.config.area.offset )( self.categories.map( function ( d ) {\\n\\t\\t\\treturn graphdef.dataset[d].map( function ( d ) { return {x: d.name, y: +d.value}; } );\\n\\t\\t} ) );\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( self.labels.map( function ( d ) { return d; } ) );\\n\\t\\tself.areagroup = self.chart.append( 'g' ).selectAll( 'g' )\\n\\t\\t\\t.data( stacklayout ).enter().append( 'g' ).attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, 'cge-' + self.categories[i] );\\n\\t\\t\\t} );\\n\\n\\t\\tself['draw' + self.config.graph.orientation + 'Area']();\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.StackedAreaGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.StackedAreaGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'stepup';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.StackedAreaGraph.prototype.drawHorizontalArea = function () {\\n\\t\\tvar self = this, axes = self.axes,\\n\\t\\t\\tcategories = self.categories,\\n\\t\\t\\tconfig = self.config;\\n\\n\\t\\taxes.ver.scale.rangePoints( [0, self.height()] );\\n\\n\\t\\tfor( var i = 0; i < categories.length; i = i + 1 ){\\n\\t\\t\\tuv.effects.area.mouseover( self, i );\\n\\t\\t\\tuv.effects.area.mouseout( self, i );\\n\\t\\t}\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.area + categories[i] );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( config, i ); } )\\n\\t\\t\\t.attr( 'd', d3.svg.area()\\n\\t\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.x ) + axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.x0( function ( d ) { return axes.hor.scale( d.y0 ); } )\\n\\t\\t\\t\\t.x1( function ( d ) { return axes.hor.scale( d.y0 + d.y ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t)\\n\\t\\t\\t.on( 'mouseover', function ( d,i ){ self.effects[categories[i]].mouseover(); } )\\n\\t\\t\\t.on( 'mouseout',  function ( d,i ) { self.effects[categories[i]].mouseout(); } );\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.line + categories[i] );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke-width', 2 )\\n\\t\\t\\t.attr( 'd', d3.svg.line()\\n\\t\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.x ) + axes.ver.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.y0 + d.y ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t);\\n\\n\\t\\treturn self;\\n\\t};\\n\\n\\tuv.StackedAreaGraph.prototype.drawVerticalArea = function () {\\n\\t\\tvar self = this, axes = self.axes,\\n\\t\\t\\tcategories = self.categories,\\n\\t\\t\\tconfig = self.config;\\n\\n\\t\\taxes.hor.scale.rangePoints( [0, self.width()] );\\n\\n\\t\\tfor( var i = 0; i < categories.length; i = i + 1 ){\\n\\t\\t\\tuv.effects.area.mouseover( self, i );\\n\\t\\t\\tuv.effects.area.mouseout( self, i );\\n\\t\\t}\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.area + categories[i] );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'fill', function ( d, i ) { return uv.util.getColorBand( config, i ); } )\\n\\t\\t\\t.attr( 'd', d3.svg.area()\\n\\t\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.x ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.y0( function ( d ) { return axes.ver.scale( d.y0 ); } )\\n\\t\\t\\t\\t.y1( function ( d ) { return axes.ver.scale( d.y0 + d.y ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t)\\n\\t\\t\\t.on( 'mouseover', function ( d,i ){ self.effects[categories[i]].mouseover(); } )\\n\\t\\t\\t.on( 'mouseout',  function ( d,i ) { self.effects[categories[i]].mouseout(); } );\\n\\n\\n\\t\\tself.areagroup.append( 'path' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\treturn uv.util.getClassName( this, uv.constants.classes.line + categories[i] );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'stroke', 'white' )\\n\\t\\t\\t.style( 'fill', 'none' )\\n\\t\\t\\t.style( 'stroke-width', 2 )\\n\\t\\t\\t.attr( 'd', d3.svg.line()\\n\\t\\t\\t\\t.x( function ( d ) { return axes.hor.scale( d.x ) + axes.hor.scale.rangeBand() / 2; } )\\n\\t\\t\\t\\t.y( function ( d ) { return axes.ver.scale( d.y0 + d.y ); } )\\n\\t\\t\\t\\t.interpolate( self.config.area.interpolation )\\n\\t\\t\\t);\\n\\n\\t\\treturn self;\\n\\t};\\n\\n\\tuv.StackedBarGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.bargroups = {};\\n\\n\\t\\tvar bargroup, bars, idx, len, color,\\n\\t\\t\\tdomainData = self.labels,\\n\\t\\t\\tcsum = domainData.map( function ( d ) {return 0; } ),\\n\\t\\t\\ttsum = domainData.map( function ( d ) {return 0; } );\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( domainData );\\n\\n\\t\\tfor ( idx = 0, len = self.categories.length; idx < len; idx = idx + 1 ) {\\n\\t\\t\\tself.bargroups[self.categories[idx]] = self.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\t\\t\\tself['draw' + self.config.graph.orientation + 'Bars']( idx, csum, tsum );\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.StackedBarGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.StackedBarGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'stepup';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.StackedBarGraph.prototype.drawHorizontalBars = function ( idx, csum, tsum ) {\\n\\t\\tvar self = this,\\n\\t\\t\\taxes = this.axes,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tconfig = this.config,\\n\\t\\t\\tbargroup = this.bargroups[this.categories[idx]];\\n\\n\\t\\tvar bars = bargroup.selectAll( 'g' ).data( this.graphdef.dataset[self.categories[idx]] )\\n\\t\\t\\t.enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', axes.ver.scale.rangeBand() )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.attr( 'x', function ( d, i ) { var value = axes.hor.scale( csum[i] ); csum[i] += d.value; return value; } )\\n\\t\\t\\t.attr( 'y', function ( d ) {return axes.ver.scale( d.name ); } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'width', function ( d,i ) { return axes.hor.scale( csum[i] ) - axes.hor.scale( csum[i]-d.value ); } )\\n\\t\\t\\t.each( \\\"end\\\", function ( d,i ){\\n\\t\\t\\t\\td3.select( this ).on( 'mouseover', uv.effects.bar.mouseover( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\td3.select( this ).on( 'mouseout', uv.effects.bar.mouseout( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\tif( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\t\\t\\td3.select( this ).on( 'click', function( _d ){\\n\\t\\t\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [_d] );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\n\\n\\t\\tbars.append( 'text' )\\n\\t\\t\\t.attr( 'y', function( d ) { return axes.ver.scale( d.name ) + axes.ver.scale.rangeBand()/2; } )\\n\\t\\t\\t.attr( 'dx', 0 )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'end' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none' )\\n\\t\\t\\t.style( 'font-family', config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', config.bar.fontweight )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return ( axes.hor.scale( d.value ) > 15 ) ? uv.util.getLabelValue( self, d ) : null; } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'x', function ( d, i ) { tsum[i] += d.value; return axes.hor.scale( tsum[i] ) - 5; } );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\t};\\n\\n\\tuv.StackedBarGraph.prototype.drawVerticalBars = function ( idx, csum, tsum ) {\\n\\t\\tvar self = this,\\n\\t\\t\\theight = this.height(),\\n\\t\\t\\taxes = this.axes,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tconfig = this.config,\\n\\t\\t\\tbargroup = this.bargroups[self.categories[idx]];\\n\\n\\t\\tvar bars = bargroup.selectAll( 'g' ).data( this.graphdef.dataset[self.categories[idx]] )\\n\\t\\t\\t.enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', 0 )\\n\\t\\t\\t.attr( 'width', axes.hor.scale.rangeBand() )\\n\\t\\t\\t.attr( 'x', function ( d ) { return axes.hor.scale( d.name ); } )\\n\\t\\t\\t.attr( 'y', function ( d, i ) { var value = axes.ver.scale( csum[i] ); csum[i] -= d.value; return value; } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'height', function ( d,i ) { return -( axes.ver.scale( -csum[i] ) - axes.ver.scale( -csum[i]-d.value ) ); } )\\n\\t\\t\\t.each( \\\"end\\\", function ( d,i ){\\n\\t\\t\\t\\td3.select( this ).on( 'mouseover', uv.effects.bar.mouseover( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\td3.select( this ).on( 'mouseout', uv.effects.bar.mouseout( self, idx, self.config.effects.textcolor ) );\\n\\t\\t\\t\\tif( typeof self.config.graph.clickCallback === \\\"function\\\" ) {\\n\\t\\t\\t\\t\\td3.select( this ).on( 'click', function( _d ){\\n\\t\\t\\t\\t\\t\\tself.config.graph.clickCallback.apply( null, [_d] );\\n\\t\\t\\t\\t\\t} );\\n\\t\\t\\t\\t}\\n\\t\\t\\t} );\\n\\n\\n\\t\\tbars.append( 'text' ).attr( 'transform','scale(1,-1)' )\\n\\t\\t\\t.attr( 'x', function( d ) { return axes.hor.scale( d.name ) + axes.hor.scale.rangeBand()/2; } )\\n\\t\\t\\t.attr( 'y', -height + 5 )\\n\\t\\t\\t.attr( 'dy', '.71em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none' )\\n\\t\\t\\t.style( 'font-family', config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', config.bar.fontweight )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return ( height - axes.ver.scale( d.value ) > 15 ) ? uv.util.getLabelValue( self, d ) : null; } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'y', function ( d, i ) { tsum[i] += d.value; return -( 2*height - axes.ver.scale( tsum[i] ) ) + 5; } );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tbargroup.attr( 'transform', 'translate(0,' + 2 * this.height() + ') scale(1,-1)' );\\n\\t};\\n\\n\\tuv.StepUpBarGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tthis.bargroups = {};\\n\\n\\t\\tvar idx, length = self.categories.length,\\n\\t\\t\\tcsum = self.labels.map( function ( d ) {return 0; } ),\\n\\t\\t\\ttsum = self.labels.map( function ( d ) {return 0; } );\\n\\n\\t\\tself.axes[this.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( this.labels );\\n\\n\\t\\tfor ( idx = 0; idx < length; idx = idx + 1 ) {\\n\\t\\t\\tself.bargroups[self.categories[idx]] = this.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\t\\t\\tself['draw' + self.config.graph.orientation + 'Bars']( idx, csum, tsum );\\n\\t\\t}\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.StepUpBarGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.StepUpBarGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'stepup';\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.StepUpBarGraph.prototype.drawHorizontalBars = function ( idx, csum, tsum ) {\\n\\t\\tvar self = this, len = self.categories.length,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx ),\\n\\t\\t\\tbargroup = self.bargroups[self.categories[idx]];\\n\\n\\t\\tvar bars = bargroup.selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', self.axes.ver.scale.rangeBand() / len )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.attr( 'transform',\\n\\t\\t\\t\\tfunction ( d ) {\\n\\t\\t\\t\\t\\treturn ( d.value < 0 ) ? 'scale(-1,1)': 'scale(1,1)';\\n\\t\\t\\t\\t} )\\n\\t\\t\\t.attr( 'x', function ( d, i ) {\\n\\t\\t\\t\\tif ( d.resetSum === true ) csum[i] = 0;\\n\\t\\t\\t\\tvar value = self.axes.hor.scale( csum[i] );\\n\\t\\t\\t\\tcsum[i] += d.value;\\n\\t\\t\\t\\treturn d.value < 0 ? -value: value;\\n\\t\\t\\t} )\\n\\t\\t\\t.attr( 'y', function ( d ) {return self.axes.ver.scale( d.name ); } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'width', function ( d, i ) { return Math.abs( self.axes.hor.scale( csum[i] ) - self.axes.hor.scale( csum[i]-d.value ) ); } )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'text' )\\n\\t\\t\\t.attr( 'y', function( d ) { return self.axes.ver.scale( d.name ) + ( self.axes.ver.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'dx', function ( d ) { return ( d.value < 0 )? -16: 4; } )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'start' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'x', function ( d, i ) {\\n\\t\\t\\t\\tif ( d.resetSum === true ) tsum[i] = 0;\\n\\t\\t\\t\\ttsum[i] += d.value;\\n\\t\\t\\t\\treturn self.axes.hor.scale( tsum[i] );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tbargroup.attr( 'transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')' );\\n\\t};\\n\\n\\tuv.StepUpBarGraph.prototype.drawVerticalBars = function ( idx, csum, tsum ) {\\n\\t\\tvar self = this, len = self.categories.length,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx ),\\n\\t\\t\\tbargroup = self.bargroups[self.categories[idx]],\\n\\t\\t\\tscaledSum = 0;\\n\\n\\t\\tvar bars = bargroup.selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', 0 )\\n\\t\\t\\t.attr( 'width', self.axes.hor.scale.rangeBand() / len )\\n\\t\\t\\t.attr( 'transform',\\n\\t\\t\\t\\tfunction ( d ) {\\n\\t\\t\\t\\t\\treturn ( d.value < 0 ) ? 'scale(1,-1)': 'scale(1,1)';\\n\\t\\t\\t\\t} )\\n\\t\\t\\t.attr( 'x', function ( d ) { return self.axes.hor.scale( d.name ); } )\\n\\t\\t\\t.attr( 'y', function ( d, i ) {\\n\\t\\t\\t\\tif ( d.resetSum === true ) csum[i] = 0;\\n\\t\\t\\t\\tvar value = ( 2*self.height() - self.axes.ver.scale( csum[i] ) );\\n\\t\\t\\t\\tcsum[i] += d.value;\\n\\t\\t\\t\\treturn ( d.value < 0 )? -value: value;\\n\\t\\t\\t} )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'height', function ( d, i ) {\\n\\t\\t\\t\\treturn Math.abs( self.axes.ver.scale( -csum[i] ) - self.axes.ver.scale( -csum[i]-d.value ) );\\n\\t\\t\\t} )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'text' ).attr( 'transform','scale(1,-1)' )\\n\\t\\t\\t.attr( 'x', function( d ) { return self.axes.hor.scale( d.name ) + ( self.axes.hor.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'y', -self.height() - 10 )\\n\\t\\t\\t.attr( 'dy', function ( d ) { return ( d.value < 0 )? '2.3em': '.71em'} )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.style( 'opacity', 0 )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.style( 'opacity', 1 )\\n\\t\\t\\t.attr( 'y', function ( d, i ) {\\n\\t\\t\\t\\tif ( d.resetSum === true ) tsum[i] = 0;\\n\\t\\t\\t\\ttsum[i] += d.value;\\n\\t\\t\\t\\treturn -( 2*self.height() - self.axes.ver.scale( tsum[i] ) ) - 10;\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tbargroup.attr( 'transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + 2 * self.height() + ') scale(1,-1)' );\\n\\t};\\n\\n\\tuv.Table = function () {\\n\\t\\tthis.caption = undefined;\\n\\t\\tthis.position = undefined;\\n\\t\\tthis.graphdef = undefined;\\n\\n\\t\\tthis.table = undefined;\\n\\t\\tthis.header = undefined;\\n\\t\\tthis.body = undefined;\\n\\t\\tthis.bodyrows = {};\\n\\t};\\n\\n\\tuv.Table.prototype.init = function ( graphdef, config ) {\\n\\t\\tthis.graphdef = graphdef;\\n\\t\\tthis.config = uv.util.extend( {}, config );\\n\\t\\tthis.position = this.config.meta.pos || 'body';\\n\\n\\t\\tthis.table = d3.select( this.position ).append( 'table' ).classed( this.config.table.tableclass, true );\\n\\t\\tthis.header = this.table.append( 'thead' ).classed( this.config.table.headerclass, true );\\n\\t\\tthis.body = this.table.append( 'tbody' ).classed( this.config.table.bodyclass, true );\\n\\t\\tthis.footer = this.table.append( 'tfoot' ).classed( this.config.table.footerclass, true );\\n\\t};\\n\\n\\tuv.Table.prototype.finalize = function () {\\n\\t\\t//console.log(this);\\n\\t};\\n\\n\\tuv.TableGraph = function ( graphdef, config ) {\\n\\t\\tuv.Table.apply( this, [graphdef] );\\n\\t\\tthis.init( graphdef, config );\\n\\n\\t\\tif ( this.config.graph.orientation === 'Horizontal' ) {\\n\\t\\t\\tthis.setHorTable();\\n\\t\\t} else {\\n\\t\\t\\tthis.setVerTable();\\n\\t\\t}\\n\\n\\t\\tthis.finalize();\\n\\t};\\n\\n\\tuv.TableGraph.prototype = uv.util.inherits( uv.Table );\\n\\n\\tuv.TableGraph.prototype.setHorTable = function () {\\n\\t\\tvar categories = this.graphdef.categories, tableData = uv.util.getTabularArray( this.graphdef );\\n\\n\\t\\tcategories.unshift( '' );\\n\\t\\tthis.header.append( 'tr' ).selectAll( 'td' ).data( categories ).enter().append( 'td' ).text( function ( d ) { return d; } );\\n\\t\\tcategories.shift();\\n\\n\\t\\tthis.bodyrows = this.body.selectAll( 'tr' ).data( tableData )\\n\\t\\t\\t.enter().append( 'tr' );\\n\\n\\t\\tthis.bodyrows.selectAll( 'td' ).data( function ( d, i ) { return tableData[i]; } )\\n\\t\\t\\t.enter().append( 'td' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\tvar classNameString = ( i === 0 ) ? 'chart3rtablelabel' : 'chart3rtabledata';\\n\\t\\t\\t\\treturn d3.select( this ).attr( 'class' ) + classNameString;\\n\\t\\t\\t} )\\n\\t\\t\\t.text( function ( d ) {return d; } );\\n\\t};\\n\\n\\tuv.TableGraph.prototype.setVerTable = function () {\\n\\t\\tvar labels = uv.util.getLabelArray( this.graphdef ), dataset = this.graphdef.dataset;\\n\\n\\t\\tlabels.unshift( '' );\\n\\t\\tthis.header.append( 'tr' ).selectAll( 'td' ).data( labels ).enter().append( 'td' ).text( function ( d ) { return d; } );\\n\\t\\tlabels.shift();\\n\\n\\t\\tthis.bodyrows = this.body.selectAll( 'tr' ).data( this.graphdef.categories )\\n\\t\\t\\t.enter().append( 'tr' );\\n\\n\\t\\tthis.bodyrows.selectAll( 'td' )\\n\\t\\t\\t.data( function ( d ) {\\n\\t\\t\\t\\tvar arr = [], i, len;\\n\\t\\t\\t\\tarr.push( d );\\n\\t\\t\\t\\tfor ( i = 0, len = dataset[d].length; i < len; i = i + 1 ) { arr.push( dataset[d][i].value ); }\\n\\t\\t\\t\\treturn arr;\\n\\t\\t\\t} ).enter().append( 'td' )\\n\\t\\t\\t.attr( 'class', function ( d, i ) {\\n\\t\\t\\t\\tvar classNameString = ( i === 0 ) ? 'chart3rtablelabel' : 'chart3rtabledata';\\n\\t\\t\\t\\treturn d3.select( this ).attr( 'class' ) + classNameString;\\n\\t\\t\\t} )\\n\\t\\t\\t.text( function ( d ) {return d; } );\\n\\t};\\n\\n\\t/**\\n* A waterfall chart capable of being rendered in horizontal and vertical manner\\n* @param {Object} graphdef Definition of the graph being rendered\\n* @param {Object} config   Configuration of the graph being rendered\\n*/\\n\\tuv.WaterfallGraph = function ( graphdef, config ) {\\n\\t\\tvar self = this;\\n\\t\\tuv.Graph.call( self, graphdef, config ).setDefaults().init();\\n\\n\\t\\tself.bargroups = {};\\n\\n\\t\\tself.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain( self.labels );\\n\\n\\t\\tvar idx, length = self.categories.length, category;\\n\\n\\t\\tcategory = self.categories[0];\\n\\t\\tself.bargroups[category] = self.chart.append( 'g' ).classed( 'cg-' + uv.util.formatClassName( category ), true );\\n\\t\\tself['draw' + self.config.graph.orientation + 'Bars']( 0 );\\n\\n\\t\\tself.finalize();\\n\\t};\\n\\n\\tuv.WaterfallGraph.prototype = uv.util.inherits( uv.Graph );\\n\\n\\tuv.WaterfallGraph.prototype.setDefaults = function () {\\n\\t\\tvar self = this;\\n\\t\\tself.graphdef.stepup = 'waterfall';\\n\\t\\tself.config.legend.showlegends = false;\\n\\t\\treturn this;\\n\\t};\\n\\n\\tuv.WaterfallGraph.prototype.drawHorizontalBars = function ( idx ) {\\n\\t\\tvar self = this, len = self.categories.length,\\n\\t\\t\\tcolor = uv.util.getColorBand( self.config, idx ),\\n\\t\\t\\tbargroup = self.bargroups[self.categories[idx]];\\n\\t\\tvar  csum = 0, tsum =0;\\n\\n\\t\\tvar bars = bargroup.selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter().append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.attr( 'height', ( self.axes.ver.scale.rangeBand() / len )-2 )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.attr( 'x', function ( d, i ) {\\n\\t\\t\\t\\tvar value = ( d.value < 0 ) ? csum + d.value : csum;\\n\\t\\t\\t\\tcsum += d.value;\\n\\t\\t\\t\\treturn self.axes.hor.scale( value ); } )\\n\\t\\t\\t.attr( 'y', function ( d ) {return self.axes.ver.scale( d.name ); } )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'stroke', 'none' )\\n\\t\\t\\t.style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'width', function ( d ) { return  self.axes.hor.scale( Math.abs( d.value ) ); } )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'text' )\\n\\t\\t\\t.attr( 'y', function( d ) { return self.axes.ver.scale( d.name ) + ( self.axes.ver.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'dx', 4 )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'start' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'x', function ( d, i ) {\\n\\t\\t\\t\\tvar value = d.value < 0 ? tsum : tsum + d.value;\\n\\t\\t\\t\\ttsum += d.value;\\n\\t\\t\\t\\treturn self.axes.hor.scale( value );\\n\\t\\t\\t} );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tbargroup.attr( 'transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')' );\\n\\t};\\n\\n\\tuv.WaterfallGraph.prototype.drawVerticalBars = function ( idx ) {\\n\\t\\tvar self = this,\\n\\t\\t\\tcolor = uv.util.getColorBand( this.config, idx ),\\n\\t\\t\\tlen = self.categories.length;\\n\\t\\tvar csum =0, tsum = 0;\\n\\n\\t\\tvar bars = self.bargroups[self.categories[idx]].selectAll( 'g' ).data( self.graphdef.dataset[self.categories[idx]] ).enter()\\n\\t\\t\\t.append( 'g' ).classed( 'cge-' + uv.util.formatClassName( self.categories[idx] ), true );\\n\\n\\t\\tbars.append( 'rect' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.attr( 'height', 0 )\\n\\t\\t\\t.attr( 'width', 0 )\\n\\t\\t\\t.attr( 'x', function ( d ) {return self.axes.hor.scale( d.name ); } )\\n\\t\\t\\t.attr( 'y', function( d ) {\\n\\t\\t\\t\\tvar value = ( d.value < 0 ) ? csum + d.value : csum;\\n\\t\\t\\t\\tcsum += d.value;\\n\\t\\t\\t\\treturn self.height() - self.axes.ver.scale( value );\\n\\t\\t\\t} )\\n\\t\\t\\t.style( 'stroke', self.config.bar.strokecolor ).style( 'fill', color )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'height', function ( d ) {  return self.height() - self.axes.ver.scale( Math.abs( d.value ) ); } )\\n\\t\\t\\t.attr( 'width', ( self.axes.hor.scale.rangeBand() / len )-2 )\\n\\t\\t\\t.call( uv.util.endAll, function ( d,i ){\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseover', uv.effects.bar.mouseover( self, idx ) );\\n\\t\\t\\t\\td3.select( this.parentNode.parentNode ).selectAll( 'rect' ).on( 'mouseout', uv.effects.bar.mouseout( self, idx ) );\\n\\t\\t\\t} );\\n\\n\\n\\t\\tbars.append( 'text' ).attr( 'transform','scale(1,-1)' )\\n\\t\\t\\t.attr( 'x', function( d ) { return self.axes.hor.scale( d.name ) + ( self.axes.hor.scale.rangeBand()/len )/2; } )\\n\\t\\t\\t.attr( 'y', -10 )\\n\\t\\t\\t.attr( 'dx', 0 )\\n\\t\\t\\t.attr( 'dy', '.35em' )\\n\\t\\t\\t.attr( 'text-anchor', 'middle' )\\n\\t\\t\\t.classed( 'cr-' + uv.util.formatClassName( self.categories[idx] ), true )\\n\\t\\t\\t.style( 'fill', self.config.label.showlabel ? uv.util.getColorBand( self.config, idx ) : 'none' )\\n\\t\\t\\t.style( 'font-family', self.config.bar.fontfamily )\\n\\t\\t\\t.style( 'font-size', self.config.bar.fontsize )\\n\\t\\t\\t.style( 'font-weight', self.config.bar.fontweight )\\n\\t\\t\\t.text( function( d ) { return uv.util.getLabelValue( self, d ); } )\\n\\t\\t\\t.transition()\\n\\t\\t\\t.duration( self.config.effects.duration )\\n\\t\\t\\t.delay( idx * self.config.effects.duration )\\n\\t\\t\\t.attr( 'y', function ( d ) {\\n\\t\\t\\t\\ttsum += d.value;\\n\\t\\t\\t\\tvar value = d.value < 0 ? tsum - d.value : tsum;\\n\\t\\t\\t\\treturn -( self.height() - self.axes.ver.scale( value ) ) - 10; } );\\n\\n\\t\\tbars.append( 'svg:title' )\\n\\t\\t\\t.text( function ( d, i ) { return uv.util.getTooltipText( self, self.categories[idx], self.labels[i], d );} );\\n\\n\\t\\tself.bargroups[self.categories[idx]].attr( 'transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + self.height() + ') scale(1,-1)' );\\n\\t};\\n\\n\\tif ( !noGlobal ) {\\n\\t\\twindow.uv = {\\n\\t\\t\\tchart: uv.chart\\n\\t\\t};\\n\\t}\\n\\n\\treturn {\\n\\t\\tchart: uv.chart\\n\\t};\\n} ) );\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/script-loader/addScript.js\")(require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/raw-loader/index.js!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/src/js/dependencies/d3.js\"))","require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/script-loader/addScript.js\")(require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/raw-loader/index.js!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/src/js/dependencies/uvcharts.js\"))","/* canvas-toBlob.js\n * A canvas.toBlob() implementation.\n * 2011-07-13\n *\n * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */\n\n( function( view ) {\n\t\"use strict\";\n\tvar\n\t  Uint8Array = view.Uint8Array\n\t\t, HTMLCanvasElement = view.HTMLCanvasElement\n\t\t, is_base64_regex = /\\s*;\\s*base64\\s*(?:;|$)/i\n\t\t, base64_ranks\n\t\t, decode_base64 = function( base64 ) {\n\t\t\tvar\n\t\t\t  len = base64.length\n\t\t\t\t, buffer = new Uint8Array( len / 4 * 3 | 0 )\n\t\t\t\t, i = 0\n\t\t\t\t, outptr = 0\n\t\t\t\t, last = [0, 0]\n\t\t\t\t, state = 0\n\t\t\t\t, save = 0\n\t\t\t\t, rank\n\t\t\t\t, code\n\t\t\t\t, undef\n\t\t;\n\t\t\twhile ( len-- ) {\n\t\t\t\tcode = base64.charCodeAt( i++ );\n\t\t\t\trank = base64_ranks[code-43];\n\t\t\t\tif ( rank !== 255 && rank !== undef ) {\n\t\t\t\t\tlast[1] = last[0];\n\t\t\t\t\tlast[0] = code;\n\t\t\t\t\tsave = ( save << 6 ) | rank;\n\t\t\t\t\tstate++;\n\t\t\t\t\tif ( state === 4 ) {\n\t\t\t\t\t\tbuffer[outptr++] = save >>> 16;\n\t\t\t\t\t\tif ( last[1] !== 61 /* padding character */ ) {\n\t\t\t\t\t\t\tbuffer[outptr++] = save >>> 8;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif ( last[0] !== 61 /* padding character */ ) {\n\t\t\t\t\t\t\tbuffer[outptr++] = save;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstate = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// 2/3 chance there's going to be some null bytes at the end, but that\n\t\t\t// doesn't really matter with most image formats.\n\t\t\t// If it somehow matters for you, truncate the buffer up outptr.\n\t\t\treturn buffer.buffer;\n\t\t}\n;\n\tif ( Uint8Array ) {\n\t\tbase64_ranks = new Uint8Array( [\n\t\t  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1\n\t\t\t, -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9\n\t\t\t, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\n\t\t\t, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35\n\t\t\t, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n\t\t] );\n\t}\n\tif ( HTMLCanvasElement && !HTMLCanvasElement.prototype.toBlob ) {\n\t\tHTMLCanvasElement.prototype.toBlob = function( callback, type /*, ...args*/ ) {\n\t\t  if ( !type ) {\n\t\t\t\ttype = \"image/png\";\n\t\t\t} if ( this.mozGetAsFile ) {\n\t\t\t\tcallback( this.mozGetAsFile( \"canvas\", type ) );\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar\n\t\t\t  args = Array.prototype.slice.call( arguments, 1 )\n\t\t\t\t, dataURI = this.toDataURL.apply( this, args )\n\t\t\t\t, header_end = dataURI.indexOf( \",\" )\n\t\t\t\t, data = dataURI.substring( header_end + 1 )\n\t\t\t\t, is_base64 = is_base64_regex.test( dataURI.substring( 0, header_end ) )\n\t\t\t\t, blob\n\t\t;\n\t\t\tif ( Blob.fake ) {\n\t\t\t// no reason to decode a data: URI that's just going to become a data URI again\n\t\t\t\tblob = new Blob\n\t\t\t\tif ( is_base64 ) {\n\t\t\t\t\tblob.encoding = \"base64\";\n\t\t\t\t} else {\n\t\t\t\t\tblob.encoding = \"URI\";\n\t\t\t\t}\n\t\t\t\tblob.data = data;\n\t\t\t\tblob.size = data.length;\n\t\t\t} else if ( Uint8Array ) {\n\t\t\t\tif ( is_base64 ) {\n\t\t\t\t\tblob = new Blob( [decode_base64( data )], {type: type} );\n\t\t\t\t} else {\n\t\t\t\t\tblob = new Blob( [decodeURIComponent( data )], {type: type} );\n\t\t\t\t}\n\t\t\t}\n\t\t\tcallback( blob );\n\t\t};\n\t}\n}( self ) );","/*\n * canvg.js - Javascript SVG parser and renderer on Canvas\n * MIT Licensed\n * Gabe Lerner (gabelerner@gmail.com)\n * http://code.google.com/p/canvg/\n *\n * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/\n */\n( function(){\n\t// canvg(target, s)\n\t// empty parameters: replace all 'svg' elements on page with 'canvas' elements\n\t// target: canvas element or the id of a canvas element\n\t// s: svg string, url to svg file, or xml document\n\t// opts: optional hash of options\n\t//\t\t ignoreMouse: true => ignore mouse events\n\t//\t\t ignoreAnimation: true => ignore animations\n\t//\t\t ignoreDimensions: true => does not try to resize canvas\n\t//\t\t ignoreClear: true => does not clear canvas\n\t//\t\t offsetX: int => draws at a x offset\n\t//\t\t offsetY: int => draws at a y offset\n\t//\t\t scaleWidth: int => scales horizontally to width\n\t//\t\t scaleHeight: int => scales vertically to height\n\t//\t\t renderCallback: function => will call the function after the first render is completed\n\t//\t\t forceRedraw: function => will call the function on every frame, if it returns true, will redraw\n\tthis.canvg = function ( target, s, opts ) {\n\t\t// no parameters\n\t\tif ( target == null && s == null && opts == null ) {\n\t\t\tvar svgTags = document.getElementsByTagName( 'svg' );\n\t\t\tfor ( var i=0; i<svgTags.length; i++ ) {\n\t\t\t\tvar svgTag = svgTags[i];\n\t\t\t\tvar c = document.createElement( 'canvas' );\n\t\t\t\tc.width = svgTag.clientWidth;\n\t\t\t\tc.height = svgTag.clientHeight;\n\t\t\t\tsvgTag.parentNode.insertBefore( c, svgTag );\n\t\t\t\tsvgTag.parentNode.removeChild( svgTag );\n\t\t\t\tvar div = document.createElement( 'div' );\n\t\t\t\tdiv.appendChild( svgTag );\n\t\t\t\tcanvg( c, div.innerHTML );\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\topts = opts || {};\n\n\t\tif ( typeof target == 'string' ) {\n\t\t\ttarget = document.getElementById( target );\n\t\t}\n\n\t\t// store class on canvas\n\t\tif ( target.svg != null ) target.svg.stop();\n\t\tvar svg = build();\n\t\t// on i.e. 8 for flash canvas, we can't assign the property so check for it\n\t\tif ( !( target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT' ) ) target.svg = svg;\n\t\tsvg.opts = opts;\n\n\t\tvar ctx = target.getContext( '2d' );\n\t\tif ( typeof( s.documentElement ) != 'undefined' ) {\n\t\t\t// load from xml doc\n\t\t\tsvg.loadXmlDoc( ctx, s );\n\t\t}\n\t\telse if ( s.substr( 0,1 ) == '<' ) {\n\t\t\t// load from xml string\n\t\t\tsvg.loadXml( ctx, s );\n\t\t}\n\t\telse {\n\t\t\t// load from url\n\t\t\tsvg.load( ctx, s );\n\t\t}\n\t}\n\n\tfunction build() {\n\t\tvar svg = { };\n\n\t\tsvg.FRAMERATE = 30;\n\t\tsvg.MAX_VIRTUAL_PIXELS = 30000;\n\n\t\t// globals\n\t\tsvg.init = function( ctx ) {\n\t\t\tvar uniqueId = 0;\n\t\t\tsvg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;\t};\n\t\t\tsvg.Definitions = {};\n\t\t\tsvg.Styles = {};\n\t\t\tsvg.Animations = [];\n\t\t\tsvg.Images = [];\n\t\t\tsvg.ctx = ctx;\n\t\t\tsvg.ViewPort = new ( function () {\n\t\t\t\tthis.viewPorts = [];\n\t\t\t\tthis.Clear = function() { this.viewPorts = []; }\n\t\t\t\tthis.SetCurrent = function( width, height ) { this.viewPorts.push( { width: width, height: height } ); }\n\t\t\t\tthis.RemoveCurrent = function() { this.viewPorts.pop(); }\n\t\t\t\tthis.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }\n\t\t\t\tthis.width = function() { return this.Current().width; }\n\t\t\t\tthis.height = function() { return this.Current().height; }\n\t\t\t\tthis.ComputeSize = function( d ) {\n\t\t\t\t\tif ( d != null && typeof( d ) == 'number' ) return d;\n\t\t\t\t\tif ( d == 'x' ) return this.width();\n\t\t\t\t\tif ( d == 'y' ) return this.height();\n\t\t\t\t\treturn Math.sqrt( Math.pow( this.width(), 2 ) + Math.pow( this.height(), 2 ) ) / Math.sqrt( 2 );\n\t\t\t\t}\n\t\t\t} );\n\t\t}\n\t\tsvg.init();\n\n\t\t// images loaded\n\t\tsvg.ImagesLoaded = function() {\n\t\t\tfor ( var i=0; i<svg.Images.length; i++ ) {\n\t\t\t\tif ( !svg.Images[i].loaded ) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t// trim\n\t\tsvg.trim = function( s ) { return s.replace( /^\\s+|\\s+$/g, '' ); }\n\n\t\t// compress spaces\n\t\tsvg.compressSpaces = function( s ) { return s.replace( /[\\s\\r\\t\\n]+/gm,' ' ); }\n\n\t\t// ajax\n\t\tsvg.ajax = function( url ) {\n\t\t\tvar AJAX;\n\t\t\tif( window.XMLHttpRequest ){AJAX=new XMLHttpRequest();}\n\t\t\telse{AJAX=new ActiveXObject( 'Microsoft.XMLHTTP' );}\n\t\t\tif( AJAX ){\n\t\t\t   AJAX.open( 'GET',url,false );\n\t\t\t   AJAX.send( null );\n\t\t\t   return AJAX.responseText;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// parse xml\n\t\tsvg.parseXml = function( xml ) {\n\t\t\tif ( window.DOMParser )\n\t\t\t{\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\treturn parser.parseFromString( xml, 'text/xml' );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txml = xml.replace( /<!DOCTYPE svg[^>]*>/, '' );\n\t\t\t\tvar xmlDoc = new ActiveXObject( 'Microsoft.XMLDOM' );\n\t\t\t\txmlDoc.async = 'false';\n\t\t\t\txmlDoc.loadXML( xml );\n\t\t\t\treturn xmlDoc;\n\t\t\t}\n\t\t}\n\n\t\tsvg.Property = function( name, value ) {\n\t\t\tthis.name = name;\n\t\t\tthis.value = value;\n\t\t}\n\t\tsvg.Property.prototype.getValue = function() {\n\t\t\treturn this.value;\n\t\t}\n\n\t\tsvg.Property.prototype.hasValue = function() {\n\t\t\treturn ( this.value != null && this.value !== '' );\n\t\t}\n\n\t\t// return the numerical value of the property\n\t\tsvg.Property.prototype.numValue = function() {\n\t\t\tif ( !this.hasValue() ) return 0;\n\n\t\t\tvar n = parseFloat( this.value );\n\t\t\tif ( ( this.value + '' ).match( /%$/ ) ) {\n\t\t\t\tn = n / 100.0;\n\t\t\t}\n\t\t\treturn n;\n\t\t}\n\n\t\tsvg.Property.prototype.valueOrDefault = function( def ) {\n\t\t\tif ( this.hasValue() ) return this.value;\n\t\t\treturn def;\n\t\t}\n\n\t\tsvg.Property.prototype.numValueOrDefault = function( def ) {\n\t\t\tif ( this.hasValue() ) return this.numValue();\n\t\t\treturn def;\n\t\t}\n\n\t\t// color extensions\n\t\t// augment the current color value with the opacity\n\t\tsvg.Property.prototype.addOpacity = function( opacity ) {\n\t\t\tvar newValue = this.value;\n\t\t\tif ( opacity != null && opacity != '' && typeof( this.value )=='string' ) { // can only add opacity to colors, not patterns\n\t\t\t\tvar color = new RGBColor( this.value );\n\t\t\t\tif ( color.ok ) {\n\t\t\t\t\tnewValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn new svg.Property( this.name, newValue );\n\t\t}\n\n\t\t// definition extensions\n\t\t// get the definition from the definitions table\n\t\tsvg.Property.prototype.getDefinition = function() {\n\t\t\tvar name = this.value.match( /#([^\\)'\"]+)/ );\n\t\t\tif ( name ) { name = name[1]; }\n\t\t\tif ( !name ) { name = this.value; }\n\t\t\treturn svg.Definitions[name];\n\t\t}\n\n\t\tsvg.Property.prototype.isUrlDefinition = function() {\n\t\t\treturn this.value.indexOf( 'url(' ) == 0\n\t\t}\n\n\t\tsvg.Property.prototype.getFillStyleDefinition = function( e, opacityProp ) {\n\t\t\tvar def = this.getDefinition();\n\n\t\t\t// gradient\n\t\t\tif ( def != null && def.createGradient ) {\n\t\t\t\treturn def.createGradient( svg.ctx, e, opacityProp );\n\t\t\t}\n\n\t\t\t// pattern\n\t\t\tif ( def != null && def.createPattern ) {\n\t\t\t\tif ( def.getHrefAttribute().hasValue() ) {\n\t\t\t\t\tvar pt = def.attribute( 'patternTransform' );\n\t\t\t\t\tdef = def.getHrefAttribute().getDefinition();\n\t\t\t\t\tif ( pt.hasValue() ) { def.attribute( 'patternTransform', true ).value = pt.value; }\n\t\t\t\t}\n\t\t\t\treturn def.createPattern( svg.ctx, e );\n\t\t\t}\n\n\t\t\treturn null;\n\t\t}\n\n\t\t// length extensions\n\t\tsvg.Property.prototype.getDPI = function( viewPort ) {\n\t\t\treturn 96.0; // TODO: compute?\n\t\t}\n\n\t\tsvg.Property.prototype.getEM = function( viewPort ) {\n\t\t\tvar em = 12;\n\n\t\t\tvar fontSize = new svg.Property( 'fontSize', svg.Font.Parse( svg.ctx.font ).fontSize );\n\t\t\tif ( fontSize.hasValue() ) em = fontSize.toPixels( viewPort );\n\n\t\t\treturn em;\n\t\t}\n\n\t\tsvg.Property.prototype.getUnits = function() {\n\t\t\tvar s = this.value+'';\n\t\t\treturn s.replace( /[0-9\\.\\-]/g,'' );\n\t\t}\n\n\t\t// get the length as pixels\n\t\tsvg.Property.prototype.toPixels = function( viewPort, processPercent ) {\n\t\t\tif ( !this.hasValue() ) return 0;\n\t\t\tvar s = this.value+'';\n\t\t\tif ( s.match( /em$/ ) ) return this.numValue() * this.getEM( viewPort );\n\t\t\tif ( s.match( /ex$/ ) ) return this.numValue() * this.getEM( viewPort ) / 2.0;\n\t\t\tif ( s.match( /px$/ ) ) return this.numValue();\n\t\t\tif ( s.match( /pt$/ ) ) return this.numValue() * this.getDPI( viewPort ) * ( 1.0 / 72.0 );\n\t\t\tif ( s.match( /pc$/ ) ) return this.numValue() * 15;\n\t\t\tif ( s.match( /cm$/ ) ) return this.numValue() * this.getDPI( viewPort ) / 2.54;\n\t\t\tif ( s.match( /mm$/ ) ) return this.numValue() * this.getDPI( viewPort ) / 25.4;\n\t\t\tif ( s.match( /in$/ ) ) return this.numValue() * this.getDPI( viewPort );\n\t\t\tif ( s.match( /%$/ ) ) return this.numValue() * svg.ViewPort.ComputeSize( viewPort );\n\t\t\tvar n = this.numValue();\n\t\t\tif ( processPercent && n < 1.0 ) return n * svg.ViewPort.ComputeSize( viewPort );\n\t\t\treturn n;\n\t\t}\n\n\t\t// time extensions\n\t\t// get the time as milliseconds\n\t\tsvg.Property.prototype.toMilliseconds = function() {\n\t\t\tif ( !this.hasValue() ) return 0;\n\t\t\tvar s = this.value+'';\n\t\t\tif ( s.match( /s$/ ) ) return this.numValue() * 1000;\n\t\t\tif ( s.match( /ms$/ ) ) return this.numValue();\n\t\t\treturn this.numValue();\n\t\t}\n\n\t\t// angle extensions\n\t\t// get the angle as radians\n\t\tsvg.Property.prototype.toRadians = function() {\n\t\t\tif ( !this.hasValue() ) return 0;\n\t\t\tvar s = this.value+'';\n\t\t\tif ( s.match( /deg$/ ) ) return this.numValue() * ( Math.PI / 180.0 );\n\t\t\tif ( s.match( /grad$/ ) ) return this.numValue() * ( Math.PI / 200.0 );\n\t\t\tif ( s.match( /rad$/ ) ) return this.numValue();\n\t\t\treturn this.numValue() * ( Math.PI / 180.0 );\n\t\t}\n\n\t\t// fonts\n\t\tsvg.Font = new ( function() {\n\t\t\tthis.Styles = 'normal|italic|oblique|inherit';\n\t\t\tthis.Variants = 'normal|small-caps|inherit';\n\t\t\tthis.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\n\n\t\t\tthis.CreateFont = function( fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit ) {\n\t\t\t\tvar f = inherit != null ? this.Parse( inherit ) : this.CreateFont( '', '', '', '', '', svg.ctx.font );\n\t\t\t\treturn {\n\t\t\t\t\tfontFamily: fontFamily || f.fontFamily,\n\t\t\t\t\tfontSize: fontSize || f.fontSize,\n\t\t\t\t\tfontStyle: fontStyle || f.fontStyle,\n\t\t\t\t\tfontWeight: fontWeight || f.fontWeight,\n\t\t\t\t\tfontVariant: fontVariant || f.fontVariant,\n\t\t\t\t\ttoString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join( ' ' ) }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar that = this;\n\t\t\tthis.Parse = function( s ) {\n\t\t\t\tvar f = {};\n\t\t\t\tvar d = svg.trim( svg.compressSpaces( s || '' ) ).split( ' ' );\n\t\t\t\tvar set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }\n\t\t\t\tvar ff = '';\n\t\t\t\tfor ( var i=0; i<d.length; i++ ) {\n\t\t\t\t\tif ( !set.fontStyle && that.Styles.indexOf( d[i] ) != -1 ) { if ( d[i] != 'inherit' ) f.fontStyle = d[i]; set.fontStyle = true; }\n\t\t\t\t\telse if ( !set.fontVariant && that.Variants.indexOf( d[i] ) != -1 ) { if ( d[i] != 'inherit' ) f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;\t}\n\t\t\t\t\telse if ( !set.fontWeight && that.Weights.indexOf( d[i] ) != -1 ) {\tif ( d[i] != 'inherit' ) f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }\n\t\t\t\t\telse if ( !set.fontSize ) { if ( d[i] != 'inherit' ) f.fontSize = d[i].split( '/' )[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }\n\t\t\t\t\telse { if ( d[i] != 'inherit' ) ff += d[i]; }\n\t\t\t\t} if ( ff != '' ) f.fontFamily = ff;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t} );\n\n\t\t// points and paths\n\t\tsvg.ToNumberArray = function( s ) {\n\t\t\tvar a = svg.trim( svg.compressSpaces( ( s || '' ).replace( /,/g, ' ' ) ) ).split( ' ' );\n\t\t\tfor ( var i=0; i<a.length; i++ ) {\n\t\t\t\ta[i] = parseFloat( a[i] );\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tsvg.Point = function( x, y ) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\tsvg.Point.prototype.angleTo = function( p ) {\n\t\t\treturn Math.atan2( p.y - this.y, p.x - this.x );\n\t\t}\n\n\t\tsvg.Point.prototype.applyTransform = function( v ) {\n\t\t\tvar xp = this.x * v[0] + this.y * v[2] + v[4];\n\t\t\tvar yp = this.x * v[1] + this.y * v[3] + v[5];\n\t\t\tthis.x = xp;\n\t\t\tthis.y = yp;\n\t\t}\n\n\t\tsvg.CreatePoint = function( s ) {\n\t\t\tvar a = svg.ToNumberArray( s );\n\t\t\treturn new svg.Point( a[0], a[1] );\n\t\t}\n\t\tsvg.CreatePath = function( s ) {\n\t\t\tvar a = svg.ToNumberArray( s );\n\t\t\tvar path = [];\n\t\t\tfor ( var i=0; i<a.length; i+=2 ) {\n\t\t\t\tpath.push( new svg.Point( a[i], a[i+1] ) );\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\t// bounding box\n\t\tsvg.BoundingBox = function( x1, y1, x2, y2 ) { // pass in initial points if you want\n\t\t\tthis.x1 = Number.NaN;\n\t\t\tthis.y1 = Number.NaN;\n\t\t\tthis.x2 = Number.NaN;\n\t\t\tthis.y2 = Number.NaN;\n\n\t\t\tthis.x = function() { return this.x1; }\n\t\t\tthis.y = function() { return this.y1; }\n\t\t\tthis.width = function() { return this.x2 - this.x1; }\n\t\t\tthis.height = function() { return this.y2 - this.y1; }\n\n\t\t\tthis.addPoint = function( x, y ) {\n\t\t\t\tif ( x != null ) {\n\t\t\t\t\tif ( isNaN( this.x1 ) || isNaN( this.x2 ) ) {\n\t\t\t\t\t\tthis.x1 = x;\n\t\t\t\t\t\tthis.x2 = x;\n\t\t\t\t\t}\n\t\t\t\t\tif ( x < this.x1 ) this.x1 = x;\n\t\t\t\t\tif ( x > this.x2 ) this.x2 = x;\n\t\t\t\t}\n\n\t\t\t\tif ( y != null ) {\n\t\t\t\t\tif ( isNaN( this.y1 ) || isNaN( this.y2 ) ) {\n\t\t\t\t\t\tthis.y1 = y;\n\t\t\t\t\t\tthis.y2 = y;\n\t\t\t\t\t}\n\t\t\t\t\tif ( y < this.y1 ) this.y1 = y;\n\t\t\t\t\tif ( y > this.y2 ) this.y2 = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.addX = function( x ) { this.addPoint( x, null ); }\n\t\t\tthis.addY = function( y ) { this.addPoint( null, y ); }\n\n\t\t\tthis.addBoundingBox = function( bb ) {\n\t\t\t\tthis.addPoint( bb.x1, bb.y1 );\n\t\t\t\tthis.addPoint( bb.x2, bb.y2 );\n\t\t\t}\n\n\t\t\tthis.addQuadraticCurve = function( p0x, p0y, p1x, p1y, p2x, p2y ) {\n\t\t\t\tvar cp1x = p0x + 2/3 * ( p1x - p0x ); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp1y = p0y + 2/3 * ( p1y - p0y ); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp2x = cp1x + 1/3 * ( p2x - p0x ); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tvar cp2y = cp1y + 1/3 * ( p2y - p0y ); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tthis.addBezierCurve( p0x, p0y, cp1x, cp2x, cp1y,\tcp2y, p2x, p2y );\n\t\t\t}\n\n\t\t\tthis.addBezierCurve = function( p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y ) {\n\t\t\t\t// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t\t\t\tvar p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];\n\t\t\t\tthis.addPoint( p0[0], p0[1] );\n\t\t\t\tthis.addPoint( p3[0], p3[1] );\n\n\t\t\t\tfor ( i=0; i<=1; i++ ) {\n\t\t\t\t\tvar f = function( t ) {\n\t\t\t\t\t\treturn Math.pow( 1-t, 3 ) * p0[i]\n\t\t\t\t\t\t+ 3 * Math.pow( 1-t, 2 ) * t * p1[i]\n\t\t\t\t\t\t+ 3 * ( 1-t ) * Math.pow( t, 2 ) * p2[i]\n\t\t\t\t\t\t+ Math.pow( t, 3 ) * p3[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n\t\t\t\t\tvar a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n\t\t\t\t\tvar c = 3 * p1[i] - 3 * p0[i];\n\n\t\t\t\t\tif ( a == 0 ) {\n\t\t\t\t\t\tif ( b == 0 ) continue;\n\t\t\t\t\t\tvar t = -c / b;\n\t\t\t\t\t\tif ( 0 < t && t < 1 ) {\n\t\t\t\t\t\t\tif ( i == 0 ) this.addX( f( t ) );\n\t\t\t\t\t\t\tif ( i == 1 ) this.addY( f( t ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar b2ac = Math.pow( b, 2 ) - 4 * c * a;\n\t\t\t\t\tif ( b2ac < 0 ) continue;\n\t\t\t\t\tvar t1 = ( -b + Math.sqrt( b2ac ) ) / ( 2 * a );\n\t\t\t\t\tif ( 0 < t1 && t1 < 1 ) {\n\t\t\t\t\t\tif ( i == 0 ) this.addX( f( t1 ) );\n\t\t\t\t\t\tif ( i == 1 ) this.addY( f( t1 ) );\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = ( -b - Math.sqrt( b2ac ) ) / ( 2 * a );\n\t\t\t\t\tif ( 0 < t2 && t2 < 1 ) {\n\t\t\t\t\t\tif ( i == 0 ) this.addX( f( t2 ) );\n\t\t\t\t\t\tif ( i == 1 ) this.addY( f( t2 ) );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.isPointInBox = function( x, y ) {\n\t\t\t\treturn ( this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2 );\n\t\t\t}\n\n\t\t\tthis.addPoint( x1, y1 );\n\t\t\tthis.addPoint( x2, y2 );\n\t\t}\n\n\t\t// transforms\n\t\tsvg.Transform = function( v ) {\n\t\t\tvar that = this;\n\t\t\tthis.Type = {}\n\n\t\t\t// translate\n\t\t\tthis.Type.translate = function( s ) {\n\t\t\t\tthis.p = svg.CreatePoint( s );\n\t\t\t\tthis.apply = function( ctx ) {\n\t\t\t\t\tctx.translate( this.p.x || 0.0, this.p.y || 0.0 );\n\t\t\t\t}\n\t\t\t\tthis.unapply = function( ctx ) {\n\t\t\t\t\tctx.translate( -1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0 );\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function( p ) {\n\t\t\t\t\tp.applyTransform( [1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// rotate\n\t\t\tthis.Type.rotate = function( s ) {\n\t\t\t\tvar a = svg.ToNumberArray( s );\n\t\t\t\tthis.angle = new svg.Property( 'angle', a[0] );\n\t\t\t\tthis.cx = a[1] || 0;\n\t\t\t\tthis.cy = a[2] || 0;\n\t\t\t\tthis.apply = function( ctx ) {\n\t\t\t\t\tctx.translate( this.cx, this.cy );\n\t\t\t\t\tctx.rotate( this.angle.toRadians() );\n\t\t\t\t\tctx.translate( -this.cx, -this.cy );\n\t\t\t\t}\n\t\t\t\tthis.unapply = function( ctx ) {\n\t\t\t\t\tctx.translate( this.cx, this.cy );\n\t\t\t\t\tctx.rotate( -1.0 * this.angle.toRadians() );\n\t\t\t\t\tctx.translate( -this.cx, -this.cy );\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function( p ) {\n\t\t\t\t\tvar a = this.angle.toRadians();\n\t\t\t\t\tp.applyTransform( [1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0] );\n\t\t\t\t\tp.applyTransform( [Math.cos( a ), Math.sin( a ), -Math.sin( a ), Math.cos( a ), 0, 0] );\n\t\t\t\t\tp.applyTransform( [1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.scale = function( s ) {\n\t\t\t\tthis.p = svg.CreatePoint( s );\n\t\t\t\tthis.apply = function( ctx ) {\n\t\t\t\t\tctx.scale( this.p.x || 1.0, this.p.y || this.p.x || 1.0 );\n\t\t\t\t}\n\t\t\t\tthis.unapply = function( ctx ) {\n\t\t\t\t\tctx.scale( 1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0 );\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function( p ) {\n\t\t\t\t\tp.applyTransform( [this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0] );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.matrix = function( s ) {\n\t\t\t\tthis.m = svg.ToNumberArray( s );\n\t\t\t\tthis.apply = function( ctx ) {\n\t\t\t\t\tctx.transform( this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5] );\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function( p ) {\n\t\t\t\t\tp.applyTransform( this.m );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.SkewBase = function( s ) {\n\t\t\t\tthis.base = that.Type.matrix;\n\t\t\t\tthis.base( s );\n\t\t\t\tthis.angle = new svg.Property( 'angle', s );\n\t\t\t}\n\t\t\tthis.Type.SkewBase.prototype = new this.Type.matrix;\n\n\t\t\tthis.Type.skewX = function( s ) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base( s );\n\t\t\t\tthis.m = [1, 0, Math.tan( this.angle.toRadians() ), 1, 0, 0];\n\t\t\t}\n\t\t\tthis.Type.skewX.prototype = new this.Type.SkewBase;\n\n\t\t\tthis.Type.skewY = function( s ) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base( s );\n\t\t\t\tthis.m = [1, Math.tan( this.angle.toRadians() ), 0, 1, 0, 0];\n\t\t\t}\n\t\t\tthis.Type.skewY.prototype = new this.Type.SkewBase;\n\n\t\t\tthis.transforms = [];\n\n\t\t\tthis.apply = function( ctx ) {\n\t\t\t\tfor ( var i=0; i<this.transforms.length; i++ ) {\n\t\t\t\t\tthis.transforms[i].apply( ctx );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.unapply = function( ctx ) {\n\t\t\t\tfor ( var i=this.transforms.length-1; i>=0; i-- ) {\n\t\t\t\t\tthis.transforms[i].unapply( ctx );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.applyToPoint = function( p ) {\n\t\t\t\tfor ( var i=0; i<this.transforms.length; i++ ) {\n\t\t\t\t\tthis.transforms[i].applyToPoint( p );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar data = svg.trim( svg.compressSpaces( v ) ).replace( /\\)(\\s?,\\s?)/g,') ' ).split( /\\s(?=[a-z])/ );\n\t\t\tfor ( var i=0; i<data.length; i++ ) {\n\t\t\t\tvar type = svg.trim( data[i].split( '(' )[0] );\n\t\t\t\tvar s = data[i].split( '(' )[1].replace( ')','' );\n\t\t\t\tvar transform = new this.Type[type]( s );\n\t\t\t\ttransform.type = type;\n\t\t\t\tthis.transforms.push( transform );\n\t\t\t}\n\t\t}\n\n\t\t// aspect ratio\n\t\tsvg.AspectRatio = function( ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY ) {\n\t\t\t// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n\t\t\taspectRatio = svg.compressSpaces( aspectRatio );\n\t\t\taspectRatio = aspectRatio.replace( /^defer\\s/,'' ); // ignore defer\n\t\t\tvar align = aspectRatio.split( ' ' )[0] || 'xMidYMid';\n\t\t\tvar meetOrSlice = aspectRatio.split( ' ' )[1] || 'meet';\n\n\t\t\t// calculate scale\n\t\t\tvar scaleX = width / desiredWidth;\n\t\t\tvar scaleY = height / desiredHeight;\n\t\t\tvar scaleMin = Math.min( scaleX, scaleY );\n\t\t\tvar scaleMax = Math.max( scaleX, scaleY );\n\t\t\tif ( meetOrSlice == 'meet' ) { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }\n\t\t\tif ( meetOrSlice == 'slice' ) { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }\n\n\t\t\trefX = new svg.Property( 'refX', refX );\n\t\t\trefY = new svg.Property( 'refY', refY );\n\t\t\tif ( refX.hasValue() && refY.hasValue() ) {\n\t\t\t\tctx.translate( -scaleMin * refX.toPixels( 'x' ), -scaleMin * refY.toPixels( 'y' ) );\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// align\n\t\t\t\tif ( align.match( /^xMid/ ) && ( ( meetOrSlice == 'meet' && scaleMin == scaleY ) || ( meetOrSlice == 'slice' && scaleMax == scaleY ) ) ) ctx.translate( width / 2.0 - desiredWidth / 2.0, 0 );\n\t\t\t\tif ( align.match( /YMid$/ ) && ( ( meetOrSlice == 'meet' && scaleMin == scaleX ) || ( meetOrSlice == 'slice' && scaleMax == scaleX ) ) ) ctx.translate( 0, height / 2.0 - desiredHeight / 2.0 );\n\t\t\t\tif ( align.match( /^xMax/ ) && ( ( meetOrSlice == 'meet' && scaleMin == scaleY ) || ( meetOrSlice == 'slice' && scaleMax == scaleY ) ) ) ctx.translate( width - desiredWidth, 0 );\n\t\t\t\tif ( align.match( /YMax$/ ) && ( ( meetOrSlice == 'meet' && scaleMin == scaleX ) || ( meetOrSlice == 'slice' && scaleMax == scaleX ) ) ) ctx.translate( 0, height - desiredHeight );\n\t\t\t}\n\n\t\t\t// scale\n\t\t\tif ( align == 'none' ) ctx.scale( scaleX, scaleY );\n\t\t\telse if ( meetOrSlice == 'meet' ) ctx.scale( scaleMin, scaleMin );\n\t\t\telse if ( meetOrSlice == 'slice' ) ctx.scale( scaleMax, scaleMax );\n\n\t\t\t// translate\n\t\t\tctx.translate( minX == null ? 0 : -minX, minY == null ? 0 : -minY );\n\t\t}\n\n\t\t// elements\n\t\tsvg.Element = {}\n\n\t\tsvg.EmptyProperty = new svg.Property( 'EMPTY', '' );\n\n\t\tsvg.Element.ElementBase = function( node ) {\n\t\t\tthis.attributes = {};\n\t\t\tthis.styles = {};\n\t\t\tthis.children = [];\n\n\t\t\t// get or create attribute\n\t\t\tthis.attribute = function( name, createIfNotExists ) {\n\t\t\t\tvar a = this.attributes[name];\n\t\t\t\tif ( a != null ) return a;\n\n\t\t\t\tif ( createIfNotExists == true ) { a = new svg.Property( name, '' ); this.attributes[name] = a; }\n\t\t\t\treturn a || svg.EmptyProperty;\n\t\t\t}\n\n\t\t\tthis.getHrefAttribute = function() {\n\t\t\t\tfor ( var a in this.attributes ) {\n\t\t\t\t\tif ( a.match( /:href$/ ) ) {\n\t\t\t\t\t\treturn this.attributes[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn svg.EmptyProperty;\n\t\t\t}\n\n\t\t\t// get or create style, crawls up node tree\n\t\t\tthis.style = function( name, createIfNotExists ) {\n\t\t\t\tvar s = this.styles[name];\n\t\t\t\tif ( s != null ) return s;\n\n\t\t\t\tvar a = this.attribute( name );\n\t\t\t\tif ( a != null && a.hasValue() ) {\n\t\t\t\t\tthis.styles[name] = a; // move up to me to cache\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tvar p = this.parent;\n\t\t\t\tif ( p != null ) {\n\t\t\t\t\tvar ps = p.style( name );\n\t\t\t\t\tif ( ps != null && ps.hasValue() ) {\n\t\t\t\t\t\treturn ps;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif ( createIfNotExists == true ) { s = new svg.Property( name, '' ); this.styles[name] = s; }\n\t\t\t\treturn s || svg.EmptyProperty;\n\t\t\t}\n\n\t\t\t// base render\n\t\t\tthis.render = function( ctx ) {\n\t\t\t\t// don't render display=none\n\t\t\t\tif ( this.style( 'display' ).value == 'none' ) return;\n\n\t\t\t\t// don't render visibility=hidden\n\t\t\t\tif ( this.attribute( 'visibility' ).value == 'hidden' ) return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif ( this.attribute( 'mask' ).hasValue() ) { // mask\n\t\t\t\t\tvar mask = this.attribute( 'mask' ).getDefinition();\n\t\t\t\t\tif ( mask != null ) mask.apply( ctx, this );\n\t\t\t\t}\n\t\t\t\telse if ( this.style( 'filter' ).hasValue() ) { // filter\n\t\t\t\t\tvar filter = this.style( 'filter' ).getDefinition();\n\t\t\t\t\tif ( filter != null ) filter.apply( ctx, this );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.setContext( ctx );\n\t\t\t\t\tthis.renderChildren( ctx );\n\t\t\t\t\tthis.clearContext( ctx );\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\t// base set context\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\t// base clear context\n\t\t\tthis.clearContext = function( ctx ) {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\t// base render children\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tthis.children[i].render( ctx );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.addChild = function( childNode, create ) {\n\t\t\t\tvar child = childNode;\n\t\t\t\tif ( create ) child = svg.CreateElement( childNode );\n\t\t\t\tchild.parent = this;\n\t\t\t\tthis.children.push( child );\n\t\t\t}\n\n\t\t\tif ( node != null && node.nodeType == 1 ) { //ELEMENT_NODE\n\t\t\t\t// add children\n\t\t\t\tfor ( var i=0; i<node.childNodes.length; i++ ) {\n\t\t\t\t\tvar childNode = node.childNodes[i];\n\t\t\t\t\tif ( childNode.nodeType == 1 ) this.addChild( childNode, true ); //ELEMENT_NODE\n\t\t\t\t\tif ( this.captureTextNodes && childNode.nodeType == 3 ) {\n\t\t\t\t\t\tvar text = childNode.nodeValue || childNode.text || '';\n\t\t\t\t\t\tif ( svg.trim( svg.compressSpaces( text ) ) != '' ) {\n\t\t\t\t\t\t\tthis.addChild( new svg.Element.tspan( childNode ), false ); // TEXT_NODE\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add attributes\n\t\t\t\tfor ( var i=0; i<node.attributes.length; i++ ) {\n\t\t\t\t\tvar attribute = node.attributes[i];\n\t\t\t\t\tthis.attributes[attribute.nodeName] = new svg.Property( attribute.nodeName, attribute.nodeValue );\n\t\t\t\t}\n\n\t\t\t\t// add tag styles\n\t\t\t\tvar styles = svg.Styles[node.nodeName];\n\t\t\t\tif ( styles != null ) {\n\t\t\t\t\tfor ( var name in styles ) {\n\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add class styles\n\t\t\t\tif ( this.attribute( 'class' ).hasValue() ) {\n\t\t\t\t\tvar classes = svg.compressSpaces( this.attribute( 'class' ).value ).split( ' ' );\n\t\t\t\t\tfor ( var j=0; j<classes.length; j++ ) {\n\t\t\t\t\t\tstyles = svg.Styles['.'+classes[j]];\n\t\t\t\t\t\tif ( styles != null ) {\n\t\t\t\t\t\t\tfor ( var name in styles ) {\n\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyles = svg.Styles[node.nodeName+'.'+classes[j]];\n\t\t\t\t\t\tif ( styles != null ) {\n\t\t\t\t\t\t\tfor ( var name in styles ) {\n\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add id styles\n\t\t\t\tif ( this.attribute( 'id' ).hasValue() ) {\n\t\t\t\t\tvar styles = svg.Styles['#' + this.attribute( 'id' ).value];\n\t\t\t\t\tif ( styles != null ) {\n\t\t\t\t\t\tfor ( var name in styles ) {\n\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add inline styles\n\t\t\t\tif ( this.attribute( 'style' ).hasValue() ) {\n\t\t\t\t\tvar styles = this.attribute( 'style' ).value.split( ';' );\n\t\t\t\t\tfor ( var i=0; i<styles.length; i++ ) {\n\t\t\t\t\t\tif ( svg.trim( styles[i] ) != '' ) {\n\t\t\t\t\t\t\tvar style = styles[i].split( ':' );\n\t\t\t\t\t\t\tvar name = svg.trim( style[0] );\n\t\t\t\t\t\t\tvar value = svg.trim( style[1] );\n\t\t\t\t\t\t\tthis.styles[name] = new svg.Property( name, value );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add id\n\t\t\t\tif ( this.attribute( 'id' ).hasValue() ) {\n\t\t\t\t\tif ( svg.Definitions[this.attribute( 'id' ).value] == null ) {\n\t\t\t\t\t\tsvg.Definitions[this.attribute( 'id' ).value] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsvg.Element.RenderedElementBase = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\t// fill\n\t\t\t\tif ( this.style( 'fill' ).isUrlDefinition() ) {\n\t\t\t\t\tvar fs = this.style( 'fill' ).getFillStyleDefinition( this, this.style( 'fill-opacity' ) );\n\t\t\t\t\tif ( fs != null ) ctx.fillStyle = fs;\n\t\t\t\t}\n\t\t\t\telse if ( this.style( 'fill' ).hasValue() ) {\n\t\t\t\t\tvar fillStyle = this.style( 'fill' );\n\t\t\t\t\tif ( fillStyle.value == 'currentColor' ) fillStyle.value = this.style( 'color' ).value;\n\t\t\t\t\tctx.fillStyle = ( fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value );\n\t\t\t\t}\n\t\t\t\tif ( this.style( 'fill-opacity' ).hasValue() ) {\n\t\t\t\t\tvar fillStyle = new svg.Property( 'fill', ctx.fillStyle );\n\t\t\t\t\tfillStyle = fillStyle.addOpacity( this.style( 'fill-opacity' ).value );\n\t\t\t\t\tctx.fillStyle = fillStyle.value;\n\t\t\t\t}\n\n\t\t\t\t// stroke\n\t\t\t\tif ( this.style( 'stroke' ).isUrlDefinition() ) {\n\t\t\t\t\tvar fs = this.style( 'stroke' ).getFillStyleDefinition( this, this.style( 'stroke-opacity' ) );\n\t\t\t\t\tif ( fs != null ) ctx.strokeStyle = fs;\n\t\t\t\t}\n\t\t\t\telse if ( this.style( 'stroke' ).hasValue() ) {\n\t\t\t\t\tvar strokeStyle = this.style( 'stroke' );\n\t\t\t\t\tif ( strokeStyle.value == 'currentColor' ) strokeStyle.value = this.style( 'color' ).value;\n\t\t\t\t\tctx.strokeStyle = ( strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value );\n\t\t\t\t}\n\t\t\t\tif ( this.style( 'stroke-opacity' ).hasValue() ) {\n\t\t\t\t\tvar strokeStyle = new svg.Property( 'stroke', ctx.strokeStyle );\n\t\t\t\t\tstrokeStyle = strokeStyle.addOpacity( this.style( 'stroke-opacity' ).value );\n\t\t\t\t\tctx.strokeStyle = strokeStyle.value;\n\t\t\t\t}\n\t\t\t\tif ( this.style( 'stroke-width' ).hasValue() ) {\n\t\t\t\t\tvar newLineWidth = this.style( 'stroke-width' ).toPixels();\n\t\t\t\t\tctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0\n\t\t\t    }\n\t\t\t\tif ( this.style( 'stroke-linecap' ).hasValue() ) ctx.lineCap = this.style( 'stroke-linecap' ).value;\n\t\t\t\tif ( this.style( 'stroke-linejoin' ).hasValue() ) ctx.lineJoin = this.style( 'stroke-linejoin' ).value;\n\t\t\t\tif ( this.style( 'stroke-miterlimit' ).hasValue() ) ctx.miterLimit = this.style( 'stroke-miterlimit' ).value;\n\t\t\t\tif ( this.style( 'stroke-dasharray' ).hasValue() && this.style( 'stroke-dasharray' ).value != 'none' ) {\n\t\t\t\t\tvar gaps = svg.ToNumberArray( this.style( 'stroke-dasharray' ).value );\n\t\t\t\t\tif ( typeof( ctx.setLineDash ) != 'undefined' ) { ctx.setLineDash( gaps ); }\n\t\t\t\t\telse if ( typeof( ctx.webkitLineDash ) != 'undefined' ) { ctx.webkitLineDash = gaps; }\n\t\t\t\t\telse if ( typeof( ctx.mozDash ) != 'undefined' ) { ctx.mozDash  = gaps; }\n\n\t\t\t\t\tvar offset = this.style( 'stroke-dashoffset' ).numValueOrDefault( 1 );\n\t\t\t\t\tif ( typeof( ctx.lineDashOffset ) != 'undefined' ) { ctx.lineDashOffset = offset; }\n\t\t\t\t\telse if ( typeof( ctx.webkitLineDashOffset ) != 'undefined' ) { ctx.webkitLineDashOffset = offset; }\n\t\t\t\t\telse if ( typeof( ctx.mozDashOffset ) != 'undefined' ) { ctx.mozDashOffset = offset; }\n\t\t\t\t}\n\n\t\t\t\t// font\n\t\t\t\tif ( typeof( ctx.font ) != 'undefined' ) {\n\t\t\t\t\tctx.font = svg.Font.CreateFont(\n\t\t\t\t\t\tthis.style( 'font-style' ).value,\n\t\t\t\t\t\tthis.style( 'font-variant' ).value,\n\t\t\t\t\t\tthis.style( 'font-weight' ).value,\n\t\t\t\t\t\tthis.style( 'font-size' ).hasValue() ? this.style( 'font-size' ).toPixels() + 'px' : '',\n\t\t\t\t\t\tthis.style( 'font-family' ).value ).toString();\n\t\t\t\t}\n\n\t\t\t\t// transform\n\t\t\t\tif ( this.attribute( 'transform' ).hasValue() ) {\n\t\t\t\t\tvar transform = new svg.Transform( this.attribute( 'transform' ).value );\n\t\t\t\t\ttransform.apply( ctx );\n\t\t\t\t}\n\n\t\t\t\t// clip\n\t\t\t\tif ( this.style( 'clip-path' ).hasValue() ) {\n\t\t\t\t\tvar clip = this.style( 'clip-path' ).getDefinition();\n\t\t\t\t\tif ( clip != null ) clip.apply( ctx );\n\t\t\t\t}\n\n\t\t\t\t// opacity\n\t\t\t\tif ( this.style( 'opacity' ).hasValue() ) {\n\t\t\t\t\tctx.globalAlpha = this.style( 'opacity' ).numValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.PathElementBase = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tif ( ctx != null ) ctx.beginPath();\n\t\t\t\treturn new svg.BoundingBox();\n\t\t\t}\n\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tthis.path( ctx );\n\t\t\t\tsvg.Mouse.checkPath( this, ctx );\n\t\t\t\tif ( ctx.fillStyle != '' ) {\n\t\t\t\t\tif ( this.attribute( 'fill-rule' ).hasValue() ) { ctx.fill( this.attribute( 'fill-rule' ).value ); }\n\t\t\t\t\telse { ctx.fill(); }\n\t\t\t\t}\n\t\t\t\tif ( ctx.strokeStyle != '' ) ctx.stroke();\n\n\t\t\t\tvar markers = this.getMarkers();\n\t\t\t\tif ( markers != null ) {\n\t\t\t\t\tif ( this.style( 'marker-start' ).isUrlDefinition() ) {\n\t\t\t\t\t\tvar marker = this.style( 'marker-start' ).getDefinition();\n\t\t\t\t\t\tmarker.render( ctx, markers[0][0], markers[0][1] );\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.style( 'marker-mid' ).isUrlDefinition() ) {\n\t\t\t\t\t\tvar marker = this.style( 'marker-mid' ).getDefinition();\n\t\t\t\t\t\tfor ( var i=1;i<markers.length-1;i++ ) {\n\t\t\t\t\t\t\tmarker.render( ctx, markers[i][0], markers[i][1] );\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif ( this.style( 'marker-end' ).isUrlDefinition() ) {\n\t\t\t\t\t\tvar marker = this.style( 'marker-end' ).getDefinition();\n\t\t\t\t\t\tmarker.render( ctx, markers[markers.length-1][0], markers[markers.length-1][1] );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\treturn this.path();\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// svg element\n\t\tsvg.Element.svg = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.baseClearContext = this.clearContext;\n\t\t\tthis.clearContext = function( ctx ) {\n\t\t\t\tthis.baseClearContext( ctx );\n\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t}\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\t// initial values\n\t\t\t\tctx.strokeStyle = 'rgba(0,0,0,0)';\n\t\t\t\tctx.lineCap = 'butt';\n\t\t\t\tctx.lineJoin = 'miter';\n\t\t\t\tctx.miterLimit = 4;\n\n\t\t\t\tthis.baseSetContext( ctx );\n\n\t\t\t\t// create new view port\n\t\t\t\tif ( !this.attribute( 'x' ).hasValue() ) this.attribute( 'x', true ).value = 0;\n\t\t\t\tif ( !this.attribute( 'y' ).hasValue() ) this.attribute( 'y', true ).value = 0;\n\t\t\t\tctx.translate( this.attribute( 'x' ).toPixels( 'x' ), this.attribute( 'y' ).toPixels( 'y' ) );\n\n\t\t\t\tvar width = svg.ViewPort.width();\n\t\t\t\tvar height = svg.ViewPort.height();\n\n\t\t\t\tif ( !this.attribute( 'width' ).hasValue() ) this.attribute( 'width', true ).value = '100%';\n\t\t\t\tif ( !this.attribute( 'height' ).hasValue() ) this.attribute( 'height', true ).value = '100%';\n\t\t\t\tif ( typeof( this.root ) == 'undefined' ) {\n\t\t\t\t\twidth = this.attribute( 'width' ).toPixels( 'x' );\n\t\t\t\t\theight = this.attribute( 'height' ).toPixels( 'y' );\n\n\t\t\t\t\tvar x = 0;\n\t\t\t\t\tvar y = 0;\n\t\t\t\t\tif ( this.attribute( 'refX' ).hasValue() && this.attribute( 'refY' ).hasValue() ) {\n\t\t\t\t\t\tx = -this.attribute( 'refX' ).toPixels( 'x' );\n\t\t\t\t\t\ty = -this.attribute( 'refY' ).toPixels( 'y' );\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( x, y );\n\t\t\t\t\tctx.lineTo( width, y );\n\t\t\t\t\tctx.lineTo( width, height );\n\t\t\t\t\tctx.lineTo( x, height );\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent( width, height );\n\n\t\t\t\t// viewbox\n\t\t\t\tif ( this.attribute( 'viewBox' ).hasValue() ) {\n\t\t\t\t\tvar viewBox = svg.ToNumberArray( this.attribute( 'viewBox' ).value );\n\t\t\t\t\tvar minX = viewBox[0];\n\t\t\t\t\tvar minY = viewBox[1];\n\t\t\t\t\twidth = viewBox[2];\n\t\t\t\t\theight = viewBox[3];\n\n\t\t\t\t\tsvg.AspectRatio( ctx,\n\t\t\t\t\t\tthis.attribute( 'preserveAspectRatio' ).value,\n\t\t\t\t\t\tsvg.ViewPort.width(),\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tsvg.ViewPort.height(),\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tminX,\n\t\t\t\t\t\tminY,\n\t\t\t\t\t\tthis.attribute( 'refX' ).value,\n\t\t\t\t\t\tthis.attribute( 'refY' ).value );\n\n\t\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t\t\tsvg.ViewPort.SetCurrent( viewBox[2], viewBox[3] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.svg.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// rect element\n\t\tsvg.Element.rect = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar x = this.attribute( 'x' ).toPixels( 'x' );\n\t\t\t\tvar y = this.attribute( 'y' ).toPixels( 'y' );\n\t\t\t\tvar width = this.attribute( 'width' ).toPixels( 'x' );\n\t\t\t\tvar height = this.attribute( 'height' ).toPixels( 'y' );\n\t\t\t\tvar rx = this.attribute( 'rx' ).toPixels( 'x' );\n\t\t\t\tvar ry = this.attribute( 'ry' ).toPixels( 'y' );\n\t\t\t\tif ( this.attribute( 'rx' ).hasValue() && !this.attribute( 'ry' ).hasValue() ) ry = rx;\n\t\t\t\tif ( this.attribute( 'ry' ).hasValue() && !this.attribute( 'rx' ).hasValue() ) rx = ry;\n\t\t\t\trx = Math.min( rx, width / 2.0 );\n\t\t\t\try = Math.min( ry, height / 2.0 );\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( x + rx, y );\n\t\t\t\t\tctx.lineTo( x + width - rx, y );\n\t\t\t\t\tctx.quadraticCurveTo( x + width, y, x + width, y + ry )\n\t\t\t\t\tctx.lineTo( x + width, y + height - ry );\n\t\t\t\t\tctx.quadraticCurveTo( x + width, y + height, x + width - rx, y + height )\n\t\t\t\t\tctx.lineTo( x + rx, y + height );\n\t\t\t\t\tctx.quadraticCurveTo( x, y + height, x, y + height - ry )\n\t\t\t\t\tctx.lineTo( x, y + ry );\n\t\t\t\t\tctx.quadraticCurveTo( x, y, x + rx, y )\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox( x, y, x + width, y + height );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.rect.prototype = new svg.Element.PathElementBase;\n\n\t\t// circle element\n\t\tsvg.Element.circle = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar cx = this.attribute( 'cx' ).toPixels( 'x' );\n\t\t\t\tvar cy = this.attribute( 'cy' ).toPixels( 'y' );\n\t\t\t\tvar r = this.attribute( 'r' ).toPixels();\n\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc( cx, cy, r, 0, Math.PI * 2, true );\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox( cx - r, cy - r, cx + r, cy + r );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.circle.prototype = new svg.Element.PathElementBase;\n\n\t\t// ellipse element\n\t\tsvg.Element.ellipse = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar KAPPA = 4 * ( ( Math.sqrt( 2 ) - 1 ) / 3 );\n\t\t\t\tvar rx = this.attribute( 'rx' ).toPixels( 'x' );\n\t\t\t\tvar ry = this.attribute( 'ry' ).toPixels( 'y' );\n\t\t\t\tvar cx = this.attribute( 'cx' ).toPixels( 'x' );\n\t\t\t\tvar cy = this.attribute( 'cy' ).toPixels( 'y' );\n\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( cx, cy - ry );\n\t\t\t\t\tctx.bezierCurveTo( cx + ( KAPPA * rx ), cy - ry,  cx + rx, cy - ( KAPPA * ry ), cx + rx, cy );\n\t\t\t\t\tctx.bezierCurveTo( cx + rx, cy + ( KAPPA * ry ), cx + ( KAPPA * rx ), cy + ry, cx, cy + ry );\n\t\t\t\t\tctx.bezierCurveTo( cx - ( KAPPA * rx ), cy + ry, cx - rx, cy + ( KAPPA * ry ), cx - rx, cy );\n\t\t\t\t\tctx.bezierCurveTo( cx - rx, cy - ( KAPPA * ry ), cx - ( KAPPA * rx ), cy - ry, cx, cy - ry );\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox( cx - rx, cy - ry, cx + rx, cy + ry );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.ellipse.prototype = new svg.Element.PathElementBase;\n\n\t\t// line element\n\t\tsvg.Element.line = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getPoints = function() {\n\t\t\t\treturn [\n\t\t\t\t\tnew svg.Point( this.attribute( 'x1' ).toPixels( 'x' ), this.attribute( 'y1' ).toPixels( 'y' ) ),\n\t\t\t\t\tnew svg.Point( this.attribute( 'x2' ).toPixels( 'x' ), this.attribute( 'y2' ).toPixels( 'y' ) )];\n\t\t\t}\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar points = this.getPoints();\n\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( points[0].x, points[0].y );\n\t\t\t\t\tctx.lineTo( points[1].x, points[1].y );\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox( points[0].x, points[0].y, points[1].x, points[1].y );\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar points = this.getPoints();\n\t\t\t\tvar a = points[0].angleTo( points[1] );\n\t\t\t\treturn [[points[0], a], [points[1], a]];\n\t\t\t}\n\t\t}\n\t\tsvg.Element.line.prototype = new svg.Element.PathElementBase;\n\n\t\t// polyline element\n\t\tsvg.Element.polyline = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.points = svg.CreatePath( this.attribute( 'points' ).value );\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar bb = new svg.BoundingBox( this.points[0].x, this.points[0].y );\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo( this.points[0].x, this.points[0].y );\n\t\t\t\t}\n\t\t\t\tfor ( var i=1; i<this.points.length; i++ ) {\n\t\t\t\t\tbb.addPoint( this.points[i].x, this.points[i].y );\n\t\t\t\t\tif ( ctx != null ) ctx.lineTo( this.points[i].x, this.points[i].y );\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar markers = [];\n\t\t\t\tfor ( var i=0; i<this.points.length - 1; i++ ) {\n\t\t\t\t\tmarkers.push( [this.points[i], this.points[i].angleTo( this.points[i+1] )] );\n\t\t\t\t}\n\t\t\t\tmarkers.push( [this.points[this.points.length-1], markers[markers.length-1][1]] );\n\t\t\t\treturn markers;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.polyline.prototype = new svg.Element.PathElementBase;\n\n\t\t// polygon element\n\t\tsvg.Element.polygon = function( node ) {\n\t\t\tthis.base = svg.Element.polyline;\n\t\t\tthis.base( node );\n\n\t\t\tthis.basePath = this.path;\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar bb = this.basePath( ctx );\n\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\tctx.lineTo( this.points[0].x, this.points[0].y );\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.polygon.prototype = new svg.Element.polyline;\n\n\t\t// path element\n\t\tsvg.Element.path = function( node ) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tvar d = this.attribute( 'd' ).value;\n\t\t\t// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\t\t\td = d.replace( /,/gm,' ' ); // get rid of all commas\n\t\t\td = d.replace( /([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2' ); // separate commands from commands\n\t\t\td = d.replace( /([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2' ); // separate commands from commands\n\t\t\td = d.replace( /([MmZzLlHhVvCcSsQqTtAa])([^\\s])/gm,'$1 $2' ); // separate commands from points\n\t\t\td = d.replace( /([^\\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2' ); // separate commands from points\n\t\t\td = d.replace( /([0-9])([+\\-])/gm,'$1 $2' ); // separate digits when no comma\n\t\t\td = d.replace( /(\\.[0-9]*)(\\.)/gm,'$1 $2' ); // separate digits when no comma\n\t\t\td = d.replace( /([Aa](\\s+[0-9]+){3})\\s+([01])\\s*([01])/gm,'$1 $3 $4 ' ); // shorthand elliptical arc path syntax\n\t\t\td = svg.compressSpaces( d ); // compress multiple spaces\n\t\t\td = svg.trim( d );\n\t\t\tthis.PathParser = new ( function( d ) {\n\t\t\t\tthis.tokens = d.split( ' ' );\n\n\t\t\t\tthis.reset = function() {\n\t\t\t\t\tthis.i = -1;\n\t\t\t\t\tthis.command = '';\n\t\t\t\t\tthis.previousCommand = '';\n\t\t\t\t\tthis.start = new svg.Point( 0, 0 );\n\t\t\t\t\tthis.control = new svg.Point( 0, 0 );\n\t\t\t\t\tthis.current = new svg.Point( 0, 0 );\n\t\t\t\t\tthis.points = [];\n\t\t\t\t\tthis.angles = [];\n\t\t\t\t}\n\n\t\t\t\tthis.isEnd = function() {\n\t\t\t\t\treturn this.i >= this.tokens.length - 1;\n\t\t\t\t}\n\n\t\t\t\tthis.isCommandOrEnd = function() {\n\t\t\t\t\tif ( this.isEnd() ) return true;\n\t\t\t\t\treturn this.tokens[this.i + 1].match( /^[A-Za-z]$/ ) != null;\n\t\t\t\t}\n\n\t\t\t\tthis.isRelativeCommand = function() {\n\t\t\t\t\tswitch( this.command )\n\t\t\t\t\t{\n\t\t\t\t\tcase 'm':\n\t\t\t\t\tcase 'l':\n\t\t\t\t\tcase 'h':\n\t\t\t\t\tcase 'v':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\tcase 's':\n\t\t\t\t\tcase 'q':\n\t\t\t\t\tcase 't':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis.getToken = function() {\n\t\t\t\t\tthis.i++;\n\t\t\t\t\treturn this.tokens[this.i];\n\t\t\t\t}\n\n\t\t\t\tthis.getScalar = function() {\n\t\t\t\t\treturn parseFloat( this.getToken() );\n\t\t\t\t}\n\n\t\t\t\tthis.nextCommand = function() {\n\t\t\t\t\tthis.previousCommand = this.command;\n\t\t\t\t\tthis.command = this.getToken();\n\t\t\t\t}\n\n\t\t\t\tthis.getPoint = function() {\n\t\t\t\t\tvar p = new svg.Point( this.getScalar(), this.getScalar() );\n\t\t\t\t\treturn this.makeAbsolute( p );\n\t\t\t\t}\n\n\t\t\t\tthis.getAsControlPoint = function() {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.control = p;\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.getAsCurrentPoint = function() {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.current = p;\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.getReflectedControlPoint = function() {\n\t\t\t\t\tif ( this.previousCommand.toLowerCase() != 'c' &&\n\t\t\t\t\t    this.previousCommand.toLowerCase() != 's' &&\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 'q' &&\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 't' ){\n\t\t\t\t\t\treturn this.current;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reflect point\n\t\t\t\t\tvar p = new svg.Point( 2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y );\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.makeAbsolute = function( p ) {\n\t\t\t\t\tif ( this.isRelativeCommand() ) {\n\t\t\t\t\t\tp.x += this.current.x;\n\t\t\t\t\t\tp.y += this.current.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.addMarker = function( p, from, priorTo ) {\n\t\t\t\t\t// if the last angle isn't filled in because we didn't have this point yet ...\n\t\t\t\t\tif ( priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null ) {\n\t\t\t\t\t\tthis.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo( priorTo );\n\t\t\t\t\t}\n\t\t\t\t\tthis.addMarkerAngle( p, from == null ? null : from.angleTo( p ) );\n\t\t\t\t}\n\n\t\t\t\tthis.addMarkerAngle = function( p, a ) {\n\t\t\t\t\tthis.points.push( p );\n\t\t\t\t\tthis.angles.push( a );\n\t\t\t\t}\n\n\t\t\t\tthis.getMarkerPoints = function() { return this.points; }\n\t\t\t\tthis.getMarkerAngles = function() {\n\t\t\t\t\tfor ( var i=0; i<this.angles.length; i++ ) {\n\t\t\t\t\t\tif ( this.angles[i] == null ) {\n\t\t\t\t\t\t\tfor ( var j=i+1; j<this.angles.length; j++ ) {\n\t\t\t\t\t\t\t\tif ( this.angles[j] != null ) {\n\t\t\t\t\t\t\t\t\tthis.angles[i] = this.angles[j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this.angles;\n\t\t\t\t}\n\t\t\t} )( d );\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar pp = this.PathParser;\n\t\t\t\tpp.reset();\n\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tif ( ctx != null ) ctx.beginPath();\n\t\t\t\twhile ( !pp.isEnd() ) {\n\t\t\t\t\tpp.nextCommand();\n\t\t\t\t\tswitch ( pp.command ) {\n\t\t\t\t\tcase 'M':\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\tpp.addMarker( p );\n\t\t\t\t\t\tbb.addPoint( p.x, p.y );\n\t\t\t\t\t\tif ( ctx != null ) ctx.moveTo( p.x, p.y );\n\t\t\t\t\t\tpp.start = pp.current;\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( p, pp.start );\n\t\t\t\t\t\t\tbb.addPoint( p.x, p.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.lineTo( p.x, p.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar c = pp.current;\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( p, c );\n\t\t\t\t\t\t\tbb.addPoint( p.x, p.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.lineTo( p.x, p.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'H':\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar newP = new svg.Point( ( pp.isRelativeCommand() ? pp.current.x : 0 ) + pp.getScalar(), pp.current.y );\n\t\t\t\t\t\t\tpp.addMarker( newP, pp.current );\n\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\tbb.addPoint( pp.current.x, pp.current.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.lineTo( pp.current.x, pp.current.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'V':\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar newP = new svg.Point( pp.current.x, ( pp.isRelativeCommand() ? pp.current.y : 0 ) + pp.getScalar() );\n\t\t\t\t\t\t\tpp.addMarker( newP, pp.current );\n\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\tbb.addPoint( pp.current.x, pp.current.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.lineTo( pp.current.x, pp.current.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar p1 = pp.getPoint();\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( cp, cntrl, p1 );\n\t\t\t\t\t\t\tbb.addBezierCurve( curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.bezierCurveTo( p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar p1 = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( cp, cntrl, p1 );\n\t\t\t\t\t\t\tbb.addBezierCurve( curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.bezierCurveTo( p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( cp, cntrl, cntrl );\n\t\t\t\t\t\t\tbb.addQuadraticCurve( curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.quadraticCurveTo( cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar cntrl = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\tpp.control = cntrl;\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker( cp, cntrl, cntrl );\n\t\t\t\t\t\t\tbb.addQuadraticCurve( curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t\tif ( ctx != null ) ctx.quadraticCurveTo( cntrl.x, cntrl.y, cp.x, cp.y );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\twhile ( !pp.isCommandOrEnd() ) {\n\t\t\t\t\t\t    var curr = pp.current;\n\t\t\t\t\t\t\tvar rx = pp.getScalar();\n\t\t\t\t\t\t\tvar ry = pp.getScalar();\n\t\t\t\t\t\t\tvar xAxisRotation = pp.getScalar() * ( Math.PI / 180.0 );\n\t\t\t\t\t\t\tvar largeArcFlag = pp.getScalar();\n\t\t\t\t\t\t\tvar sweepFlag = pp.getScalar();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\n\t\t\t\t\t\t\t// Conversion from endpoint to center parameterization\n\t\t\t\t\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t\t\t\t\t\t\t// x1', y1'\n\t\t\t\t\t\t\tvar currp = new svg.Point(\n\t\t\t\t\t\t\t\tMath.cos( xAxisRotation ) * ( curr.x - cp.x ) / 2.0 + Math.sin( xAxisRotation ) * ( curr.y - cp.y ) / 2.0,\n\t\t\t\t\t\t\t\t-Math.sin( xAxisRotation ) * ( curr.x - cp.x ) / 2.0 + Math.cos( xAxisRotation ) * ( curr.y - cp.y ) / 2.0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t// adjust radii\n\t\t\t\t\t\t\tvar l = Math.pow( currp.x,2 )/Math.pow( rx,2 )+Math.pow( currp.y,2 )/Math.pow( ry,2 );\n\t\t\t\t\t\t\tif ( l > 1 ) {\n\t\t\t\t\t\t\t\trx *= Math.sqrt( l );\n\t\t\t\t\t\t\t\try *= Math.sqrt( l );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// cx', cy'\n\t\t\t\t\t\t\tvar s = ( largeArcFlag == sweepFlag ? -1 : 1 ) * Math.sqrt(\n\t\t\t\t\t\t\t\t( ( Math.pow( rx,2 )*Math.pow( ry,2 ) )-( Math.pow( rx,2 )*Math.pow( currp.y,2 ) )-( Math.pow( ry,2 )*Math.pow( currp.x,2 ) ) ) /\n\t\t\t\t\t\t\t\t( Math.pow( rx,2 )*Math.pow( currp.y,2 )+Math.pow( ry,2 )*Math.pow( currp.x,2 ) )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif ( isNaN( s ) ) s = 0;\n\t\t\t\t\t\t\tvar cpp = new svg.Point( s * rx * currp.y / ry, s * -ry * currp.x / rx );\n\t\t\t\t\t\t\t// cx, cy\n\t\t\t\t\t\t\tvar centp = new svg.Point(\n\t\t\t\t\t\t\t\t( curr.x + cp.x ) / 2.0 + Math.cos( xAxisRotation ) * cpp.x - Math.sin( xAxisRotation ) * cpp.y,\n\t\t\t\t\t\t\t\t( curr.y + cp.y ) / 2.0 + Math.sin( xAxisRotation ) * cpp.x + Math.cos( xAxisRotation ) * cpp.y\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t// vector magnitude\n\t\t\t\t\t\t\tvar m = function( v ) { return Math.sqrt( Math.pow( v[0],2 ) + Math.pow( v[1],2 ) ); }\n\t\t\t\t\t\t\t// ratio between two vectors\n\t\t\t\t\t\t\tvar r = function( u, v ) { return ( u[0]*v[0]+u[1]*v[1] ) / ( m( u )*m( v ) ) }\n\t\t\t\t\t\t\t// angle between two vectors\n\t\t\t\t\t\t\tvar a = function( u, v ) { return ( u[0]*v[1] < u[1]*v[0] ? -1 : 1 ) * Math.acos( r( u,v ) ); }\n\t\t\t\t\t\t\t// initial angle\n\t\t\t\t\t\t\tvar a1 = a( [1,0], [( currp.x-cpp.x )/rx,( currp.y-cpp.y )/ry] );\n\t\t\t\t\t\t\t// angle delta\n\t\t\t\t\t\t\tvar u = [( currp.x-cpp.x )/rx,( currp.y-cpp.y )/ry];\n\t\t\t\t\t\t\tvar v = [( -currp.x-cpp.x )/rx,( -currp.y-cpp.y )/ry];\n\t\t\t\t\t\t\tvar ad = a( u, v );\n\t\t\t\t\t\t\tif ( r( u,v ) <= -1 ) ad = Math.PI;\n\t\t\t\t\t\t\tif ( r( u,v ) >= 1 ) ad = 0;\n\n\t\t\t\t\t\t\t// for markers\n\t\t\t\t\t\t\tvar dir = 1 - sweepFlag ? 1.0 : -1.0;\n\t\t\t\t\t\t\tvar ah = a1 + dir * ( ad / 2.0 );\n\t\t\t\t\t\t\tvar halfWay = new svg.Point(\n\t\t\t\t\t\t\t\tcentp.x + rx * Math.cos( ah ),\n\t\t\t\t\t\t\t\tcentp.y + ry * Math.sin( ah )\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tpp.addMarkerAngle( halfWay, ah - dir * Math.PI / 2 );\n\t\t\t\t\t\t\tpp.addMarkerAngle( cp, ah - dir * Math.PI );\n\n\t\t\t\t\t\t\tbb.addPoint( cp.x, cp.y ); // TODO: this is too naive, make it better\n\t\t\t\t\t\t\tif ( ctx != null ) {\n\t\t\t\t\t\t\t\tvar r = rx > ry ? rx : ry;\n\t\t\t\t\t\t\t\tvar sx = rx > ry ? 1 : rx / ry;\n\t\t\t\t\t\t\t\tvar sy = rx > ry ? ry / rx : 1;\n\n\t\t\t\t\t\t\t\tctx.translate( centp.x, centp.y );\n\t\t\t\t\t\t\t\tctx.rotate( xAxisRotation );\n\t\t\t\t\t\t\t\tctx.scale( sx, sy );\n\t\t\t\t\t\t\t\tctx.arc( 0, 0, r, a1, a1 + ad, 1 - sweepFlag );\n\t\t\t\t\t\t\t\tctx.scale( 1/sx, 1/sy );\n\t\t\t\t\t\t\t\tctx.rotate( -xAxisRotation );\n\t\t\t\t\t\t\t\tctx.translate( -centp.x, -centp.y );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tif ( ctx != null ) ctx.closePath();\n\t\t\t\t\t\tpp.current = pp.start;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn bb;\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar points = this.PathParser.getMarkerPoints();\n\t\t\t\tvar angles = this.PathParser.getMarkerAngles();\n\n\t\t\t\tvar markers = [];\n\t\t\t\tfor ( var i=0; i<points.length; i++ ) {\n\t\t\t\t\tmarkers.push( [points[i], angles[i]] );\n\t\t\t\t}\n\t\t\t\treturn markers;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.path.prototype = new svg.Element.PathElementBase;\n\n\t\t// pattern element\n\t\tsvg.Element.pattern = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.createPattern = function( ctx, element ) {\n\t\t\t\tvar width = this.attribute( 'width' ).toPixels( 'x', true );\n\t\t\t\tvar height = this.attribute( 'height' ).toPixels( 'y', true );\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property( 'viewBox', this.attribute( 'viewBox' ).value );\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property( 'width', width + 'px' );\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property( 'height', height + 'px' );\n\t\t\t\ttempSvg.attributes['transform'] = new svg.Property( 'transform', this.attribute( 'patternTransform' ).value );\n\t\t\t\ttempSvg.children = this.children;\n\n\t\t\t\tvar c = document.createElement( 'canvas' );\n\t\t\t\tc.width = width;\n\t\t\t\tc.height = height;\n\t\t\t\tvar cctx = c.getContext( '2d' );\n\t\t\t\tif ( this.attribute( 'x' ).hasValue() && this.attribute( 'y' ).hasValue() ) {\n\t\t\t\t\tcctx.translate( this.attribute( 'x' ).toPixels( 'x', true ), this.attribute( 'y' ).toPixels( 'y', true ) );\n\t\t\t\t}\n\t\t\t\t// render 3x3 grid so when we transform there's no white space on edges\n\t\t\t\tfor ( var x=-1; x<=1; x++ ) {\n\t\t\t\t\tfor ( var y=-1; y<=1; y++ ) {\n\t\t\t\t\t\tcctx.save();\n\t\t\t\t\t\tcctx.translate( x * c.width, y * c.height );\n\t\t\t\t\t\ttempSvg.render( cctx );\n\t\t\t\t\t\tcctx.restore();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar pattern = ctx.createPattern( c, 'repeat' );\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.pattern.prototype = new svg.Element.ElementBase;\n\n\t\t// marker element\n\t\tsvg.Element.marker = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.baseRender = this.render;\n\t\t\tthis.render = function( ctx, point, angle ) {\n\t\t\t\tctx.translate( point.x, point.y );\n\t\t\t\tif ( this.attribute( 'orient' ).valueOrDefault( 'auto' ) == 'auto' ) ctx.rotate( angle );\n\t\t\t\tif ( this.attribute( 'markerUnits' ).valueOrDefault( 'strokeWidth' ) == 'strokeWidth' ) ctx.scale( ctx.lineWidth, ctx.lineWidth );\n\t\t\t\tctx.save();\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property( 'viewBox', this.attribute( 'viewBox' ).value );\n\t\t\t\ttempSvg.attributes['refX'] = new svg.Property( 'refX', this.attribute( 'refX' ).value );\n\t\t\t\ttempSvg.attributes['refY'] = new svg.Property( 'refY', this.attribute( 'refY' ).value );\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property( 'width', this.attribute( 'markerWidth' ).value );\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property( 'height', this.attribute( 'markerHeight' ).value );\n\t\t\t\ttempSvg.attributes['fill'] = new svg.Property( 'fill', this.attribute( 'fill' ).valueOrDefault( 'black' ) );\n\t\t\t\ttempSvg.attributes['stroke'] = new svg.Property( 'stroke', this.attribute( 'stroke' ).valueOrDefault( 'none' ) );\n\t\t\t\ttempSvg.children = this.children;\n\t\t\t\ttempSvg.render( ctx );\n\n\t\t\t\tctx.restore();\n\t\t\t\tif ( this.attribute( 'markerUnits' ).valueOrDefault( 'strokeWidth' ) == 'strokeWidth' ) ctx.scale( 1/ctx.lineWidth, 1/ctx.lineWidth );\n\t\t\t\tif ( this.attribute( 'orient' ).valueOrDefault( 'auto' ) == 'auto' ) ctx.rotate( -angle );\n\t\t\t\tctx.translate( -point.x, -point.y );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.marker.prototype = new svg.Element.ElementBase;\n\n\t\t// definitions element\n\t\tsvg.Element.defs = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.render = function( ctx ) {\n\t\t\t\t// NOOP\n\t\t\t}\n\t\t}\n\t\tsvg.Element.defs.prototype = new svg.Element.ElementBase;\n\n\t\t// base for gradients\n\t\tsvg.Element.GradientBase = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.gradientUnits = this.attribute( 'gradientUnits' ).valueOrDefault( 'objectBoundingBox' );\n\n\t\t\tthis.stops = [];\n\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif ( child.type == 'stop' ) this.stops.push( child );\n\t\t\t}\n\n\t\t\tthis.getGradient = function() {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\tthis.createGradient = function( ctx, element, parentOpacityProp ) {\n\t\t\t\tvar stopsContainer = this;\n\t\t\t\tif ( this.getHrefAttribute().hasValue() ) {\n\t\t\t\t\tstopsContainer = this.getHrefAttribute().getDefinition();\n\t\t\t\t}\n\n\t\t\t\tvar addParentOpacity = function ( color ) {\n\t\t\t\t\tif ( parentOpacityProp.hasValue() ) {\n\t\t\t\t\t\tvar p = new svg.Property( 'color', color );\n\t\t\t\t\t\treturn p.addOpacity( parentOpacityProp.value ).value;\n\t\t\t\t\t}\n\t\t\t\t\treturn color;\n\t\t\t\t};\n\n\t\t\t\tvar g = this.getGradient( ctx, element );\n\t\t\t\tif ( g == null ) return addParentOpacity( stopsContainer.stops[stopsContainer.stops.length - 1].color );\n\t\t\t\tfor ( var i=0; i<stopsContainer.stops.length; i++ ) {\n\t\t\t\t\tg.addColorStop( stopsContainer.stops[i].offset, addParentOpacity( stopsContainer.stops[i].color ) );\n\t\t\t\t}\n\n\t\t\t\tif ( this.attribute( 'gradientTransform' ).hasValue() ) {\n\t\t\t\t\t// render as transformed pattern on temporary canvas\n\t\t\t\t\tvar rootView = svg.ViewPort.viewPorts[0];\n\n\t\t\t\t\tvar rect = new svg.Element.rect();\n\t\t\t\t\trect.attributes['x'] = new svg.Property( 'x', -svg.MAX_VIRTUAL_PIXELS/3.0 );\n\t\t\t\t\trect.attributes['y'] = new svg.Property( 'y', -svg.MAX_VIRTUAL_PIXELS/3.0 );\n\t\t\t\t\trect.attributes['width'] = new svg.Property( 'width', svg.MAX_VIRTUAL_PIXELS );\n\t\t\t\t\trect.attributes['height'] = new svg.Property( 'height', svg.MAX_VIRTUAL_PIXELS );\n\n\t\t\t\t\tvar group = new svg.Element.g();\n\t\t\t\t\tgroup.attributes['transform'] = new svg.Property( 'transform', this.attribute( 'gradientTransform' ).value );\n\t\t\t\t\tgroup.children = [ rect ];\n\n\t\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property( 'x', 0 );\n\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property( 'y', 0 );\n\t\t\t\t\ttempSvg.attributes['width'] = new svg.Property( 'width', rootView.width );\n\t\t\t\t\ttempSvg.attributes['height'] = new svg.Property( 'height', rootView.height );\n\t\t\t\t\ttempSvg.children = [ group ];\n\n\t\t\t\t\tvar c = document.createElement( 'canvas' );\n\t\t\t\t\tc.width = rootView.width;\n\t\t\t\t\tc.height = rootView.height;\n\t\t\t\t\tvar tempCtx = c.getContext( '2d' );\n\t\t\t\t\ttempCtx.fillStyle = g;\n\t\t\t\t\ttempSvg.render( tempCtx );\n\t\t\t\t\treturn tempCtx.createPattern( c, 'no-repeat' );\n\t\t\t\t}\n\n\t\t\t\treturn g;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.GradientBase.prototype = new svg.Element.ElementBase;\n\n\t\t// linear gradient element\n\t\tsvg.Element.linearGradient = function( node ) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getGradient = function( ctx, element ) {\n\t\t\t\tvar bb = element.getBoundingBox();\n\n\t\t\t\tif ( !this.attribute( 'x1' ).hasValue()\n\t\t\t\t && !this.attribute( 'y1' ).hasValue()\n\t\t\t\t && !this.attribute( 'x2' ).hasValue()\n\t\t\t\t && !this.attribute( 'y2' ).hasValue() ) {\n\t\t\t\t\tthis.attribute( 'x1', true ).value = 0;\n\t\t\t\t\tthis.attribute( 'y1', true ).value = 0;\n\t\t\t\t\tthis.attribute( 'x2', true ).value = 1;\n\t\t\t\t\tthis.attribute( 'y2', true ).value = 0;\n\t\t\t\t }\n\n\t\t\t\tvar x1 = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute( 'x1' ).numValue()\n\t\t\t\t\t: this.attribute( 'x1' ).toPixels( 'x' ) );\n\t\t\t\tvar y1 = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute( 'y1' ).numValue()\n\t\t\t\t\t: this.attribute( 'y1' ).toPixels( 'y' ) );\n\t\t\t\tvar x2 = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute( 'x2' ).numValue()\n\t\t\t\t\t: this.attribute( 'x2' ).toPixels( 'x' ) );\n\t\t\t\tvar y2 = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute( 'y2' ).numValue()\n\t\t\t\t\t: this.attribute( 'y2' ).toPixels( 'y' ) );\n\n\t\t\t\tif ( x1 == x2 && y1 == y2 ) return null;\n\t\t\t\treturn ctx.createLinearGradient( x1, y1, x2, y2 );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.linearGradient.prototype = new svg.Element.GradientBase;\n\n\t\t// radial gradient element\n\t\tsvg.Element.radialGradient = function( node ) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getGradient = function( ctx, element ) {\n\t\t\t\tvar bb = element.getBoundingBox();\n\n\t\t\t\tif ( !this.attribute( 'cx' ).hasValue() ) this.attribute( 'cx', true ).value = '50%';\n\t\t\t\tif ( !this.attribute( 'cy' ).hasValue() ) this.attribute( 'cy', true ).value = '50%';\n\t\t\t\tif ( !this.attribute( 'r' ).hasValue() ) this.attribute( 'r', true ).value = '50%';\n\n\t\t\t\tvar cx = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute( 'cx' ).numValue()\n\t\t\t\t\t: this.attribute( 'cx' ).toPixels( 'x' ) );\n\t\t\t\tvar cy = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute( 'cy' ).numValue()\n\t\t\t\t\t: this.attribute( 'cy' ).toPixels( 'y' ) );\n\n\t\t\t\tvar fx = cx;\n\t\t\t\tvar fy = cy;\n\t\t\t\tif ( this.attribute( 'fx' ).hasValue() ) {\n\t\t\t\t\tfx = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t\t? bb.x() + bb.width() * this.attribute( 'fx' ).numValue()\n\t\t\t\t\t\t: this.attribute( 'fx' ).toPixels( 'x' ) );\n\t\t\t\t}\n\t\t\t\tif ( this.attribute( 'fy' ).hasValue() ) {\n\t\t\t\t\tfy = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t\t? bb.y() + bb.height() * this.attribute( 'fy' ).numValue()\n\t\t\t\t\t\t: this.attribute( 'fy' ).toPixels( 'y' ) );\n\t\t\t\t}\n\n\t\t\t\tvar r = ( this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? ( bb.width() + bb.height() ) / 2.0 * this.attribute( 'r' ).numValue()\n\t\t\t\t\t: this.attribute( 'r' ).toPixels() );\n\n\t\t\t\treturn ctx.createRadialGradient( fx, fy, 0, cx, cy, r );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.radialGradient.prototype = new svg.Element.GradientBase;\n\n\t\t// gradient stop element\n\t\tsvg.Element.stop = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.offset = this.attribute( 'offset' ).numValue();\n\t\t\tif ( this.offset < 0 ) this.offset = 0;\n\t\t\tif ( this.offset > 1 ) this.offset = 1;\n\n\t\t\tvar stopColor = this.style( 'stop-color' );\n\t\t\tif ( this.style( 'stop-opacity' ).hasValue() ) stopColor = stopColor.addOpacity( this.style( 'stop-opacity' ).value );\n\t\t\tthis.color = stopColor.value;\n\t\t}\n\t\tsvg.Element.stop.prototype = new svg.Element.ElementBase;\n\n\t\t// animation base element\n\t\tsvg.Element.AnimateBase = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tsvg.Animations.push( this );\n\n\t\t\tthis.duration = 0.0;\n\t\t\tthis.begin = this.attribute( 'begin' ).toMilliseconds();\n\t\t\tthis.maxDuration = this.begin + this.attribute( 'dur' ).toMilliseconds();\n\n\t\t\tthis.getProperty = function() {\n\t\t\t\tvar attributeType = this.attribute( 'attributeType' ).value;\n\t\t\t\tvar attributeName = this.attribute( 'attributeName' ).value;\n\n\t\t\t\tif ( attributeType == 'CSS' ) {\n\t\t\t\t\treturn this.parent.style( attributeName, true );\n\t\t\t\t}\n\t\t\t\treturn this.parent.attribute( attributeName, true );\n\t\t\t};\n\n\t\t\tthis.initialValue = null;\n\t\t\tthis.initialUnits = '';\n\t\t\tthis.removed = false;\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tthis.update = function( delta ) {\n\t\t\t\t// set initial value\n\t\t\t\tif ( this.initialValue == null ) {\n\t\t\t\t\tthis.initialValue = this.getProperty().value;\n\t\t\t\t\tthis.initialUnits = this.getProperty().getUnits();\n\t\t\t\t}\n\n\t\t\t\t// if we're past the end time\n\t\t\t\tif ( this.duration > this.maxDuration ) {\n\t\t\t\t\t// loop for indefinitely repeating animations\n\t\t\t\t\tif ( this.attribute( 'repeatCount' ).value == 'indefinite'\n\t\t\t\t\t || this.attribute( 'repeatDur' ).value == 'indefinite' ) {\n\t\t\t\t\t\tthis.duration = 0.0\n\t\t\t\t\t}\n\t\t\t\t\telse if ( this.attribute( 'fill' ).valueOrDefault( 'remove' ) == 'remove' && !this.removed ) {\n\t\t\t\t\t\tthis.removed = true;\n\t\t\t\t\t\tthis.getProperty().value = this.initialValue;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false; // no updates made\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.duration = this.duration + delta;\n\n\t\t\t\t// if we're past the begin time\n\t\t\t\tvar updated = false;\n\t\t\t\tif ( this.begin < this.duration ) {\n\t\t\t\t\tvar newValue = this.calcValue(); // tween\n\n\t\t\t\t\tif ( this.attribute( 'type' ).hasValue() ) {\n\t\t\t\t\t\t// for transform, etc.\n\t\t\t\t\t\tvar type = this.attribute( 'type' ).value;\n\t\t\t\t\t\tnewValue = type + '(' + newValue + ')';\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.getProperty().value = newValue;\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\n\t\t\t\treturn updated;\n\t\t\t}\n\n\t\t\tthis.from = this.attribute( 'from' );\n\t\t\tthis.to = this.attribute( 'to' );\n\t\t\tthis.values = this.attribute( 'values' );\n\t\t\tif ( this.values.hasValue() ) this.values.value = this.values.value.split( ';' );\n\n\t\t\t// fraction of duration we've covered\n\t\t\tthis.progress = function() {\n\t\t\t\tvar ret = { progress: ( this.duration - this.begin ) / ( this.maxDuration - this.begin ) };\n\t\t\t\tif ( this.values.hasValue() ) {\n\t\t\t\t\tvar p = ret.progress * ( this.values.value.length - 1 );\n\t\t\t\t\tvar lb = Math.floor( p ), ub = Math.ceil( p );\n\t\t\t\t\tret.from = new svg.Property( 'from', parseFloat( this.values.value[lb] ) );\n\t\t\t\t\tret.to = new svg.Property( 'to', parseFloat( this.values.value[ub] ) );\n\t\t\t\t\tret.progress = ( p - lb ) / ( ub - lb );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.from = this.from;\n\t\t\t\t\tret.to = this.to;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.AnimateBase.prototype = new svg.Element.ElementBase;\n\n\t\t// animate element\n\t\tsvg.Element.animate = function( node ) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar newValue = p.from.numValue() + ( p.to.numValue() - p.from.numValue() ) * p.progress;\n\t\t\t\treturn newValue + this.initialUnits;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animate.prototype = new svg.Element.AnimateBase;\n\n\t\t// animate color element\n\t\tsvg.Element.animateColor = function( node ) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\t\t\t\tvar from = new RGBColor( p.from.value );\n\t\t\t\tvar to = new RGBColor( p.to.value );\n\n\t\t\t\tif ( from.ok && to.ok ) {\n\t\t\t\t\t// tween color linearly\n\t\t\t\t\tvar r = from.r + ( to.r - from.r ) * p.progress;\n\t\t\t\t\tvar g = from.g + ( to.g - from.g ) * p.progress;\n\t\t\t\t\tvar b = from.b + ( to.b - from.b ) * p.progress;\n\t\t\t\t\treturn 'rgb('+parseInt( r,10 )+','+parseInt( g,10 )+','+parseInt( b,10 )+')';\n\t\t\t\t}\n\t\t\t\treturn this.attribute( 'from' ).value;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animateColor.prototype = new svg.Element.AnimateBase;\n\n\t\t// animate transform element\n\t\tsvg.Element.animateTransform = function( node ) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar from = svg.ToNumberArray( p.from.value );\n\t\t\t\tvar to = svg.ToNumberArray( p.to.value );\n\t\t\t\tvar newValue = '';\n\t\t\t\tfor ( var i=0; i<from.length; i++ ) {\n\t\t\t\t\tnewValue += from[i] + ( to[i] - from[i] ) * p.progress + ' ';\n\t\t\t\t}\n\t\t\t\treturn newValue;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animateTransform.prototype = new svg.Element.animate;\n\n\t\t// font element\n\t\tsvg.Element.font = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.horizAdvX = this.attribute( 'horiz-adv-x' ).numValue();\n\n\t\t\tthis.isRTL = false;\n\t\t\tthis.isArabic = false;\n\t\t\tthis.fontFace = null;\n\t\t\tthis.missingGlyph = null;\n\t\t\tthis.glyphs = [];\n\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif ( child.type == 'font-face' ) {\n\t\t\t\t\tthis.fontFace = child;\n\t\t\t\t\tif ( child.style( 'font-family' ).hasValue() ) {\n\t\t\t\t\t\tsvg.Definitions[child.style( 'font-family' ).value] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if ( child.type == 'missing-glyph' ) this.missingGlyph = child;\n\t\t\t\telse if ( child.type == 'glyph' ) {\n\t\t\t\t\tif ( child.arabicForm != '' ) {\n\t\t\t\t\t\tthis.isRTL = true;\n\t\t\t\t\t\tthis.isArabic = true;\n\t\t\t\t\t\tif ( typeof( this.glyphs[child.unicode] ) == 'undefined' ) this.glyphs[child.unicode] = [];\n\t\t\t\t\t\tthis.glyphs[child.unicode][child.arabicForm] = child;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.glyphs[child.unicode] = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.font.prototype = new svg.Element.ElementBase;\n\n\t\t// font-face element\n\t\tsvg.Element.fontface = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.ascent = this.attribute( 'ascent' ).value;\n\t\t\tthis.descent = this.attribute( 'descent' ).value;\n\t\t\tthis.unitsPerEm = this.attribute( 'units-per-em' ).numValue();\n\t\t}\n\t\tsvg.Element.fontface.prototype = new svg.Element.ElementBase;\n\n\t\t// missing-glyph element\n\t\tsvg.Element.missingglyph = function( node ) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base( node );\n\n\t\t\tthis.horizAdvX = 0;\n\t\t}\n\t\tsvg.Element.missingglyph.prototype = new svg.Element.path;\n\n\t\t// glyph element\n\t\tsvg.Element.glyph = function( node ) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base( node );\n\n\t\t\tthis.horizAdvX = this.attribute( 'horiz-adv-x' ).numValue();\n\t\t\tthis.unicode = this.attribute( 'unicode' ).value;\n\t\t\tthis.arabicForm = this.attribute( 'arabic-form' ).value;\n\t\t}\n\t\tsvg.Element.glyph.prototype = new svg.Element.path;\n\n\t\t// text element\n\t\tsvg.Element.text = function( node ) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\tthis.baseSetContext( ctx );\n\t\t\t\tif ( this.style( 'dominant-baseline' ).hasValue() ) ctx.textBaseline = this.style( 'dominant-baseline' ).value;\n\t\t\t\tif ( this.style( 'alignment-baseline' ).hasValue() ) ctx.textBaseline = this.style( 'alignment-baseline' ).value;\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\t// TODO: implement\n\t\t\t\treturn new svg.BoundingBox( this.attribute( 'x' ).toPixels( 'x' ), this.attribute( 'y' ).toPixels( 'y' ), 0, 0 );\n\t\t\t}\n\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tthis.x = this.attribute( 'x' ).toPixels( 'x' );\n\t\t\t\tthis.y = this.attribute( 'y' ).toPixels( 'y' );\n\t\t\t\tthis.x += this.getAnchorDelta( ctx, this, 0 );\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tthis.renderChild( ctx, this, i );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getAnchorDelta = function ( ctx, parent, startI ) {\n\t\t\t\tvar textAnchor = this.style( 'text-anchor' ).valueOrDefault( 'start' );\n\t\t\t\tif ( textAnchor != 'start' ) {\n\t\t\t\t\tvar width = 0;\n\t\t\t\t\tfor ( var i=startI; i<parent.children.length; i++ ) {\n\t\t\t\t\t\tvar child = parent.children[i];\n\t\t\t\t\t\tif ( i > startI && child.attribute( 'x' ).hasValue() ) break; // new group\n\t\t\t\t\t\twidth += child.measureTextRecursive( ctx );\n\t\t\t\t\t}\n\t\t\t\t\treturn -1 * ( textAnchor == 'end' ? width : width / 2.0 );\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tthis.renderChild = function( ctx, parent, i ) {\n\t\t\t\tvar child = parent.children[i];\n\t\t\t\tif ( child.attribute( 'x' ).hasValue() ) {\n\t\t\t\t\tchild.x = child.attribute( 'x' ).toPixels( 'x' ) + this.getAnchorDelta( ctx, parent, i );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( this.attribute( 'dx' ).hasValue() ) this.x += this.attribute( 'dx' ).toPixels( 'x' );\n\t\t\t\t\tif ( child.attribute( 'dx' ).hasValue() ) this.x += child.attribute( 'dx' ).toPixels( 'x' );\n\t\t\t\t\tchild.x = this.x;\n\t\t\t\t}\n\t\t\t\tthis.x = child.x + child.measureText( ctx );\n\n\t\t\t\tif ( child.attribute( 'y' ).hasValue() ) {\n\t\t\t\t\tchild.y = child.attribute( 'y' ).toPixels( 'y' );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif ( this.attribute( 'dy' ).hasValue() ) this.y += this.attribute( 'dy' ).toPixels( 'y' );\n\t\t\t\t\tif ( child.attribute( 'dy' ).hasValue() ) this.y += child.attribute( 'dy' ).toPixels( 'y' );\n\t\t\t\t\tchild.y = this.y;\n\t\t\t\t}\n\t\t\t\tthis.y = child.y;\n\n\t\t\t\tchild.render( ctx );\n\n\t\t\t\tfor ( var i=0; i<child.children.length; i++ ) {\n\t\t\t\t\tthis.renderChild( ctx, child, i );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.text.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// text base\n\t\tsvg.Element.TextElementBase = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getGlyph = function( font, text, i ) {\n\t\t\t\tvar c = text[i];\n\t\t\t\tvar glyph = null;\n\t\t\t\tif ( font.isArabic ) {\n\t\t\t\t\tvar arabicForm = 'isolated';\n\t\t\t\t\tif ( ( i==0 || text[i-1]==' ' ) && i<text.length-2 && text[i+1]!=' ' ) arabicForm = 'terminal';\n\t\t\t\t\tif ( i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ' ) arabicForm = 'medial';\n\t\t\t\t\tif ( i>0 && text[i-1]!=' ' && ( i == text.length-1 || text[i+1]==' ' ) ) arabicForm = 'initial';\n\t\t\t\t\tif ( typeof( font.glyphs[c] ) != 'undefined' ) {\n\t\t\t\t\t\tglyph = font.glyphs[c][arabicForm];\n\t\t\t\t\t\tif ( glyph == null && font.glyphs[c].type == 'glyph' ) glyph = font.glyphs[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tglyph = font.glyphs[c];\n\t\t\t\t}\n\t\t\t\tif ( glyph == null ) glyph = font.missingGlyph;\n\t\t\t\treturn glyph;\n\t\t\t}\n\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tvar customFont = this.parent.style( 'font-family' ).getDefinition();\n\t\t\t\tif ( customFont != null ) {\n\t\t\t\t\tvar fontSize = this.parent.style( 'font-size' ).numValueOrDefault( svg.Font.Parse( svg.ctx.font ).fontSize );\n\t\t\t\t\tvar fontStyle = this.parent.style( 'font-style' ).valueOrDefault( svg.Font.Parse( svg.ctx.font ).fontStyle );\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif ( customFont.isRTL ) text = text.split( \"\" ).reverse().join( \"\" );\n\n\t\t\t\t\tvar dx = svg.ToNumberArray( this.parent.attribute( 'dx' ).value );\n\t\t\t\t\tfor ( var i=0; i<text.length; i++ ) {\n\t\t\t\t\t\tvar glyph = this.getGlyph( customFont, text, i );\n\t\t\t\t\t\tvar scale = fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tctx.translate( this.x, this.y );\n\t\t\t\t\t\tctx.scale( scale, -scale );\n\t\t\t\t\t\tvar lw = ctx.lineWidth;\n\t\t\t\t\t\tctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;\n\t\t\t\t\t\tif ( fontStyle == 'italic' ) ctx.transform( 1, 0, .4, 1, 0, 0 );\n\t\t\t\t\t\tglyph.render( ctx );\n\t\t\t\t\t\tif ( fontStyle == 'italic' ) ctx.transform( 1, 0, -.4, 1, 0, 0 );\n\t\t\t\t\t\tctx.lineWidth = lw;\n\t\t\t\t\t\tctx.scale( 1/scale, -1/scale );\n\t\t\t\t\t\tctx.translate( -this.x, -this.y );\n\n\t\t\t\t\t\tthis.x += fontSize * ( glyph.horizAdvX || customFont.horizAdvX ) / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif ( typeof( dx[i] ) != 'undefined' && !isNaN( dx[i] ) ) {\n\t\t\t\t\t\t\tthis.x += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif ( ctx.fillStyle != '' ) ctx.fillText( svg.compressSpaces( this.getText() ), this.x, this.y );\n\t\t\t\tif ( ctx.strokeStyle != '' ) ctx.strokeText( svg.compressSpaces( this.getText() ), this.x, this.y );\n\t\t\t}\n\n\t\t\tthis.getText = function() {\n\t\t\t\t// OVERRIDE ME\n\t\t\t}\n\n\t\t\tthis.measureTextRecursive = function( ctx ) {\n\t\t\t\tvar width = this.measureText( ctx );\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\twidth += this.children[i].measureTextRecursive( ctx );\n\t\t\t\t}\n\t\t\t\treturn width;\n\t\t\t}\n\n\t\t\tthis.measureText = function( ctx ) {\n\t\t\t\tvar customFont = this.parent.style( 'font-family' ).getDefinition();\n\t\t\t\tif ( customFont != null ) {\n\t\t\t\t\tvar fontSize = this.parent.style( 'font-size' ).numValueOrDefault( svg.Font.Parse( svg.ctx.font ).fontSize );\n\t\t\t\t\tvar measure = 0;\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif ( customFont.isRTL ) text = text.split( \"\" ).reverse().join( \"\" );\n\t\t\t\t\tvar dx = svg.ToNumberArray( this.parent.attribute( 'dx' ).value );\n\t\t\t\t\tfor ( var i=0; i<text.length; i++ ) {\n\t\t\t\t\t\tvar glyph = this.getGlyph( customFont, text, i );\n\t\t\t\t\t\tmeasure += ( glyph.horizAdvX || customFont.horizAdvX ) * fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif ( typeof( dx[i] ) != 'undefined' && !isNaN( dx[i] ) ) {\n\t\t\t\t\t\t\tmeasure += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn measure;\n\t\t\t\t}\n\n\t\t\t\tvar textToMeasure = svg.compressSpaces( this.getText() );\n\t\t\t\tif ( !ctx.measureText ) return textToMeasure.length * 10;\n\n\t\t\t\tctx.save();\n\t\t\t\tthis.setContext( ctx );\n\t\t\t\tvar width = ctx.measureText( textToMeasure ).width;\n\t\t\t\tctx.restore();\n\t\t\t\treturn width;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// tspan\n\t\tsvg.Element.tspan = function( node ) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.text = node.nodeValue || node.text || '';\n\t\t\tthis.getText = function() {\n\t\t\t\treturn this.text;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.tspan.prototype = new svg.Element.TextElementBase;\n\n\t\t// tref\n\t\tsvg.Element.tref = function( node ) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getText = function() {\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\t\t\t\tif ( element != null ) return element.children[0].getText();\n\t\t\t}\n\t\t}\n\t\tsvg.Element.tref.prototype = new svg.Element.TextElementBase;\n\n\t\t// a element\n\t\tsvg.Element.a = function( node ) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.hasText = true;\n\t\t\tfor ( var i=0; i<node.childNodes.length; i++ ) {\n\t\t\t\tif ( node.childNodes[i].nodeType != 3 ) this.hasText = false;\n\t\t\t}\n\n\t\t\t// this might contain text\n\t\t\tthis.text = this.hasText ? node.childNodes[0].nodeValue : '';\n\t\t\tthis.getText = function() {\n\t\t\t\treturn this.text;\n\t\t\t}\n\n\t\t\tthis.baseRenderChildren = this.renderChildren;\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tif ( this.hasText ) {\n\t\t\t\t\t// render as text element\n\t\t\t\t\tthis.baseRenderChildren( ctx );\n\t\t\t\t\tvar fontSize = new svg.Property( 'fontSize', svg.Font.Parse( svg.ctx.font ).fontSize );\n\t\t\t\t\tsvg.Mouse.checkBoundingBox( this, new svg.BoundingBox( this.x, this.y - fontSize.toPixels( 'y' ), this.x + this.measureText( ctx ), this.y ) );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// render as temporary group\n\t\t\t\t\tvar g = new svg.Element.g();\n\t\t\t\t\tg.children = this.children;\n\t\t\t\t\tg.parent = this;\n\t\t\t\t\tg.render( ctx );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onclick = function() {\n\t\t\t\twindow.open( this.getHrefAttribute().value );\n\t\t\t}\n\n\t\t\tthis.onmousemove = function() {\n\t\t\t\tsvg.ctx.canvas.style.cursor = 'pointer';\n\t\t\t}\n\t\t}\n\t\tsvg.Element.a.prototype = new svg.Element.TextElementBase;\n\n\t\t// image element\n\t\tsvg.Element.image = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tvar href = this.getHrefAttribute().value;\n\t\t\tvar isSvg = href.match( /\\.svg$/ )\n\n\t\t\tsvg.Images.push( this );\n\t\t\tthis.loaded = false;\n\t\t\tif ( !isSvg ) {\n\t\t\t\tthis.img = document.createElement( 'img' );\n\t\t\t\tvar self = this;\n\t\t\t\tthis.img.onload = function() { self.loaded = true; }\n\t\t\t\tthis.img.onerror = function() { if ( typeof( console ) != 'undefined' ) { console.log( 'ERROR: image \"' + href + '\" not found' ); self.loaded = true; } }\n\t\t\t\tthis.img.src = href;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.img = svg.ajax( href );\n\t\t\t\tthis.loaded = true;\n\t\t\t}\n\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tvar x = this.attribute( 'x' ).toPixels( 'x' );\n\t\t\t\tvar y = this.attribute( 'y' ).toPixels( 'y' );\n\n\t\t\t\tvar width = this.attribute( 'width' ).toPixels( 'x' );\n\t\t\t\tvar height = this.attribute( 'height' ).toPixels( 'y' );\n\t\t\t\tif ( width == 0 || height == 0 ) return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif ( isSvg ) {\n\t\t\t\t\tctx.drawSvg( this.img, x, y, width, height );\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tctx.translate( x, y );\n\t\t\t\t\tsvg.AspectRatio( ctx,\n\t\t\t\t\t\tthis.attribute( 'preserveAspectRatio' ).value,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tthis.img.width,\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tthis.img.height,\n\t\t\t\t\t\t0,\n\t\t\t\t\t\t0 );\n\t\t\t\t\tctx.drawImage( this.img, 0, 0 );\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar x = this.attribute( 'x' ).toPixels( 'x' );\n\t\t\t\tvar y = this.attribute( 'y' ).toPixels( 'y' );\n\t\t\t\tvar width = this.attribute( 'width' ).toPixels( 'x' );\n\t\t\t\tvar height = this.attribute( 'height' ).toPixels( 'y' );\n\t\t\t\treturn new svg.BoundingBox( x, y, x + width, y + height );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.image.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// group element\n\t\tsvg.Element.g = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tbb.addBoundingBox( this.children[i].getBoundingBox() );\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.g.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// symbol element\n\t\tsvg.Element.symbol = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\tthis.baseSetContext( ctx );\n\n\t\t\t\t// viewbox\n\t\t\t\tif ( this.attribute( 'viewBox' ).hasValue() ) {\n\t\t\t\t\tvar viewBox = svg.ToNumberArray( this.attribute( 'viewBox' ).value );\n\t\t\t\t\tvar minX = viewBox[0];\n\t\t\t\t\tvar minY = viewBox[1];\n\t\t\t\t\twidth = viewBox[2];\n\t\t\t\t\theight = viewBox[3];\n\n\t\t\t\t\tsvg.AspectRatio( ctx,\n\t\t\t\t\t\tthis.attribute( 'preserveAspectRatio' ).value,\n\t\t\t\t\t\tthis.attribute( 'width' ).toPixels( 'x' ),\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tthis.attribute( 'height' ).toPixels( 'y' ),\n\t\t\t\t\t\theight,\n\t\t\t\t\t\tminX,\n\t\t\t\t\t\tminY );\n\n\t\t\t\t\tsvg.ViewPort.SetCurrent( viewBox[2], viewBox[3] );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.symbol.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// style element\n\t\tsvg.Element.style = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\t// text, or spaces then CDATA\n\t\t\tvar css = ''\n\t\t\tfor ( var i=0; i<node.childNodes.length; i++ ) {\n\t\t\t  css += node.childNodes[i].nodeValue;\n\t\t\t}\n\t\t\tcss = css.replace( /(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, '' ); // remove comments\n\t\t\tcss = svg.compressSpaces( css ); // replace whitespace\n\t\t\tvar cssDefs = css.split( '}' );\n\t\t\tfor ( var i=0; i<cssDefs.length; i++ ) {\n\t\t\t\tif ( svg.trim( cssDefs[i] ) != '' ) {\n\t\t\t\t\tvar cssDef = cssDefs[i].split( '{' );\n\t\t\t\t\tvar cssClasses = cssDef[0].split( ',' );\n\t\t\t\t\tvar cssProps = cssDef[1].split( ';' );\n\t\t\t\t\tfor ( var j=0; j<cssClasses.length; j++ ) {\n\t\t\t\t\t\tvar cssClass = svg.trim( cssClasses[j] );\n\t\t\t\t\t\tif ( cssClass != '' ) {\n\t\t\t\t\t\t\tvar props = {};\n\t\t\t\t\t\t\tfor ( var k=0; k<cssProps.length; k++ ) {\n\t\t\t\t\t\t\t\tvar prop = cssProps[k].indexOf( ':' );\n\t\t\t\t\t\t\t\tvar name = cssProps[k].substr( 0, prop );\n\t\t\t\t\t\t\t\tvar value = cssProps[k].substr( prop + 1, cssProps[k].length - prop );\n\t\t\t\t\t\t\t\tif ( name != null && value != null ) {\n\t\t\t\t\t\t\t\t\tprops[svg.trim( name )] = new svg.Property( svg.trim( name ), svg.trim( value ) );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsvg.Styles[cssClass] = props;\n\t\t\t\t\t\t\tif ( cssClass == '@font-face' ) {\n\t\t\t\t\t\t\t\tvar fontFamily = props['font-family'].value.replace( /\"/g,'' );\n\t\t\t\t\t\t\t\tvar srcs = props['src'].value.split( ',' );\n\t\t\t\t\t\t\t\tfor ( var s=0; s<srcs.length; s++ ) {\n\t\t\t\t\t\t\t\t\tif ( srcs[s].indexOf( 'format(\"svg\")' ) > 0 ) {\n\t\t\t\t\t\t\t\t\t\tvar urlStart = srcs[s].indexOf( 'url' );\n\t\t\t\t\t\t\t\t\t\tvar urlEnd = srcs[s].indexOf( ')', urlStart );\n\t\t\t\t\t\t\t\t\t\tvar url = srcs[s].substr( urlStart + 5, urlEnd - urlStart - 6 );\n\t\t\t\t\t\t\t\t\t\tvar doc = svg.parseXml( svg.ajax( url ) );\n\t\t\t\t\t\t\t\t\t\tvar fonts = doc.getElementsByTagName( 'font' );\n\t\t\t\t\t\t\t\t\t\tfor ( var f=0; f<fonts.length; f++ ) {\n\t\t\t\t\t\t\t\t\t\t\tvar font = svg.CreateElement( fonts[f] );\n\t\t\t\t\t\t\t\t\t\t\tsvg.Definitions[fontFamily] = font;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.style.prototype = new svg.Element.ElementBase;\n\n\t\t// use element\n\t\tsvg.Element.use = function( node ) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function( ctx ) {\n\t\t\t\tthis.baseSetContext( ctx );\n\t\t\t\tif ( this.attribute( 'x' ).hasValue() ) ctx.translate( this.attribute( 'x' ).toPixels( 'x' ), 0 );\n\t\t\t\tif ( this.attribute( 'y' ).hasValue() ) ctx.translate( 0, this.attribute( 'y' ).toPixels( 'y' ) );\n\t\t\t}\n\n\t\t\tthis.getDefinition = function() {\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\t\t\t\tif ( this.attribute( 'width' ).hasValue() ) element.attribute( 'width', true ).value = this.attribute( 'width' ).value;\n\t\t\t\tif ( this.attribute( 'height' ).hasValue() ) element.attribute( 'height', true ).value = this.attribute( 'height' ).value;\n\t\t\t\treturn element;\n\t\t\t}\n\n\t\t\tthis.path = function( ctx ) {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif ( element != null ) element.path( ctx );\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif ( element != null ) return element.getBoundingBox();\n\t\t\t}\n\n\t\t\tthis.renderChildren = function( ctx ) {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif ( element != null ) {\n\t\t\t\t\t// temporarily detach from parent and render\n\t\t\t\t\tvar oldParent = element.parent;\n\t\t\t\t\telement.parent = null;\n\t\t\t\t\telement.render( ctx );\n\t\t\t\t\telement.parent = oldParent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.use.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// mask element\n\t\tsvg.Element.mask = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.apply = function( ctx, element ) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar x = this.attribute( 'x' ).toPixels( 'x' );\n\t\t\t\tvar y = this.attribute( 'y' ).toPixels( 'y' );\n\t\t\t\tvar width = this.attribute( 'width' ).toPixels( 'x' );\n\t\t\t\tvar height = this.attribute( 'height' ).toPixels( 'y' );\n\n\t\t\t\tif ( width == 0 && height == 0 ) {\n\t\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\t\tbb.addBoundingBox( this.children[i].getBoundingBox() );\n\t\t\t\t\t}\n\t\t\t\t\tvar x = Math.floor( bb.x1 );\n\t\t\t\t\tvar y = Math.floor( bb.y1 );\n\t\t\t\t\tvar width = Math.floor( bb.width() );\n\t\t\t\t\tvar\theight = Math.floor( bb.height() );\n\t\t\t\t}\n\n\t\t\t\t// temporarily remove mask to avoid recursion\n\t\t\t\tvar mask = element.attribute( 'mask' ).value;\n\t\t\t\telement.attribute( 'mask' ).value = '';\n\n\t\t\t\tvar cMask = document.createElement( 'canvas' );\n\t\t\t\tcMask.width = x + width;\n\t\t\t\tcMask.height = y + height;\n\t\t\t\tvar maskCtx = cMask.getContext( '2d' );\n\t\t\t\tthis.renderChildren( maskCtx );\n\n\t\t\t\tvar c = document.createElement( 'canvas' );\n\t\t\t\tc.width = x + width;\n\t\t\t\tc.height = y + height;\n\t\t\t\tvar tempCtx = c.getContext( '2d' );\n\t\t\t\telement.render( tempCtx );\n\t\t\t\ttempCtx.globalCompositeOperation = 'destination-in';\n\t\t\t\ttempCtx.fillStyle = maskCtx.createPattern( cMask, 'no-repeat' );\n\t\t\t\ttempCtx.fillRect( 0, 0, x + width, y + height );\n\n\t\t\t\tctx.fillStyle = tempCtx.createPattern( c, 'no-repeat' );\n\t\t\t\tctx.fillRect( 0, 0, x + width, y + height );\n\n\t\t\t\t// reassign mask\n\t\t\t\telement.attribute( 'mask' ).value = mask;\n\t\t\t}\n\n\t\t\tthis.render = function( ctx ) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.mask.prototype = new svg.Element.ElementBase;\n\n\t\t// clip element\n\t\tsvg.Element.clipPath = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.apply = function( ctx ) {\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tvar child = this.children[i];\n\t\t\t\t\tif ( typeof( child.path ) != 'undefined' ) {\n\t\t\t\t\t\tvar transform = null;\n\t\t\t\t\t\tif ( child.attribute( 'transform' ).hasValue() ) {\n\t\t\t\t\t\t\ttransform = new svg.Transform( child.attribute( 'transform' ).value );\n\t\t\t\t\t\t\ttransform.apply( ctx );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild.path( ctx );\n\t\t\t\t\t\tctx.clip();\n\t\t\t\t\t\tif ( transform ) { transform.unapply( ctx ); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.render = function( ctx ) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.clipPath.prototype = new svg.Element.ElementBase;\n\n\t\t// filters\n\t\tsvg.Element.filter = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.apply = function( ctx, element ) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar bb = element.getBoundingBox();\n\t\t\t\tvar x = Math.floor( bb.x1 );\n\t\t\t\tvar y = Math.floor( bb.y1 );\n\t\t\t\tvar width = Math.floor( bb.width() );\n\t\t\t\tvar\theight = Math.floor( bb.height() );\n\n\t\t\t\t// temporarily remove filter to avoid recursion\n\t\t\t\tvar filter = element.style( 'filter' ).value;\n\t\t\t\telement.style( 'filter' ).value = '';\n\n\t\t\t\tvar px = 0, py = 0;\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tvar efd = this.children[i].extraFilterDistance || 0;\n\t\t\t\t\tpx = Math.max( px, efd );\n\t\t\t\t\tpy = Math.max( py, efd );\n\t\t\t\t}\n\n\t\t\t\tvar c = document.createElement( 'canvas' );\n\t\t\t\tc.width = width + 2*px;\n\t\t\t\tc.height = height + 2*py;\n\t\t\t\tvar tempCtx = c.getContext( '2d' );\n\t\t\t\ttempCtx.translate( -x + px, -y + py );\n\t\t\t\telement.render( tempCtx );\n\n\t\t\t\t// apply filters\n\t\t\t\tfor ( var i=0; i<this.children.length; i++ ) {\n\t\t\t\t\tthis.children[i].apply( tempCtx, 0, 0, width + 2*px, height + 2*py );\n\t\t\t\t}\n\n\t\t\t\t// render on me\n\t\t\t\tctx.drawImage( c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py );\n\n\t\t\t\t// reassign filter\n\t\t\t\telement.style( 'filter', true ).value = filter;\n\t\t\t}\n\n\t\t\tthis.render = function( ctx ) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.filter.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feMorphology = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.apply = function( ctx, x, y, width, height ) {\n\t\t\t\t// TODO: implement\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feMorphology.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feColorMatrix = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tfunction imGet( img, x, y, width, height, rgba ) {\n\t\t\t\treturn img[y*width*4 + x*4 + rgba];\n\t\t\t}\n\n\t\t\tfunction imSet( img, x, y, width, height, rgba, val ) {\n\t\t\t\timg[y*width*4 + x*4 + rgba] = val;\n\t\t\t}\n\n\t\t\tthis.apply = function( ctx, x, y, width, height ) {\n\t\t\t\t// only supporting grayscale for now per Issue 195, need to extend to all matrix\n\t\t\t\t// assuming x==0 && y==0 for now\n\t\t\t\tvar srcData = ctx.getImageData( 0, 0, width, height );\n\t\t\t\tfor ( var y = 0; y < height; y++ ) {\n\t\t\t\t\tfor ( var x = 0; x < width; x++ ) {\n\t\t\t\t\t\tvar r = imGet( srcData.data, x, y, width, height, 0 );\n\t\t\t\t\t\tvar g = imGet( srcData.data, x, y, width, height, 1 );\n\t\t\t\t\t\tvar b = imGet( srcData.data, x, y, width, height, 2 );\n\t\t\t\t\t\tvar gray = ( r + g + b ) / 3;\n\t\t\t\t\t\timSet( srcData.data, x, y, width, height, 0, gray );\n\t\t\t\t\t\timSet( srcData.data, x, y, width, height, 1, gray );\n\t\t\t\t\t\timSet( srcData.data, x, y, width, height, 2, gray );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.clearRect( 0, 0, width, height );\n\t\t\t\tctx.putImageData( srcData, 0, 0 );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feGaussianBlur = function( node ) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base( node );\n\n\t\t\tthis.blurRadius = Math.floor( this.attribute( 'stdDeviation' ).numValue() );\n\t\t\tthis.extraFilterDistance = this.blurRadius;\n\n\t\t\tthis.apply = function( ctx, x, y, width, height ) {\n\t\t\t\tif ( typeof( stackBlurCanvasRGBA ) == 'undefined' ) {\n\t\t\t\t\tif ( typeof( console ) != 'undefined' ) { console.log( 'ERROR: StackBlur.js must be included for blur to work' ); }\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// StackBlur requires canvas be on document\n\t\t\t\tctx.canvas.id = svg.UniqueId();\n\t\t\t\tctx.canvas.style.display = 'none';\n\t\t\t\tdocument.body.appendChild( ctx.canvas );\n\t\t\t\tstackBlurCanvasRGBA( ctx.canvas.id, x, y, width, height, this.blurRadius );\n\t\t\t\tdocument.body.removeChild( ctx.canvas );\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;\n\n\t\t// title element, do nothing\n\t\tsvg.Element.title = function( node ) {\n\t\t}\n\t\tsvg.Element.title.prototype = new svg.Element.ElementBase;\n\n\t\t// desc element, do nothing\n\t\tsvg.Element.desc = function( node ) {\n\t\t}\n\t\tsvg.Element.desc.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.MISSING = function( node ) {\n\t\t\tif ( typeof( console ) != 'undefined' ) { console.log( 'ERROR: Element \\'' + node.nodeName + '\\' not yet implemented.' ); }\n\t\t}\n\t\tsvg.Element.MISSING.prototype = new svg.Element.ElementBase;\n\n\t\t// element factory\n\t\tsvg.CreateElement = function( node ) {\n\t\t\tvar className = node.nodeName.replace( /^[^:]+:/,'' ); // remove namespace\n\t\t\tclassName = className.replace( /\\-/g,'' ); // remove dashes\n\t\t\tvar e = null;\n\t\t\tif ( typeof( svg.Element[className] ) != 'undefined' ) {\n\t\t\t\te = new svg.Element[className]( node );\n\t\t\t}\n\t\t\telse {\n\t\t\t\te = new svg.Element.MISSING( node );\n\t\t\t}\n\n\t\t\te.type = node.nodeName;\n\t\t\treturn e;\n\t\t}\n\n\t\t// load from url\n\t\tsvg.load = function( ctx, url ) {\n\t\t\tsvg.loadXml( ctx, svg.ajax( url ) );\n\t\t}\n\n\t\t// load from xml\n\t\tsvg.loadXml = function( ctx, xml ) {\n\t\t\tsvg.loadXmlDoc( ctx, svg.parseXml( xml ) );\n\t\t}\n\n\t\tsvg.loadXmlDoc = function( ctx, dom ) {\n\t\t\tsvg.init( ctx );\n\n\t\t\tvar mapXY = function( p ) {\n\t\t\t\tvar e = ctx.canvas;\n\t\t\t\twhile ( e ) {\n\t\t\t\t\tp.x -= e.offsetLeft;\n\t\t\t\t\tp.y -= e.offsetTop;\n\t\t\t\t\te = e.offsetParent;\n\t\t\t\t}\n\t\t\t\tif ( window.scrollX ) p.x += window.scrollX;\n\t\t\t\tif ( window.scrollY ) p.y += window.scrollY;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\t// bind mouse\n\t\t\tif ( svg.opts['ignoreMouse'] != true ) {\n\t\t\t\tctx.canvas.onclick = function( e ) {\n\t\t\t\t\tvar p = mapXY( new svg.Point( e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY ) );\n\t\t\t\t\tsvg.Mouse.onclick( p.x, p.y );\n\t\t\t\t};\n\t\t\t\tctx.canvas.onmousemove = function( e ) {\n\t\t\t\t\tvar p = mapXY( new svg.Point( e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY ) );\n\t\t\t\t\tsvg.Mouse.onmousemove( p.x, p.y );\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar e = svg.CreateElement( dom.documentElement );\n\t\t\te.root = true;\n\n\t\t\t// render loop\n\t\t\tvar isFirstRender = true;\n\t\t\tvar draw = function() {\n\t\t\t\tsvg.ViewPort.Clear();\n\t\t\t\tif ( ctx.canvas.parentNode ) svg.ViewPort.SetCurrent( ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight );\n\n\t\t\t\tif ( svg.opts['ignoreDimensions'] != true ) {\n\t\t\t\t\t// set canvas size\n\t\t\t\t\tif ( e.style( 'width' ).hasValue() ) {\n\t\t\t\t\t\tctx.canvas.width = e.style( 'width' ).toPixels( 'x' );\n\t\t\t\t\t\tctx.canvas.style.width = ctx.canvas.width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\tif ( e.style( 'height' ).hasValue() ) {\n\t\t\t\t\t\tctx.canvas.height = e.style( 'height' ).toPixels( 'y' );\n\t\t\t\t\t\tctx.canvas.style.height = ctx.canvas.height + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar cWidth = ctx.canvas.clientWidth || ctx.canvas.width;\n\t\t\t\tvar cHeight = ctx.canvas.clientHeight || ctx.canvas.height;\n\t\t\t\tif ( svg.opts['ignoreDimensions'] == true && e.style( 'width' ).hasValue() && e.style( 'height' ).hasValue() ) {\n\t\t\t\t\tcWidth = e.style( 'width' ).toPixels( 'x' );\n\t\t\t\t\tcHeight = e.style( 'height' ).toPixels( 'y' );\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent( cWidth, cHeight );\n\n\t\t\t\tif ( svg.opts['offsetX'] != null ) e.attribute( 'x', true ).value = svg.opts['offsetX'];\n\t\t\t\tif ( svg.opts['offsetY'] != null ) e.attribute( 'y', true ).value = svg.opts['offsetY'];\n\t\t\t\tif ( svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null ) {\n\t\t\t\t\tvar xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray( e.attribute( 'viewBox' ).value );\n\t\t\t\t\tif ( e.attribute( 'width' ).hasValue() ) xRatio = e.attribute( 'width' ).toPixels( 'x' ) / svg.opts['scaleWidth'];\n\t\t\t\t\telse if ( !isNaN( viewBox[2] ) ) xRatio = viewBox[2] / svg.opts['scaleWidth'];\n\t\t\t\t\tif ( e.attribute( 'height' ).hasValue() ) yRatio = e.attribute( 'height' ).toPixels( 'y' ) / svg.opts['scaleHeight'];\n\t\t\t\t\telse if ( !isNaN( viewBox[3] ) ) yRatio = viewBox[3] / svg.opts['scaleHeight'];\n\n\t\t\t\t\te.attribute( 'width', true ).value = svg.opts['scaleWidth'];\n\t\t\t\t\te.attribute( 'height', true ).value = svg.opts['scaleHeight'];\n\t\t\t\t\te.attribute( 'viewBox', true ).value = '0 0 ' + ( cWidth * xRatio ) + ' ' + ( cHeight * yRatio );\n\t\t\t\t\te.attribute( 'preserveAspectRatio', true ).value = 'none';\n\t\t\t\t}\n\n\t\t\t\t// clear and render\n\t\t\t\tif ( svg.opts['ignoreClear'] != true ) {\n\t\t\t\t\tctx.clearRect( 0, 0, cWidth, cHeight );\n\t\t\t\t}\n\t\t\t\te.render( ctx );\n\t\t\t\tif ( isFirstRender ) {\n\t\t\t\t\tisFirstRender = false;\n\t\t\t\t\tif ( typeof( svg.opts['renderCallback'] ) == 'function' ) svg.opts['renderCallback']( dom );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar waitingForImages = true;\n\t\t\tif ( svg.ImagesLoaded() ) {\n\t\t\t\twaitingForImages = false;\n\t\t\t\tdraw();\n\t\t\t}\n\t\t\tsvg.intervalID = setInterval( function() {\n\t\t\t\tvar needUpdate = false;\n\n\t\t\t\tif ( waitingForImages && svg.ImagesLoaded() ) {\n\t\t\t\t\twaitingForImages = false;\n\t\t\t\t\tneedUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// need update from mouse events?\n\t\t\t\tif ( svg.opts['ignoreMouse'] != true ) {\n\t\t\t\t\tneedUpdate = needUpdate | svg.Mouse.hasEvents();\n\t\t\t\t}\n\n\t\t\t\t// need update from animations?\n\t\t\t\tif ( svg.opts['ignoreAnimation'] != true ) {\n\t\t\t\t\tfor ( var i=0; i<svg.Animations.length; i++ ) {\n\t\t\t\t\t\tneedUpdate = needUpdate | svg.Animations[i].update( 1000 / svg.FRAMERATE );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// need update from redraw?\n\t\t\t\tif ( typeof( svg.opts['forceRedraw'] ) == 'function' ) {\n\t\t\t\t\tif ( svg.opts['forceRedraw']() == true ) needUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// render if needed\n\t\t\t\tif ( needUpdate ) {\n\t\t\t\t\tdraw();\n\t\t\t\t\tsvg.Mouse.runEvents(); // run and clear our events\n\t\t\t\t}\n\t\t\t}, 1000 / svg.FRAMERATE );\n\t\t}\n\n\t\tsvg.stop = function() {\n\t\t\tif ( svg.intervalID ) {\n\t\t\t\tclearInterval( svg.intervalID );\n\t\t\t}\n\t\t}\n\n\t\tsvg.Mouse = new ( function() {\n\t\t\tthis.events = [];\n\t\t\tthis.hasEvents = function() { return this.events.length != 0; }\n\n\t\t\tthis.onclick = function( x, y ) {\n\t\t\t\tthis.events.push( { type: 'onclick', x: x, y: y,\n\t\t\t\t\trun: function( e ) { if ( e.onclick ) e.onclick(); }\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\tthis.onmousemove = function( x, y ) {\n\t\t\t\tthis.events.push( { type: 'onmousemove', x: x, y: y,\n\t\t\t\t\trun: function( e ) { if ( e.onmousemove ) e.onmousemove(); }\n\t\t\t\t} );\n\t\t\t}\n\n\t\t\tthis.eventElements = [];\n\n\t\t\tthis.checkPath = function( element, ctx ) {\n\t\t\t\tfor ( var i=0; i<this.events.length; i++ ) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif ( ctx.isPointInPath && ctx.isPointInPath( e.x, e.y ) ) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.checkBoundingBox = function( element, bb ) {\n\t\t\t\tfor ( var i=0; i<this.events.length; i++ ) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif ( bb.isPointInBox( e.x, e.y ) ) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.runEvents = function() {\n\t\t\t\tsvg.ctx.canvas.style.cursor = '';\n\n\t\t\t\tfor ( var i=0; i<this.events.length; i++ ) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tvar element = this.eventElements[i];\n\t\t\t\t\twhile ( element ) {\n\t\t\t\t\t\te.run( element );\n\t\t\t\t\t\telement = element.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// done running, clear\n\t\t\t\tthis.events = [];\n\t\t\t\tthis.eventElements = [];\n\t\t\t}\n\t\t} );\n\n\t\treturn svg;\n\t}\n} )();\n\nif ( typeof( CanvasRenderingContext2D ) != 'undefined' ) {\n\tCanvasRenderingContext2D.prototype.drawSvg = function( s, dx, dy, dw, dh ) {\n\t\tcanvg( this.canvas, s, {\n\t\t\tignoreMouse: true,\n\t\t\tignoreAnimation: true,\n\t\t\tignoreDimensions: true,\n\t\t\tignoreClear: true,\n\t\t\toffsetX: dx,\n\t\t\toffsetY: dy,\n\t\t\tscaleWidth: dw,\n\t\t\tscaleHeight: dh\n\t\t} );\n\t}\n}\n","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 2012-12-11\n *\n * By Eli Grey, http://eligrey.com\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs\n  || ( navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind( navigator ) )\n  || ( function( view ) {\n  \t\"use strict\";\n  \tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet\n  \t\t, get_URL = function() {\n  \t\t\treturn view.URL || view.webkitURL || view;\n  \t\t}\n  \t\t, URL = view.URL || view.webkitURL || view\n  \t\t, save_link = doc.createElementNS( \"http://www.w3.org/1999/xhtml\", \"a\" )\n  \t\t, can_use_save_link = \"download\" in save_link\n  \t\t, click = function( node ) {\n  \t\t\tvar event = doc.createEvent( \"MouseEvents\" );\n  \t\t\tevent.initMouseEvent(\n  \t\t\t\t\"click\", true, false, view, 0, 0, 0, 0, 0\n  \t\t\t\t, false, false, false, false, 0, null\n  \t\t\t);\n  \t\t\treturn node.dispatchEvent( event ); // false if event was cancelled\n  \t\t}\n  \t\t, webkit_req_fs = view.webkitRequestFileSystem\n  \t\t, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem\n  \t\t, throw_outside = function ( ex ) {\n  \t\t\t( view.setImmediate || view.setTimeout )( function() {\n  \t\t\t\tthrow ex;\n  \t\t\t}, 0 );\n  \t\t}\n  \t\t, force_saveable_type = \"application/octet-stream\"\n  \t\t, fs_min_size = 0\n  \t\t, deletion_queue = []\n  \t\t, process_deletion_queue = function() {\n  \t\t\tvar i = deletion_queue.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar file = deletion_queue[i];\n  \t\t\t\tif ( typeof file === \"string\" ) { // file is an object URL\n  \t\t\t\t\tURL.revokeObjectURL( file );\n  \t\t\t\t} else { // file is a File\n  \t\t\t\t\tfile.remove();\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\tdeletion_queue.length = 0; // clear queue\n  \t\t}\n  \t\t, dispatch = function( filesaver, event_types, event ) {\n  \t\t\tevent_types = [].concat( event_types );\n  \t\t\tvar i = event_types.length;\n  \t\t\twhile ( i-- ) {\n  \t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n  \t\t\t\tif ( typeof listener === \"function\" ) {\n  \t\t\t\t\ttry {\n  \t\t\t\t\t\tlistener.call( filesaver, event || filesaver );\n  \t\t\t\t\t} catch ( ex ) {\n  \t\t\t\t\t\tthrow_outside( ex );\n  \t\t\t\t\t}\n  \t\t\t\t}\n  \t\t\t}\n  \t\t}\n  \t\t, FileSaver = function( blob, name ) {\n  \t\t\t// First try a.download, then web filesystem, then object URLs\n  \t\t\tvar\n\t\t\t\t  filesaver = this\n  \t\t\t\t, type = blob.type\n  \t\t\t\t, blob_changed = false\n  \t\t\t\t, object_url\n  \t\t\t\t, target_view\n  \t\t\t\t, get_object_url = function() {\n  \t\t\t\t\tvar object_url = get_URL().createObjectURL( blob );\n  \t\t\t\t\tdeletion_queue.push( object_url );\n  \t\t\t\t\treturn object_url;\n  \t\t\t\t}\n  \t\t\t\t, dispatch_all = function() {\n  \t\t\t\t\tdispatch( filesaver, \"writestart progress write writeend\".split( \" \" ) );\n  \t\t\t\t}\n  \t\t\t\t// on any filesys errors revert to saving with object URLs\n  \t\t\t\t, fs_error = function() {\n  \t\t\t\t\t// don't create more object URLs than needed\n  \t\t\t\t\tif ( blob_changed || !object_url ) {\n  \t\t\t\t\t\tobject_url = get_object_url( blob );\n  \t\t\t\t\t}\n  \t\t\t\t\ttarget_view.location.href = object_url;\n  \t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n  \t\t\t\t\tdispatch_all();\n  \t\t\t\t}\n  \t\t\t\t, abortable = function( func ) {\n  \t\t\t\t\treturn function() {\n  \t\t\t\t\t\tif ( filesaver.readyState !== filesaver.DONE ) {\n  \t\t\t\t\t\t\treturn func.apply( this, arguments );\n  \t\t\t\t\t\t}\n  \t\t\t\t\t};\n  \t\t\t\t}\n  \t\t\t\t, create_if_not_found = {create: true, exclusive: false}\n  \t\t\t\t, slice\n\t\t\t;\n  \t\t\tfilesaver.readyState = filesaver.INIT;\n  \t\t\tif ( !name ) {\n  \t\t\t\tname = \"download\";\n  \t\t\t}\n  \t\t\tif ( can_use_save_link ) {\n  \t\t\t\tobject_url = get_object_url( blob );\n  \t\t\t\tsave_link.href = object_url;\n  \t\t\t\tsave_link.download = name;\n  \t\t\t\tif ( click( save_link ) ) {\n  \t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n  \t\t\t\t\tdispatch_all();\n  \t\t\t\t\treturn;\n  \t\t\t\t}\n  \t\t\t}\n  \t\t\t// Object and web filesystem URLs have a problem saving in Google Chrome when\n  \t\t\t// viewed in a tab, so I force save with application/octet-stream\n  \t\t\t// http://code.google.com/p/chromium/issues/detail?id=91158\n  \t\t\tif ( view.chrome && type && type !== force_saveable_type ) {\n  \t\t\t\tslice = blob.slice || blob.webkitSlice;\n  \t\t\t\tblob = slice.call( blob, 0, blob.size, force_saveable_type );\n  \t\t\t\tblob_changed = true;\n  \t\t\t}\n  \t\t\t// Since I can't be sure that the guessed media type will trigger a download\n  \t\t\t// in WebKit, I append .download to the filename.\n  \t\t\t// https://bugs.webkit.org/show_bug.cgi?id=65440\n  \t\t\tif ( webkit_req_fs && name !== \"download\" ) {\n  \t\t\t\tname += \".download\";\n  \t\t\t}\n  \t\t\tif ( type === force_saveable_type || webkit_req_fs ) {\n  \t\t\t\ttarget_view = view;\n  \t\t\t} else {\n  \t\t\t\ttarget_view = view.open();\n  \t\t\t}\n  \t\t\tif ( !req_fs ) {\n  \t\t\t\tfs_error();\n  \t\t\t\treturn;\n  \t\t\t}\n  \t\t\tfs_min_size += blob.size;\n  \t\t\treq_fs( view.TEMPORARY, fs_min_size, abortable( function( fs ) {\n  \t\t\t\tfs.root.getDirectory( \"saved\", create_if_not_found, abortable( function( dir ) {\n  \t\t\t\t\tvar save = function() {\n  \t\t\t\t\t\tdir.getFile( name, create_if_not_found, abortable( function( file ) {\n  \t\t\t\t\t\t\tfile.createWriter( abortable( function( writer ) {\n  \t\t\t\t\t\t\t\twriter.onwriteend = function( event ) {\n  \t\t\t\t\t\t\t\t\ttarget_view.location.href = file.toURL();\n  \t\t\t\t\t\t\t\t\tdeletion_queue.push( file );\n  \t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n  \t\t\t\t\t\t\t\t\tdispatch( filesaver, \"writeend\", event );\n  \t\t\t\t\t\t\t\t};\n  \t\t\t\t\t\t\t\twriter.onerror = function() {\n  \t\t\t\t\t\t\t\t\tvar error = writer.error;\n  \t\t\t\t\t\t\t\t\tif ( error.code !== error.ABORT_ERR ) {\n  \t\t\t\t\t\t\t\t\t\tfs_error();\n  \t\t\t\t\t\t\t\t\t}\n  \t\t\t\t\t\t\t\t};\n  \t\t\t\t\t\t\t\t\"writestart progress write abort\".split( \" \" ).forEach( function( event ) {\n  \t\t\t\t\t\t\t\t\twriter[\"on\" + event] = filesaver[\"on\" + event];\n  \t\t\t\t\t\t\t\t} );\n  \t\t\t\t\t\t\t\twriter.write( blob );\n  \t\t\t\t\t\t\t\tfilesaver.abort = function() {\n  \t\t\t\t\t\t\t\t\twriter.abort();\n  \t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n  \t\t\t\t\t\t\t\t};\n  \t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.WRITING;\n  \t\t\t\t\t\t\t} ), fs_error );\n  \t\t\t\t\t\t} ), fs_error );\n  \t\t\t\t\t};\n  \t\t\t\t\tdir.getFile( name, {create: false}, abortable( function( file ) {\n  \t\t\t\t\t\t// delete file if it already exists\n  \t\t\t\t\t\tfile.remove();\n  \t\t\t\t\t\tsave();\n  \t\t\t\t\t} ), abortable( function( ex ) {\n  \t\t\t\t\t\tif ( ex.code === ex.NOT_FOUND_ERR ) {\n  \t\t\t\t\t\t\tsave();\n  \t\t\t\t\t\t} else {\n  \t\t\t\t\t\t\tfs_error();\n  \t\t\t\t\t\t}\n  \t\t\t\t\t} ) );\n  \t\t\t\t} ), fs_error );\n  \t\t\t} ), fs_error );\n  \t\t}\n  \t\t, FS_proto = FileSaver.prototype\n  \t\t, saveAs = function( blob, name ) {\n  \t\t\treturn new FileSaver( blob, name );\n  \t\t}\n\t;\n  \tFS_proto.abort = function() {\n  \t\tvar filesaver = this;\n  \t\tfilesaver.readyState = filesaver.DONE;\n  \t\tdispatch( filesaver, \"abort\" );\n  \t};\n  \tFS_proto.readyState = FS_proto.INIT = 0;\n  \tFS_proto.WRITING = 1;\n  \tFS_proto.DONE = 2;\n\n  \tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\n  \tview.addEventListener( \"unload\", process_deletion_queue, false );\n  \treturn saveAs;\n  }( self ) );","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","\nimport 'script-loader!./dependencies/d3.js';\nimport 'script-loader!./dependencies/uvcharts.js';\nimport './dependencies/filesaver.js';\nimport './dependencies/canvg.js';\nimport './dependencies/canvas-toblob.js';\n"],"names":[],"sourceRoot":""}