{"version":3,"file":"js/dependencies.js","mappings":"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AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA,4CAA4C,WAAW;AACvD,KAAK;AACL,iDAAiD,WAAW;AAC5D;AACA;AACA;AACA;AACA;AACA,CAAC,Q;;;;;;;;;;AC1GD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,gCAAgC,YAAY;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,8BAA8B;AAC9B,gDAAgD,sBAAsB,8BAA8B;AACpG,sCAAsC;AACtC,gCAAgC;AAChC,8BAA8B;AAC9B,+BAA+B;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;AACA,iBAAiB,qBAAqB;AACtC;AACA;AACA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;AACA,qCAAqC;;AAErC;AACA;AACA;AACA,6BAA6B;AAC7B,QAAQ;AACR;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,6EAA6E;AAC7E;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iBAAiB;AACjB,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAkB;AAClB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;;AAEA;AACA;AACA;AACA;AACA,gBAAgB;AAChB;AACA,kBAAkB,YAAY;AAC9B,8DAA8D,2CAA2C;AACzG,uEAAuE,6CAA6C;AACpH,qEAAqE,4CAA4C;AACjH,+BAA+B,wDAAwD;AACvF,YAAY;AACZ,MAAM;AACN;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA,+CAA+C;AAC/C;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB,yBAAyB;AACzB,6BAA6B;AAC7B,8BAA8B;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B,6BAA6B;;AAE7B;AACA;AACA;AACA;;AAEA;AACA,wCAAwC;AACxC,wCAAwC;AACxC,yCAAyC;AACzC,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,cAAc,MAAM;AACpB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA,yCAAyC,MAAM;AAC/C;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA,iBAAiB,eAAe;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,gCAAgC,0BAA0B;AAC1D,iCAAiC,0BAA0B;;AAE3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,qCAAqC,gCAAgC;AACrE;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,4BAA4B;AAC5B;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC,gCAAgC;AACrE;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,6CAA6C;AAC7C;AACA;AACA;AACA,gDAAgD;AAChD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,6CAA6C;AAC7C;AACA,kBAAkB,0BAA0B;AAC5C;AACA,kEAAkE;AAClE;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;;AAEA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,mBAAmB,kBAAkB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD,mBAAmB,iBAAiB;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,2DAA2D;AAC3D,qDAAqD;;AAErD;AACA,sDAAsD;AACtD,iEAAiE;AACjE,0DAA0D;AAC1D;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mDAAmD;AACnD,YAAY;AACZ;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,0BAA0B;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,6BAA6B;AAC7B,gFAAgF;AAChF,gFAAgF;AAChF,+DAA+D;AAC/D,+DAA+D;AAC/D,8CAA8C;AAC9C,8CAA8C;AAC9C,mCAAmC,EAAE,qCAAqC;AAC1E,8BAA8B;AAC9B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AAAM;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC;AACxC;AACA,mBAAmB,sBAAsB;AACzC;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA,gCAAgC;AAChC;AACA,gCAAgC;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,gCAAgC;AAChC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,iBAAiB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,MAAM;AACzB,oBAAoB,MAAM;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,+BAA+B;AACjD;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6EAA6E;;AAE7E;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,eAAe;AACjC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,wBAAwB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,0BAA0B;AAClD;AACA,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAkB,yBAAyB;AAC3C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,eAAe;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC,oCAAoC,sCAAsC,sDAAsD;AAChI;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAiB,0BAA0B;AAC3C;AACA;AACA,6FAA6F;AAC7F,kCAAkC;AAClC,6BAA6B;AAC7B,iBAAiB,kBAAkB;AACnC;AACA,qCAAqC;AACrC;AACA,sCAAsC;AACtC,mBAAmB,qBAAqB;AACxC;AACA;AACA;AACA,qBAAqB,mBAAmB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAsB,eAAe;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,wBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,wBAAwB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB;AACvB;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,wBAAwB;AAC1C;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,oBAAoB,YAAY;AAChC,qBAAqB,WAAW;AAChC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,2CAA2C;AAC3C;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yCAAyC;AACzC;AACA;;AAEA;AACA;AACA,wDAAwD;AACxD,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,mBAAmB,yBAAyB;AAC5C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,4BAA4B;AAC5B;AACA,IAAI;AACJ;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iCAAiC;;AAEjC;AACA,uBAAuB;AACvB,wBAAwB;AACxB,KAAK;AACL;;AAEA;AACA,uBAAuB;AACvB,wBAAwB;AACxB,KAAK;AACL;;AAEA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;;AAEA;AACA;;AAEA,kBAAkB,sBAAsB;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;;;;;ACxxFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAqC;AACrC;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oCAAoC;AACpC;AACA,MAAM,OAAO;AACb;AACA;AACA;AACA,8BAA8B;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR,OAAO;AACP;AACA,wBAAwB,cAAc;AACtC;AACA;AACA;AACA,MAAM;AACN;AACA;AACA,QAAQ;AACR;AACA;AACA,MAAM;AACN,KAAK;AACL,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,Q;;;;;;UCtND;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA;WACA;WACA,iCAAiC,WAAW;WAC5C;WACA,E;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA,E;;;;;WCPA,wF;;;;;WCAA;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D,E;;;;;;;;;;;;;;;;;;;;;;ACNA;AAC4C;AACM;AACb;AACJ;AACQ","sources":["webpack://easy-charts/./src/js/dependencies/d3.js","webpack://easy-charts/./src/js/dependencies/uvcharts.js","webpack://easy-charts/./node_modules/script-loader/addScript.js","webpack://easy-charts/./src/js/dependencies/d3.js?05b8","webpack://easy-charts/./src/js/dependencies/uvcharts.js?677f","webpack://easy-charts/./src/js/dependencies/canvas-toblob.js","webpack://easy-charts/./src/js/dependencies/canvg.js","webpack://easy-charts/./src/js/dependencies/filesaver.js","webpack://easy-charts/webpack/bootstrap","webpack://easy-charts/webpack/runtime/compat get default export","webpack://easy-charts/webpack/runtime/define property getters","webpack://easy-charts/webpack/runtime/hasOwnProperty shorthand","webpack://easy-charts/webpack/runtime/make namespace object","webpack://easy-charts/./src/js/dependencies.js"],"sourcesContent":["module.exports = \"!function() {\\n  var d3 = {\\n    version: \\\"3.5.12\\\"\\n  };\\n  var d3_arraySlice = [].slice, d3_array = function(list) {\\n    return d3_arraySlice.call(list);\\n  };\\n  var d3_document = this.document;\\n  function d3_documentElement(node) {\\n    return node && (node.ownerDocument || node.document || node).documentElement;\\n  }\\n  function d3_window(node) {\\n    return node && (node.ownerDocument && node.ownerDocument.defaultView || node.document && node || node.defaultView);\\n  }\\n  if (d3_document) {\\n    try {\\n      d3_array(d3_document.documentElement.childNodes)[0].nodeType;\\n    } catch (e) {\\n      d3_array = function(list) {\\n        var i = list.length, array = new Array(i);\\n        while (i--) array[i] = list[i];\\n        return array;\\n      };\\n    }\\n  }\\n  if (!Date.now) Date.now = function() {\\n    return +new Date();\\n  };\\n  if (d3_document) {\\n    try {\\n      d3_document.createElement(\\\"DIV\\\").style.setProperty(\\\"opacity\\\", 0, \\\"\\\");\\n    } catch (error) {\\n      var d3_element_prototype = this.Element.prototype, d3_element_setAttribute = d3_element_prototype.setAttribute, d3_element_setAttributeNS = d3_element_prototype.setAttributeNS, d3_style_prototype = this.CSSStyleDeclaration.prototype, d3_style_setProperty = d3_style_prototype.setProperty;\\n      d3_element_prototype.setAttribute = function(name, value) {\\n        d3_element_setAttribute.call(this, name, value + \\\"\\\");\\n      };\\n      d3_element_prototype.setAttributeNS = function(space, local, value) {\\n        d3_element_setAttributeNS.call(this, space, local, value + \\\"\\\");\\n      };\\n      d3_style_prototype.setProperty = function(name, value, priority) {\\n        d3_style_setProperty.call(this, name, value + \\\"\\\", priority);\\n      };\\n    }\\n  }\\n  d3.ascending = d3_ascending;\\n  function d3_ascending(a, b) {\\n    return a < b ? -1 : a > b ? 1 : a >= b ? 0 : NaN;\\n  }\\n  d3.descending = function(a, b) {\\n    return b < a ? -1 : b > a ? 1 : b >= a ? 0 : NaN;\\n  };\\n  d3.min = function(array, f) {\\n    var i = -1, n = array.length, a, b;\\n    if (arguments.length === 1) {\\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\\n        a = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = array[i]) != null && a > b) a = b;\\n    } else {\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\\n        a = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && a > b) a = b;\\n    }\\n    return a;\\n  };\\n  d3.max = function(array, f) {\\n    var i = -1, n = array.length, a, b;\\n    if (arguments.length === 1) {\\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\\n        a = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = array[i]) != null && b > a) a = b;\\n    } else {\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\\n        a = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b > a) a = b;\\n    }\\n    return a;\\n  };\\n  d3.extent = function(array, f) {\\n    var i = -1, n = array.length, a, b, c;\\n    if (arguments.length === 1) {\\n      while (++i < n) if ((b = array[i]) != null && b >= b) {\\n        a = c = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = array[i]) != null) {\\n        if (a > b) a = b;\\n        if (c < b) c = b;\\n      }\\n    } else {\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null && b >= b) {\\n        a = c = b;\\n        break;\\n      }\\n      while (++i < n) if ((b = f.call(array, array[i], i)) != null) {\\n        if (a > b) a = b;\\n        if (c < b) c = b;\\n      }\\n    }\\n    return [ a, c ];\\n  };\\n  function d3_number(x) {\\n    return x === null ? NaN : +x;\\n  }\\n  function d3_numeric(x) {\\n    return !isNaN(x);\\n  }\\n  d3.sum = function(array, f) {\\n    var s = 0, n = array.length, a, i = -1;\\n    if (arguments.length === 1) {\\n      while (++i < n) if (d3_numeric(a = +array[i])) s += a;\\n    } else {\\n      while (++i < n) if (d3_numeric(a = +f.call(array, array[i], i))) s += a;\\n    }\\n    return s;\\n  };\\n  d3.mean = function(array, f) {\\n    var s = 0, n = array.length, a, i = -1, j = n;\\n    if (arguments.length === 1) {\\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) s += a; else --j;\\n    } else {\\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) s += a; else --j;\\n    }\\n    if (j) return s / j;\\n  };\\n  d3.quantile = function(values, p) {\\n    var H = (values.length - 1) * p + 1, h = Math.floor(H), v = +values[h - 1], e = H - h;\\n    return e ? v + e * (values[h] - v) : v;\\n  };\\n  d3.median = function(array, f) {\\n    var numbers = [], n = array.length, a, i = -1;\\n    if (arguments.length === 1) {\\n      while (++i < n) if (d3_numeric(a = d3_number(array[i]))) numbers.push(a);\\n    } else {\\n      while (++i < n) if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) numbers.push(a);\\n    }\\n    if (numbers.length) return d3.quantile(numbers.sort(d3_ascending), .5);\\n  };\\n  d3.variance = function(array, f) {\\n    var n = array.length, m = 0, a, d, s = 0, i = -1, j = 0;\\n    if (arguments.length === 1) {\\n      while (++i < n) {\\n        if (d3_numeric(a = d3_number(array[i]))) {\\n          d = a - m;\\n          m += d / ++j;\\n          s += d * (a - m);\\n        }\\n      }\\n    } else {\\n      while (++i < n) {\\n        if (d3_numeric(a = d3_number(f.call(array, array[i], i)))) {\\n          d = a - m;\\n          m += d / ++j;\\n          s += d * (a - m);\\n        }\\n      }\\n    }\\n    if (j > 1) return s / (j - 1);\\n  };\\n  d3.deviation = function() {\\n    var v = d3.variance.apply(this, arguments);\\n    return v ? Math.sqrt(v) : v;\\n  };\\n  function d3_bisector(compare) {\\n    return {\\n      left: function(a, x, lo, hi) {\\n        if (arguments.length < 3) lo = 0;\\n        if (arguments.length < 4) hi = a.length;\\n        while (lo < hi) {\\n          var mid = lo + hi >>> 1;\\n          if (compare(a[mid], x) < 0) lo = mid + 1; else hi = mid;\\n        }\\n        return lo;\\n      },\\n      right: function(a, x, lo, hi) {\\n        if (arguments.length < 3) lo = 0;\\n        if (arguments.length < 4) hi = a.length;\\n        while (lo < hi) {\\n          var mid = lo + hi >>> 1;\\n          if (compare(a[mid], x) > 0) hi = mid; else lo = mid + 1;\\n        }\\n        return lo;\\n      }\\n    };\\n  }\\n  var d3_bisect = d3_bisector(d3_ascending);\\n  d3.bisectLeft = d3_bisect.left;\\n  d3.bisect = d3.bisectRight = d3_bisect.right;\\n  d3.bisector = function(f) {\\n    return d3_bisector(f.length === 1 ? function(d, x) {\\n      return d3_ascending(f(d), x);\\n    } : f);\\n  };\\n  d3.shuffle = function(array, i0, i1) {\\n    if ((m = arguments.length) < 3) {\\n      i1 = array.length;\\n      if (m < 2) i0 = 0;\\n    }\\n    var m = i1 - i0, t, i;\\n    while (m) {\\n      i = Math.random() * m-- | 0;\\n      t = array[m + i0], array[m + i0] = array[i + i0], array[i + i0] = t;\\n    }\\n    return array;\\n  };\\n  d3.permute = function(array, indexes) {\\n    var i = indexes.length, permutes = new Array(i);\\n    while (i--) permutes[i] = array[indexes[i]];\\n    return permutes;\\n  };\\n  d3.pairs = function(array) {\\n    var i = 0, n = array.length - 1, p0, p1 = array[0], pairs = new Array(n < 0 ? 0 : n);\\n    while (i < n) pairs[i] = [ p0 = p1, p1 = array[++i] ];\\n    return pairs;\\n  };\\n  d3.zip = function() {\\n    if (!(n = arguments.length)) return [];\\n    for (var i = -1, m = d3.min(arguments, d3_zipLength), zips = new Array(m); ++i < m; ) {\\n      for (var j = -1, n, zip = zips[i] = new Array(n); ++j < n; ) {\\n        zip[j] = arguments[j][i];\\n      }\\n    }\\n    return zips;\\n  };\\n  function d3_zipLength(d) {\\n    return d.length;\\n  }\\n  d3.transpose = function(matrix) {\\n    return d3.zip.apply(d3, matrix);\\n  };\\n  d3.keys = function(map) {\\n    var keys = [];\\n    for (var key in map) keys.push(key);\\n    return keys;\\n  };\\n  d3.values = function(map) {\\n    var values = [];\\n    for (var key in map) values.push(map[key]);\\n    return values;\\n  };\\n  d3.entries = function(map) {\\n    var entries = [];\\n    for (var key in map) entries.push({\\n      key: key,\\n      value: map[key]\\n    });\\n    return entries;\\n  };\\n  d3.merge = function(arrays) {\\n    var n = arrays.length, m, i = -1, j = 0, merged, array;\\n    while (++i < n) j += arrays[i].length;\\n    merged = new Array(j);\\n    while (--n >= 0) {\\n      array = arrays[n];\\n      m = array.length;\\n      while (--m >= 0) {\\n        merged[--j] = array[m];\\n      }\\n    }\\n    return merged;\\n  };\\n  var abs = Math.abs;\\n  d3.range = function(start, stop, step) {\\n    if (arguments.length < 3) {\\n      step = 1;\\n      if (arguments.length < 2) {\\n        stop = start;\\n        start = 0;\\n      }\\n    }\\n    if ((stop - start) / step === Infinity) throw new Error(\\\"infinite range\\\");\\n    var range = [], k = d3_range_integerScale(abs(step)), i = -1, j;\\n    start *= k, stop *= k, step *= k;\\n    if (step < 0) while ((j = start + step * ++i) > stop) range.push(j / k); else while ((j = start + step * ++i) < stop) range.push(j / k);\\n    return range;\\n  };\\n  function d3_range_integerScale(x) {\\n    var k = 1;\\n    while (x * k % 1) k *= 10;\\n    return k;\\n  }\\n  function d3_class(ctor, properties) {\\n    for (var key in properties) {\\n      Object.defineProperty(ctor.prototype, key, {\\n        value: properties[key],\\n        enumerable: false\\n      });\\n    }\\n  }\\n  d3.map = function(object, f) {\\n    var map = new d3_Map();\\n    if (object instanceof d3_Map) {\\n      object.forEach(function(key, value) {\\n        map.set(key, value);\\n      });\\n    } else if (Array.isArray(object)) {\\n      var i = -1, n = object.length, o;\\n      if (arguments.length === 1) while (++i < n) map.set(i, object[i]); else while (++i < n) map.set(f.call(object, o = object[i], i), o);\\n    } else {\\n      for (var key in object) map.set(key, object[key]);\\n    }\\n    return map;\\n  };\\n  function d3_Map() {\\n    this._ = Object.create(null);\\n  }\\n  var d3_map_proto = \\\"__proto__\\\", d3_map_zero = \\\"\\\\x00\\\";\\n  d3_class(d3_Map, {\\n    has: d3_map_has,\\n    get: function(key) {\\n      return this._[d3_map_escape(key)];\\n    },\\n    set: function(key, value) {\\n      return this._[d3_map_escape(key)] = value;\\n    },\\n    remove: d3_map_remove,\\n    keys: d3_map_keys,\\n    values: function() {\\n      var values = [];\\n      for (var key in this._) values.push(this._[key]);\\n      return values;\\n    },\\n    entries: function() {\\n      var entries = [];\\n      for (var key in this._) entries.push({\\n        key: d3_map_unescape(key),\\n        value: this._[key]\\n      });\\n      return entries;\\n    },\\n    size: d3_map_size,\\n    empty: d3_map_empty,\\n    forEach: function(f) {\\n      for (var key in this._) f.call(this, d3_map_unescape(key), this._[key]);\\n    }\\n  });\\n  function d3_map_escape(key) {\\n    return (key += \\\"\\\") === d3_map_proto || key[0] === d3_map_zero ? d3_map_zero + key : key;\\n  }\\n  function d3_map_unescape(key) {\\n    return (key += \\\"\\\")[0] === d3_map_zero ? key.slice(1) : key;\\n  }\\n  function d3_map_has(key) {\\n    return d3_map_escape(key) in this._;\\n  }\\n  function d3_map_remove(key) {\\n    return (key = d3_map_escape(key)) in this._ && delete this._[key];\\n  }\\n  function d3_map_keys() {\\n    var keys = [];\\n    for (var key in this._) keys.push(d3_map_unescape(key));\\n    return keys;\\n  }\\n  function d3_map_size() {\\n    var size = 0;\\n    for (var key in this._) ++size;\\n    return size;\\n  }\\n  function d3_map_empty() {\\n    for (var key in this._) return false;\\n    return true;\\n  }\\n  d3.nest = function() {\\n    var nest = {}, keys = [], sortKeys = [], sortValues, rollup;\\n    function map(mapType, array, depth) {\\n      if (depth >= keys.length) return rollup ? rollup.call(nest, array) : sortValues ? array.sort(sortValues) : array;\\n      var i = -1, n = array.length, key = keys[depth++], keyValue, object, setter, valuesByKey = new d3_Map(), values;\\n      while (++i < n) {\\n        if (values = valuesByKey.get(keyValue = key(object = array[i]))) {\\n          values.push(object);\\n        } else {\\n          valuesByKey.set(keyValue, [ object ]);\\n        }\\n      }\\n      if (mapType) {\\n        object = mapType();\\n        setter = function(keyValue, values) {\\n          object.set(keyValue, map(mapType, values, depth));\\n        };\\n      } else {\\n        object = {};\\n        setter = function(keyValue, values) {\\n          object[keyValue] = map(mapType, values, depth);\\n        };\\n      }\\n      valuesByKey.forEach(setter);\\n      return object;\\n    }\\n    function entries(map, depth) {\\n      if (depth >= keys.length) return map;\\n      var array = [], sortKey = sortKeys[depth++];\\n      map.forEach(function(key, keyMap) {\\n        array.push({\\n          key: key,\\n          values: entries(keyMap, depth)\\n        });\\n      });\\n      return sortKey ? array.sort(function(a, b) {\\n        return sortKey(a.key, b.key);\\n      }) : array;\\n    }\\n    nest.map = function(array, mapType) {\\n      return map(mapType, array, 0);\\n    };\\n    nest.entries = function(array) {\\n      return entries(map(d3.map, array, 0), 0);\\n    };\\n    nest.key = function(d) {\\n      keys.push(d);\\n      return nest;\\n    };\\n    nest.sortKeys = function(order) {\\n      sortKeys[keys.length - 1] = order;\\n      return nest;\\n    };\\n    nest.sortValues = function(order) {\\n      sortValues = order;\\n      return nest;\\n    };\\n    nest.rollup = function(f) {\\n      rollup = f;\\n      return nest;\\n    };\\n    return nest;\\n  };\\n  d3.set = function(array) {\\n    var set = new d3_Set();\\n    if (array) for (var i = 0, n = array.length; i < n; ++i) set.add(array[i]);\\n    return set;\\n  };\\n  function d3_Set() {\\n    this._ = Object.create(null);\\n  }\\n  d3_class(d3_Set, {\\n    has: d3_map_has,\\n    add: function(key) {\\n      this._[d3_map_escape(key += \\\"\\\")] = true;\\n      return key;\\n    },\\n    remove: d3_map_remove,\\n    values: d3_map_keys,\\n    size: d3_map_size,\\n    empty: d3_map_empty,\\n    forEach: function(f) {\\n      for (var key in this._) f.call(this, d3_map_unescape(key));\\n    }\\n  });\\n  d3.behavior = {};\\n  function d3_identity(d) {\\n    return d;\\n  }\\n  d3.rebind = function(target, source) {\\n    var i = 1, n = arguments.length, method;\\n    while (++i < n) target[method = arguments[i]] = d3_rebind(target, source, source[method]);\\n    return target;\\n  };\\n  function d3_rebind(target, source, method) {\\n    return function() {\\n      var value = method.apply(source, arguments);\\n      return value === source ? target : value;\\n    };\\n  }\\n  function d3_vendorSymbol(object, name) {\\n    if (name in object) return name;\\n    name = name.charAt(0).toUpperCase() + name.slice(1);\\n    for (var i = 0, n = d3_vendorPrefixes.length; i < n; ++i) {\\n      var prefixName = d3_vendorPrefixes[i] + name;\\n      if (prefixName in object) return prefixName;\\n    }\\n  }\\n  var d3_vendorPrefixes = [ \\\"webkit\\\", \\\"ms\\\", \\\"moz\\\", \\\"Moz\\\", \\\"o\\\", \\\"O\\\" ];\\n  function d3_noop() {}\\n  d3.dispatch = function() {\\n    var dispatch = new d3_dispatch(), i = -1, n = arguments.length;\\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\\n    return dispatch;\\n  };\\n  function d3_dispatch() {}\\n  d3_dispatch.prototype.on = function(type, listener) {\\n    var i = type.indexOf(\\\".\\\"), name = \\\"\\\";\\n    if (i >= 0) {\\n      name = type.slice(i + 1);\\n      type = type.slice(0, i);\\n    }\\n    if (type) return arguments.length < 2 ? this[type].on(name) : this[type].on(name, listener);\\n    if (arguments.length === 2) {\\n      if (listener == null) for (type in this) {\\n        if (this.hasOwnProperty(type)) this[type].on(name, null);\\n      }\\n      return this;\\n    }\\n  };\\n  function d3_dispatch_event(dispatch) {\\n    var listeners = [], listenerByName = new d3_Map();\\n    function event() {\\n      var z = listeners, i = -1, n = z.length, l;\\n      while (++i < n) if (l = z[i].on) l.apply(this, arguments);\\n      return dispatch;\\n    }\\n    event.on = function(name, listener) {\\n      var l = listenerByName.get(name), i;\\n      if (arguments.length < 2) return l && l.on;\\n      if (l) {\\n        l.on = null;\\n        listeners = listeners.slice(0, i = listeners.indexOf(l)).concat(listeners.slice(i + 1));\\n        listenerByName.remove(name);\\n      }\\n      if (listener) listeners.push(listenerByName.set(name, {\\n        on: listener\\n      }));\\n      return dispatch;\\n    };\\n    return event;\\n  }\\n  d3.event = null;\\n  function d3_eventPreventDefault() {\\n    d3.event.preventDefault();\\n  }\\n  function d3_eventSource() {\\n    var e = d3.event, s;\\n    while (s = e.sourceEvent) e = s;\\n    return e;\\n  }\\n  function d3_eventDispatch(target) {\\n    var dispatch = new d3_dispatch(), i = 0, n = arguments.length;\\n    while (++i < n) dispatch[arguments[i]] = d3_dispatch_event(dispatch);\\n    dispatch.of = function(thiz, argumentz) {\\n      return function(e1) {\\n        try {\\n          var e0 = e1.sourceEvent = d3.event;\\n          e1.target = target;\\n          d3.event = e1;\\n          dispatch[e1.type].apply(thiz, argumentz);\\n        } finally {\\n          d3.event = e0;\\n        }\\n      };\\n    };\\n    return dispatch;\\n  }\\n  d3.requote = function(s) {\\n    return s.replace(d3_requote_re, \\\"\\\\\\\\$&\\\");\\n  };\\n  var d3_requote_re = /[\\\\\\\\\\\\^\\\\$\\\\*\\\\+\\\\?\\\\|\\\\[\\\\]\\\\(\\\\)\\\\.\\\\{\\\\}]/g;\\n  var d3_subclass = {}.__proto__ ? function(object, prototype) {\\n    object.__proto__ = prototype;\\n  } : function(object, prototype) {\\n    for (var property in prototype) object[property] = prototype[property];\\n  };\\n  function d3_selection(groups) {\\n    d3_subclass(groups, d3_selectionPrototype);\\n    return groups;\\n  }\\n  var d3_select = function(s, n) {\\n    return n.querySelector(s);\\n  }, d3_selectAll = function(s, n) {\\n    return n.querySelectorAll(s);\\n  }, d3_selectMatches = function(n, s) {\\n    var d3_selectMatcher = n.matches || n[d3_vendorSymbol(n, \\\"matchesSelector\\\")];\\n    d3_selectMatches = function(n, s) {\\n      return d3_selectMatcher.call(n, s);\\n    };\\n    return d3_selectMatches(n, s);\\n  };\\n  if (typeof Sizzle === \\\"function\\\") {\\n    d3_select = function(s, n) {\\n      return Sizzle(s, n)[0] || null;\\n    };\\n    d3_selectAll = Sizzle;\\n    d3_selectMatches = Sizzle.matchesSelector;\\n  }\\n  d3.selection = function() {\\n    return d3.select(d3_document.documentElement);\\n  };\\n  var d3_selectionPrototype = d3.selection.prototype = [];\\n  d3_selectionPrototype.select = function(selector) {\\n    var subgroups = [], subgroup, subnode, group, node;\\n    selector = d3_selection_selector(selector);\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      subgroups.push(subgroup = []);\\n      subgroup.parentNode = (group = this[j]).parentNode;\\n      for (var i = -1, n = group.length; ++i < n; ) {\\n        if (node = group[i]) {\\n          subgroup.push(subnode = selector.call(node, node.__data__, i, j));\\n          if (subnode && \\\"__data__\\\" in node) subnode.__data__ = node.__data__;\\n        } else {\\n          subgroup.push(null);\\n        }\\n      }\\n    }\\n    return d3_selection(subgroups);\\n  };\\n  function d3_selection_selector(selector) {\\n    return typeof selector === \\\"function\\\" ? selector : function() {\\n      return d3_select(selector, this);\\n    };\\n  }\\n  d3_selectionPrototype.selectAll = function(selector) {\\n    var subgroups = [], subgroup, node;\\n    selector = d3_selection_selectorAll(selector);\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n        if (node = group[i]) {\\n          subgroups.push(subgroup = d3_array(selector.call(node, node.__data__, i, j)));\\n          subgroup.parentNode = node;\\n        }\\n      }\\n    }\\n    return d3_selection(subgroups);\\n  };\\n  function d3_selection_selectorAll(selector) {\\n    return typeof selector === \\\"function\\\" ? selector : function() {\\n      return d3_selectAll(selector, this);\\n    };\\n  }\\n  var d3_nsPrefix = {\\n    svg: \\\"http://www.w3.org/2000/svg\\\",\\n    xhtml: \\\"http://www.w3.org/1999/xhtml\\\",\\n    xlink: \\\"http://www.w3.org/1999/xlink\\\",\\n    xml: \\\"http://www.w3.org/XML/1998/namespace\\\",\\n    xmlns: \\\"http://www.w3.org/2000/xmlns/\\\"\\n  };\\n  d3.ns = {\\n    prefix: d3_nsPrefix,\\n    qualify: function(name) {\\n      var i = name.indexOf(\\\":\\\"), prefix = name;\\n      if (i >= 0 && (prefix = name.slice(0, i)) !== \\\"xmlns\\\") name = name.slice(i + 1);\\n      return d3_nsPrefix.hasOwnProperty(prefix) ? {\\n        space: d3_nsPrefix[prefix],\\n        local: name\\n      } : name;\\n    }\\n  };\\n  d3_selectionPrototype.attr = function(name, value) {\\n    if (arguments.length < 2) {\\n      if (typeof name === \\\"string\\\") {\\n        var node = this.node();\\n        name = d3.ns.qualify(name);\\n        return name.local ? node.getAttributeNS(name.space, name.local) : node.getAttribute(name);\\n      }\\n      for (value in name) this.each(d3_selection_attr(value, name[value]));\\n      return this;\\n    }\\n    return this.each(d3_selection_attr(name, value));\\n  };\\n  function d3_selection_attr(name, value) {\\n    name = d3.ns.qualify(name);\\n    function attrNull() {\\n      this.removeAttribute(name);\\n    }\\n    function attrNullNS() {\\n      this.removeAttributeNS(name.space, name.local);\\n    }\\n    function attrConstant() {\\n      this.setAttribute(name, value);\\n    }\\n    function attrConstantNS() {\\n      this.setAttributeNS(name.space, name.local, value);\\n    }\\n    function attrFunction() {\\n      var x = value.apply(this, arguments);\\n      if (x == null) this.removeAttribute(name); else this.setAttribute(name, x);\\n    }\\n    function attrFunctionNS() {\\n      var x = value.apply(this, arguments);\\n      if (x == null) this.removeAttributeNS(name.space, name.local); else this.setAttributeNS(name.space, name.local, x);\\n    }\\n    return value == null ? name.local ? attrNullNS : attrNull : typeof value === \\\"function\\\" ? name.local ? attrFunctionNS : attrFunction : name.local ? attrConstantNS : attrConstant;\\n  }\\n  function d3_collapse(s) {\\n    return s.trim().replace(/\\\\s+/g, \\\" \\\");\\n  }\\n  d3_selectionPrototype.classed = function(name, value) {\\n    if (arguments.length < 2) {\\n      if (typeof name === \\\"string\\\") {\\n        var node = this.node(), n = (name = d3_selection_classes(name)).length, i = -1;\\n        if (value = node.classList) {\\n          while (++i < n) if (!value.contains(name[i])) return false;\\n        } else {\\n          value = node.getAttribute(\\\"class\\\");\\n          while (++i < n) if (!d3_selection_classedRe(name[i]).test(value)) return false;\\n        }\\n        return true;\\n      }\\n      for (value in name) this.each(d3_selection_classed(value, name[value]));\\n      return this;\\n    }\\n    return this.each(d3_selection_classed(name, value));\\n  };\\n  function d3_selection_classedRe(name) {\\n    return new RegExp(\\\"(?:^|\\\\\\\\s+)\\\" + d3.requote(name) + \\\"(?:\\\\\\\\s+|$)\\\", \\\"g\\\");\\n  }\\n  function d3_selection_classes(name) {\\n    return (name + \\\"\\\").trim().split(/^|\\\\s+/);\\n  }\\n  function d3_selection_classed(name, value) {\\n    name = d3_selection_classes(name).map(d3_selection_classedName);\\n    var n = name.length;\\n    function classedConstant() {\\n      var i = -1;\\n      while (++i < n) name[i](this, value);\\n    }\\n    function classedFunction() {\\n      var i = -1, x = value.apply(this, arguments);\\n      while (++i < n) name[i](this, x);\\n    }\\n    return typeof value === \\\"function\\\" ? classedFunction : classedConstant;\\n  }\\n  function d3_selection_classedName(name) {\\n    var re = d3_selection_classedRe(name);\\n    return function(node, value) {\\n      if (c = node.classList) return value ? c.add(name) : c.remove(name);\\n      var c = node.getAttribute(\\\"class\\\") || \\\"\\\";\\n      if (value) {\\n        re.lastIndex = 0;\\n        if (!re.test(c)) node.setAttribute(\\\"class\\\", d3_collapse(c + \\\" \\\" + name));\\n      } else {\\n        node.setAttribute(\\\"class\\\", d3_collapse(c.replace(re, \\\" \\\")));\\n      }\\n    };\\n  }\\n  d3_selectionPrototype.style = function(name, value, priority) {\\n    var n = arguments.length;\\n    if (n < 3) {\\n      if (typeof name !== \\\"string\\\") {\\n        if (n < 2) value = \\\"\\\";\\n        for (priority in name) this.each(d3_selection_style(priority, name[priority], value));\\n        return this;\\n      }\\n      if (n < 2) {\\n        var node = this.node();\\n        return d3_window(node).getComputedStyle(node, null).getPropertyValue(name);\\n      }\\n      priority = \\\"\\\";\\n    }\\n    return this.each(d3_selection_style(name, value, priority));\\n  };\\n  function d3_selection_style(name, value, priority) {\\n    function styleNull() {\\n      this.style.removeProperty(name);\\n    }\\n    function styleConstant() {\\n      this.style.setProperty(name, value, priority);\\n    }\\n    function styleFunction() {\\n      var x = value.apply(this, arguments);\\n      if (x == null) this.style.removeProperty(name); else this.style.setProperty(name, x, priority);\\n    }\\n    return value == null ? styleNull : typeof value === \\\"function\\\" ? styleFunction : styleConstant;\\n  }\\n  d3_selectionPrototype.property = function(name, value) {\\n    if (arguments.length < 2) {\\n      if (typeof name === \\\"string\\\") return this.node()[name];\\n      for (value in name) this.each(d3_selection_property(value, name[value]));\\n      return this;\\n    }\\n    return this.each(d3_selection_property(name, value));\\n  };\\n  function d3_selection_property(name, value) {\\n    function propertyNull() {\\n      delete this[name];\\n    }\\n    function propertyConstant() {\\n      this[name] = value;\\n    }\\n    function propertyFunction() {\\n      var x = value.apply(this, arguments);\\n      if (x == null) delete this[name]; else this[name] = x;\\n    }\\n    return value == null ? propertyNull : typeof value === \\\"function\\\" ? propertyFunction : propertyConstant;\\n  }\\n  d3_selectionPrototype.text = function(value) {\\n    return arguments.length ? this.each(typeof value === \\\"function\\\" ? function() {\\n      var v = value.apply(this, arguments);\\n      this.textContent = v == null ? \\\"\\\" : v;\\n    } : value == null ? function() {\\n      this.textContent = \\\"\\\";\\n    } : function() {\\n      this.textContent = value;\\n    }) : this.node().textContent;\\n  };\\n  d3_selectionPrototype.html = function(value) {\\n    return arguments.length ? this.each(typeof value === \\\"function\\\" ? function() {\\n      var v = value.apply(this, arguments);\\n      this.innerHTML = v == null ? \\\"\\\" : v;\\n    } : value == null ? function() {\\n      this.innerHTML = \\\"\\\";\\n    } : function() {\\n      this.innerHTML = value;\\n    }) : this.node().innerHTML;\\n  };\\n  d3_selectionPrototype.append = function(name) {\\n    name = d3_selection_creator(name);\\n    return this.select(function() {\\n      return this.appendChild(name.apply(this, arguments));\\n    });\\n  };\\n  function d3_selection_creator(name) {\\n    function create() {\\n      var document = this.ownerDocument, namespace = this.namespaceURI;\\n      return namespace ? document.createElementNS(namespace, name) : document.createElement(name);\\n    }\\n    function createNS() {\\n      return this.ownerDocument.createElementNS(name.space, name.local);\\n    }\\n    return typeof name === \\\"function\\\" ? name : (name = d3.ns.qualify(name)).local ? createNS : create;\\n  }\\n  d3_selectionPrototype.insert = function(name, before) {\\n    name = d3_selection_creator(name);\\n    before = d3_selection_selector(before);\\n    return this.select(function() {\\n      return this.insertBefore(name.apply(this, arguments), before.apply(this, arguments) || null);\\n    });\\n  };\\n  d3_selectionPrototype.remove = function() {\\n    return this.each(d3_selectionRemove);\\n  };\\n  function d3_selectionRemove() {\\n    var parent = this.parentNode;\\n    if (parent) parent.removeChild(this);\\n  }\\n  d3_selectionPrototype.data = function(value, key) {\\n    var i = -1, n = this.length, group, node;\\n    if (!arguments.length) {\\n      value = new Array(n = (group = this[0]).length);\\n      while (++i < n) {\\n        if (node = group[i]) {\\n          value[i] = node.__data__;\\n        }\\n      }\\n      return value;\\n    }\\n    function bind(group, groupData) {\\n      var i, n = group.length, m = groupData.length, n0 = Math.min(n, m), updateNodes = new Array(m), enterNodes = new Array(m), exitNodes = new Array(n), node, nodeData;\\n      if (key) {\\n        var nodeByKeyValue = new d3_Map(), keyValues = new Array(n), keyValue;\\n        for (i = -1; ++i < n; ) {\\n          if (node = group[i]) {\\n            if (nodeByKeyValue.has(keyValue = key.call(node, node.__data__, i))) {\\n              exitNodes[i] = node;\\n            } else {\\n              nodeByKeyValue.set(keyValue, node);\\n            }\\n            keyValues[i] = keyValue;\\n          }\\n        }\\n        for (i = -1; ++i < m; ) {\\n          if (!(node = nodeByKeyValue.get(keyValue = key.call(groupData, nodeData = groupData[i], i)))) {\\n            enterNodes[i] = d3_selection_dataNode(nodeData);\\n          } else if (node !== true) {\\n            updateNodes[i] = node;\\n            node.__data__ = nodeData;\\n          }\\n          nodeByKeyValue.set(keyValue, true);\\n        }\\n        for (i = -1; ++i < n; ) {\\n          if (i in keyValues && nodeByKeyValue.get(keyValues[i]) !== true) {\\n            exitNodes[i] = group[i];\\n          }\\n        }\\n      } else {\\n        for (i = -1; ++i < n0; ) {\\n          node = group[i];\\n          nodeData = groupData[i];\\n          if (node) {\\n            node.__data__ = nodeData;\\n            updateNodes[i] = node;\\n          } else {\\n            enterNodes[i] = d3_selection_dataNode(nodeData);\\n          }\\n        }\\n        for (;i < m; ++i) {\\n          enterNodes[i] = d3_selection_dataNode(groupData[i]);\\n        }\\n        for (;i < n; ++i) {\\n          exitNodes[i] = group[i];\\n        }\\n      }\\n      enterNodes.update = updateNodes;\\n      enterNodes.parentNode = updateNodes.parentNode = exitNodes.parentNode = group.parentNode;\\n      enter.push(enterNodes);\\n      update.push(updateNodes);\\n      exit.push(exitNodes);\\n    }\\n    var enter = d3_selection_enter([]), update = d3_selection([]), exit = d3_selection([]);\\n    if (typeof value === \\\"function\\\") {\\n      while (++i < n) {\\n        bind(group = this[i], value.call(group, group.parentNode.__data__, i));\\n      }\\n    } else {\\n      while (++i < n) {\\n        bind(group = this[i], value);\\n      }\\n    }\\n    update.enter = function() {\\n      return enter;\\n    };\\n    update.exit = function() {\\n      return exit;\\n    };\\n    return update;\\n  };\\n  function d3_selection_dataNode(data) {\\n    return {\\n      __data__: data\\n    };\\n  }\\n  d3_selectionPrototype.datum = function(value) {\\n    return arguments.length ? this.property(\\\"__data__\\\", value) : this.property(\\\"__data__\\\");\\n  };\\n  d3_selectionPrototype.filter = function(filter) {\\n    var subgroups = [], subgroup, group, node;\\n    if (typeof filter !== \\\"function\\\") filter = d3_selection_filter(filter);\\n    for (var j = 0, m = this.length; j < m; j++) {\\n      subgroups.push(subgroup = []);\\n      subgroup.parentNode = (group = this[j]).parentNode;\\n      for (var i = 0, n = group.length; i < n; i++) {\\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\\n          subgroup.push(node);\\n        }\\n      }\\n    }\\n    return d3_selection(subgroups);\\n  };\\n  function d3_selection_filter(selector) {\\n    return function() {\\n      return d3_selectMatches(this, selector);\\n    };\\n  }\\n  d3_selectionPrototype.order = function() {\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      for (var group = this[j], i = group.length - 1, next = group[i], node; --i >= 0; ) {\\n        if (node = group[i]) {\\n          if (next && next !== node.nextSibling) next.parentNode.insertBefore(node, next);\\n          next = node;\\n        }\\n      }\\n    }\\n    return this;\\n  };\\n  d3_selectionPrototype.sort = function(comparator) {\\n    comparator = d3_selection_sortComparator.apply(this, arguments);\\n    for (var j = -1, m = this.length; ++j < m; ) this[j].sort(comparator);\\n    return this.order();\\n  };\\n  function d3_selection_sortComparator(comparator) {\\n    if (!arguments.length) comparator = d3_ascending;\\n    return function(a, b) {\\n      return a && b ? comparator(a.__data__, b.__data__) : !a - !b;\\n    };\\n  }\\n  d3_selectionPrototype.each = function(callback) {\\n    return d3_selection_each(this, function(node, i, j) {\\n      callback.call(node, node.__data__, i, j);\\n    });\\n  };\\n  function d3_selection_each(groups, callback) {\\n    for (var j = 0, m = groups.length; j < m; j++) {\\n      for (var group = groups[j], i = 0, n = group.length, node; i < n; i++) {\\n        if (node = group[i]) callback(node, i, j);\\n      }\\n    }\\n    return groups;\\n  }\\n  d3_selectionPrototype.call = function(callback) {\\n    var args = d3_array(arguments);\\n    callback.apply(args[0] = this, args);\\n    return this;\\n  };\\n  d3_selectionPrototype.empty = function() {\\n    return !this.node();\\n  };\\n  d3_selectionPrototype.node = function() {\\n    for (var j = 0, m = this.length; j < m; j++) {\\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\\n        var node = group[i];\\n        if (node) return node;\\n      }\\n    }\\n    return null;\\n  };\\n  d3_selectionPrototype.size = function() {\\n    var n = 0;\\n    d3_selection_each(this, function() {\\n      ++n;\\n    });\\n    return n;\\n  };\\n  function d3_selection_enter(selection) {\\n    d3_subclass(selection, d3_selection_enterPrototype);\\n    return selection;\\n  }\\n  var d3_selection_enterPrototype = [];\\n  d3.selection.enter = d3_selection_enter;\\n  d3.selection.enter.prototype = d3_selection_enterPrototype;\\n  d3_selection_enterPrototype.append = d3_selectionPrototype.append;\\n  d3_selection_enterPrototype.empty = d3_selectionPrototype.empty;\\n  d3_selection_enterPrototype.node = d3_selectionPrototype.node;\\n  d3_selection_enterPrototype.call = d3_selectionPrototype.call;\\n  d3_selection_enterPrototype.size = d3_selectionPrototype.size;\\n  d3_selection_enterPrototype.select = function(selector) {\\n    var subgroups = [], subgroup, subnode, upgroup, group, node;\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      upgroup = (group = this[j]).update;\\n      subgroups.push(subgroup = []);\\n      subgroup.parentNode = group.parentNode;\\n      for (var i = -1, n = group.length; ++i < n; ) {\\n        if (node = group[i]) {\\n          subgroup.push(upgroup[i] = subnode = selector.call(group.parentNode, node.__data__, i, j));\\n          subnode.__data__ = node.__data__;\\n        } else {\\n          subgroup.push(null);\\n        }\\n      }\\n    }\\n    return d3_selection(subgroups);\\n  };\\n  d3_selection_enterPrototype.insert = function(name, before) {\\n    if (arguments.length < 2) before = d3_selection_enterInsertBefore(this);\\n    return d3_selectionPrototype.insert.call(this, name, before);\\n  };\\n  function d3_selection_enterInsertBefore(enter) {\\n    var i0, j0;\\n    return function(d, i, j) {\\n      var group = enter[j].update, n = group.length, node;\\n      if (j != j0) j0 = j, i0 = 0;\\n      if (i >= i0) i0 = i + 1;\\n      while (!(node = group[i0]) && ++i0 < n) ;\\n      return node;\\n    };\\n  }\\n  d3.select = function(node) {\\n    var group;\\n    if (typeof node === \\\"string\\\") {\\n      group = [ d3_select(node, d3_document) ];\\n      group.parentNode = d3_document.documentElement;\\n    } else {\\n      group = [ node ];\\n      group.parentNode = d3_documentElement(node);\\n    }\\n    return d3_selection([ group ]);\\n  };\\n  d3.selectAll = function(nodes) {\\n    var group;\\n    if (typeof nodes === \\\"string\\\") {\\n      group = d3_array(d3_selectAll(nodes, d3_document));\\n      group.parentNode = d3_document.documentElement;\\n    } else {\\n      group = d3_array(nodes);\\n      group.parentNode = null;\\n    }\\n    return d3_selection([ group ]);\\n  };\\n  d3_selectionPrototype.on = function(type, listener, capture) {\\n    var n = arguments.length;\\n    if (n < 3) {\\n      if (typeof type !== \\\"string\\\") {\\n        if (n < 2) listener = false;\\n        for (capture in type) this.each(d3_selection_on(capture, type[capture], listener));\\n        return this;\\n      }\\n      if (n < 2) return (n = this.node()[\\\"__on\\\" + type]) && n._;\\n      capture = false;\\n    }\\n    return this.each(d3_selection_on(type, listener, capture));\\n  };\\n  function d3_selection_on(type, listener, capture) {\\n    var name = \\\"__on\\\" + type, i = type.indexOf(\\\".\\\"), wrap = d3_selection_onListener;\\n    if (i > 0) type = type.slice(0, i);\\n    var filter = d3_selection_onFilters.get(type);\\n    if (filter) type = filter, wrap = d3_selection_onFilter;\\n    function onRemove() {\\n      var l = this[name];\\n      if (l) {\\n        this.removeEventListener(type, l, l.$);\\n        delete this[name];\\n      }\\n    }\\n    function onAdd() {\\n      var l = wrap(listener, d3_array(arguments));\\n      onRemove.call(this);\\n      this.addEventListener(type, this[name] = l, l.$ = capture);\\n      l._ = listener;\\n    }\\n    function removeAll() {\\n      var re = new RegExp(\\\"^__on([^.]+)\\\" + d3.requote(type) + \\\"$\\\"), match;\\n      for (var name in this) {\\n        if (match = name.match(re)) {\\n          var l = this[name];\\n          this.removeEventListener(match[1], l, l.$);\\n          delete this[name];\\n        }\\n      }\\n    }\\n    return i ? listener ? onAdd : onRemove : listener ? d3_noop : removeAll;\\n  }\\n  var d3_selection_onFilters = d3.map({\\n    mouseenter: \\\"mouseover\\\",\\n    mouseleave: \\\"mouseout\\\"\\n  });\\n  if (d3_document) {\\n    d3_selection_onFilters.forEach(function(k) {\\n      if (\\\"on\\\" + k in d3_document) d3_selection_onFilters.remove(k);\\n    });\\n  }\\n  function d3_selection_onListener(listener, argumentz) {\\n    return function(e) {\\n      var o = d3.event;\\n      d3.event = e;\\n      argumentz[0] = this.__data__;\\n      try {\\n        listener.apply(this, argumentz);\\n      } finally {\\n        d3.event = o;\\n      }\\n    };\\n  }\\n  function d3_selection_onFilter(listener, argumentz) {\\n    var l = d3_selection_onListener(listener, argumentz);\\n    return function(e) {\\n      var target = this, related = e.relatedTarget;\\n      if (!related || related !== target && !(related.compareDocumentPosition(target) & 8)) {\\n        l.call(target, e);\\n      }\\n    };\\n  }\\n  var d3_event_dragSelect, d3_event_dragId = 0;\\n  function d3_event_dragSuppress(node) {\\n    var name = \\\".dragsuppress-\\\" + ++d3_event_dragId, click = \\\"click\\\" + name, w = d3.select(d3_window(node)).on(\\\"touchmove\\\" + name, d3_eventPreventDefault).on(\\\"dragstart\\\" + name, d3_eventPreventDefault).on(\\\"selectstart\\\" + name, d3_eventPreventDefault);\\n    if (d3_event_dragSelect == null) {\\n      d3_event_dragSelect = \\\"onselectstart\\\" in node ? false : d3_vendorSymbol(node.style, \\\"userSelect\\\");\\n    }\\n    if (d3_event_dragSelect) {\\n      var style = d3_documentElement(node).style, select = style[d3_event_dragSelect];\\n      style[d3_event_dragSelect] = \\\"none\\\";\\n    }\\n    return function(suppressClick) {\\n      w.on(name, null);\\n      if (d3_event_dragSelect) style[d3_event_dragSelect] = select;\\n      if (suppressClick) {\\n        var off = function() {\\n          w.on(click, null);\\n        };\\n        w.on(click, function() {\\n          d3_eventPreventDefault();\\n          off();\\n        }, true);\\n        setTimeout(off, 0);\\n      }\\n    };\\n  }\\n  d3.mouse = function(container) {\\n    return d3_mousePoint(container, d3_eventSource());\\n  };\\n  var d3_mouse_bug44083 = this.navigator && /WebKit/.test(this.navigator.userAgent) ? -1 : 0;\\n  function d3_mousePoint(container, e) {\\n    if (e.changedTouches) e = e.changedTouches[0];\\n    var svg = container.ownerSVGElement || container;\\n    if (svg.createSVGPoint) {\\n      var point = svg.createSVGPoint();\\n      if (d3_mouse_bug44083 < 0) {\\n        var window = d3_window(container);\\n        if (window.scrollX || window.scrollY) {\\n          svg = d3.select(\\\"body\\\").append(\\\"svg\\\").style({\\n            position: \\\"absolute\\\",\\n            top: 0,\\n            left: 0,\\n            margin: 0,\\n            padding: 0,\\n            border: \\\"none\\\"\\n          }, \\\"important\\\");\\n          var ctm = svg[0][0].getScreenCTM();\\n          d3_mouse_bug44083 = !(ctm.f || ctm.e);\\n          svg.remove();\\n        }\\n      }\\n      if (d3_mouse_bug44083) point.x = e.pageX, point.y = e.pageY; else point.x = e.clientX, \\n      point.y = e.clientY;\\n      point = point.matrixTransform(container.getScreenCTM().inverse());\\n      return [ point.x, point.y ];\\n    }\\n    var rect = container.getBoundingClientRect();\\n    return [ e.clientX - rect.left - container.clientLeft, e.clientY - rect.top - container.clientTop ];\\n  }\\n  d3.touch = function(container, touches, identifier) {\\n    if (arguments.length < 3) identifier = touches, touches = d3_eventSource().changedTouches;\\n    if (touches) for (var i = 0, n = touches.length, touch; i < n; ++i) {\\n      if ((touch = touches[i]).identifier === identifier) {\\n        return d3_mousePoint(container, touch);\\n      }\\n    }\\n  };\\n  d3.behavior.drag = function() {\\n    var event = d3_eventDispatch(drag, \\\"drag\\\", \\\"dragstart\\\", \\\"dragend\\\"), origin = null, mousedown = dragstart(d3_noop, d3.mouse, d3_window, \\\"mousemove\\\", \\\"mouseup\\\"), touchstart = dragstart(d3_behavior_dragTouchId, d3.touch, d3_identity, \\\"touchmove\\\", \\\"touchend\\\");\\n    function drag() {\\n      this.on(\\\"mousedown.drag\\\", mousedown).on(\\\"touchstart.drag\\\", touchstart);\\n    }\\n    function dragstart(id, position, subject, move, end) {\\n      return function() {\\n        var that = this, target = d3.event.target, parent = that.parentNode, dispatch = event.of(that, arguments), dragged = 0, dragId = id(), dragName = \\\".drag\\\" + (dragId == null ? \\\"\\\" : \\\"-\\\" + dragId), dragOffset, dragSubject = d3.select(subject(target)).on(move + dragName, moved).on(end + dragName, ended), dragRestore = d3_event_dragSuppress(target), position0 = position(parent, dragId);\\n        if (origin) {\\n          dragOffset = origin.apply(that, arguments);\\n          dragOffset = [ dragOffset.x - position0[0], dragOffset.y - position0[1] ];\\n        } else {\\n          dragOffset = [ 0, 0 ];\\n        }\\n        dispatch({\\n          type: \\\"dragstart\\\"\\n        });\\n        function moved() {\\n          var position1 = position(parent, dragId), dx, dy;\\n          if (!position1) return;\\n          dx = position1[0] - position0[0];\\n          dy = position1[1] - position0[1];\\n          dragged |= dx | dy;\\n          position0 = position1;\\n          dispatch({\\n            type: \\\"drag\\\",\\n            x: position1[0] + dragOffset[0],\\n            y: position1[1] + dragOffset[1],\\n            dx: dx,\\n            dy: dy\\n          });\\n        }\\n        function ended() {\\n          if (!position(parent, dragId)) return;\\n          dragSubject.on(move + dragName, null).on(end + dragName, null);\\n          dragRestore(dragged);\\n          dispatch({\\n            type: \\\"dragend\\\"\\n          });\\n        }\\n      };\\n    }\\n    drag.origin = function(x) {\\n      if (!arguments.length) return origin;\\n      origin = x;\\n      return drag;\\n    };\\n    return d3.rebind(drag, event, \\\"on\\\");\\n  };\\n  function d3_behavior_dragTouchId() {\\n    return d3.event.changedTouches[0].identifier;\\n  }\\n  d3.touches = function(container, touches) {\\n    if (arguments.length < 2) touches = d3_eventSource().touches;\\n    return touches ? d3_array(touches).map(function(touch) {\\n      var point = d3_mousePoint(container, touch);\\n      point.identifier = touch.identifier;\\n      return point;\\n    }) : [];\\n  };\\n  var ε = 1e-6, ε2 = ε * ε, π = Math.PI, τ = 2 * π, τε = τ - ε, halfπ = π / 2, d3_radians = π / 180, d3_degrees = 180 / π;\\n  function d3_sgn(x) {\\n    return x > 0 ? 1 : x < 0 ? -1 : 0;\\n  }\\n  function d3_cross2d(a, b, c) {\\n    return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]);\\n  }\\n  function d3_acos(x) {\\n    return x > 1 ? 0 : x < -1 ? π : Math.acos(x);\\n  }\\n  function d3_asin(x) {\\n    return x > 1 ? halfπ : x < -1 ? -halfπ : Math.asin(x);\\n  }\\n  function d3_sinh(x) {\\n    return ((x = Math.exp(x)) - 1 / x) / 2;\\n  }\\n  function d3_cosh(x) {\\n    return ((x = Math.exp(x)) + 1 / x) / 2;\\n  }\\n  function d3_tanh(x) {\\n    return ((x = Math.exp(2 * x)) - 1) / (x + 1);\\n  }\\n  function d3_haversin(x) {\\n    return (x = Math.sin(x / 2)) * x;\\n  }\\n  var ρ = Math.SQRT2, ρ2 = 2, ρ4 = 4;\\n  d3.interpolateZoom = function(p0, p1) {\\n    var ux0 = p0[0], uy0 = p0[1], w0 = p0[2], ux1 = p1[0], uy1 = p1[1], w1 = p1[2], dx = ux1 - ux0, dy = uy1 - uy0, d2 = dx * dx + dy * dy, i, S;\\n    if (d2 < ε2) {\\n      S = Math.log(w1 / w0) / ρ;\\n      i = function(t) {\\n        return [ ux0 + t * dx, uy0 + t * dy, w0 * Math.exp(ρ * t * S) ];\\n      };\\n    } else {\\n      var d1 = Math.sqrt(d2), b0 = (w1 * w1 - w0 * w0 + ρ4 * d2) / (2 * w0 * ρ2 * d1), b1 = (w1 * w1 - w0 * w0 - ρ4 * d2) / (2 * w1 * ρ2 * d1), r0 = Math.log(Math.sqrt(b0 * b0 + 1) - b0), r1 = Math.log(Math.sqrt(b1 * b1 + 1) - b1);\\n      S = (r1 - r0) / ρ;\\n      i = function(t) {\\n        var s = t * S, coshr0 = d3_cosh(r0), u = w0 / (ρ2 * d1) * (coshr0 * d3_tanh(ρ * s + r0) - d3_sinh(r0));\\n        return [ ux0 + u * dx, uy0 + u * dy, w0 * coshr0 / d3_cosh(ρ * s + r0) ];\\n      };\\n    }\\n    i.duration = S * 1e3;\\n    return i;\\n  };\\n  d3.behavior.zoom = function() {\\n    var view = {\\n      x: 0,\\n      y: 0,\\n      k: 1\\n    }, translate0, center0, center, size = [ 960, 500 ], scaleExtent = d3_behavior_zoomInfinity, duration = 250, zooming = 0, mousedown = \\\"mousedown.zoom\\\", mousemove = \\\"mousemove.zoom\\\", mouseup = \\\"mouseup.zoom\\\", mousewheelTimer, touchstart = \\\"touchstart.zoom\\\", touchtime, event = d3_eventDispatch(zoom, \\\"zoomstart\\\", \\\"zoom\\\", \\\"zoomend\\\"), x0, x1, y0, y1;\\n    if (!d3_behavior_zoomWheel) {\\n      d3_behavior_zoomWheel = \\\"onwheel\\\" in d3_document ? (d3_behavior_zoomDelta = function() {\\n        return -d3.event.deltaY * (d3.event.deltaMode ? 120 : 1);\\n      }, \\\"wheel\\\") : \\\"onmousewheel\\\" in d3_document ? (d3_behavior_zoomDelta = function() {\\n        return d3.event.wheelDelta;\\n      }, \\\"mousewheel\\\") : (d3_behavior_zoomDelta = function() {\\n        return -d3.event.detail;\\n      }, \\\"MozMousePixelScroll\\\");\\n    }\\n    function zoom(g) {\\n      g.on(mousedown, mousedowned).on(d3_behavior_zoomWheel + \\\".zoom\\\", mousewheeled).on(\\\"dblclick.zoom\\\", dblclicked).on(touchstart, touchstarted);\\n    }\\n    zoom.event = function(g) {\\n      g.each(function() {\\n        var dispatch = event.of(this, arguments), view1 = view;\\n        if (d3_transitionInheritId) {\\n          d3.select(this).transition().each(\\\"start.zoom\\\", function() {\\n            view = this.__chart__ || {\\n              x: 0,\\n              y: 0,\\n              k: 1\\n            };\\n            zoomstarted(dispatch);\\n          }).tween(\\\"zoom:zoom\\\", function() {\\n            var dx = size[0], dy = size[1], cx = center0 ? center0[0] : dx / 2, cy = center0 ? center0[1] : dy / 2, i = d3.interpolateZoom([ (cx - view.x) / view.k, (cy - view.y) / view.k, dx / view.k ], [ (cx - view1.x) / view1.k, (cy - view1.y) / view1.k, dx / view1.k ]);\\n            return function(t) {\\n              var l = i(t), k = dx / l[2];\\n              this.__chart__ = view = {\\n                x: cx - l[0] * k,\\n                y: cy - l[1] * k,\\n                k: k\\n              };\\n              zoomed(dispatch);\\n            };\\n          }).each(\\\"interrupt.zoom\\\", function() {\\n            zoomended(dispatch);\\n          }).each(\\\"end.zoom\\\", function() {\\n            zoomended(dispatch);\\n          });\\n        } else {\\n          this.__chart__ = view;\\n          zoomstarted(dispatch);\\n          zoomed(dispatch);\\n          zoomended(dispatch);\\n        }\\n      });\\n    };\\n    zoom.translate = function(_) {\\n      if (!arguments.length) return [ view.x, view.y ];\\n      view = {\\n        x: +_[0],\\n        y: +_[1],\\n        k: view.k\\n      };\\n      rescale();\\n      return zoom;\\n    };\\n    zoom.scale = function(_) {\\n      if (!arguments.length) return view.k;\\n      view = {\\n        x: view.x,\\n        y: view.y,\\n        k: null\\n      };\\n      scaleTo(+_);\\n      rescale();\\n      return zoom;\\n    };\\n    zoom.scaleExtent = function(_) {\\n      if (!arguments.length) return scaleExtent;\\n      scaleExtent = _ == null ? d3_behavior_zoomInfinity : [ +_[0], +_[1] ];\\n      return zoom;\\n    };\\n    zoom.center = function(_) {\\n      if (!arguments.length) return center;\\n      center = _ && [ +_[0], +_[1] ];\\n      return zoom;\\n    };\\n    zoom.size = function(_) {\\n      if (!arguments.length) return size;\\n      size = _ && [ +_[0], +_[1] ];\\n      return zoom;\\n    };\\n    zoom.duration = function(_) {\\n      if (!arguments.length) return duration;\\n      duration = +_;\\n      return zoom;\\n    };\\n    zoom.x = function(z) {\\n      if (!arguments.length) return x1;\\n      x1 = z;\\n      x0 = z.copy();\\n      view = {\\n        x: 0,\\n        y: 0,\\n        k: 1\\n      };\\n      return zoom;\\n    };\\n    zoom.y = function(z) {\\n      if (!arguments.length) return y1;\\n      y1 = z;\\n      y0 = z.copy();\\n      view = {\\n        x: 0,\\n        y: 0,\\n        k: 1\\n      };\\n      return zoom;\\n    };\\n    function location(p) {\\n      return [ (p[0] - view.x) / view.k, (p[1] - view.y) / view.k ];\\n    }\\n    function point(l) {\\n      return [ l[0] * view.k + view.x, l[1] * view.k + view.y ];\\n    }\\n    function scaleTo(s) {\\n      view.k = Math.max(scaleExtent[0], Math.min(scaleExtent[1], s));\\n    }\\n    function translateTo(p, l) {\\n      l = point(l);\\n      view.x += p[0] - l[0];\\n      view.y += p[1] - l[1];\\n    }\\n    function zoomTo(that, p, l, k) {\\n      that.__chart__ = {\\n        x: view.x,\\n        y: view.y,\\n        k: view.k\\n      };\\n      scaleTo(Math.pow(2, k));\\n      translateTo(center0 = p, l);\\n      that = d3.select(that);\\n      if (duration > 0) that = that.transition().duration(duration);\\n      that.call(zoom.event);\\n    }\\n    function rescale() {\\n      if (x1) x1.domain(x0.range().map(function(x) {\\n        return (x - view.x) / view.k;\\n      }).map(x0.invert));\\n      if (y1) y1.domain(y0.range().map(function(y) {\\n        return (y - view.y) / view.k;\\n      }).map(y0.invert));\\n    }\\n    function zoomstarted(dispatch) {\\n      if (!zooming++) dispatch({\\n        type: \\\"zoomstart\\\"\\n      });\\n    }\\n    function zoomed(dispatch) {\\n      rescale();\\n      dispatch({\\n        type: \\\"zoom\\\",\\n        scale: view.k,\\n        translate: [ view.x, view.y ]\\n      });\\n    }\\n    function zoomended(dispatch) {\\n      if (!--zooming) dispatch({\\n        type: \\\"zoomend\\\"\\n      }), center0 = null;\\n    }\\n    function mousedowned() {\\n      var that = this, dispatch = event.of(that, arguments), dragged = 0, subject = d3.select(d3_window(that)).on(mousemove, moved).on(mouseup, ended), location0 = location(d3.mouse(that)), dragRestore = d3_event_dragSuppress(that);\\n      d3_selection_interrupt.call(that);\\n      zoomstarted(dispatch);\\n      function moved() {\\n        dragged = 1;\\n        translateTo(d3.mouse(that), location0);\\n        zoomed(dispatch);\\n      }\\n      function ended() {\\n        subject.on(mousemove, null).on(mouseup, null);\\n        dragRestore(dragged);\\n        zoomended(dispatch);\\n      }\\n    }\\n    function touchstarted() {\\n      var that = this, dispatch = event.of(that, arguments), locations0 = {}, distance0 = 0, scale0, zoomName = \\\".zoom-\\\" + d3.event.changedTouches[0].identifier, touchmove = \\\"touchmove\\\" + zoomName, touchend = \\\"touchend\\\" + zoomName, targets = [], subject = d3.select(that), dragRestore = d3_event_dragSuppress(that);\\n      started();\\n      zoomstarted(dispatch);\\n      subject.on(mousedown, null).on(touchstart, started);\\n      function relocate() {\\n        var touches = d3.touches(that);\\n        scale0 = view.k;\\n        touches.forEach(function(t) {\\n          if (t.identifier in locations0) locations0[t.identifier] = location(t);\\n        });\\n        return touches;\\n      }\\n      function started() {\\n        var target = d3.event.target;\\n        d3.select(target).on(touchmove, moved).on(touchend, ended);\\n        targets.push(target);\\n        var changed = d3.event.changedTouches;\\n        for (var i = 0, n = changed.length; i < n; ++i) {\\n          locations0[changed[i].identifier] = null;\\n        }\\n        var touches = relocate(), now = Date.now();\\n        if (touches.length === 1) {\\n          if (now - touchtime < 500) {\\n            var p = touches[0];\\n            zoomTo(that, p, locations0[p.identifier], Math.floor(Math.log(view.k) / Math.LN2) + 1);\\n            d3_eventPreventDefault();\\n          }\\n          touchtime = now;\\n        } else if (touches.length > 1) {\\n          var p = touches[0], q = touches[1], dx = p[0] - q[0], dy = p[1] - q[1];\\n          distance0 = dx * dx + dy * dy;\\n        }\\n      }\\n      function moved() {\\n        var touches = d3.touches(that), p0, l0, p1, l1;\\n        d3_selection_interrupt.call(that);\\n        for (var i = 0, n = touches.length; i < n; ++i, l1 = null) {\\n          p1 = touches[i];\\n          if (l1 = locations0[p1.identifier]) {\\n            if (l0) break;\\n            p0 = p1, l0 = l1;\\n          }\\n        }\\n        if (l1) {\\n          var distance1 = (distance1 = p1[0] - p0[0]) * distance1 + (distance1 = p1[1] - p0[1]) * distance1, scale1 = distance0 && Math.sqrt(distance1 / distance0);\\n          p0 = [ (p0[0] + p1[0]) / 2, (p0[1] + p1[1]) / 2 ];\\n          l0 = [ (l0[0] + l1[0]) / 2, (l0[1] + l1[1]) / 2 ];\\n          scaleTo(scale1 * scale0);\\n        }\\n        touchtime = null;\\n        translateTo(p0, l0);\\n        zoomed(dispatch);\\n      }\\n      function ended() {\\n        if (d3.event.touches.length) {\\n          var changed = d3.event.changedTouches;\\n          for (var i = 0, n = changed.length; i < n; ++i) {\\n            delete locations0[changed[i].identifier];\\n          }\\n          for (var identifier in locations0) {\\n            return void relocate();\\n          }\\n        }\\n        d3.selectAll(targets).on(zoomName, null);\\n        subject.on(mousedown, mousedowned).on(touchstart, touchstarted);\\n        dragRestore();\\n        zoomended(dispatch);\\n      }\\n    }\\n    function mousewheeled() {\\n      var dispatch = event.of(this, arguments);\\n      if (mousewheelTimer) clearTimeout(mousewheelTimer); else d3_selection_interrupt.call(this), \\n      translate0 = location(center0 = center || d3.mouse(this)), zoomstarted(dispatch);\\n      mousewheelTimer = setTimeout(function() {\\n        mousewheelTimer = null;\\n        zoomended(dispatch);\\n      }, 50);\\n      d3_eventPreventDefault();\\n      scaleTo(Math.pow(2, d3_behavior_zoomDelta() * .002) * view.k);\\n      translateTo(center0, translate0);\\n      zoomed(dispatch);\\n    }\\n    function dblclicked() {\\n      var p = d3.mouse(this), k = Math.log(view.k) / Math.LN2;\\n      zoomTo(this, p, location(p), d3.event.shiftKey ? Math.ceil(k) - 1 : Math.floor(k) + 1);\\n    }\\n    return d3.rebind(zoom, event, \\\"on\\\");\\n  };\\n  var d3_behavior_zoomInfinity = [ 0, Infinity ], d3_behavior_zoomDelta, d3_behavior_zoomWheel;\\n  d3.color = d3_color;\\n  function d3_color() {}\\n  d3_color.prototype.toString = function() {\\n    return this.rgb() + \\\"\\\";\\n  };\\n  d3.hsl = d3_hsl;\\n  function d3_hsl(h, s, l) {\\n    return this instanceof d3_hsl ? void (this.h = +h, this.s = +s, this.l = +l) : arguments.length < 2 ? h instanceof d3_hsl ? new d3_hsl(h.h, h.s, h.l) : d3_rgb_parse(\\\"\\\" + h, d3_rgb_hsl, d3_hsl) : new d3_hsl(h, s, l);\\n  }\\n  var d3_hslPrototype = d3_hsl.prototype = new d3_color();\\n  d3_hslPrototype.brighter = function(k) {\\n    k = Math.pow(.7, arguments.length ? k : 1);\\n    return new d3_hsl(this.h, this.s, this.l / k);\\n  };\\n  d3_hslPrototype.darker = function(k) {\\n    k = Math.pow(.7, arguments.length ? k : 1);\\n    return new d3_hsl(this.h, this.s, k * this.l);\\n  };\\n  d3_hslPrototype.rgb = function() {\\n    return d3_hsl_rgb(this.h, this.s, this.l);\\n  };\\n  function d3_hsl_rgb(h, s, l) {\\n    var m1, m2;\\n    h = isNaN(h) ? 0 : (h %= 360) < 0 ? h + 360 : h;\\n    s = isNaN(s) ? 0 : s < 0 ? 0 : s > 1 ? 1 : s;\\n    l = l < 0 ? 0 : l > 1 ? 1 : l;\\n    m2 = l <= .5 ? l * (1 + s) : l + s - l * s;\\n    m1 = 2 * l - m2;\\n    function v(h) {\\n      if (h > 360) h -= 360; else if (h < 0) h += 360;\\n      if (h < 60) return m1 + (m2 - m1) * h / 60;\\n      if (h < 180) return m2;\\n      if (h < 240) return m1 + (m2 - m1) * (240 - h) / 60;\\n      return m1;\\n    }\\n    function vv(h) {\\n      return Math.round(v(h) * 255);\\n    }\\n    return new d3_rgb(vv(h + 120), vv(h), vv(h - 120));\\n  }\\n  d3.hcl = d3_hcl;\\n  function d3_hcl(h, c, l) {\\n    return this instanceof d3_hcl ? void (this.h = +h, this.c = +c, this.l = +l) : arguments.length < 2 ? h instanceof d3_hcl ? new d3_hcl(h.h, h.c, h.l) : h instanceof d3_lab ? d3_lab_hcl(h.l, h.a, h.b) : d3_lab_hcl((h = d3_rgb_lab((h = d3.rgb(h)).r, h.g, h.b)).l, h.a, h.b) : new d3_hcl(h, c, l);\\n  }\\n  var d3_hclPrototype = d3_hcl.prototype = new d3_color();\\n  d3_hclPrototype.brighter = function(k) {\\n    return new d3_hcl(this.h, this.c, Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)));\\n  };\\n  d3_hclPrototype.darker = function(k) {\\n    return new d3_hcl(this.h, this.c, Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)));\\n  };\\n  d3_hclPrototype.rgb = function() {\\n    return d3_hcl_lab(this.h, this.c, this.l).rgb();\\n  };\\n  function d3_hcl_lab(h, c, l) {\\n    if (isNaN(h)) h = 0;\\n    if (isNaN(c)) c = 0;\\n    return new d3_lab(l, Math.cos(h *= d3_radians) * c, Math.sin(h) * c);\\n  }\\n  d3.lab = d3_lab;\\n  function d3_lab(l, a, b) {\\n    return this instanceof d3_lab ? void (this.l = +l, this.a = +a, this.b = +b) : arguments.length < 2 ? l instanceof d3_lab ? new d3_lab(l.l, l.a, l.b) : l instanceof d3_hcl ? d3_hcl_lab(l.h, l.c, l.l) : d3_rgb_lab((l = d3_rgb(l)).r, l.g, l.b) : new d3_lab(l, a, b);\\n  }\\n  var d3_lab_K = 18;\\n  var d3_lab_X = .95047, d3_lab_Y = 1, d3_lab_Z = 1.08883;\\n  var d3_labPrototype = d3_lab.prototype = new d3_color();\\n  d3_labPrototype.brighter = function(k) {\\n    return new d3_lab(Math.min(100, this.l + d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\\n  };\\n  d3_labPrototype.darker = function(k) {\\n    return new d3_lab(Math.max(0, this.l - d3_lab_K * (arguments.length ? k : 1)), this.a, this.b);\\n  };\\n  d3_labPrototype.rgb = function() {\\n    return d3_lab_rgb(this.l, this.a, this.b);\\n  };\\n  function d3_lab_rgb(l, a, b) {\\n    var y = (l + 16) / 116, x = y + a / 500, z = y - b / 200;\\n    x = d3_lab_xyz(x) * d3_lab_X;\\n    y = d3_lab_xyz(y) * d3_lab_Y;\\n    z = d3_lab_xyz(z) * d3_lab_Z;\\n    return new d3_rgb(d3_xyz_rgb(3.2404542 * x - 1.5371385 * y - .4985314 * z), d3_xyz_rgb(-.969266 * x + 1.8760108 * y + .041556 * z), d3_xyz_rgb(.0556434 * x - .2040259 * y + 1.0572252 * z));\\n  }\\n  function d3_lab_hcl(l, a, b) {\\n    return l > 0 ? new d3_hcl(Math.atan2(b, a) * d3_degrees, Math.sqrt(a * a + b * b), l) : new d3_hcl(NaN, NaN, l);\\n  }\\n  function d3_lab_xyz(x) {\\n    return x > .206893034 ? x * x * x : (x - 4 / 29) / 7.787037;\\n  }\\n  function d3_xyz_lab(x) {\\n    return x > .008856 ? Math.pow(x, 1 / 3) : 7.787037 * x + 4 / 29;\\n  }\\n  function d3_xyz_rgb(r) {\\n    return Math.round(255 * (r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055));\\n  }\\n  d3.rgb = d3_rgb;\\n  function d3_rgb(r, g, b) {\\n    return this instanceof d3_rgb ? void (this.r = ~~r, this.g = ~~g, this.b = ~~b) : arguments.length < 2 ? r instanceof d3_rgb ? new d3_rgb(r.r, r.g, r.b) : d3_rgb_parse(\\\"\\\" + r, d3_rgb, d3_hsl_rgb) : new d3_rgb(r, g, b);\\n  }\\n  function d3_rgbNumber(value) {\\n    return new d3_rgb(value >> 16, value >> 8 & 255, value & 255);\\n  }\\n  function d3_rgbString(value) {\\n    return d3_rgbNumber(value) + \\\"\\\";\\n  }\\n  var d3_rgbPrototype = d3_rgb.prototype = new d3_color();\\n  d3_rgbPrototype.brighter = function(k) {\\n    k = Math.pow(.7, arguments.length ? k : 1);\\n    var r = this.r, g = this.g, b = this.b, i = 30;\\n    if (!r && !g && !b) return new d3_rgb(i, i, i);\\n    if (r && r < i) r = i;\\n    if (g && g < i) g = i;\\n    if (b && b < i) b = i;\\n    return new d3_rgb(Math.min(255, r / k), Math.min(255, g / k), Math.min(255, b / k));\\n  };\\n  d3_rgbPrototype.darker = function(k) {\\n    k = Math.pow(.7, arguments.length ? k : 1);\\n    return new d3_rgb(k * this.r, k * this.g, k * this.b);\\n  };\\n  d3_rgbPrototype.hsl = function() {\\n    return d3_rgb_hsl(this.r, this.g, this.b);\\n  };\\n  d3_rgbPrototype.toString = function() {\\n    return \\\"#\\\" + d3_rgb_hex(this.r) + d3_rgb_hex(this.g) + d3_rgb_hex(this.b);\\n  };\\n  function d3_rgb_hex(v) {\\n    return v < 16 ? \\\"0\\\" + Math.max(0, v).toString(16) : Math.min(255, v).toString(16);\\n  }\\n  function d3_rgb_parse(format, rgb, hsl) {\\n    var r = 0, g = 0, b = 0, m1, m2, color;\\n    m1 = /([a-z]+)\\\\((.*)\\\\)/.exec(format = format.toLowerCase());\\n    if (m1) {\\n      m2 = m1[2].split(\\\",\\\");\\n      switch (m1[1]) {\\n       case \\\"hsl\\\":\\n        {\\n          return hsl(parseFloat(m2[0]), parseFloat(m2[1]) / 100, parseFloat(m2[2]) / 100);\\n        }\\n\\n       case \\\"rgb\\\":\\n        {\\n          return rgb(d3_rgb_parseNumber(m2[0]), d3_rgb_parseNumber(m2[1]), d3_rgb_parseNumber(m2[2]));\\n        }\\n      }\\n    }\\n    if (color = d3_rgb_names.get(format)) {\\n      return rgb(color.r, color.g, color.b);\\n    }\\n    if (format != null && format.charAt(0) === \\\"#\\\" && !isNaN(color = parseInt(format.slice(1), 16))) {\\n      if (format.length === 4) {\\n        r = (color & 3840) >> 4;\\n        r = r >> 4 | r;\\n        g = color & 240;\\n        g = g >> 4 | g;\\n        b = color & 15;\\n        b = b << 4 | b;\\n      } else if (format.length === 7) {\\n        r = (color & 16711680) >> 16;\\n        g = (color & 65280) >> 8;\\n        b = color & 255;\\n      }\\n    }\\n    return rgb(r, g, b);\\n  }\\n  function d3_rgb_hsl(r, g, b) {\\n    var min = Math.min(r /= 255, g /= 255, b /= 255), max = Math.max(r, g, b), d = max - min, h, s, l = (max + min) / 2;\\n    if (d) {\\n      s = l < .5 ? d / (max + min) : d / (2 - max - min);\\n      if (r == max) h = (g - b) / d + (g < b ? 6 : 0); else if (g == max) h = (b - r) / d + 2; else h = (r - g) / d + 4;\\n      h *= 60;\\n    } else {\\n      h = NaN;\\n      s = l > 0 && l < 1 ? 0 : h;\\n    }\\n    return new d3_hsl(h, s, l);\\n  }\\n  function d3_rgb_lab(r, g, b) {\\n    r = d3_rgb_xyz(r);\\n    g = d3_rgb_xyz(g);\\n    b = d3_rgb_xyz(b);\\n    var x = d3_xyz_lab((.4124564 * r + .3575761 * g + .1804375 * b) / d3_lab_X), y = d3_xyz_lab((.2126729 * r + .7151522 * g + .072175 * b) / d3_lab_Y), z = d3_xyz_lab((.0193339 * r + .119192 * g + .9503041 * b) / d3_lab_Z);\\n    return d3_lab(116 * y - 16, 500 * (x - y), 200 * (y - z));\\n  }\\n  function d3_rgb_xyz(r) {\\n    return (r /= 255) <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4);\\n  }\\n  function d3_rgb_parseNumber(c) {\\n    var f = parseFloat(c);\\n    return c.charAt(c.length - 1) === \\\"%\\\" ? Math.round(f * 2.55) : f;\\n  }\\n  var d3_rgb_names = d3.map({\\n    aliceblue: 15792383,\\n    antiquewhite: 16444375,\\n    aqua: 65535,\\n    aquamarine: 8388564,\\n    azure: 15794175,\\n    beige: 16119260,\\n    bisque: 16770244,\\n    black: 0,\\n    blanchedalmond: 16772045,\\n    blue: 255,\\n    blueviolet: 9055202,\\n    brown: 10824234,\\n    burlywood: 14596231,\\n    cadetblue: 6266528,\\n    chartreuse: 8388352,\\n    chocolate: 13789470,\\n    coral: 16744272,\\n    cornflowerblue: 6591981,\\n    cornsilk: 16775388,\\n    crimson: 14423100,\\n    cyan: 65535,\\n    darkblue: 139,\\n    darkcyan: 35723,\\n    darkgoldenrod: 12092939,\\n    darkgray: 11119017,\\n    darkgreen: 25600,\\n    darkgrey: 11119017,\\n    darkkhaki: 12433259,\\n    darkmagenta: 9109643,\\n    darkolivegreen: 5597999,\\n    darkorange: 16747520,\\n    darkorchid: 10040012,\\n    darkred: 9109504,\\n    darksalmon: 15308410,\\n    darkseagreen: 9419919,\\n    darkslateblue: 4734347,\\n    darkslategray: 3100495,\\n    darkslategrey: 3100495,\\n    darkturquoise: 52945,\\n    darkviolet: 9699539,\\n    deeppink: 16716947,\\n    deepskyblue: 49151,\\n    dimgray: 6908265,\\n    dimgrey: 6908265,\\n    dodgerblue: 2003199,\\n    firebrick: 11674146,\\n    floralwhite: 16775920,\\n    forestgreen: 2263842,\\n    fuchsia: 16711935,\\n    gainsboro: 14474460,\\n    ghostwhite: 16316671,\\n    gold: 16766720,\\n    goldenrod: 14329120,\\n    gray: 8421504,\\n    green: 32768,\\n    greenyellow: 11403055,\\n    grey: 8421504,\\n    honeydew: 15794160,\\n    hotpink: 16738740,\\n    indianred: 13458524,\\n    indigo: 4915330,\\n    ivory: 16777200,\\n    khaki: 15787660,\\n    lavender: 15132410,\\n    lavenderblush: 16773365,\\n    lawngreen: 8190976,\\n    lemonchiffon: 16775885,\\n    lightblue: 11393254,\\n    lightcoral: 15761536,\\n    lightcyan: 14745599,\\n    lightgoldenrodyellow: 16448210,\\n    lightgray: 13882323,\\n    lightgreen: 9498256,\\n    lightgrey: 13882323,\\n    lightpink: 16758465,\\n    lightsalmon: 16752762,\\n    lightseagreen: 2142890,\\n    lightskyblue: 8900346,\\n    lightslategray: 7833753,\\n    lightslategrey: 7833753,\\n    lightsteelblue: 11584734,\\n    lightyellow: 16777184,\\n    lime: 65280,\\n    limegreen: 3329330,\\n    linen: 16445670,\\n    magenta: 16711935,\\n    maroon: 8388608,\\n    mediumaquamarine: 6737322,\\n    mediumblue: 205,\\n    mediumorchid: 12211667,\\n    mediumpurple: 9662683,\\n    mediumseagreen: 3978097,\\n    mediumslateblue: 8087790,\\n    mediumspringgreen: 64154,\\n    mediumturquoise: 4772300,\\n    mediumvioletred: 13047173,\\n    midnightblue: 1644912,\\n    mintcream: 16121850,\\n    mistyrose: 16770273,\\n    moccasin: 16770229,\\n    navajowhite: 16768685,\\n    navy: 128,\\n    oldlace: 16643558,\\n    olive: 8421376,\\n    olivedrab: 7048739,\\n    orange: 16753920,\\n    orangered: 16729344,\\n    orchid: 14315734,\\n    palegoldenrod: 15657130,\\n    palegreen: 10025880,\\n    paleturquoise: 11529966,\\n    palevioletred: 14381203,\\n    papayawhip: 16773077,\\n    peachpuff: 16767673,\\n    peru: 13468991,\\n    pink: 16761035,\\n    plum: 14524637,\\n    powderblue: 11591910,\\n    purple: 8388736,\\n    rebeccapurple: 6697881,\\n    red: 16711680,\\n    rosybrown: 12357519,\\n    royalblue: 4286945,\\n    saddlebrown: 9127187,\\n    salmon: 16416882,\\n    sandybrown: 16032864,\\n    seagreen: 3050327,\\n    seashell: 16774638,\\n    sienna: 10506797,\\n    silver: 12632256,\\n    skyblue: 8900331,\\n    slateblue: 6970061,\\n    slategray: 7372944,\\n    slategrey: 7372944,\\n    snow: 16775930,\\n    springgreen: 65407,\\n    steelblue: 4620980,\\n    tan: 13808780,\\n    teal: 32896,\\n    thistle: 14204888,\\n    tomato: 16737095,\\n    turquoise: 4251856,\\n    violet: 15631086,\\n    wheat: 16113331,\\n    white: 16777215,\\n    whitesmoke: 16119285,\\n    yellow: 16776960,\\n    yellowgreen: 10145074\\n  });\\n  d3_rgb_names.forEach(function(key, value) {\\n    d3_rgb_names.set(key, d3_rgbNumber(value));\\n  });\\n  function d3_functor(v) {\\n    return typeof v === \\\"function\\\" ? v : function() {\\n      return v;\\n    };\\n  }\\n  d3.functor = d3_functor;\\n  d3.xhr = d3_xhrType(d3_identity);\\n  function d3_xhrType(response) {\\n    return function(url, mimeType, callback) {\\n      if (arguments.length === 2 && typeof mimeType === \\\"function\\\") callback = mimeType, \\n      mimeType = null;\\n      return d3_xhr(url, mimeType, response, callback);\\n    };\\n  }\\n  function d3_xhr(url, mimeType, response, callback) {\\n    var xhr = {}, dispatch = d3.dispatch(\\\"beforesend\\\", \\\"progress\\\", \\\"load\\\", \\\"error\\\"), headers = {}, request = new XMLHttpRequest(), responseType = null;\\n    if (this.XDomainRequest && !(\\\"withCredentials\\\" in request) && /^(http(s)?:)?\\\\/\\\\//.test(url)) request = new XDomainRequest();\\n    \\\"onload\\\" in request ? request.onload = request.onerror = respond : request.onreadystatechange = function() {\\n      request.readyState > 3 && respond();\\n    };\\n    function respond() {\\n      var status = request.status, result;\\n      if (!status && d3_xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\\n        try {\\n          result = response.call(xhr, request);\\n        } catch (e) {\\n          dispatch.error.call(xhr, e);\\n          return;\\n        }\\n        dispatch.load.call(xhr, result);\\n      } else {\\n        dispatch.error.call(xhr, request);\\n      }\\n    }\\n    request.onprogress = function(event) {\\n      var o = d3.event;\\n      d3.event = event;\\n      try {\\n        dispatch.progress.call(xhr, request);\\n      } finally {\\n        d3.event = o;\\n      }\\n    };\\n    xhr.header = function(name, value) {\\n      name = (name + \\\"\\\").toLowerCase();\\n      if (arguments.length < 2) return headers[name];\\n      if (value == null) delete headers[name]; else headers[name] = value + \\\"\\\";\\n      return xhr;\\n    };\\n    xhr.mimeType = function(value) {\\n      if (!arguments.length) return mimeType;\\n      mimeType = value == null ? null : value + \\\"\\\";\\n      return xhr;\\n    };\\n    xhr.responseType = function(value) {\\n      if (!arguments.length) return responseType;\\n      responseType = value;\\n      return xhr;\\n    };\\n    xhr.response = function(value) {\\n      response = value;\\n      return xhr;\\n    };\\n    [ \\\"get\\\", \\\"post\\\" ].forEach(function(method) {\\n      xhr[method] = function() {\\n        return xhr.send.apply(xhr, [ method ].concat(d3_array(arguments)));\\n      };\\n    });\\n    xhr.send = function(method, data, callback) {\\n      if (arguments.length === 2 && typeof data === \\\"function\\\") callback = data, data = null;\\n      request.open(method, url, true);\\n      if (mimeType != null && !(\\\"accept\\\" in headers)) headers[\\\"accept\\\"] = mimeType + \\\",*/*\\\";\\n      if (request.setRequestHeader) for (var name in headers) request.setRequestHeader(name, headers[name]);\\n      if (mimeType != null && request.overrideMimeType) request.overrideMimeType(mimeType);\\n      if (responseType != null) request.responseType = responseType;\\n      if (callback != null) xhr.on(\\\"error\\\", callback).on(\\\"load\\\", function(request) {\\n        callback(null, request);\\n      });\\n      dispatch.beforesend.call(xhr, request);\\n      request.send(data == null ? null : data);\\n      return xhr;\\n    };\\n    xhr.abort = function() {\\n      request.abort();\\n      return xhr;\\n    };\\n    d3.rebind(xhr, dispatch, \\\"on\\\");\\n    return callback == null ? xhr : xhr.get(d3_xhr_fixCallback(callback));\\n  }\\n  function d3_xhr_fixCallback(callback) {\\n    return callback.length === 1 ? function(error, request) {\\n      callback(error == null ? request : null);\\n    } : callback;\\n  }\\n  function d3_xhrHasResponse(request) {\\n    var type = request.responseType;\\n    return type && type !== \\\"text\\\" ? request.response : request.responseText;\\n  }\\n  d3.dsv = function(delimiter, mimeType) {\\n    var reFormat = new RegExp('[\\\"' + delimiter + \\\"\\\\n]\\\"), delimiterCode = delimiter.charCodeAt(0);\\n    function dsv(url, row, callback) {\\n      if (arguments.length < 3) callback = row, row = null;\\n      var xhr = d3_xhr(url, mimeType, row == null ? response : typedResponse(row), callback);\\n      xhr.row = function(_) {\\n        return arguments.length ? xhr.response((row = _) == null ? response : typedResponse(_)) : row;\\n      };\\n      return xhr;\\n    }\\n    function response(request) {\\n      return dsv.parse(request.responseText);\\n    }\\n    function typedResponse(f) {\\n      return function(request) {\\n        return dsv.parse(request.responseText, f);\\n      };\\n    }\\n    dsv.parse = function(text, f) {\\n      var o;\\n      return dsv.parseRows(text, function(row, i) {\\n        if (o) return o(row, i - 1);\\n        var a = new Function(\\\"d\\\", \\\"return {\\\" + row.map(function(name, i) {\\n          return JSON.stringify(name) + \\\": d[\\\" + i + \\\"]\\\";\\n        }).join(\\\",\\\") + \\\"}\\\");\\n        o = f ? function(row, i) {\\n          return f(a(row), i);\\n        } : a;\\n      });\\n    };\\n    dsv.parseRows = function(text, f) {\\n      var EOL = {}, EOF = {}, rows = [], N = text.length, I = 0, n = 0, t, eol;\\n      function token() {\\n        if (I >= N) return EOF;\\n        if (eol) return eol = false, EOL;\\n        var j = I;\\n        if (text.charCodeAt(j) === 34) {\\n          var i = j;\\n          while (i++ < N) {\\n            if (text.charCodeAt(i) === 34) {\\n              if (text.charCodeAt(i + 1) !== 34) break;\\n              ++i;\\n            }\\n          }\\n          I = i + 2;\\n          var c = text.charCodeAt(i + 1);\\n          if (c === 13) {\\n            eol = true;\\n            if (text.charCodeAt(i + 2) === 10) ++I;\\n          } else if (c === 10) {\\n            eol = true;\\n          }\\n          return text.slice(j + 1, i).replace(/\\\"\\\"/g, '\\\"');\\n        }\\n        while (I < N) {\\n          var c = text.charCodeAt(I++), k = 1;\\n          if (c === 10) eol = true; else if (c === 13) {\\n            eol = true;\\n            if (text.charCodeAt(I) === 10) ++I, ++k;\\n          } else if (c !== delimiterCode) continue;\\n          return text.slice(j, I - k);\\n        }\\n        return text.slice(j);\\n      }\\n      while ((t = token()) !== EOF) {\\n        var a = [];\\n        while (t !== EOL && t !== EOF) {\\n          a.push(t);\\n          t = token();\\n        }\\n        if (f && (a = f(a, n++)) == null) continue;\\n        rows.push(a);\\n      }\\n      return rows;\\n    };\\n    dsv.format = function(rows) {\\n      if (Array.isArray(rows[0])) return dsv.formatRows(rows);\\n      var fieldSet = new d3_Set(), fields = [];\\n      rows.forEach(function(row) {\\n        for (var field in row) {\\n          if (!fieldSet.has(field)) {\\n            fields.push(fieldSet.add(field));\\n          }\\n        }\\n      });\\n      return [ fields.map(formatValue).join(delimiter) ].concat(rows.map(function(row) {\\n        return fields.map(function(field) {\\n          return formatValue(row[field]);\\n        }).join(delimiter);\\n      })).join(\\\"\\\\n\\\");\\n    };\\n    dsv.formatRows = function(rows) {\\n      return rows.map(formatRow).join(\\\"\\\\n\\\");\\n    };\\n    function formatRow(row) {\\n      return row.map(formatValue).join(delimiter);\\n    }\\n    function formatValue(text) {\\n      return reFormat.test(text) ? '\\\"' + text.replace(/\\\\\\\"/g, '\\\"\\\"') + '\\\"' : text;\\n    }\\n    return dsv;\\n  };\\n  d3.csv = d3.dsv(\\\",\\\", \\\"text/csv\\\");\\n  d3.tsv = d3.dsv(\\\"\\t\\\", \\\"text/tab-separated-values\\\");\\n  var d3_timer_queueHead, d3_timer_queueTail, d3_timer_interval, d3_timer_timeout, d3_timer_frame = this[d3_vendorSymbol(this, \\\"requestAnimationFrame\\\")] || function(callback) {\\n    setTimeout(callback, 17);\\n  };\\n  d3.timer = function() {\\n    d3_timer.apply(this, arguments);\\n  };\\n  function d3_timer(callback, delay, then) {\\n    var n = arguments.length;\\n    if (n < 2) delay = 0;\\n    if (n < 3) then = Date.now();\\n    var time = then + delay, timer = {\\n      c: callback,\\n      t: time,\\n      n: null\\n    };\\n    if (d3_timer_queueTail) d3_timer_queueTail.n = timer; else d3_timer_queueHead = timer;\\n    d3_timer_queueTail = timer;\\n    if (!d3_timer_interval) {\\n      d3_timer_timeout = clearTimeout(d3_timer_timeout);\\n      d3_timer_interval = 1;\\n      d3_timer_frame(d3_timer_step);\\n    }\\n    return timer;\\n  }\\n  function d3_timer_step() {\\n    var now = d3_timer_mark(), delay = d3_timer_sweep() - now;\\n    if (delay > 24) {\\n      if (isFinite(delay)) {\\n        clearTimeout(d3_timer_timeout);\\n        d3_timer_timeout = setTimeout(d3_timer_step, delay);\\n      }\\n      d3_timer_interval = 0;\\n    } else {\\n      d3_timer_interval = 1;\\n      d3_timer_frame(d3_timer_step);\\n    }\\n  }\\n  d3.timer.flush = function() {\\n    d3_timer_mark();\\n    d3_timer_sweep();\\n  };\\n  function d3_timer_mark() {\\n    var now = Date.now(), timer = d3_timer_queueHead;\\n    while (timer) {\\n      if (now >= timer.t && timer.c(now - timer.t)) timer.c = null;\\n      timer = timer.n;\\n    }\\n    return now;\\n  }\\n  function d3_timer_sweep() {\\n    var t0, t1 = d3_timer_queueHead, time = Infinity;\\n    while (t1) {\\n      if (t1.c) {\\n        if (t1.t < time) time = t1.t;\\n        t1 = (t0 = t1).n;\\n      } else {\\n        t1 = t0 ? t0.n = t1.n : d3_timer_queueHead = t1.n;\\n      }\\n    }\\n    d3_timer_queueTail = t0;\\n    return time;\\n  }\\n  function d3_format_precision(x, p) {\\n    return p - (x ? Math.ceil(Math.log(x) / Math.LN10) : 1);\\n  }\\n  d3.round = function(x, n) {\\n    return n ? Math.round(x * (n = Math.pow(10, n))) / n : Math.round(x);\\n  };\\n  var d3_formatPrefixes = [ \\\"y\\\", \\\"z\\\", \\\"a\\\", \\\"f\\\", \\\"p\\\", \\\"n\\\", \\\"µ\\\", \\\"m\\\", \\\"\\\", \\\"k\\\", \\\"M\\\", \\\"G\\\", \\\"T\\\", \\\"P\\\", \\\"E\\\", \\\"Z\\\", \\\"Y\\\" ].map(d3_formatPrefix);\\n  d3.formatPrefix = function(value, precision) {\\n    var i = 0;\\n    if (value = +value) {\\n      if (value < 0) value *= -1;\\n      if (precision) value = d3.round(value, d3_format_precision(value, precision));\\n      i = 1 + Math.floor(1e-12 + Math.log(value) / Math.LN10);\\n      i = Math.max(-24, Math.min(24, Math.floor((i - 1) / 3) * 3));\\n    }\\n    return d3_formatPrefixes[8 + i / 3];\\n  };\\n  function d3_formatPrefix(d, i) {\\n    var k = Math.pow(10, abs(8 - i) * 3);\\n    return {\\n      scale: i > 8 ? function(d) {\\n        return d / k;\\n      } : function(d) {\\n        return d * k;\\n      },\\n      symbol: d\\n    };\\n  }\\n  function d3_locale_numberFormat(locale) {\\n    var locale_decimal = locale.decimal, locale_thousands = locale.thousands, locale_grouping = locale.grouping, locale_currency = locale.currency, formatGroup = locale_grouping && locale_thousands ? function(value, width) {\\n      var i = value.length, t = [], j = 0, g = locale_grouping[0], length = 0;\\n      while (i > 0 && g > 0) {\\n        if (length + g + 1 > width) g = Math.max(1, width - length);\\n        t.push(value.substring(i -= g, i + g));\\n        if ((length += g + 1) > width) break;\\n        g = locale_grouping[j = (j + 1) % locale_grouping.length];\\n      }\\n      return t.reverse().join(locale_thousands);\\n    } : d3_identity;\\n    return function(specifier) {\\n      var match = d3_format_re.exec(specifier), fill = match[1] || \\\" \\\", align = match[2] || \\\">\\\", sign = match[3] || \\\"-\\\", symbol = match[4] || \\\"\\\", zfill = match[5], width = +match[6], comma = match[7], precision = match[8], type = match[9], scale = 1, prefix = \\\"\\\", suffix = \\\"\\\", integer = false, exponent = true;\\n      if (precision) precision = +precision.substring(1);\\n      if (zfill || fill === \\\"0\\\" && align === \\\"=\\\") {\\n        zfill = fill = \\\"0\\\";\\n        align = \\\"=\\\";\\n      }\\n      switch (type) {\\n       case \\\"n\\\":\\n        comma = true;\\n        type = \\\"g\\\";\\n        break;\\n\\n       case \\\"%\\\":\\n        scale = 100;\\n        suffix = \\\"%\\\";\\n        type = \\\"f\\\";\\n        break;\\n\\n       case \\\"p\\\":\\n        scale = 100;\\n        suffix = \\\"%\\\";\\n        type = \\\"r\\\";\\n        break;\\n\\n       case \\\"b\\\":\\n       case \\\"o\\\":\\n       case \\\"x\\\":\\n       case \\\"X\\\":\\n        if (symbol === \\\"#\\\") prefix = \\\"0\\\" + type.toLowerCase();\\n\\n       case \\\"c\\\":\\n        exponent = false;\\n\\n       case \\\"d\\\":\\n        integer = true;\\n        precision = 0;\\n        break;\\n\\n       case \\\"s\\\":\\n        scale = -1;\\n        type = \\\"r\\\";\\n        break;\\n      }\\n      if (symbol === \\\"$\\\") prefix = locale_currency[0], suffix = locale_currency[1];\\n      if (type == \\\"r\\\" && !precision) type = \\\"g\\\";\\n      if (precision != null) {\\n        if (type == \\\"g\\\") precision = Math.max(1, Math.min(21, precision)); else if (type == \\\"e\\\" || type == \\\"f\\\") precision = Math.max(0, Math.min(20, precision));\\n      }\\n      type = d3_format_types.get(type) || d3_format_typeDefault;\\n      var zcomma = zfill && comma;\\n      return function(value) {\\n        var fullSuffix = suffix;\\n        if (integer && value % 1) return \\\"\\\";\\n        var negative = value < 0 || value === 0 && 1 / value < 0 ? (value = -value, \\\"-\\\") : sign === \\\"-\\\" ? \\\"\\\" : sign;\\n        if (scale < 0) {\\n          var unit = d3.formatPrefix(value, precision);\\n          value = unit.scale(value);\\n          fullSuffix = unit.symbol + suffix;\\n        } else {\\n          value *= scale;\\n        }\\n        value = type(value, precision);\\n        var i = value.lastIndexOf(\\\".\\\"), before, after;\\n        if (i < 0) {\\n          var j = exponent ? value.lastIndexOf(\\\"e\\\") : -1;\\n          if (j < 0) before = value, after = \\\"\\\"; else before = value.substring(0, j), after = value.substring(j);\\n        } else {\\n          before = value.substring(0, i);\\n          after = locale_decimal + value.substring(i + 1);\\n        }\\n        if (!zfill && comma) before = formatGroup(before, Infinity);\\n        var length = prefix.length + before.length + after.length + (zcomma ? 0 : negative.length), padding = length < width ? new Array(length = width - length + 1).join(fill) : \\\"\\\";\\n        if (zcomma) before = formatGroup(padding + before, padding.length ? width - after.length : Infinity);\\n        negative += prefix;\\n        value = before + after;\\n        return (align === \\\"<\\\" ? negative + value + padding : align === \\\">\\\" ? padding + negative + value : align === \\\"^\\\" ? padding.substring(0, length >>= 1) + negative + value + padding.substring(length) : negative + (zcomma ? value : padding + value)) + fullSuffix;\\n      };\\n    };\\n  }\\n  var d3_format_re = /(?:([^{])?([<>=^]))?([+\\\\- ])?([$#])?(0)?(\\\\d+)?(,)?(\\\\.-?\\\\d+)?([a-z%])?/i;\\n  var d3_format_types = d3.map({\\n    b: function(x) {\\n      return x.toString(2);\\n    },\\n    c: function(x) {\\n      return String.fromCharCode(x);\\n    },\\n    o: function(x) {\\n      return x.toString(8);\\n    },\\n    x: function(x) {\\n      return x.toString(16);\\n    },\\n    X: function(x) {\\n      return x.toString(16).toUpperCase();\\n    },\\n    g: function(x, p) {\\n      return x.toPrecision(p);\\n    },\\n    e: function(x, p) {\\n      return x.toExponential(p);\\n    },\\n    f: function(x, p) {\\n      return x.toFixed(p);\\n    },\\n    r: function(x, p) {\\n      return (x = d3.round(x, d3_format_precision(x, p))).toFixed(Math.max(0, Math.min(20, d3_format_precision(x * (1 + 1e-15), p))));\\n    }\\n  });\\n  function d3_format_typeDefault(x) {\\n    return x + \\\"\\\";\\n  }\\n  var d3_time = d3.time = {}, d3_date = Date;\\n  function d3_date_utc() {\\n    this._ = new Date(arguments.length > 1 ? Date.UTC.apply(this, arguments) : arguments[0]);\\n  }\\n  d3_date_utc.prototype = {\\n    getDate: function() {\\n      return this._.getUTCDate();\\n    },\\n    getDay: function() {\\n      return this._.getUTCDay();\\n    },\\n    getFullYear: function() {\\n      return this._.getUTCFullYear();\\n    },\\n    getHours: function() {\\n      return this._.getUTCHours();\\n    },\\n    getMilliseconds: function() {\\n      return this._.getUTCMilliseconds();\\n    },\\n    getMinutes: function() {\\n      return this._.getUTCMinutes();\\n    },\\n    getMonth: function() {\\n      return this._.getUTCMonth();\\n    },\\n    getSeconds: function() {\\n      return this._.getUTCSeconds();\\n    },\\n    getTime: function() {\\n      return this._.getTime();\\n    },\\n    getTimezoneOffset: function() {\\n      return 0;\\n    },\\n    valueOf: function() {\\n      return this._.valueOf();\\n    },\\n    setDate: function() {\\n      d3_time_prototype.setUTCDate.apply(this._, arguments);\\n    },\\n    setDay: function() {\\n      d3_time_prototype.setUTCDay.apply(this._, arguments);\\n    },\\n    setFullYear: function() {\\n      d3_time_prototype.setUTCFullYear.apply(this._, arguments);\\n    },\\n    setHours: function() {\\n      d3_time_prototype.setUTCHours.apply(this._, arguments);\\n    },\\n    setMilliseconds: function() {\\n      d3_time_prototype.setUTCMilliseconds.apply(this._, arguments);\\n    },\\n    setMinutes: function() {\\n      d3_time_prototype.setUTCMinutes.apply(this._, arguments);\\n    },\\n    setMonth: function() {\\n      d3_time_prototype.setUTCMonth.apply(this._, arguments);\\n    },\\n    setSeconds: function() {\\n      d3_time_prototype.setUTCSeconds.apply(this._, arguments);\\n    },\\n    setTime: function() {\\n      d3_time_prototype.setTime.apply(this._, arguments);\\n    }\\n  };\\n  var d3_time_prototype = Date.prototype;\\n  function d3_time_interval(local, step, number) {\\n    function round(date) {\\n      var d0 = local(date), d1 = offset(d0, 1);\\n      return date - d0 < d1 - date ? d0 : d1;\\n    }\\n    function ceil(date) {\\n      step(date = local(new d3_date(date - 1)), 1);\\n      return date;\\n    }\\n    function offset(date, k) {\\n      step(date = new d3_date(+date), k);\\n      return date;\\n    }\\n    function range(t0, t1, dt) {\\n      var time = ceil(t0), times = [];\\n      if (dt > 1) {\\n        while (time < t1) {\\n          if (!(number(time) % dt)) times.push(new Date(+time));\\n          step(time, 1);\\n        }\\n      } else {\\n        while (time < t1) times.push(new Date(+time)), step(time, 1);\\n      }\\n      return times;\\n    }\\n    function range_utc(t0, t1, dt) {\\n      try {\\n        d3_date = d3_date_utc;\\n        var utc = new d3_date_utc();\\n        utc._ = t0;\\n        return range(utc, t1, dt);\\n      } finally {\\n        d3_date = Date;\\n      }\\n    }\\n    local.floor = local;\\n    local.round = round;\\n    local.ceil = ceil;\\n    local.offset = offset;\\n    local.range = range;\\n    var utc = local.utc = d3_time_interval_utc(local);\\n    utc.floor = utc;\\n    utc.round = d3_time_interval_utc(round);\\n    utc.ceil = d3_time_interval_utc(ceil);\\n    utc.offset = d3_time_interval_utc(offset);\\n    utc.range = range_utc;\\n    return local;\\n  }\\n  function d3_time_interval_utc(method) {\\n    return function(date, k) {\\n      try {\\n        d3_date = d3_date_utc;\\n        var utc = new d3_date_utc();\\n        utc._ = date;\\n        return method(utc, k)._;\\n      } finally {\\n        d3_date = Date;\\n      }\\n    };\\n  }\\n  d3_time.year = d3_time_interval(function(date) {\\n    date = d3_time.day(date);\\n    date.setMonth(0, 1);\\n    return date;\\n  }, function(date, offset) {\\n    date.setFullYear(date.getFullYear() + offset);\\n  }, function(date) {\\n    return date.getFullYear();\\n  });\\n  d3_time.years = d3_time.year.range;\\n  d3_time.years.utc = d3_time.year.utc.range;\\n  d3_time.day = d3_time_interval(function(date) {\\n    var day = new d3_date(2e3, 0);\\n    day.setFullYear(date.getFullYear(), date.getMonth(), date.getDate());\\n    return day;\\n  }, function(date, offset) {\\n    date.setDate(date.getDate() + offset);\\n  }, function(date) {\\n    return date.getDate() - 1;\\n  });\\n  d3_time.days = d3_time.day.range;\\n  d3_time.days.utc = d3_time.day.utc.range;\\n  d3_time.dayOfYear = function(date) {\\n    var year = d3_time.year(date);\\n    return Math.floor((date - year - (date.getTimezoneOffset() - year.getTimezoneOffset()) * 6e4) / 864e5);\\n  };\\n  [ \\\"sunday\\\", \\\"monday\\\", \\\"tuesday\\\", \\\"wednesday\\\", \\\"thursday\\\", \\\"friday\\\", \\\"saturday\\\" ].forEach(function(day, i) {\\n    i = 7 - i;\\n    var interval = d3_time[day] = d3_time_interval(function(date) {\\n      (date = d3_time.day(date)).setDate(date.getDate() - (date.getDay() + i) % 7);\\n      return date;\\n    }, function(date, offset) {\\n      date.setDate(date.getDate() + Math.floor(offset) * 7);\\n    }, function(date) {\\n      var day = d3_time.year(date).getDay();\\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7) - (day !== i);\\n    });\\n    d3_time[day + \\\"s\\\"] = interval.range;\\n    d3_time[day + \\\"s\\\"].utc = interval.utc.range;\\n    d3_time[day + \\\"OfYear\\\"] = function(date) {\\n      var day = d3_time.year(date).getDay();\\n      return Math.floor((d3_time.dayOfYear(date) + (day + i) % 7) / 7);\\n    };\\n  });\\n  d3_time.week = d3_time.sunday;\\n  d3_time.weeks = d3_time.sunday.range;\\n  d3_time.weeks.utc = d3_time.sunday.utc.range;\\n  d3_time.weekOfYear = d3_time.sundayOfYear;\\n  function d3_locale_timeFormat(locale) {\\n    var locale_dateTime = locale.dateTime, locale_date = locale.date, locale_time = locale.time, locale_periods = locale.periods, locale_days = locale.days, locale_shortDays = locale.shortDays, locale_months = locale.months, locale_shortMonths = locale.shortMonths;\\n    function d3_time_format(template) {\\n      var n = template.length;\\n      function format(date) {\\n        var string = [], i = -1, j = 0, c, p, f;\\n        while (++i < n) {\\n          if (template.charCodeAt(i) === 37) {\\n            string.push(template.slice(j, i));\\n            if ((p = d3_time_formatPads[c = template.charAt(++i)]) != null) c = template.charAt(++i);\\n            if (f = d3_time_formats[c]) c = f(date, p == null ? c === \\\"e\\\" ? \\\" \\\" : \\\"0\\\" : p);\\n            string.push(c);\\n            j = i + 1;\\n          }\\n        }\\n        string.push(template.slice(j, i));\\n        return string.join(\\\"\\\");\\n      }\\n      format.parse = function(string) {\\n        var d = {\\n          y: 1900,\\n          m: 0,\\n          d: 1,\\n          H: 0,\\n          M: 0,\\n          S: 0,\\n          L: 0,\\n          Z: null\\n        }, i = d3_time_parse(d, template, string, 0);\\n        if (i != string.length) return null;\\n        if (\\\"p\\\" in d) d.H = d.H % 12 + d.p * 12;\\n        var localZ = d.Z != null && d3_date !== d3_date_utc, date = new (localZ ? d3_date_utc : d3_date)();\\n        if (\\\"j\\\" in d) date.setFullYear(d.y, 0, d.j); else if (\\\"W\\\" in d || \\\"U\\\" in d) {\\n          if (!(\\\"w\\\" in d)) d.w = \\\"W\\\" in d ? 1 : 0;\\n          date.setFullYear(d.y, 0, 1);\\n          date.setFullYear(d.y, 0, \\\"W\\\" in d ? (d.w + 6) % 7 + d.W * 7 - (date.getDay() + 5) % 7 : d.w + d.U * 7 - (date.getDay() + 6) % 7);\\n        } else date.setFullYear(d.y, d.m, d.d);\\n        date.setHours(d.H + (d.Z / 100 | 0), d.M + d.Z % 100, d.S, d.L);\\n        return localZ ? date._ : date;\\n      };\\n      format.toString = function() {\\n        return template;\\n      };\\n      return format;\\n    }\\n    function d3_time_parse(date, template, string, j) {\\n      var c, p, t, i = 0, n = template.length, m = string.length;\\n      while (i < n) {\\n        if (j >= m) return -1;\\n        c = template.charCodeAt(i++);\\n        if (c === 37) {\\n          t = template.charAt(i++);\\n          p = d3_time_parsers[t in d3_time_formatPads ? template.charAt(i++) : t];\\n          if (!p || (j = p(date, string, j)) < 0) return -1;\\n        } else if (c != string.charCodeAt(j++)) {\\n          return -1;\\n        }\\n      }\\n      return j;\\n    }\\n    d3_time_format.utc = function(template) {\\n      var local = d3_time_format(template);\\n      function format(date) {\\n        try {\\n          d3_date = d3_date_utc;\\n          var utc = new d3_date();\\n          utc._ = date;\\n          return local(utc);\\n        } finally {\\n          d3_date = Date;\\n        }\\n      }\\n      format.parse = function(string) {\\n        try {\\n          d3_date = d3_date_utc;\\n          var date = local.parse(string);\\n          return date && date._;\\n        } finally {\\n          d3_date = Date;\\n        }\\n      };\\n      format.toString = local.toString;\\n      return format;\\n    };\\n    d3_time_format.multi = d3_time_format.utc.multi = d3_time_formatMulti;\\n    var d3_time_periodLookup = d3.map(), d3_time_dayRe = d3_time_formatRe(locale_days), d3_time_dayLookup = d3_time_formatLookup(locale_days), d3_time_dayAbbrevRe = d3_time_formatRe(locale_shortDays), d3_time_dayAbbrevLookup = d3_time_formatLookup(locale_shortDays), d3_time_monthRe = d3_time_formatRe(locale_months), d3_time_monthLookup = d3_time_formatLookup(locale_months), d3_time_monthAbbrevRe = d3_time_formatRe(locale_shortMonths), d3_time_monthAbbrevLookup = d3_time_formatLookup(locale_shortMonths);\\n    locale_periods.forEach(function(p, i) {\\n      d3_time_periodLookup.set(p.toLowerCase(), i);\\n    });\\n    var d3_time_formats = {\\n      a: function(d) {\\n        return locale_shortDays[d.getDay()];\\n      },\\n      A: function(d) {\\n        return locale_days[d.getDay()];\\n      },\\n      b: function(d) {\\n        return locale_shortMonths[d.getMonth()];\\n      },\\n      B: function(d) {\\n        return locale_months[d.getMonth()];\\n      },\\n      c: d3_time_format(locale_dateTime),\\n      d: function(d, p) {\\n        return d3_time_formatPad(d.getDate(), p, 2);\\n      },\\n      e: function(d, p) {\\n        return d3_time_formatPad(d.getDate(), p, 2);\\n      },\\n      H: function(d, p) {\\n        return d3_time_formatPad(d.getHours(), p, 2);\\n      },\\n      I: function(d, p) {\\n        return d3_time_formatPad(d.getHours() % 12 || 12, p, 2);\\n      },\\n      j: function(d, p) {\\n        return d3_time_formatPad(1 + d3_time.dayOfYear(d), p, 3);\\n      },\\n      L: function(d, p) {\\n        return d3_time_formatPad(d.getMilliseconds(), p, 3);\\n      },\\n      m: function(d, p) {\\n        return d3_time_formatPad(d.getMonth() + 1, p, 2);\\n      },\\n      M: function(d, p) {\\n        return d3_time_formatPad(d.getMinutes(), p, 2);\\n      },\\n      p: function(d) {\\n        return locale_periods[+(d.getHours() >= 12)];\\n      },\\n      S: function(d, p) {\\n        return d3_time_formatPad(d.getSeconds(), p, 2);\\n      },\\n      U: function(d, p) {\\n        return d3_time_formatPad(d3_time.sundayOfYear(d), p, 2);\\n      },\\n      w: function(d) {\\n        return d.getDay();\\n      },\\n      W: function(d, p) {\\n        return d3_time_formatPad(d3_time.mondayOfYear(d), p, 2);\\n      },\\n      x: d3_time_format(locale_date),\\n      X: d3_time_format(locale_time),\\n      y: function(d, p) {\\n        return d3_time_formatPad(d.getFullYear() % 100, p, 2);\\n      },\\n      Y: function(d, p) {\\n        return d3_time_formatPad(d.getFullYear() % 1e4, p, 4);\\n      },\\n      Z: d3_time_zone,\\n      \\\"%\\\": function() {\\n        return \\\"%\\\";\\n      }\\n    };\\n    var d3_time_parsers = {\\n      a: d3_time_parseWeekdayAbbrev,\\n      A: d3_time_parseWeekday,\\n      b: d3_time_parseMonthAbbrev,\\n      B: d3_time_parseMonth,\\n      c: d3_time_parseLocaleFull,\\n      d: d3_time_parseDay,\\n      e: d3_time_parseDay,\\n      H: d3_time_parseHour24,\\n      I: d3_time_parseHour24,\\n      j: d3_time_parseDayOfYear,\\n      L: d3_time_parseMilliseconds,\\n      m: d3_time_parseMonthNumber,\\n      M: d3_time_parseMinutes,\\n      p: d3_time_parseAmPm,\\n      S: d3_time_parseSeconds,\\n      U: d3_time_parseWeekNumberSunday,\\n      w: d3_time_parseWeekdayNumber,\\n      W: d3_time_parseWeekNumberMonday,\\n      x: d3_time_parseLocaleDate,\\n      X: d3_time_parseLocaleTime,\\n      y: d3_time_parseYear,\\n      Y: d3_time_parseFullYear,\\n      Z: d3_time_parseZone,\\n      \\\"%\\\": d3_time_parseLiteralPercent\\n    };\\n    function d3_time_parseWeekdayAbbrev(date, string, i) {\\n      d3_time_dayAbbrevRe.lastIndex = 0;\\n      var n = d3_time_dayAbbrevRe.exec(string.slice(i));\\n      return n ? (date.w = d3_time_dayAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\\n    }\\n    function d3_time_parseWeekday(date, string, i) {\\n      d3_time_dayRe.lastIndex = 0;\\n      var n = d3_time_dayRe.exec(string.slice(i));\\n      return n ? (date.w = d3_time_dayLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\\n    }\\n    function d3_time_parseMonthAbbrev(date, string, i) {\\n      d3_time_monthAbbrevRe.lastIndex = 0;\\n      var n = d3_time_monthAbbrevRe.exec(string.slice(i));\\n      return n ? (date.m = d3_time_monthAbbrevLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\\n    }\\n    function d3_time_parseMonth(date, string, i) {\\n      d3_time_monthRe.lastIndex = 0;\\n      var n = d3_time_monthRe.exec(string.slice(i));\\n      return n ? (date.m = d3_time_monthLookup.get(n[0].toLowerCase()), i + n[0].length) : -1;\\n    }\\n    function d3_time_parseLocaleFull(date, string, i) {\\n      return d3_time_parse(date, d3_time_formats.c.toString(), string, i);\\n    }\\n    function d3_time_parseLocaleDate(date, string, i) {\\n      return d3_time_parse(date, d3_time_formats.x.toString(), string, i);\\n    }\\n    function d3_time_parseLocaleTime(date, string, i) {\\n      return d3_time_parse(date, d3_time_formats.X.toString(), string, i);\\n    }\\n    function d3_time_parseAmPm(date, string, i) {\\n      var n = d3_time_periodLookup.get(string.slice(i, i += 2).toLowerCase());\\n      return n == null ? -1 : (date.p = n, i);\\n    }\\n    return d3_time_format;\\n  }\\n  var d3_time_formatPads = {\\n    \\\"-\\\": \\\"\\\",\\n    _: \\\" \\\",\\n    \\\"0\\\": \\\"0\\\"\\n  }, d3_time_numberRe = /^\\\\s*\\\\d+/, d3_time_percentRe = /^%/;\\n  function d3_time_formatPad(value, fill, width) {\\n    var sign = value < 0 ? \\\"-\\\" : \\\"\\\", string = (sign ? -value : value) + \\\"\\\", length = string.length;\\n    return sign + (length < width ? new Array(width - length + 1).join(fill) + string : string);\\n  }\\n  function d3_time_formatRe(names) {\\n    return new RegExp(\\\"^(?:\\\" + names.map(d3.requote).join(\\\"|\\\") + \\\")\\\", \\\"i\\\");\\n  }\\n  function d3_time_formatLookup(names) {\\n    var map = new d3_Map(), i = -1, n = names.length;\\n    while (++i < n) map.set(names[i].toLowerCase(), i);\\n    return map;\\n  }\\n  function d3_time_parseWeekdayNumber(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 1));\\n    return n ? (date.w = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseWeekNumberSunday(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i));\\n    return n ? (date.U = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseWeekNumberMonday(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i));\\n    return n ? (date.W = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseFullYear(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 4));\\n    return n ? (date.y = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseYear(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.y = d3_time_expandYear(+n[0]), i + n[0].length) : -1;\\n  }\\n  function d3_time_parseZone(date, string, i) {\\n    return /^[+-]\\\\d{4}$/.test(string = string.slice(i, i + 5)) ? (date.Z = -string, \\n    i + 5) : -1;\\n  }\\n  function d3_time_expandYear(d) {\\n    return d + (d > 68 ? 1900 : 2e3);\\n  }\\n  function d3_time_parseMonthNumber(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.m = n[0] - 1, i + n[0].length) : -1;\\n  }\\n  function d3_time_parseDay(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.d = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseDayOfYear(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\\n    return n ? (date.j = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseHour24(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.H = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseMinutes(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.M = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseSeconds(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 2));\\n    return n ? (date.S = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_parseMilliseconds(date, string, i) {\\n    d3_time_numberRe.lastIndex = 0;\\n    var n = d3_time_numberRe.exec(string.slice(i, i + 3));\\n    return n ? (date.L = +n[0], i + n[0].length) : -1;\\n  }\\n  function d3_time_zone(d) {\\n    var z = d.getTimezoneOffset(), zs = z > 0 ? \\\"-\\\" : \\\"+\\\", zh = abs(z) / 60 | 0, zm = abs(z) % 60;\\n    return zs + d3_time_formatPad(zh, \\\"0\\\", 2) + d3_time_formatPad(zm, \\\"0\\\", 2);\\n  }\\n  function d3_time_parseLiteralPercent(date, string, i) {\\n    d3_time_percentRe.lastIndex = 0;\\n    var n = d3_time_percentRe.exec(string.slice(i, i + 1));\\n    return n ? i + n[0].length : -1;\\n  }\\n  function d3_time_formatMulti(formats) {\\n    var n = formats.length, i = -1;\\n    while (++i < n) formats[i][0] = this(formats[i][0]);\\n    return function(date) {\\n      var i = 0, f = formats[i];\\n      while (!f[1](date)) f = formats[++i];\\n      return f[0](date);\\n    };\\n  }\\n  d3.locale = function(locale) {\\n    return {\\n      numberFormat: d3_locale_numberFormat(locale),\\n      timeFormat: d3_locale_timeFormat(locale)\\n    };\\n  };\\n  var d3_locale_enUS = d3.locale({\\n    decimal: \\\".\\\",\\n    thousands: \\\",\\\",\\n    grouping: [ 3 ],\\n    currency: [ \\\"$\\\", \\\"\\\" ],\\n    dateTime: \\\"%a %b %e %X %Y\\\",\\n    date: \\\"%m/%d/%Y\\\",\\n    time: \\\"%H:%M:%S\\\",\\n    periods: [ \\\"AM\\\", \\\"PM\\\" ],\\n    days: [ \\\"Sunday\\\", \\\"Monday\\\", \\\"Tuesday\\\", \\\"Wednesday\\\", \\\"Thursday\\\", \\\"Friday\\\", \\\"Saturday\\\" ],\\n    shortDays: [ \\\"Sun\\\", \\\"Mon\\\", \\\"Tue\\\", \\\"Wed\\\", \\\"Thu\\\", \\\"Fri\\\", \\\"Sat\\\" ],\\n    months: [ \\\"January\\\", \\\"February\\\", \\\"March\\\", \\\"April\\\", \\\"May\\\", \\\"June\\\", \\\"July\\\", \\\"August\\\", \\\"September\\\", \\\"October\\\", \\\"November\\\", \\\"December\\\" ],\\n    shortMonths: [ \\\"Jan\\\", \\\"Feb\\\", \\\"Mar\\\", \\\"Apr\\\", \\\"May\\\", \\\"Jun\\\", \\\"Jul\\\", \\\"Aug\\\", \\\"Sep\\\", \\\"Oct\\\", \\\"Nov\\\", \\\"Dec\\\" ]\\n  });\\n  d3.format = d3_locale_enUS.numberFormat;\\n  d3.geo = {};\\n  function d3_adder() {}\\n  d3_adder.prototype = {\\n    s: 0,\\n    t: 0,\\n    add: function(y) {\\n      d3_adderSum(y, this.t, d3_adderTemp);\\n      d3_adderSum(d3_adderTemp.s, this.s, this);\\n      if (this.s) this.t += d3_adderTemp.t; else this.s = d3_adderTemp.t;\\n    },\\n    reset: function() {\\n      this.s = this.t = 0;\\n    },\\n    valueOf: function() {\\n      return this.s;\\n    }\\n  };\\n  var d3_adderTemp = new d3_adder();\\n  function d3_adderSum(a, b, o) {\\n    var x = o.s = a + b, bv = x - a, av = x - bv;\\n    o.t = a - av + (b - bv);\\n  }\\n  d3.geo.stream = function(object, listener) {\\n    if (object && d3_geo_streamObjectType.hasOwnProperty(object.type)) {\\n      d3_geo_streamObjectType[object.type](object, listener);\\n    } else {\\n      d3_geo_streamGeometry(object, listener);\\n    }\\n  };\\n  function d3_geo_streamGeometry(geometry, listener) {\\n    if (geometry && d3_geo_streamGeometryType.hasOwnProperty(geometry.type)) {\\n      d3_geo_streamGeometryType[geometry.type](geometry, listener);\\n    }\\n  }\\n  var d3_geo_streamObjectType = {\\n    Feature: function(feature, listener) {\\n      d3_geo_streamGeometry(feature.geometry, listener);\\n    },\\n    FeatureCollection: function(object, listener) {\\n      var features = object.features, i = -1, n = features.length;\\n      while (++i < n) d3_geo_streamGeometry(features[i].geometry, listener);\\n    }\\n  };\\n  var d3_geo_streamGeometryType = {\\n    Sphere: function(object, listener) {\\n      listener.sphere();\\n    },\\n    Point: function(object, listener) {\\n      object = object.coordinates;\\n      listener.point(object[0], object[1], object[2]);\\n    },\\n    MultiPoint: function(object, listener) {\\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\\n      while (++i < n) object = coordinates[i], listener.point(object[0], object[1], object[2]);\\n    },\\n    LineString: function(object, listener) {\\n      d3_geo_streamLine(object.coordinates, listener, 0);\\n    },\\n    MultiLineString: function(object, listener) {\\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\\n      while (++i < n) d3_geo_streamLine(coordinates[i], listener, 0);\\n    },\\n    Polygon: function(object, listener) {\\n      d3_geo_streamPolygon(object.coordinates, listener);\\n    },\\n    MultiPolygon: function(object, listener) {\\n      var coordinates = object.coordinates, i = -1, n = coordinates.length;\\n      while (++i < n) d3_geo_streamPolygon(coordinates[i], listener);\\n    },\\n    GeometryCollection: function(object, listener) {\\n      var geometries = object.geometries, i = -1, n = geometries.length;\\n      while (++i < n) d3_geo_streamGeometry(geometries[i], listener);\\n    }\\n  };\\n  function d3_geo_streamLine(coordinates, listener, closed) {\\n    var i = -1, n = coordinates.length - closed, coordinate;\\n    listener.lineStart();\\n    while (++i < n) coordinate = coordinates[i], listener.point(coordinate[0], coordinate[1], coordinate[2]);\\n    listener.lineEnd();\\n  }\\n  function d3_geo_streamPolygon(coordinates, listener) {\\n    var i = -1, n = coordinates.length;\\n    listener.polygonStart();\\n    while (++i < n) d3_geo_streamLine(coordinates[i], listener, 1);\\n    listener.polygonEnd();\\n  }\\n  d3.geo.area = function(object) {\\n    d3_geo_areaSum = 0;\\n    d3.geo.stream(object, d3_geo_area);\\n    return d3_geo_areaSum;\\n  };\\n  var d3_geo_areaSum, d3_geo_areaRingSum = new d3_adder();\\n  var d3_geo_area = {\\n    sphere: function() {\\n      d3_geo_areaSum += 4 * π;\\n    },\\n    point: d3_noop,\\n    lineStart: d3_noop,\\n    lineEnd: d3_noop,\\n    polygonStart: function() {\\n      d3_geo_areaRingSum.reset();\\n      d3_geo_area.lineStart = d3_geo_areaRingStart;\\n    },\\n    polygonEnd: function() {\\n      var area = 2 * d3_geo_areaRingSum;\\n      d3_geo_areaSum += area < 0 ? 4 * π + area : area;\\n      d3_geo_area.lineStart = d3_geo_area.lineEnd = d3_geo_area.point = d3_noop;\\n    }\\n  };\\n  function d3_geo_areaRingStart() {\\n    var λ00, φ00, λ0, cosφ0, sinφ0;\\n    d3_geo_area.point = function(λ, φ) {\\n      d3_geo_area.point = nextPoint;\\n      λ0 = (λ00 = λ) * d3_radians, cosφ0 = Math.cos(φ = (φ00 = φ) * d3_radians / 2 + π / 4), \\n      sinφ0 = Math.sin(φ);\\n    };\\n    function nextPoint(λ, φ) {\\n      λ *= d3_radians;\\n      φ = φ * d3_radians / 2 + π / 4;\\n      var dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, cosφ = Math.cos(φ), sinφ = Math.sin(φ), k = sinφ0 * sinφ, u = cosφ0 * cosφ + k * Math.cos(adλ), v = k * sdλ * Math.sin(adλ);\\n      d3_geo_areaRingSum.add(Math.atan2(v, u));\\n      λ0 = λ, cosφ0 = cosφ, sinφ0 = sinφ;\\n    }\\n    d3_geo_area.lineEnd = function() {\\n      nextPoint(λ00, φ00);\\n    };\\n  }\\n  function d3_geo_cartesian(spherical) {\\n    var λ = spherical[0], φ = spherical[1], cosφ = Math.cos(φ);\\n    return [ cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ) ];\\n  }\\n  function d3_geo_cartesianDot(a, b) {\\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\\n  }\\n  function d3_geo_cartesianCross(a, b) {\\n    return [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\\n  }\\n  function d3_geo_cartesianAdd(a, b) {\\n    a[0] += b[0];\\n    a[1] += b[1];\\n    a[2] += b[2];\\n  }\\n  function d3_geo_cartesianScale(vector, k) {\\n    return [ vector[0] * k, vector[1] * k, vector[2] * k ];\\n  }\\n  function d3_geo_cartesianNormalize(d) {\\n    var l = Math.sqrt(d[0] * d[0] + d[1] * d[1] + d[2] * d[2]);\\n    d[0] /= l;\\n    d[1] /= l;\\n    d[2] /= l;\\n  }\\n  function d3_geo_spherical(cartesian) {\\n    return [ Math.atan2(cartesian[1], cartesian[0]), d3_asin(cartesian[2]) ];\\n  }\\n  function d3_geo_sphericalEqual(a, b) {\\n    return abs(a[0] - b[0]) < ε && abs(a[1] - b[1]) < ε;\\n  }\\n  d3.geo.bounds = function() {\\n    var λ0, φ0, λ1, φ1, λ_, λ__, φ__, p0, dλSum, ranges, range;\\n    var bound = {\\n      point: point,\\n      lineStart: lineStart,\\n      lineEnd: lineEnd,\\n      polygonStart: function() {\\n        bound.point = ringPoint;\\n        bound.lineStart = ringStart;\\n        bound.lineEnd = ringEnd;\\n        dλSum = 0;\\n        d3_geo_area.polygonStart();\\n      },\\n      polygonEnd: function() {\\n        d3_geo_area.polygonEnd();\\n        bound.point = point;\\n        bound.lineStart = lineStart;\\n        bound.lineEnd = lineEnd;\\n        if (d3_geo_areaRingSum < 0) λ0 = -(λ1 = 180), φ0 = -(φ1 = 90); else if (dλSum > ε) φ1 = 90; else if (dλSum < -ε) φ0 = -90;\\n        range[0] = λ0, range[1] = λ1;\\n      }\\n    };\\n    function point(λ, φ) {\\n      ranges.push(range = [ λ0 = λ, λ1 = λ ]);\\n      if (φ < φ0) φ0 = φ;\\n      if (φ > φ1) φ1 = φ;\\n    }\\n    function linePoint(λ, φ) {\\n      var p = d3_geo_cartesian([ λ * d3_radians, φ * d3_radians ]);\\n      if (p0) {\\n        var normal = d3_geo_cartesianCross(p0, p), equatorial = [ normal[1], -normal[0], 0 ], inflection = d3_geo_cartesianCross(equatorial, normal);\\n        d3_geo_cartesianNormalize(inflection);\\n        inflection = d3_geo_spherical(inflection);\\n        var dλ = λ - λ_, s = dλ > 0 ? 1 : -1, λi = inflection[0] * d3_degrees * s, antimeridian = abs(dλ) > 180;\\n        if (antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\\n          var φi = inflection[1] * d3_degrees;\\n          if (φi > φ1) φ1 = φi;\\n        } else if (λi = (λi + 360) % 360 - 180, antimeridian ^ (s * λ_ < λi && λi < s * λ)) {\\n          var φi = -inflection[1] * d3_degrees;\\n          if (φi < φ0) φ0 = φi;\\n        } else {\\n          if (φ < φ0) φ0 = φ;\\n          if (φ > φ1) φ1 = φ;\\n        }\\n        if (antimeridian) {\\n          if (λ < λ_) {\\n            if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\\n          } else {\\n            if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\\n          }\\n        } else {\\n          if (λ1 >= λ0) {\\n            if (λ < λ0) λ0 = λ;\\n            if (λ > λ1) λ1 = λ;\\n          } else {\\n            if (λ > λ_) {\\n              if (angle(λ0, λ) > angle(λ0, λ1)) λ1 = λ;\\n            } else {\\n              if (angle(λ, λ1) > angle(λ0, λ1)) λ0 = λ;\\n            }\\n          }\\n        }\\n      } else {\\n        point(λ, φ);\\n      }\\n      p0 = p, λ_ = λ;\\n    }\\n    function lineStart() {\\n      bound.point = linePoint;\\n    }\\n    function lineEnd() {\\n      range[0] = λ0, range[1] = λ1;\\n      bound.point = point;\\n      p0 = null;\\n    }\\n    function ringPoint(λ, φ) {\\n      if (p0) {\\n        var dλ = λ - λ_;\\n        dλSum += abs(dλ) > 180 ? dλ + (dλ > 0 ? 360 : -360) : dλ;\\n      } else λ__ = λ, φ__ = φ;\\n      d3_geo_area.point(λ, φ);\\n      linePoint(λ, φ);\\n    }\\n    function ringStart() {\\n      d3_geo_area.lineStart();\\n    }\\n    function ringEnd() {\\n      ringPoint(λ__, φ__);\\n      d3_geo_area.lineEnd();\\n      if (abs(dλSum) > ε) λ0 = -(λ1 = 180);\\n      range[0] = λ0, range[1] = λ1;\\n      p0 = null;\\n    }\\n    function angle(λ0, λ1) {\\n      return (λ1 -= λ0) < 0 ? λ1 + 360 : λ1;\\n    }\\n    function compareRanges(a, b) {\\n      return a[0] - b[0];\\n    }\\n    function withinRange(x, range) {\\n      return range[0] <= range[1] ? range[0] <= x && x <= range[1] : x < range[0] || range[1] < x;\\n    }\\n    return function(feature) {\\n      φ1 = λ1 = -(λ0 = φ0 = Infinity);\\n      ranges = [];\\n      d3.geo.stream(feature, bound);\\n      var n = ranges.length;\\n      if (n) {\\n        ranges.sort(compareRanges);\\n        for (var i = 1, a = ranges[0], b, merged = [ a ]; i < n; ++i) {\\n          b = ranges[i];\\n          if (withinRange(b[0], a) || withinRange(b[1], a)) {\\n            if (angle(a[0], b[1]) > angle(a[0], a[1])) a[1] = b[1];\\n            if (angle(b[0], a[1]) > angle(a[0], a[1])) a[0] = b[0];\\n          } else {\\n            merged.push(a = b);\\n          }\\n        }\\n        var best = -Infinity, dλ;\\n        for (var n = merged.length - 1, i = 0, a = merged[n], b; i <= n; a = b, ++i) {\\n          b = merged[i];\\n          if ((dλ = angle(a[1], b[0])) > best) best = dλ, λ0 = b[0], λ1 = a[1];\\n        }\\n      }\\n      ranges = range = null;\\n      return λ0 === Infinity || φ0 === Infinity ? [ [ NaN, NaN ], [ NaN, NaN ] ] : [ [ λ0, φ0 ], [ λ1, φ1 ] ];\\n    };\\n  }();\\n  d3.geo.centroid = function(object) {\\n    d3_geo_centroidW0 = d3_geo_centroidW1 = d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\\n    d3.geo.stream(object, d3_geo_centroid);\\n    var x = d3_geo_centroidX2, y = d3_geo_centroidY2, z = d3_geo_centroidZ2, m = x * x + y * y + z * z;\\n    if (m < ε2) {\\n      x = d3_geo_centroidX1, y = d3_geo_centroidY1, z = d3_geo_centroidZ1;\\n      if (d3_geo_centroidW1 < ε) x = d3_geo_centroidX0, y = d3_geo_centroidY0, z = d3_geo_centroidZ0;\\n      m = x * x + y * y + z * z;\\n      if (m < ε2) return [ NaN, NaN ];\\n    }\\n    return [ Math.atan2(y, x) * d3_degrees, d3_asin(z / Math.sqrt(m)) * d3_degrees ];\\n  };\\n  var d3_geo_centroidW0, d3_geo_centroidW1, d3_geo_centroidX0, d3_geo_centroidY0, d3_geo_centroidZ0, d3_geo_centroidX1, d3_geo_centroidY1, d3_geo_centroidZ1, d3_geo_centroidX2, d3_geo_centroidY2, d3_geo_centroidZ2;\\n  var d3_geo_centroid = {\\n    sphere: d3_noop,\\n    point: d3_geo_centroidPoint,\\n    lineStart: d3_geo_centroidLineStart,\\n    lineEnd: d3_geo_centroidLineEnd,\\n    polygonStart: function() {\\n      d3_geo_centroid.lineStart = d3_geo_centroidRingStart;\\n    },\\n    polygonEnd: function() {\\n      d3_geo_centroid.lineStart = d3_geo_centroidLineStart;\\n    }\\n  };\\n  function d3_geo_centroidPoint(λ, φ) {\\n    λ *= d3_radians;\\n    var cosφ = Math.cos(φ *= d3_radians);\\n    d3_geo_centroidPointXYZ(cosφ * Math.cos(λ), cosφ * Math.sin(λ), Math.sin(φ));\\n  }\\n  function d3_geo_centroidPointXYZ(x, y, z) {\\n    ++d3_geo_centroidW0;\\n    d3_geo_centroidX0 += (x - d3_geo_centroidX0) / d3_geo_centroidW0;\\n    d3_geo_centroidY0 += (y - d3_geo_centroidY0) / d3_geo_centroidW0;\\n    d3_geo_centroidZ0 += (z - d3_geo_centroidZ0) / d3_geo_centroidW0;\\n  }\\n  function d3_geo_centroidLineStart() {\\n    var x0, y0, z0;\\n    d3_geo_centroid.point = function(λ, φ) {\\n      λ *= d3_radians;\\n      var cosφ = Math.cos(φ *= d3_radians);\\n      x0 = cosφ * Math.cos(λ);\\n      y0 = cosφ * Math.sin(λ);\\n      z0 = Math.sin(φ);\\n      d3_geo_centroid.point = nextPoint;\\n      d3_geo_centroidPointXYZ(x0, y0, z0);\\n    };\\n    function nextPoint(λ, φ) {\\n      λ *= d3_radians;\\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), w = Math.atan2(Math.sqrt((w = y0 * z - z0 * y) * w + (w = z0 * x - x0 * z) * w + (w = x0 * y - y0 * x) * w), x0 * x + y0 * y + z0 * z);\\n      d3_geo_centroidW1 += w;\\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\\n      d3_geo_centroidPointXYZ(x0, y0, z0);\\n    }\\n  }\\n  function d3_geo_centroidLineEnd() {\\n    d3_geo_centroid.point = d3_geo_centroidPoint;\\n  }\\n  function d3_geo_centroidRingStart() {\\n    var λ00, φ00, x0, y0, z0;\\n    d3_geo_centroid.point = function(λ, φ) {\\n      λ00 = λ, φ00 = φ;\\n      d3_geo_centroid.point = nextPoint;\\n      λ *= d3_radians;\\n      var cosφ = Math.cos(φ *= d3_radians);\\n      x0 = cosφ * Math.cos(λ);\\n      y0 = cosφ * Math.sin(λ);\\n      z0 = Math.sin(φ);\\n      d3_geo_centroidPointXYZ(x0, y0, z0);\\n    };\\n    d3_geo_centroid.lineEnd = function() {\\n      nextPoint(λ00, φ00);\\n      d3_geo_centroid.lineEnd = d3_geo_centroidLineEnd;\\n      d3_geo_centroid.point = d3_geo_centroidPoint;\\n    };\\n    function nextPoint(λ, φ) {\\n      λ *= d3_radians;\\n      var cosφ = Math.cos(φ *= d3_radians), x = cosφ * Math.cos(λ), y = cosφ * Math.sin(λ), z = Math.sin(φ), cx = y0 * z - z0 * y, cy = z0 * x - x0 * z, cz = x0 * y - y0 * x, m = Math.sqrt(cx * cx + cy * cy + cz * cz), u = x0 * x + y0 * y + z0 * z, v = m && -d3_acos(u) / m, w = Math.atan2(m, u);\\n      d3_geo_centroidX2 += v * cx;\\n      d3_geo_centroidY2 += v * cy;\\n      d3_geo_centroidZ2 += v * cz;\\n      d3_geo_centroidW1 += w;\\n      d3_geo_centroidX1 += w * (x0 + (x0 = x));\\n      d3_geo_centroidY1 += w * (y0 + (y0 = y));\\n      d3_geo_centroidZ1 += w * (z0 + (z0 = z));\\n      d3_geo_centroidPointXYZ(x0, y0, z0);\\n    }\\n  }\\n  function d3_geo_compose(a, b) {\\n    function compose(x, y) {\\n      return x = a(x, y), b(x[0], x[1]);\\n    }\\n    if (a.invert && b.invert) compose.invert = function(x, y) {\\n      return x = b.invert(x, y), x && a.invert(x[0], x[1]);\\n    };\\n    return compose;\\n  }\\n  function d3_true() {\\n    return true;\\n  }\\n  function d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener) {\\n    var subject = [], clip = [];\\n    segments.forEach(function(segment) {\\n      if ((n = segment.length - 1) <= 0) return;\\n      var n, p0 = segment[0], p1 = segment[n];\\n      if (d3_geo_sphericalEqual(p0, p1)) {\\n        listener.lineStart();\\n        for (var i = 0; i < n; ++i) listener.point((p0 = segment[i])[0], p0[1]);\\n        listener.lineEnd();\\n        return;\\n      }\\n      var a = new d3_geo_clipPolygonIntersection(p0, segment, null, true), b = new d3_geo_clipPolygonIntersection(p0, null, a, false);\\n      a.o = b;\\n      subject.push(a);\\n      clip.push(b);\\n      a = new d3_geo_clipPolygonIntersection(p1, segment, null, false);\\n      b = new d3_geo_clipPolygonIntersection(p1, null, a, true);\\n      a.o = b;\\n      subject.push(a);\\n      clip.push(b);\\n    });\\n    clip.sort(compare);\\n    d3_geo_clipPolygonLinkCircular(subject);\\n    d3_geo_clipPolygonLinkCircular(clip);\\n    if (!subject.length) return;\\n    for (var i = 0, entry = clipStartInside, n = clip.length; i < n; ++i) {\\n      clip[i].e = entry = !entry;\\n    }\\n    var start = subject[0], points, point;\\n    while (1) {\\n      var current = start, isSubject = true;\\n      while (current.v) if ((current = current.n) === start) return;\\n      points = current.z;\\n      listener.lineStart();\\n      do {\\n        current.v = current.o.v = true;\\n        if (current.e) {\\n          if (isSubject) {\\n            for (var i = 0, n = points.length; i < n; ++i) listener.point((point = points[i])[0], point[1]);\\n          } else {\\n            interpolate(current.x, current.n.x, 1, listener);\\n          }\\n          current = current.n;\\n        } else {\\n          if (isSubject) {\\n            points = current.p.z;\\n            for (var i = points.length - 1; i >= 0; --i) listener.point((point = points[i])[0], point[1]);\\n          } else {\\n            interpolate(current.x, current.p.x, -1, listener);\\n          }\\n          current = current.p;\\n        }\\n        current = current.o;\\n        points = current.z;\\n        isSubject = !isSubject;\\n      } while (!current.v);\\n      listener.lineEnd();\\n    }\\n  }\\n  function d3_geo_clipPolygonLinkCircular(array) {\\n    if (!(n = array.length)) return;\\n    var n, i = 0, a = array[0], b;\\n    while (++i < n) {\\n      a.n = b = array[i];\\n      b.p = a;\\n      a = b;\\n    }\\n    a.n = b = array[0];\\n    b.p = a;\\n  }\\n  function d3_geo_clipPolygonIntersection(point, points, other, entry) {\\n    this.x = point;\\n    this.z = points;\\n    this.o = other;\\n    this.e = entry;\\n    this.v = false;\\n    this.n = this.p = null;\\n  }\\n  function d3_geo_clip(pointVisible, clipLine, interpolate, clipStart) {\\n    return function(rotate, listener) {\\n      var line = clipLine(listener), rotatedClipStart = rotate.invert(clipStart[0], clipStart[1]);\\n      var clip = {\\n        point: point,\\n        lineStart: lineStart,\\n        lineEnd: lineEnd,\\n        polygonStart: function() {\\n          clip.point = pointRing;\\n          clip.lineStart = ringStart;\\n          clip.lineEnd = ringEnd;\\n          segments = [];\\n          polygon = [];\\n        },\\n        polygonEnd: function() {\\n          clip.point = point;\\n          clip.lineStart = lineStart;\\n          clip.lineEnd = lineEnd;\\n          segments = d3.merge(segments);\\n          var clipStartInside = d3_geo_pointInPolygon(rotatedClipStart, polygon);\\n          if (segments.length) {\\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\\n            d3_geo_clipPolygon(segments, d3_geo_clipSort, clipStartInside, interpolate, listener);\\n          } else if (clipStartInside) {\\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\\n            listener.lineStart();\\n            interpolate(null, null, 1, listener);\\n            listener.lineEnd();\\n          }\\n          if (polygonStarted) listener.polygonEnd(), polygonStarted = false;\\n          segments = polygon = null;\\n        },\\n        sphere: function() {\\n          listener.polygonStart();\\n          listener.lineStart();\\n          interpolate(null, null, 1, listener);\\n          listener.lineEnd();\\n          listener.polygonEnd();\\n        }\\n      };\\n      function point(λ, φ) {\\n        var point = rotate(λ, φ);\\n        if (pointVisible(λ = point[0], φ = point[1])) listener.point(λ, φ);\\n      }\\n      function pointLine(λ, φ) {\\n        var point = rotate(λ, φ);\\n        line.point(point[0], point[1]);\\n      }\\n      function lineStart() {\\n        clip.point = pointLine;\\n        line.lineStart();\\n      }\\n      function lineEnd() {\\n        clip.point = point;\\n        line.lineEnd();\\n      }\\n      var segments;\\n      var buffer = d3_geo_clipBufferListener(), ringListener = clipLine(buffer), polygonStarted = false, polygon, ring;\\n      function pointRing(λ, φ) {\\n        ring.push([ λ, φ ]);\\n        var point = rotate(λ, φ);\\n        ringListener.point(point[0], point[1]);\\n      }\\n      function ringStart() {\\n        ringListener.lineStart();\\n        ring = [];\\n      }\\n      function ringEnd() {\\n        pointRing(ring[0][0], ring[0][1]);\\n        ringListener.lineEnd();\\n        var clean = ringListener.clean(), ringSegments = buffer.buffer(), segment, n = ringSegments.length;\\n        ring.pop();\\n        polygon.push(ring);\\n        ring = null;\\n        if (!n) return;\\n        if (clean & 1) {\\n          segment = ringSegments[0];\\n          var n = segment.length - 1, i = -1, point;\\n          if (n > 0) {\\n            if (!polygonStarted) listener.polygonStart(), polygonStarted = true;\\n            listener.lineStart();\\n            while (++i < n) listener.point((point = segment[i])[0], point[1]);\\n            listener.lineEnd();\\n          }\\n          return;\\n        }\\n        if (n > 1 && clean & 2) ringSegments.push(ringSegments.pop().concat(ringSegments.shift()));\\n        segments.push(ringSegments.filter(d3_geo_clipSegmentLength1));\\n      }\\n      return clip;\\n    };\\n  }\\n  function d3_geo_clipSegmentLength1(segment) {\\n    return segment.length > 1;\\n  }\\n  function d3_geo_clipBufferListener() {\\n    var lines = [], line;\\n    return {\\n      lineStart: function() {\\n        lines.push(line = []);\\n      },\\n      point: function(λ, φ) {\\n        line.push([ λ, φ ]);\\n      },\\n      lineEnd: d3_noop,\\n      buffer: function() {\\n        var buffer = lines;\\n        lines = [];\\n        line = null;\\n        return buffer;\\n      },\\n      rejoin: function() {\\n        if (lines.length > 1) lines.push(lines.pop().concat(lines.shift()));\\n      }\\n    };\\n  }\\n  function d3_geo_clipSort(a, b) {\\n    return ((a = a.x)[0] < 0 ? a[1] - halfπ - ε : halfπ - a[1]) - ((b = b.x)[0] < 0 ? b[1] - halfπ - ε : halfπ - b[1]);\\n  }\\n  var d3_geo_clipAntimeridian = d3_geo_clip(d3_true, d3_geo_clipAntimeridianLine, d3_geo_clipAntimeridianInterpolate, [ -π, -π / 2 ]);\\n  function d3_geo_clipAntimeridianLine(listener) {\\n    var λ0 = NaN, φ0 = NaN, sλ0 = NaN, clean;\\n    return {\\n      lineStart: function() {\\n        listener.lineStart();\\n        clean = 1;\\n      },\\n      point: function(λ1, φ1) {\\n        var sλ1 = λ1 > 0 ? π : -π, dλ = abs(λ1 - λ0);\\n        if (abs(dλ - π) < ε) {\\n          listener.point(λ0, φ0 = (φ0 + φ1) / 2 > 0 ? halfπ : -halfπ);\\n          listener.point(sλ0, φ0);\\n          listener.lineEnd();\\n          listener.lineStart();\\n          listener.point(sλ1, φ0);\\n          listener.point(λ1, φ0);\\n          clean = 0;\\n        } else if (sλ0 !== sλ1 && dλ >= π) {\\n          if (abs(λ0 - sλ0) < ε) λ0 -= sλ0 * ε;\\n          if (abs(λ1 - sλ1) < ε) λ1 -= sλ1 * ε;\\n          φ0 = d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1);\\n          listener.point(sλ0, φ0);\\n          listener.lineEnd();\\n          listener.lineStart();\\n          listener.point(sλ1, φ0);\\n          clean = 0;\\n        }\\n        listener.point(λ0 = λ1, φ0 = φ1);\\n        sλ0 = sλ1;\\n      },\\n      lineEnd: function() {\\n        listener.lineEnd();\\n        λ0 = φ0 = NaN;\\n      },\\n      clean: function() {\\n        return 2 - clean;\\n      }\\n    };\\n  }\\n  function d3_geo_clipAntimeridianIntersect(λ0, φ0, λ1, φ1) {\\n    var cosφ0, cosφ1, sinλ0_λ1 = Math.sin(λ0 - λ1);\\n    return abs(sinλ0_λ1) > ε ? Math.atan((Math.sin(φ0) * (cosφ1 = Math.cos(φ1)) * Math.sin(λ1) - Math.sin(φ1) * (cosφ0 = Math.cos(φ0)) * Math.sin(λ0)) / (cosφ0 * cosφ1 * sinλ0_λ1)) : (φ0 + φ1) / 2;\\n  }\\n  function d3_geo_clipAntimeridianInterpolate(from, to, direction, listener) {\\n    var φ;\\n    if (from == null) {\\n      φ = direction * halfπ;\\n      listener.point(-π, φ);\\n      listener.point(0, φ);\\n      listener.point(π, φ);\\n      listener.point(π, 0);\\n      listener.point(π, -φ);\\n      listener.point(0, -φ);\\n      listener.point(-π, -φ);\\n      listener.point(-π, 0);\\n      listener.point(-π, φ);\\n    } else if (abs(from[0] - to[0]) > ε) {\\n      var s = from[0] < to[0] ? π : -π;\\n      φ = direction * s / 2;\\n      listener.point(-s, φ);\\n      listener.point(0, φ);\\n      listener.point(s, φ);\\n    } else {\\n      listener.point(to[0], to[1]);\\n    }\\n  }\\n  function d3_geo_pointInPolygon(point, polygon) {\\n    var meridian = point[0], parallel = point[1], meridianNormal = [ Math.sin(meridian), -Math.cos(meridian), 0 ], polarAngle = 0, winding = 0;\\n    d3_geo_areaRingSum.reset();\\n    for (var i = 0, n = polygon.length; i < n; ++i) {\\n      var ring = polygon[i], m = ring.length;\\n      if (!m) continue;\\n      var point0 = ring[0], λ0 = point0[0], φ0 = point0[1] / 2 + π / 4, sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), j = 1;\\n      while (true) {\\n        if (j === m) j = 0;\\n        point = ring[j];\\n        var λ = point[0], φ = point[1] / 2 + π / 4, sinφ = Math.sin(φ), cosφ = Math.cos(φ), dλ = λ - λ0, sdλ = dλ >= 0 ? 1 : -1, adλ = sdλ * dλ, antimeridian = adλ > π, k = sinφ0 * sinφ;\\n        d3_geo_areaRingSum.add(Math.atan2(k * sdλ * Math.sin(adλ), cosφ0 * cosφ + k * Math.cos(adλ)));\\n        polarAngle += antimeridian ? dλ + sdλ * τ : dλ;\\n        if (antimeridian ^ λ0 >= meridian ^ λ >= meridian) {\\n          var arc = d3_geo_cartesianCross(d3_geo_cartesian(point0), d3_geo_cartesian(point));\\n          d3_geo_cartesianNormalize(arc);\\n          var intersection = d3_geo_cartesianCross(meridianNormal, arc);\\n          d3_geo_cartesianNormalize(intersection);\\n          var φarc = (antimeridian ^ dλ >= 0 ? -1 : 1) * d3_asin(intersection[2]);\\n          if (parallel > φarc || parallel === φarc && (arc[0] || arc[1])) {\\n            winding += antimeridian ^ dλ >= 0 ? 1 : -1;\\n          }\\n        }\\n        if (!j++) break;\\n        λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ, point0 = point;\\n      }\\n    }\\n    return (polarAngle < -ε || polarAngle < ε && d3_geo_areaRingSum < 0) ^ winding & 1;\\n  }\\n  function d3_geo_clipCircle(radius) {\\n    var cr = Math.cos(radius), smallRadius = cr > 0, notHemisphere = abs(cr) > ε, interpolate = d3_geo_circleInterpolate(radius, 6 * d3_radians);\\n    return d3_geo_clip(visible, clipLine, interpolate, smallRadius ? [ 0, -radius ] : [ -π, radius - π ]);\\n    function visible(λ, φ) {\\n      return Math.cos(λ) * Math.cos(φ) > cr;\\n    }\\n    function clipLine(listener) {\\n      var point0, c0, v0, v00, clean;\\n      return {\\n        lineStart: function() {\\n          v00 = v0 = false;\\n          clean = 1;\\n        },\\n        point: function(λ, φ) {\\n          var point1 = [ λ, φ ], point2, v = visible(λ, φ), c = smallRadius ? v ? 0 : code(λ, φ) : v ? code(λ + (λ < 0 ? π : -π), φ) : 0;\\n          if (!point0 && (v00 = v0 = v)) listener.lineStart();\\n          if (v !== v0) {\\n            point2 = intersect(point0, point1);\\n            if (d3_geo_sphericalEqual(point0, point2) || d3_geo_sphericalEqual(point1, point2)) {\\n              point1[0] += ε;\\n              point1[1] += ε;\\n              v = visible(point1[0], point1[1]);\\n            }\\n          }\\n          if (v !== v0) {\\n            clean = 0;\\n            if (v) {\\n              listener.lineStart();\\n              point2 = intersect(point1, point0);\\n              listener.point(point2[0], point2[1]);\\n            } else {\\n              point2 = intersect(point0, point1);\\n              listener.point(point2[0], point2[1]);\\n              listener.lineEnd();\\n            }\\n            point0 = point2;\\n          } else if (notHemisphere && point0 && smallRadius ^ v) {\\n            var t;\\n            if (!(c & c0) && (t = intersect(point1, point0, true))) {\\n              clean = 0;\\n              if (smallRadius) {\\n                listener.lineStart();\\n                listener.point(t[0][0], t[0][1]);\\n                listener.point(t[1][0], t[1][1]);\\n                listener.lineEnd();\\n              } else {\\n                listener.point(t[1][0], t[1][1]);\\n                listener.lineEnd();\\n                listener.lineStart();\\n                listener.point(t[0][0], t[0][1]);\\n              }\\n            }\\n          }\\n          if (v && (!point0 || !d3_geo_sphericalEqual(point0, point1))) {\\n            listener.point(point1[0], point1[1]);\\n          }\\n          point0 = point1, v0 = v, c0 = c;\\n        },\\n        lineEnd: function() {\\n          if (v0) listener.lineEnd();\\n          point0 = null;\\n        },\\n        clean: function() {\\n          return clean | (v00 && v0) << 1;\\n        }\\n      };\\n    }\\n    function intersect(a, b, two) {\\n      var pa = d3_geo_cartesian(a), pb = d3_geo_cartesian(b);\\n      var n1 = [ 1, 0, 0 ], n2 = d3_geo_cartesianCross(pa, pb), n2n2 = d3_geo_cartesianDot(n2, n2), n1n2 = n2[0], determinant = n2n2 - n1n2 * n1n2;\\n      if (!determinant) return !two && a;\\n      var c1 = cr * n2n2 / determinant, c2 = -cr * n1n2 / determinant, n1xn2 = d3_geo_cartesianCross(n1, n2), A = d3_geo_cartesianScale(n1, c1), B = d3_geo_cartesianScale(n2, c2);\\n      d3_geo_cartesianAdd(A, B);\\n      var u = n1xn2, w = d3_geo_cartesianDot(A, u), uu = d3_geo_cartesianDot(u, u), t2 = w * w - uu * (d3_geo_cartesianDot(A, A) - 1);\\n      if (t2 < 0) return;\\n      var t = Math.sqrt(t2), q = d3_geo_cartesianScale(u, (-w - t) / uu);\\n      d3_geo_cartesianAdd(q, A);\\n      q = d3_geo_spherical(q);\\n      if (!two) return q;\\n      var λ0 = a[0], λ1 = b[0], φ0 = a[1], φ1 = b[1], z;\\n      if (λ1 < λ0) z = λ0, λ0 = λ1, λ1 = z;\\n      var δλ = λ1 - λ0, polar = abs(δλ - π) < ε, meridian = polar || δλ < ε;\\n      if (!polar && φ1 < φ0) z = φ0, φ0 = φ1, φ1 = z;\\n      if (meridian ? polar ? φ0 + φ1 > 0 ^ q[1] < (abs(q[0] - λ0) < ε ? φ0 : φ1) : φ0 <= q[1] && q[1] <= φ1 : δλ > π ^ (λ0 <= q[0] && q[0] <= λ1)) {\\n        var q1 = d3_geo_cartesianScale(u, (-w + t) / uu);\\n        d3_geo_cartesianAdd(q1, A);\\n        return [ q, d3_geo_spherical(q1) ];\\n      }\\n    }\\n    function code(λ, φ) {\\n      var r = smallRadius ? radius : π - radius, code = 0;\\n      if (λ < -r) code |= 1; else if (λ > r) code |= 2;\\n      if (φ < -r) code |= 4; else if (φ > r) code |= 8;\\n      return code;\\n    }\\n  }\\n  function d3_geom_clipLine(x0, y0, x1, y1) {\\n    return function(line) {\\n      var a = line.a, b = line.b, ax = a.x, ay = a.y, bx = b.x, by = b.y, t0 = 0, t1 = 1, dx = bx - ax, dy = by - ay, r;\\n      r = x0 - ax;\\n      if (!dx && r > 0) return;\\n      r /= dx;\\n      if (dx < 0) {\\n        if (r < t0) return;\\n        if (r < t1) t1 = r;\\n      } else if (dx > 0) {\\n        if (r > t1) return;\\n        if (r > t0) t0 = r;\\n      }\\n      r = x1 - ax;\\n      if (!dx && r < 0) return;\\n      r /= dx;\\n      if (dx < 0) {\\n        if (r > t1) return;\\n        if (r > t0) t0 = r;\\n      } else if (dx > 0) {\\n        if (r < t0) return;\\n        if (r < t1) t1 = r;\\n      }\\n      r = y0 - ay;\\n      if (!dy && r > 0) return;\\n      r /= dy;\\n      if (dy < 0) {\\n        if (r < t0) return;\\n        if (r < t1) t1 = r;\\n      } else if (dy > 0) {\\n        if (r > t1) return;\\n        if (r > t0) t0 = r;\\n      }\\n      r = y1 - ay;\\n      if (!dy && r < 0) return;\\n      r /= dy;\\n      if (dy < 0) {\\n        if (r > t1) return;\\n        if (r > t0) t0 = r;\\n      } else if (dy > 0) {\\n        if (r < t0) return;\\n        if (r < t1) t1 = r;\\n      }\\n      if (t0 > 0) line.a = {\\n        x: ax + t0 * dx,\\n        y: ay + t0 * dy\\n      };\\n      if (t1 < 1) line.b = {\\n        x: ax + t1 * dx,\\n        y: ay + t1 * dy\\n      };\\n      return line;\\n    };\\n  }\\n  var d3_geo_clipExtentMAX = 1e9;\\n  d3.geo.clipExtent = function() {\\n    var x0, y0, x1, y1, stream, clip, clipExtent = {\\n      stream: function(output) {\\n        if (stream) stream.valid = false;\\n        stream = clip(output);\\n        stream.valid = true;\\n        return stream;\\n      },\\n      extent: function(_) {\\n        if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\\n        clip = d3_geo_clipExtent(x0 = +_[0][0], y0 = +_[0][1], x1 = +_[1][0], y1 = +_[1][1]);\\n        if (stream) stream.valid = false, stream = null;\\n        return clipExtent;\\n      }\\n    };\\n    return clipExtent.extent([ [ 0, 0 ], [ 960, 500 ] ]);\\n  };\\n  function d3_geo_clipExtent(x0, y0, x1, y1) {\\n    return function(listener) {\\n      var listener_ = listener, bufferListener = d3_geo_clipBufferListener(), clipLine = d3_geom_clipLine(x0, y0, x1, y1), segments, polygon, ring;\\n      var clip = {\\n        point: point,\\n        lineStart: lineStart,\\n        lineEnd: lineEnd,\\n        polygonStart: function() {\\n          listener = bufferListener;\\n          segments = [];\\n          polygon = [];\\n          clean = true;\\n        },\\n        polygonEnd: function() {\\n          listener = listener_;\\n          segments = d3.merge(segments);\\n          var clipStartInside = insidePolygon([ x0, y1 ]), inside = clean && clipStartInside, visible = segments.length;\\n          if (inside || visible) {\\n            listener.polygonStart();\\n            if (inside) {\\n              listener.lineStart();\\n              interpolate(null, null, 1, listener);\\n              listener.lineEnd();\\n            }\\n            if (visible) {\\n              d3_geo_clipPolygon(segments, compare, clipStartInside, interpolate, listener);\\n            }\\n            listener.polygonEnd();\\n          }\\n          segments = polygon = ring = null;\\n        }\\n      };\\n      function insidePolygon(p) {\\n        var wn = 0, n = polygon.length, y = p[1];\\n        for (var i = 0; i < n; ++i) {\\n          for (var j = 1, v = polygon[i], m = v.length, a = v[0], b; j < m; ++j) {\\n            b = v[j];\\n            if (a[1] <= y) {\\n              if (b[1] > y && d3_cross2d(a, b, p) > 0) ++wn;\\n            } else {\\n              if (b[1] <= y && d3_cross2d(a, b, p) < 0) --wn;\\n            }\\n            a = b;\\n          }\\n        }\\n        return wn !== 0;\\n      }\\n      function interpolate(from, to, direction, listener) {\\n        var a = 0, a1 = 0;\\n        if (from == null || (a = corner(from, direction)) !== (a1 = corner(to, direction)) || comparePoints(from, to) < 0 ^ direction > 0) {\\n          do {\\n            listener.point(a === 0 || a === 3 ? x0 : x1, a > 1 ? y1 : y0);\\n          } while ((a = (a + direction + 4) % 4) !== a1);\\n        } else {\\n          listener.point(to[0], to[1]);\\n        }\\n      }\\n      function pointVisible(x, y) {\\n        return x0 <= x && x <= x1 && y0 <= y && y <= y1;\\n      }\\n      function point(x, y) {\\n        if (pointVisible(x, y)) listener.point(x, y);\\n      }\\n      var x__, y__, v__, x_, y_, v_, first, clean;\\n      function lineStart() {\\n        clip.point = linePoint;\\n        if (polygon) polygon.push(ring = []);\\n        first = true;\\n        v_ = false;\\n        x_ = y_ = NaN;\\n      }\\n      function lineEnd() {\\n        if (segments) {\\n          linePoint(x__, y__);\\n          if (v__ && v_) bufferListener.rejoin();\\n          segments.push(bufferListener.buffer());\\n        }\\n        clip.point = point;\\n        if (v_) listener.lineEnd();\\n      }\\n      function linePoint(x, y) {\\n        x = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, x));\\n        y = Math.max(-d3_geo_clipExtentMAX, Math.min(d3_geo_clipExtentMAX, y));\\n        var v = pointVisible(x, y);\\n        if (polygon) ring.push([ x, y ]);\\n        if (first) {\\n          x__ = x, y__ = y, v__ = v;\\n          first = false;\\n          if (v) {\\n            listener.lineStart();\\n            listener.point(x, y);\\n          }\\n        } else {\\n          if (v && v_) listener.point(x, y); else {\\n            var l = {\\n              a: {\\n                x: x_,\\n                y: y_\\n              },\\n              b: {\\n                x: x,\\n                y: y\\n              }\\n            };\\n            if (clipLine(l)) {\\n              if (!v_) {\\n                listener.lineStart();\\n                listener.point(l.a.x, l.a.y);\\n              }\\n              listener.point(l.b.x, l.b.y);\\n              if (!v) listener.lineEnd();\\n              clean = false;\\n            } else if (v) {\\n              listener.lineStart();\\n              listener.point(x, y);\\n              clean = false;\\n            }\\n          }\\n        }\\n        x_ = x, y_ = y, v_ = v;\\n      }\\n      return clip;\\n    };\\n    function corner(p, direction) {\\n      return abs(p[0] - x0) < ε ? direction > 0 ? 0 : 3 : abs(p[0] - x1) < ε ? direction > 0 ? 2 : 1 : abs(p[1] - y0) < ε ? direction > 0 ? 1 : 0 : direction > 0 ? 3 : 2;\\n    }\\n    function compare(a, b) {\\n      return comparePoints(a.x, b.x);\\n    }\\n    function comparePoints(a, b) {\\n      var ca = corner(a, 1), cb = corner(b, 1);\\n      return ca !== cb ? ca - cb : ca === 0 ? b[1] - a[1] : ca === 1 ? a[0] - b[0] : ca === 2 ? a[1] - b[1] : b[0] - a[0];\\n    }\\n  }\\n  function d3_geo_conic(projectAt) {\\n    var φ0 = 0, φ1 = π / 3, m = d3_geo_projectionMutator(projectAt), p = m(φ0, φ1);\\n    p.parallels = function(_) {\\n      if (!arguments.length) return [ φ0 / π * 180, φ1 / π * 180 ];\\n      return m(φ0 = _[0] * π / 180, φ1 = _[1] * π / 180);\\n    };\\n    return p;\\n  }\\n  function d3_geo_conicEqualArea(φ0, φ1) {\\n    var sinφ0 = Math.sin(φ0), n = (sinφ0 + Math.sin(φ1)) / 2, C = 1 + sinφ0 * (2 * n - sinφ0), ρ0 = Math.sqrt(C) / n;\\n    function forward(λ, φ) {\\n      var ρ = Math.sqrt(C - 2 * n * Math.sin(φ)) / n;\\n      return [ ρ * Math.sin(λ *= n), ρ0 - ρ * Math.cos(λ) ];\\n    }\\n    forward.invert = function(x, y) {\\n      var ρ0_y = ρ0 - y;\\n      return [ Math.atan2(x, ρ0_y) / n, d3_asin((C - (x * x + ρ0_y * ρ0_y) * n * n) / (2 * n)) ];\\n    };\\n    return forward;\\n  }\\n  (d3.geo.conicEqualArea = function() {\\n    return d3_geo_conic(d3_geo_conicEqualArea);\\n  }).raw = d3_geo_conicEqualArea;\\n  d3.geo.albers = function() {\\n    return d3.geo.conicEqualArea().rotate([ 96, 0 ]).center([ -.6, 38.7 ]).parallels([ 29.5, 45.5 ]).scale(1070);\\n  };\\n  d3.geo.albersUsa = function() {\\n    var lower48 = d3.geo.albers();\\n    var alaska = d3.geo.conicEqualArea().rotate([ 154, 0 ]).center([ -2, 58.5 ]).parallels([ 55, 65 ]);\\n    var hawaii = d3.geo.conicEqualArea().rotate([ 157, 0 ]).center([ -3, 19.9 ]).parallels([ 8, 18 ]);\\n    var point, pointStream = {\\n      point: function(x, y) {\\n        point = [ x, y ];\\n      }\\n    }, lower48Point, alaskaPoint, hawaiiPoint;\\n    function albersUsa(coordinates) {\\n      var x = coordinates[0], y = coordinates[1];\\n      point = null;\\n      (lower48Point(x, y), point) || (alaskaPoint(x, y), point) || hawaiiPoint(x, y);\\n      return point;\\n    }\\n    albersUsa.invert = function(coordinates) {\\n      var k = lower48.scale(), t = lower48.translate(), x = (coordinates[0] - t[0]) / k, y = (coordinates[1] - t[1]) / k;\\n      return (y >= .12 && y < .234 && x >= -.425 && x < -.214 ? alaska : y >= .166 && y < .234 && x >= -.214 && x < -.115 ? hawaii : lower48).invert(coordinates);\\n    };\\n    albersUsa.stream = function(stream) {\\n      var lower48Stream = lower48.stream(stream), alaskaStream = alaska.stream(stream), hawaiiStream = hawaii.stream(stream);\\n      return {\\n        point: function(x, y) {\\n          lower48Stream.point(x, y);\\n          alaskaStream.point(x, y);\\n          hawaiiStream.point(x, y);\\n        },\\n        sphere: function() {\\n          lower48Stream.sphere();\\n          alaskaStream.sphere();\\n          hawaiiStream.sphere();\\n        },\\n        lineStart: function() {\\n          lower48Stream.lineStart();\\n          alaskaStream.lineStart();\\n          hawaiiStream.lineStart();\\n        },\\n        lineEnd: function() {\\n          lower48Stream.lineEnd();\\n          alaskaStream.lineEnd();\\n          hawaiiStream.lineEnd();\\n        },\\n        polygonStart: function() {\\n          lower48Stream.polygonStart();\\n          alaskaStream.polygonStart();\\n          hawaiiStream.polygonStart();\\n        },\\n        polygonEnd: function() {\\n          lower48Stream.polygonEnd();\\n          alaskaStream.polygonEnd();\\n          hawaiiStream.polygonEnd();\\n        }\\n      };\\n    };\\n    albersUsa.precision = function(_) {\\n      if (!arguments.length) return lower48.precision();\\n      lower48.precision(_);\\n      alaska.precision(_);\\n      hawaii.precision(_);\\n      return albersUsa;\\n    };\\n    albersUsa.scale = function(_) {\\n      if (!arguments.length) return lower48.scale();\\n      lower48.scale(_);\\n      alaska.scale(_ * .35);\\n      hawaii.scale(_);\\n      return albersUsa.translate(lower48.translate());\\n    };\\n    albersUsa.translate = function(_) {\\n      if (!arguments.length) return lower48.translate();\\n      var k = lower48.scale(), x = +_[0], y = +_[1];\\n      lower48Point = lower48.translate(_).clipExtent([ [ x - .455 * k, y - .238 * k ], [ x + .455 * k, y + .238 * k ] ]).stream(pointStream).point;\\n      alaskaPoint = alaska.translate([ x - .307 * k, y + .201 * k ]).clipExtent([ [ x - .425 * k + ε, y + .12 * k + ε ], [ x - .214 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\\n      hawaiiPoint = hawaii.translate([ x - .205 * k, y + .212 * k ]).clipExtent([ [ x - .214 * k + ε, y + .166 * k + ε ], [ x - .115 * k - ε, y + .234 * k - ε ] ]).stream(pointStream).point;\\n      return albersUsa;\\n    };\\n    return albersUsa.scale(1070);\\n  };\\n  var d3_geo_pathAreaSum, d3_geo_pathAreaPolygon, d3_geo_pathArea = {\\n    point: d3_noop,\\n    lineStart: d3_noop,\\n    lineEnd: d3_noop,\\n    polygonStart: function() {\\n      d3_geo_pathAreaPolygon = 0;\\n      d3_geo_pathArea.lineStart = d3_geo_pathAreaRingStart;\\n    },\\n    polygonEnd: function() {\\n      d3_geo_pathArea.lineStart = d3_geo_pathArea.lineEnd = d3_geo_pathArea.point = d3_noop;\\n      d3_geo_pathAreaSum += abs(d3_geo_pathAreaPolygon / 2);\\n    }\\n  };\\n  function d3_geo_pathAreaRingStart() {\\n    var x00, y00, x0, y0;\\n    d3_geo_pathArea.point = function(x, y) {\\n      d3_geo_pathArea.point = nextPoint;\\n      x00 = x0 = x, y00 = y0 = y;\\n    };\\n    function nextPoint(x, y) {\\n      d3_geo_pathAreaPolygon += y0 * x - x0 * y;\\n      x0 = x, y0 = y;\\n    }\\n    d3_geo_pathArea.lineEnd = function() {\\n      nextPoint(x00, y00);\\n    };\\n  }\\n  var d3_geo_pathBoundsX0, d3_geo_pathBoundsY0, d3_geo_pathBoundsX1, d3_geo_pathBoundsY1;\\n  var d3_geo_pathBounds = {\\n    point: d3_geo_pathBoundsPoint,\\n    lineStart: d3_noop,\\n    lineEnd: d3_noop,\\n    polygonStart: d3_noop,\\n    polygonEnd: d3_noop\\n  };\\n  function d3_geo_pathBoundsPoint(x, y) {\\n    if (x < d3_geo_pathBoundsX0) d3_geo_pathBoundsX0 = x;\\n    if (x > d3_geo_pathBoundsX1) d3_geo_pathBoundsX1 = x;\\n    if (y < d3_geo_pathBoundsY0) d3_geo_pathBoundsY0 = y;\\n    if (y > d3_geo_pathBoundsY1) d3_geo_pathBoundsY1 = y;\\n  }\\n  function d3_geo_pathBuffer() {\\n    var pointCircle = d3_geo_pathBufferCircle(4.5), buffer = [];\\n    var stream = {\\n      point: point,\\n      lineStart: function() {\\n        stream.point = pointLineStart;\\n      },\\n      lineEnd: lineEnd,\\n      polygonStart: function() {\\n        stream.lineEnd = lineEndPolygon;\\n      },\\n      polygonEnd: function() {\\n        stream.lineEnd = lineEnd;\\n        stream.point = point;\\n      },\\n      pointRadius: function(_) {\\n        pointCircle = d3_geo_pathBufferCircle(_);\\n        return stream;\\n      },\\n      result: function() {\\n        if (buffer.length) {\\n          var result = buffer.join(\\\"\\\");\\n          buffer = [];\\n          return result;\\n        }\\n      }\\n    };\\n    function point(x, y) {\\n      buffer.push(\\\"M\\\", x, \\\",\\\", y, pointCircle);\\n    }\\n    function pointLineStart(x, y) {\\n      buffer.push(\\\"M\\\", x, \\\",\\\", y);\\n      stream.point = pointLine;\\n    }\\n    function pointLine(x, y) {\\n      buffer.push(\\\"L\\\", x, \\\",\\\", y);\\n    }\\n    function lineEnd() {\\n      stream.point = point;\\n    }\\n    function lineEndPolygon() {\\n      buffer.push(\\\"Z\\\");\\n    }\\n    return stream;\\n  }\\n  function d3_geo_pathBufferCircle(radius) {\\n    return \\\"m0,\\\" + radius + \\\"a\\\" + radius + \\\",\\\" + radius + \\\" 0 1,1 0,\\\" + -2 * radius + \\\"a\\\" + radius + \\\",\\\" + radius + \\\" 0 1,1 0,\\\" + 2 * radius + \\\"z\\\";\\n  }\\n  var d3_geo_pathCentroid = {\\n    point: d3_geo_pathCentroidPoint,\\n    lineStart: d3_geo_pathCentroidLineStart,\\n    lineEnd: d3_geo_pathCentroidLineEnd,\\n    polygonStart: function() {\\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidRingStart;\\n    },\\n    polygonEnd: function() {\\n      d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\\n      d3_geo_pathCentroid.lineStart = d3_geo_pathCentroidLineStart;\\n      d3_geo_pathCentroid.lineEnd = d3_geo_pathCentroidLineEnd;\\n    }\\n  };\\n  function d3_geo_pathCentroidPoint(x, y) {\\n    d3_geo_centroidX0 += x;\\n    d3_geo_centroidY0 += y;\\n    ++d3_geo_centroidZ0;\\n  }\\n  function d3_geo_pathCentroidLineStart() {\\n    var x0, y0;\\n    d3_geo_pathCentroid.point = function(x, y) {\\n      d3_geo_pathCentroid.point = nextPoint;\\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\\n    };\\n    function nextPoint(x, y) {\\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\\n      d3_geo_centroidZ1 += z;\\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\\n    }\\n  }\\n  function d3_geo_pathCentroidLineEnd() {\\n    d3_geo_pathCentroid.point = d3_geo_pathCentroidPoint;\\n  }\\n  function d3_geo_pathCentroidRingStart() {\\n    var x00, y00, x0, y0;\\n    d3_geo_pathCentroid.point = function(x, y) {\\n      d3_geo_pathCentroid.point = nextPoint;\\n      d3_geo_pathCentroidPoint(x00 = x0 = x, y00 = y0 = y);\\n    };\\n    function nextPoint(x, y) {\\n      var dx = x - x0, dy = y - y0, z = Math.sqrt(dx * dx + dy * dy);\\n      d3_geo_centroidX1 += z * (x0 + x) / 2;\\n      d3_geo_centroidY1 += z * (y0 + y) / 2;\\n      d3_geo_centroidZ1 += z;\\n      z = y0 * x - x0 * y;\\n      d3_geo_centroidX2 += z * (x0 + x);\\n      d3_geo_centroidY2 += z * (y0 + y);\\n      d3_geo_centroidZ2 += z * 3;\\n      d3_geo_pathCentroidPoint(x0 = x, y0 = y);\\n    }\\n    d3_geo_pathCentroid.lineEnd = function() {\\n      nextPoint(x00, y00);\\n    };\\n  }\\n  function d3_geo_pathContext(context) {\\n    var pointRadius = 4.5;\\n    var stream = {\\n      point: point,\\n      lineStart: function() {\\n        stream.point = pointLineStart;\\n      },\\n      lineEnd: lineEnd,\\n      polygonStart: function() {\\n        stream.lineEnd = lineEndPolygon;\\n      },\\n      polygonEnd: function() {\\n        stream.lineEnd = lineEnd;\\n        stream.point = point;\\n      },\\n      pointRadius: function(_) {\\n        pointRadius = _;\\n        return stream;\\n      },\\n      result: d3_noop\\n    };\\n    function point(x, y) {\\n      context.moveTo(x + pointRadius, y);\\n      context.arc(x, y, pointRadius, 0, τ);\\n    }\\n    function pointLineStart(x, y) {\\n      context.moveTo(x, y);\\n      stream.point = pointLine;\\n    }\\n    function pointLine(x, y) {\\n      context.lineTo(x, y);\\n    }\\n    function lineEnd() {\\n      stream.point = point;\\n    }\\n    function lineEndPolygon() {\\n      context.closePath();\\n    }\\n    return stream;\\n  }\\n  function d3_geo_resample(project) {\\n    var δ2 = .5, cosMinDistance = Math.cos(30 * d3_radians), maxDepth = 16;\\n    function resample(stream) {\\n      return (maxDepth ? resampleRecursive : resampleNone)(stream);\\n    }\\n    function resampleNone(stream) {\\n      return d3_geo_transformPoint(stream, function(x, y) {\\n        x = project(x, y);\\n        stream.point(x[0], x[1]);\\n      });\\n    }\\n    function resampleRecursive(stream) {\\n      var λ00, φ00, x00, y00, a00, b00, c00, λ0, x0, y0, a0, b0, c0;\\n      var resample = {\\n        point: point,\\n        lineStart: lineStart,\\n        lineEnd: lineEnd,\\n        polygonStart: function() {\\n          stream.polygonStart();\\n          resample.lineStart = ringStart;\\n        },\\n        polygonEnd: function() {\\n          stream.polygonEnd();\\n          resample.lineStart = lineStart;\\n        }\\n      };\\n      function point(x, y) {\\n        x = project(x, y);\\n        stream.point(x[0], x[1]);\\n      }\\n      function lineStart() {\\n        x0 = NaN;\\n        resample.point = linePoint;\\n        stream.lineStart();\\n      }\\n      function linePoint(λ, φ) {\\n        var c = d3_geo_cartesian([ λ, φ ]), p = project(λ, φ);\\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x0 = p[0], y0 = p[1], λ0 = λ, a0 = c[0], b0 = c[1], c0 = c[2], maxDepth, stream);\\n        stream.point(x0, y0);\\n      }\\n      function lineEnd() {\\n        resample.point = point;\\n        stream.lineEnd();\\n      }\\n      function ringStart() {\\n        lineStart();\\n        resample.point = ringPoint;\\n        resample.lineEnd = ringEnd;\\n      }\\n      function ringPoint(λ, φ) {\\n        linePoint(λ00 = λ, φ00 = φ), x00 = x0, y00 = y0, a00 = a0, b00 = b0, c00 = c0;\\n        resample.point = linePoint;\\n      }\\n      function ringEnd() {\\n        resampleLineTo(x0, y0, λ0, a0, b0, c0, x00, y00, λ00, a00, b00, c00, maxDepth, stream);\\n        resample.lineEnd = lineEnd;\\n        lineEnd();\\n      }\\n      return resample;\\n    }\\n    function resampleLineTo(x0, y0, λ0, a0, b0, c0, x1, y1, λ1, a1, b1, c1, depth, stream) {\\n      var dx = x1 - x0, dy = y1 - y0, d2 = dx * dx + dy * dy;\\n      if (d2 > 4 * δ2 && depth--) {\\n        var a = a0 + a1, b = b0 + b1, c = c0 + c1, m = Math.sqrt(a * a + b * b + c * c), φ2 = Math.asin(c /= m), λ2 = abs(abs(c) - 1) < ε || abs(λ0 - λ1) < ε ? (λ0 + λ1) / 2 : Math.atan2(b, a), p = project(λ2, φ2), x2 = p[0], y2 = p[1], dx2 = x2 - x0, dy2 = y2 - y0, dz = dy * dx2 - dx * dy2;\\n        if (dz * dz / d2 > δ2 || abs((dx * dx2 + dy * dy2) / d2 - .5) > .3 || a0 * a1 + b0 * b1 + c0 * c1 < cosMinDistance) {\\n          resampleLineTo(x0, y0, λ0, a0, b0, c0, x2, y2, λ2, a /= m, b /= m, c, depth, stream);\\n          stream.point(x2, y2);\\n          resampleLineTo(x2, y2, λ2, a, b, c, x1, y1, λ1, a1, b1, c1, depth, stream);\\n        }\\n      }\\n    }\\n    resample.precision = function(_) {\\n      if (!arguments.length) return Math.sqrt(δ2);\\n      maxDepth = (δ2 = _ * _) > 0 && 16;\\n      return resample;\\n    };\\n    return resample;\\n  }\\n  d3.geo.path = function() {\\n    var pointRadius = 4.5, projection, context, projectStream, contextStream, cacheStream;\\n    function path(object) {\\n      if (object) {\\n        if (typeof pointRadius === \\\"function\\\") contextStream.pointRadius(+pointRadius.apply(this, arguments));\\n        if (!cacheStream || !cacheStream.valid) cacheStream = projectStream(contextStream);\\n        d3.geo.stream(object, cacheStream);\\n      }\\n      return contextStream.result();\\n    }\\n    path.area = function(object) {\\n      d3_geo_pathAreaSum = 0;\\n      d3.geo.stream(object, projectStream(d3_geo_pathArea));\\n      return d3_geo_pathAreaSum;\\n    };\\n    path.centroid = function(object) {\\n      d3_geo_centroidX0 = d3_geo_centroidY0 = d3_geo_centroidZ0 = d3_geo_centroidX1 = d3_geo_centroidY1 = d3_geo_centroidZ1 = d3_geo_centroidX2 = d3_geo_centroidY2 = d3_geo_centroidZ2 = 0;\\n      d3.geo.stream(object, projectStream(d3_geo_pathCentroid));\\n      return d3_geo_centroidZ2 ? [ d3_geo_centroidX2 / d3_geo_centroidZ2, d3_geo_centroidY2 / d3_geo_centroidZ2 ] : d3_geo_centroidZ1 ? [ d3_geo_centroidX1 / d3_geo_centroidZ1, d3_geo_centroidY1 / d3_geo_centroidZ1 ] : d3_geo_centroidZ0 ? [ d3_geo_centroidX0 / d3_geo_centroidZ0, d3_geo_centroidY0 / d3_geo_centroidZ0 ] : [ NaN, NaN ];\\n    };\\n    path.bounds = function(object) {\\n      d3_geo_pathBoundsX1 = d3_geo_pathBoundsY1 = -(d3_geo_pathBoundsX0 = d3_geo_pathBoundsY0 = Infinity);\\n      d3.geo.stream(object, projectStream(d3_geo_pathBounds));\\n      return [ [ d3_geo_pathBoundsX0, d3_geo_pathBoundsY0 ], [ d3_geo_pathBoundsX1, d3_geo_pathBoundsY1 ] ];\\n    };\\n    path.projection = function(_) {\\n      if (!arguments.length) return projection;\\n      projectStream = (projection = _) ? _.stream || d3_geo_pathProjectStream(_) : d3_identity;\\n      return reset();\\n    };\\n    path.context = function(_) {\\n      if (!arguments.length) return context;\\n      contextStream = (context = _) == null ? new d3_geo_pathBuffer() : new d3_geo_pathContext(_);\\n      if (typeof pointRadius !== \\\"function\\\") contextStream.pointRadius(pointRadius);\\n      return reset();\\n    };\\n    path.pointRadius = function(_) {\\n      if (!arguments.length) return pointRadius;\\n      pointRadius = typeof _ === \\\"function\\\" ? _ : (contextStream.pointRadius(+_), +_);\\n      return path;\\n    };\\n    function reset() {\\n      cacheStream = null;\\n      return path;\\n    }\\n    return path.projection(d3.geo.albersUsa()).context(null);\\n  };\\n  function d3_geo_pathProjectStream(project) {\\n    var resample = d3_geo_resample(function(x, y) {\\n      return project([ x * d3_degrees, y * d3_degrees ]);\\n    });\\n    return function(stream) {\\n      return d3_geo_projectionRadians(resample(stream));\\n    };\\n  }\\n  d3.geo.transform = function(methods) {\\n    return {\\n      stream: function(stream) {\\n        var transform = new d3_geo_transform(stream);\\n        for (var k in methods) transform[k] = methods[k];\\n        return transform;\\n      }\\n    };\\n  };\\n  function d3_geo_transform(stream) {\\n    this.stream = stream;\\n  }\\n  d3_geo_transform.prototype = {\\n    point: function(x, y) {\\n      this.stream.point(x, y);\\n    },\\n    sphere: function() {\\n      this.stream.sphere();\\n    },\\n    lineStart: function() {\\n      this.stream.lineStart();\\n    },\\n    lineEnd: function() {\\n      this.stream.lineEnd();\\n    },\\n    polygonStart: function() {\\n      this.stream.polygonStart();\\n    },\\n    polygonEnd: function() {\\n      this.stream.polygonEnd();\\n    }\\n  };\\n  function d3_geo_transformPoint(stream, point) {\\n    return {\\n      point: point,\\n      sphere: function() {\\n        stream.sphere();\\n      },\\n      lineStart: function() {\\n        stream.lineStart();\\n      },\\n      lineEnd: function() {\\n        stream.lineEnd();\\n      },\\n      polygonStart: function() {\\n        stream.polygonStart();\\n      },\\n      polygonEnd: function() {\\n        stream.polygonEnd();\\n      }\\n    };\\n  }\\n  d3.geo.projection = d3_geo_projection;\\n  d3.geo.projectionMutator = d3_geo_projectionMutator;\\n  function d3_geo_projection(project) {\\n    return d3_geo_projectionMutator(function() {\\n      return project;\\n    })();\\n  }\\n  function d3_geo_projectionMutator(projectAt) {\\n    var project, rotate, projectRotate, projectResample = d3_geo_resample(function(x, y) {\\n      x = project(x, y);\\n      return [ x[0] * k + δx, δy - x[1] * k ];\\n    }), k = 150, x = 480, y = 250, λ = 0, φ = 0, δλ = 0, δφ = 0, δγ = 0, δx, δy, preclip = d3_geo_clipAntimeridian, postclip = d3_identity, clipAngle = null, clipExtent = null, stream;\\n    function projection(point) {\\n      point = projectRotate(point[0] * d3_radians, point[1] * d3_radians);\\n      return [ point[0] * k + δx, δy - point[1] * k ];\\n    }\\n    function invert(point) {\\n      point = projectRotate.invert((point[0] - δx) / k, (δy - point[1]) / k);\\n      return point && [ point[0] * d3_degrees, point[1] * d3_degrees ];\\n    }\\n    projection.stream = function(output) {\\n      if (stream) stream.valid = false;\\n      stream = d3_geo_projectionRadians(preclip(rotate, projectResample(postclip(output))));\\n      stream.valid = true;\\n      return stream;\\n    };\\n    projection.clipAngle = function(_) {\\n      if (!arguments.length) return clipAngle;\\n      preclip = _ == null ? (clipAngle = _, d3_geo_clipAntimeridian) : d3_geo_clipCircle((clipAngle = +_) * d3_radians);\\n      return invalidate();\\n    };\\n    projection.clipExtent = function(_) {\\n      if (!arguments.length) return clipExtent;\\n      clipExtent = _;\\n      postclip = _ ? d3_geo_clipExtent(_[0][0], _[0][1], _[1][0], _[1][1]) : d3_identity;\\n      return invalidate();\\n    };\\n    projection.scale = function(_) {\\n      if (!arguments.length) return k;\\n      k = +_;\\n      return reset();\\n    };\\n    projection.translate = function(_) {\\n      if (!arguments.length) return [ x, y ];\\n      x = +_[0];\\n      y = +_[1];\\n      return reset();\\n    };\\n    projection.center = function(_) {\\n      if (!arguments.length) return [ λ * d3_degrees, φ * d3_degrees ];\\n      λ = _[0] % 360 * d3_radians;\\n      φ = _[1] % 360 * d3_radians;\\n      return reset();\\n    };\\n    projection.rotate = function(_) {\\n      if (!arguments.length) return [ δλ * d3_degrees, δφ * d3_degrees, δγ * d3_degrees ];\\n      δλ = _[0] % 360 * d3_radians;\\n      δφ = _[1] % 360 * d3_radians;\\n      δγ = _.length > 2 ? _[2] % 360 * d3_radians : 0;\\n      return reset();\\n    };\\n    d3.rebind(projection, projectResample, \\\"precision\\\");\\n    function reset() {\\n      projectRotate = d3_geo_compose(rotate = d3_geo_rotation(δλ, δφ, δγ), project);\\n      var center = project(λ, φ);\\n      δx = x - center[0] * k;\\n      δy = y + center[1] * k;\\n      return invalidate();\\n    }\\n    function invalidate() {\\n      if (stream) stream.valid = false, stream = null;\\n      return projection;\\n    }\\n    return function() {\\n      project = projectAt.apply(this, arguments);\\n      projection.invert = project.invert && invert;\\n      return reset();\\n    };\\n  }\\n  function d3_geo_projectionRadians(stream) {\\n    return d3_geo_transformPoint(stream, function(x, y) {\\n      stream.point(x * d3_radians, y * d3_radians);\\n    });\\n  }\\n  function d3_geo_equirectangular(λ, φ) {\\n    return [ λ, φ ];\\n  }\\n  (d3.geo.equirectangular = function() {\\n    return d3_geo_projection(d3_geo_equirectangular);\\n  }).raw = d3_geo_equirectangular.invert = d3_geo_equirectangular;\\n  d3.geo.rotation = function(rotate) {\\n    rotate = d3_geo_rotation(rotate[0] % 360 * d3_radians, rotate[1] * d3_radians, rotate.length > 2 ? rotate[2] * d3_radians : 0);\\n    function forward(coordinates) {\\n      coordinates = rotate(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\\n    }\\n    forward.invert = function(coordinates) {\\n      coordinates = rotate.invert(coordinates[0] * d3_radians, coordinates[1] * d3_radians);\\n      return coordinates[0] *= d3_degrees, coordinates[1] *= d3_degrees, coordinates;\\n    };\\n    return forward;\\n  };\\n  function d3_geo_identityRotation(λ, φ) {\\n    return [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\\n  }\\n  d3_geo_identityRotation.invert = d3_geo_equirectangular;\\n  function d3_geo_rotation(δλ, δφ, δγ) {\\n    return δλ ? δφ || δγ ? d3_geo_compose(d3_geo_rotationλ(δλ), d3_geo_rotationφγ(δφ, δγ)) : d3_geo_rotationλ(δλ) : δφ || δγ ? d3_geo_rotationφγ(δφ, δγ) : d3_geo_identityRotation;\\n  }\\n  function d3_geo_forwardRotationλ(δλ) {\\n    return function(λ, φ) {\\n      return λ += δλ, [ λ > π ? λ - τ : λ < -π ? λ + τ : λ, φ ];\\n    };\\n  }\\n  function d3_geo_rotationλ(δλ) {\\n    var rotation = d3_geo_forwardRotationλ(δλ);\\n    rotation.invert = d3_geo_forwardRotationλ(-δλ);\\n    return rotation;\\n  }\\n  function d3_geo_rotationφγ(δφ, δγ) {\\n    var cosδφ = Math.cos(δφ), sinδφ = Math.sin(δφ), cosδγ = Math.cos(δγ), sinδγ = Math.sin(δγ);\\n    function rotation(λ, φ) {\\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδφ + x * sinδφ;\\n      return [ Math.atan2(y * cosδγ - k * sinδγ, x * cosδφ - z * sinδφ), d3_asin(k * cosδγ + y * sinδγ) ];\\n    }\\n    rotation.invert = function(λ, φ) {\\n      var cosφ = Math.cos(φ), x = Math.cos(λ) * cosφ, y = Math.sin(λ) * cosφ, z = Math.sin(φ), k = z * cosδγ - y * sinδγ;\\n      return [ Math.atan2(y * cosδγ + z * sinδγ, x * cosδφ + k * sinδφ), d3_asin(k * cosδφ - x * sinδφ) ];\\n    };\\n    return rotation;\\n  }\\n  d3.geo.circle = function() {\\n    var origin = [ 0, 0 ], angle, precision = 6, interpolate;\\n    function circle() {\\n      var center = typeof origin === \\\"function\\\" ? origin.apply(this, arguments) : origin, rotate = d3_geo_rotation(-center[0] * d3_radians, -center[1] * d3_radians, 0).invert, ring = [];\\n      interpolate(null, null, 1, {\\n        point: function(x, y) {\\n          ring.push(x = rotate(x, y));\\n          x[0] *= d3_degrees, x[1] *= d3_degrees;\\n        }\\n      });\\n      return {\\n        type: \\\"Polygon\\\",\\n        coordinates: [ ring ]\\n      };\\n    }\\n    circle.origin = function(x) {\\n      if (!arguments.length) return origin;\\n      origin = x;\\n      return circle;\\n    };\\n    circle.angle = function(x) {\\n      if (!arguments.length) return angle;\\n      interpolate = d3_geo_circleInterpolate((angle = +x) * d3_radians, precision * d3_radians);\\n      return circle;\\n    };\\n    circle.precision = function(_) {\\n      if (!arguments.length) return precision;\\n      interpolate = d3_geo_circleInterpolate(angle * d3_radians, (precision = +_) * d3_radians);\\n      return circle;\\n    };\\n    return circle.angle(90);\\n  };\\n  function d3_geo_circleInterpolate(radius, precision) {\\n    var cr = Math.cos(radius), sr = Math.sin(radius);\\n    return function(from, to, direction, listener) {\\n      var step = direction * precision;\\n      if (from != null) {\\n        from = d3_geo_circleAngle(cr, from);\\n        to = d3_geo_circleAngle(cr, to);\\n        if (direction > 0 ? from < to : from > to) from += direction * τ;\\n      } else {\\n        from = radius + direction * τ;\\n        to = radius - .5 * step;\\n      }\\n      for (var point, t = from; direction > 0 ? t > to : t < to; t -= step) {\\n        listener.point((point = d3_geo_spherical([ cr, -sr * Math.cos(t), -sr * Math.sin(t) ]))[0], point[1]);\\n      }\\n    };\\n  }\\n  function d3_geo_circleAngle(cr, point) {\\n    var a = d3_geo_cartesian(point);\\n    a[0] -= cr;\\n    d3_geo_cartesianNormalize(a);\\n    var angle = d3_acos(-a[1]);\\n    return ((-a[2] < 0 ? -angle : angle) + 2 * Math.PI - ε) % (2 * Math.PI);\\n  }\\n  d3.geo.distance = function(a, b) {\\n    var Δλ = (b[0] - a[0]) * d3_radians, φ0 = a[1] * d3_radians, φ1 = b[1] * d3_radians, sinΔλ = Math.sin(Δλ), cosΔλ = Math.cos(Δλ), sinφ0 = Math.sin(φ0), cosφ0 = Math.cos(φ0), sinφ1 = Math.sin(φ1), cosφ1 = Math.cos(φ1), t;\\n    return Math.atan2(Math.sqrt((t = cosφ1 * sinΔλ) * t + (t = cosφ0 * sinφ1 - sinφ0 * cosφ1 * cosΔλ) * t), sinφ0 * sinφ1 + cosφ0 * cosφ1 * cosΔλ);\\n  };\\n  d3.geo.graticule = function() {\\n    var x1, x0, X1, X0, y1, y0, Y1, Y0, dx = 10, dy = dx, DX = 90, DY = 360, x, y, X, Y, precision = 2.5;\\n    function graticule() {\\n      return {\\n        type: \\\"MultiLineString\\\",\\n        coordinates: lines()\\n      };\\n    }\\n    function lines() {\\n      return d3.range(Math.ceil(X0 / DX) * DX, X1, DX).map(X).concat(d3.range(Math.ceil(Y0 / DY) * DY, Y1, DY).map(Y)).concat(d3.range(Math.ceil(x0 / dx) * dx, x1, dx).filter(function(x) {\\n        return abs(x % DX) > ε;\\n      }).map(x)).concat(d3.range(Math.ceil(y0 / dy) * dy, y1, dy).filter(function(y) {\\n        return abs(y % DY) > ε;\\n      }).map(y));\\n    }\\n    graticule.lines = function() {\\n      return lines().map(function(coordinates) {\\n        return {\\n          type: \\\"LineString\\\",\\n          coordinates: coordinates\\n        };\\n      });\\n    };\\n    graticule.outline = function() {\\n      return {\\n        type: \\\"Polygon\\\",\\n        coordinates: [ X(X0).concat(Y(Y1).slice(1), X(X1).reverse().slice(1), Y(Y0).reverse().slice(1)) ]\\n      };\\n    };\\n    graticule.extent = function(_) {\\n      if (!arguments.length) return graticule.minorExtent();\\n      return graticule.majorExtent(_).minorExtent(_);\\n    };\\n    graticule.majorExtent = function(_) {\\n      if (!arguments.length) return [ [ X0, Y0 ], [ X1, Y1 ] ];\\n      X0 = +_[0][0], X1 = +_[1][0];\\n      Y0 = +_[0][1], Y1 = +_[1][1];\\n      if (X0 > X1) _ = X0, X0 = X1, X1 = _;\\n      if (Y0 > Y1) _ = Y0, Y0 = Y1, Y1 = _;\\n      return graticule.precision(precision);\\n    };\\n    graticule.minorExtent = function(_) {\\n      if (!arguments.length) return [ [ x0, y0 ], [ x1, y1 ] ];\\n      x0 = +_[0][0], x1 = +_[1][0];\\n      y0 = +_[0][1], y1 = +_[1][1];\\n      if (x0 > x1) _ = x0, x0 = x1, x1 = _;\\n      if (y0 > y1) _ = y0, y0 = y1, y1 = _;\\n      return graticule.precision(precision);\\n    };\\n    graticule.step = function(_) {\\n      if (!arguments.length) return graticule.minorStep();\\n      return graticule.majorStep(_).minorStep(_);\\n    };\\n    graticule.majorStep = function(_) {\\n      if (!arguments.length) return [ DX, DY ];\\n      DX = +_[0], DY = +_[1];\\n      return graticule;\\n    };\\n    graticule.minorStep = function(_) {\\n      if (!arguments.length) return [ dx, dy ];\\n      dx = +_[0], dy = +_[1];\\n      return graticule;\\n    };\\n    graticule.precision = function(_) {\\n      if (!arguments.length) return precision;\\n      precision = +_;\\n      x = d3_geo_graticuleX(y0, y1, 90);\\n      y = d3_geo_graticuleY(x0, x1, precision);\\n      X = d3_geo_graticuleX(Y0, Y1, 90);\\n      Y = d3_geo_graticuleY(X0, X1, precision);\\n      return graticule;\\n    };\\n    return graticule.majorExtent([ [ -180, -90 + ε ], [ 180, 90 - ε ] ]).minorExtent([ [ -180, -80 - ε ], [ 180, 80 + ε ] ]);\\n  };\\n  function d3_geo_graticuleX(y0, y1, dy) {\\n    var y = d3.range(y0, y1 - ε, dy).concat(y1);\\n    return function(x) {\\n      return y.map(function(y) {\\n        return [ x, y ];\\n      });\\n    };\\n  }\\n  function d3_geo_graticuleY(x0, x1, dx) {\\n    var x = d3.range(x0, x1 - ε, dx).concat(x1);\\n    return function(y) {\\n      return x.map(function(x) {\\n        return [ x, y ];\\n      });\\n    };\\n  }\\n  function d3_source(d) {\\n    return d.source;\\n  }\\n  function d3_target(d) {\\n    return d.target;\\n  }\\n  d3.geo.greatArc = function() {\\n    var source = d3_source, source_, target = d3_target, target_;\\n    function greatArc() {\\n      return {\\n        type: \\\"LineString\\\",\\n        coordinates: [ source_ || source.apply(this, arguments), target_ || target.apply(this, arguments) ]\\n      };\\n    }\\n    greatArc.distance = function() {\\n      return d3.geo.distance(source_ || source.apply(this, arguments), target_ || target.apply(this, arguments));\\n    };\\n    greatArc.source = function(_) {\\n      if (!arguments.length) return source;\\n      source = _, source_ = typeof _ === \\\"function\\\" ? null : _;\\n      return greatArc;\\n    };\\n    greatArc.target = function(_) {\\n      if (!arguments.length) return target;\\n      target = _, target_ = typeof _ === \\\"function\\\" ? null : _;\\n      return greatArc;\\n    };\\n    greatArc.precision = function() {\\n      return arguments.length ? greatArc : 0;\\n    };\\n    return greatArc;\\n  };\\n  d3.geo.interpolate = function(source, target) {\\n    return d3_geo_interpolate(source[0] * d3_radians, source[1] * d3_radians, target[0] * d3_radians, target[1] * d3_radians);\\n  };\\n  function d3_geo_interpolate(x0, y0, x1, y1) {\\n    var cy0 = Math.cos(y0), sy0 = Math.sin(y0), cy1 = Math.cos(y1), sy1 = Math.sin(y1), kx0 = cy0 * Math.cos(x0), ky0 = cy0 * Math.sin(x0), kx1 = cy1 * Math.cos(x1), ky1 = cy1 * Math.sin(x1), d = 2 * Math.asin(Math.sqrt(d3_haversin(y1 - y0) + cy0 * cy1 * d3_haversin(x1 - x0))), k = 1 / Math.sin(d);\\n    var interpolate = d ? function(t) {\\n      var B = Math.sin(t *= d) * k, A = Math.sin(d - t) * k, x = A * kx0 + B * kx1, y = A * ky0 + B * ky1, z = A * sy0 + B * sy1;\\n      return [ Math.atan2(y, x) * d3_degrees, Math.atan2(z, Math.sqrt(x * x + y * y)) * d3_degrees ];\\n    } : function() {\\n      return [ x0 * d3_degrees, y0 * d3_degrees ];\\n    };\\n    interpolate.distance = d;\\n    return interpolate;\\n  }\\n  d3.geo.length = function(object) {\\n    d3_geo_lengthSum = 0;\\n    d3.geo.stream(object, d3_geo_length);\\n    return d3_geo_lengthSum;\\n  };\\n  var d3_geo_lengthSum;\\n  var d3_geo_length = {\\n    sphere: d3_noop,\\n    point: d3_noop,\\n    lineStart: d3_geo_lengthLineStart,\\n    lineEnd: d3_noop,\\n    polygonStart: d3_noop,\\n    polygonEnd: d3_noop\\n  };\\n  function d3_geo_lengthLineStart() {\\n    var λ0, sinφ0, cosφ0;\\n    d3_geo_length.point = function(λ, φ) {\\n      λ0 = λ * d3_radians, sinφ0 = Math.sin(φ *= d3_radians), cosφ0 = Math.cos(φ);\\n      d3_geo_length.point = nextPoint;\\n    };\\n    d3_geo_length.lineEnd = function() {\\n      d3_geo_length.point = d3_geo_length.lineEnd = d3_noop;\\n    };\\n    function nextPoint(λ, φ) {\\n      var sinφ = Math.sin(φ *= d3_radians), cosφ = Math.cos(φ), t = abs((λ *= d3_radians) - λ0), cosΔλ = Math.cos(t);\\n      d3_geo_lengthSum += Math.atan2(Math.sqrt((t = cosφ * Math.sin(t)) * t + (t = cosφ0 * sinφ - sinφ0 * cosφ * cosΔλ) * t), sinφ0 * sinφ + cosφ0 * cosφ * cosΔλ);\\n      λ0 = λ, sinφ0 = sinφ, cosφ0 = cosφ;\\n    }\\n  }\\n  function d3_geo_azimuthal(scale, angle) {\\n    function azimuthal(λ, φ) {\\n      var cosλ = Math.cos(λ), cosφ = Math.cos(φ), k = scale(cosλ * cosφ);\\n      return [ k * cosφ * Math.sin(λ), k * Math.sin(φ) ];\\n    }\\n    azimuthal.invert = function(x, y) {\\n      var ρ = Math.sqrt(x * x + y * y), c = angle(ρ), sinc = Math.sin(c), cosc = Math.cos(c);\\n      return [ Math.atan2(x * sinc, ρ * cosc), Math.asin(ρ && y * sinc / ρ) ];\\n    };\\n    return azimuthal;\\n  }\\n  var d3_geo_azimuthalEqualArea = d3_geo_azimuthal(function(cosλcosφ) {\\n    return Math.sqrt(2 / (1 + cosλcosφ));\\n  }, function(ρ) {\\n    return 2 * Math.asin(ρ / 2);\\n  });\\n  (d3.geo.azimuthalEqualArea = function() {\\n    return d3_geo_projection(d3_geo_azimuthalEqualArea);\\n  }).raw = d3_geo_azimuthalEqualArea;\\n  var d3_geo_azimuthalEquidistant = d3_geo_azimuthal(function(cosλcosφ) {\\n    var c = Math.acos(cosλcosφ);\\n    return c && c / Math.sin(c);\\n  }, d3_identity);\\n  (d3.geo.azimuthalEquidistant = function() {\\n    return d3_geo_projection(d3_geo_azimuthalEquidistant);\\n  }).raw = d3_geo_azimuthalEquidistant;\\n  function d3_geo_conicConformal(φ0, φ1) {\\n    var cosφ0 = Math.cos(φ0), t = function(φ) {\\n      return Math.tan(π / 4 + φ / 2);\\n    }, n = φ0 === φ1 ? Math.sin(φ0) : Math.log(cosφ0 / Math.cos(φ1)) / Math.log(t(φ1) / t(φ0)), F = cosφ0 * Math.pow(t(φ0), n) / n;\\n    if (!n) return d3_geo_mercator;\\n    function forward(λ, φ) {\\n      if (F > 0) {\\n        if (φ < -halfπ + ε) φ = -halfπ + ε;\\n      } else {\\n        if (φ > halfπ - ε) φ = halfπ - ε;\\n      }\\n      var ρ = F / Math.pow(t(φ), n);\\n      return [ ρ * Math.sin(n * λ), F - ρ * Math.cos(n * λ) ];\\n    }\\n    forward.invert = function(x, y) {\\n      var ρ0_y = F - y, ρ = d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y);\\n      return [ Math.atan2(x, ρ0_y) / n, 2 * Math.atan(Math.pow(F / ρ, 1 / n)) - halfπ ];\\n    };\\n    return forward;\\n  }\\n  (d3.geo.conicConformal = function() {\\n    return d3_geo_conic(d3_geo_conicConformal);\\n  }).raw = d3_geo_conicConformal;\\n  function d3_geo_conicEquidistant(φ0, φ1) {\\n    var cosφ0 = Math.cos(φ0), n = φ0 === φ1 ? Math.sin(φ0) : (cosφ0 - Math.cos(φ1)) / (φ1 - φ0), G = cosφ0 / n + φ0;\\n    if (abs(n) < ε) return d3_geo_equirectangular;\\n    function forward(λ, φ) {\\n      var ρ = G - φ;\\n      return [ ρ * Math.sin(n * λ), G - ρ * Math.cos(n * λ) ];\\n    }\\n    forward.invert = function(x, y) {\\n      var ρ0_y = G - y;\\n      return [ Math.atan2(x, ρ0_y) / n, G - d3_sgn(n) * Math.sqrt(x * x + ρ0_y * ρ0_y) ];\\n    };\\n    return forward;\\n  }\\n  (d3.geo.conicEquidistant = function() {\\n    return d3_geo_conic(d3_geo_conicEquidistant);\\n  }).raw = d3_geo_conicEquidistant;\\n  var d3_geo_gnomonic = d3_geo_azimuthal(function(cosλcosφ) {\\n    return 1 / cosλcosφ;\\n  }, Math.atan);\\n  (d3.geo.gnomonic = function() {\\n    return d3_geo_projection(d3_geo_gnomonic);\\n  }).raw = d3_geo_gnomonic;\\n  function d3_geo_mercator(λ, φ) {\\n    return [ λ, Math.log(Math.tan(π / 4 + φ / 2)) ];\\n  }\\n  d3_geo_mercator.invert = function(x, y) {\\n    return [ x, 2 * Math.atan(Math.exp(y)) - halfπ ];\\n  };\\n  function d3_geo_mercatorProjection(project) {\\n    var m = d3_geo_projection(project), scale = m.scale, translate = m.translate, clipExtent = m.clipExtent, clipAuto;\\n    m.scale = function() {\\n      var v = scale.apply(m, arguments);\\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\\n    };\\n    m.translate = function() {\\n      var v = translate.apply(m, arguments);\\n      return v === m ? clipAuto ? m.clipExtent(null) : m : v;\\n    };\\n    m.clipExtent = function(_) {\\n      var v = clipExtent.apply(m, arguments);\\n      if (v === m) {\\n        if (clipAuto = _ == null) {\\n          var k = π * scale(), t = translate();\\n          clipExtent([ [ t[0] - k, t[1] - k ], [ t[0] + k, t[1] + k ] ]);\\n        }\\n      } else if (clipAuto) {\\n        v = null;\\n      }\\n      return v;\\n    };\\n    return m.clipExtent(null);\\n  }\\n  (d3.geo.mercator = function() {\\n    return d3_geo_mercatorProjection(d3_geo_mercator);\\n  }).raw = d3_geo_mercator;\\n  var d3_geo_orthographic = d3_geo_azimuthal(function() {\\n    return 1;\\n  }, Math.asin);\\n  (d3.geo.orthographic = function() {\\n    return d3_geo_projection(d3_geo_orthographic);\\n  }).raw = d3_geo_orthographic;\\n  var d3_geo_stereographic = d3_geo_azimuthal(function(cosλcosφ) {\\n    return 1 / (1 + cosλcosφ);\\n  }, function(ρ) {\\n    return 2 * Math.atan(ρ);\\n  });\\n  (d3.geo.stereographic = function() {\\n    return d3_geo_projection(d3_geo_stereographic);\\n  }).raw = d3_geo_stereographic;\\n  function d3_geo_transverseMercator(λ, φ) {\\n    return [ Math.log(Math.tan(π / 4 + φ / 2)), -λ ];\\n  }\\n  d3_geo_transverseMercator.invert = function(x, y) {\\n    return [ -y, 2 * Math.atan(Math.exp(x)) - halfπ ];\\n  };\\n  (d3.geo.transverseMercator = function() {\\n    var projection = d3_geo_mercatorProjection(d3_geo_transverseMercator), center = projection.center, rotate = projection.rotate;\\n    projection.center = function(_) {\\n      return _ ? center([ -_[1], _[0] ]) : (_ = center(), [ _[1], -_[0] ]);\\n    };\\n    projection.rotate = function(_) {\\n      return _ ? rotate([ _[0], _[1], _.length > 2 ? _[2] + 90 : 90 ]) : (_ = rotate(), \\n      [ _[0], _[1], _[2] - 90 ]);\\n    };\\n    return rotate([ 0, 0, 90 ]);\\n  }).raw = d3_geo_transverseMercator;\\n  d3.geom = {};\\n  function d3_geom_pointX(d) {\\n    return d[0];\\n  }\\n  function d3_geom_pointY(d) {\\n    return d[1];\\n  }\\n  d3.geom.hull = function(vertices) {\\n    var x = d3_geom_pointX, y = d3_geom_pointY;\\n    if (arguments.length) return hull(vertices);\\n    function hull(data) {\\n      if (data.length < 3) return [];\\n      var fx = d3_functor(x), fy = d3_functor(y), i, n = data.length, points = [], flippedPoints = [];\\n      for (i = 0; i < n; i++) {\\n        points.push([ +fx.call(this, data[i], i), +fy.call(this, data[i], i), i ]);\\n      }\\n      points.sort(d3_geom_hullOrder);\\n      for (i = 0; i < n; i++) flippedPoints.push([ points[i][0], -points[i][1] ]);\\n      var upper = d3_geom_hullUpper(points), lower = d3_geom_hullUpper(flippedPoints);\\n      var skipLeft = lower[0] === upper[0], skipRight = lower[lower.length - 1] === upper[upper.length - 1], polygon = [];\\n      for (i = upper.length - 1; i >= 0; --i) polygon.push(data[points[upper[i]][2]]);\\n      for (i = +skipLeft; i < lower.length - skipRight; ++i) polygon.push(data[points[lower[i]][2]]);\\n      return polygon;\\n    }\\n    hull.x = function(_) {\\n      return arguments.length ? (x = _, hull) : x;\\n    };\\n    hull.y = function(_) {\\n      return arguments.length ? (y = _, hull) : y;\\n    };\\n    return hull;\\n  };\\n  function d3_geom_hullUpper(points) {\\n    var n = points.length, hull = [ 0, 1 ], hs = 2;\\n    for (var i = 2; i < n; i++) {\\n      while (hs > 1 && d3_cross2d(points[hull[hs - 2]], points[hull[hs - 1]], points[i]) <= 0) --hs;\\n      hull[hs++] = i;\\n    }\\n    return hull.slice(0, hs);\\n  }\\n  function d3_geom_hullOrder(a, b) {\\n    return a[0] - b[0] || a[1] - b[1];\\n  }\\n  d3.geom.polygon = function(coordinates) {\\n    d3_subclass(coordinates, d3_geom_polygonPrototype);\\n    return coordinates;\\n  };\\n  var d3_geom_polygonPrototype = d3.geom.polygon.prototype = [];\\n  d3_geom_polygonPrototype.area = function() {\\n    var i = -1, n = this.length, a, b = this[n - 1], area = 0;\\n    while (++i < n) {\\n      a = b;\\n      b = this[i];\\n      area += a[1] * b[0] - a[0] * b[1];\\n    }\\n    return area * .5;\\n  };\\n  d3_geom_polygonPrototype.centroid = function(k) {\\n    var i = -1, n = this.length, x = 0, y = 0, a, b = this[n - 1], c;\\n    if (!arguments.length) k = -1 / (6 * this.area());\\n    while (++i < n) {\\n      a = b;\\n      b = this[i];\\n      c = a[0] * b[1] - b[0] * a[1];\\n      x += (a[0] + b[0]) * c;\\n      y += (a[1] + b[1]) * c;\\n    }\\n    return [ x * k, y * k ];\\n  };\\n  d3_geom_polygonPrototype.clip = function(subject) {\\n    var input, closed = d3_geom_polygonClosed(subject), i = -1, n = this.length - d3_geom_polygonClosed(this), j, m, a = this[n - 1], b, c, d;\\n    while (++i < n) {\\n      input = subject.slice();\\n      subject.length = 0;\\n      b = this[i];\\n      c = input[(m = input.length - closed) - 1];\\n      j = -1;\\n      while (++j < m) {\\n        d = input[j];\\n        if (d3_geom_polygonInside(d, a, b)) {\\n          if (!d3_geom_polygonInside(c, a, b)) {\\n            subject.push(d3_geom_polygonIntersect(c, d, a, b));\\n          }\\n          subject.push(d);\\n        } else if (d3_geom_polygonInside(c, a, b)) {\\n          subject.push(d3_geom_polygonIntersect(c, d, a, b));\\n        }\\n        c = d;\\n      }\\n      if (closed) subject.push(subject[0]);\\n      a = b;\\n    }\\n    return subject;\\n  };\\n  function d3_geom_polygonInside(p, a, b) {\\n    return (b[0] - a[0]) * (p[1] - a[1]) < (b[1] - a[1]) * (p[0] - a[0]);\\n  }\\n  function d3_geom_polygonIntersect(c, d, a, b) {\\n    var x1 = c[0], x3 = a[0], x21 = d[0] - x1, x43 = b[0] - x3, y1 = c[1], y3 = a[1], y21 = d[1] - y1, y43 = b[1] - y3, ua = (x43 * (y1 - y3) - y43 * (x1 - x3)) / (y43 * x21 - x43 * y21);\\n    return [ x1 + ua * x21, y1 + ua * y21 ];\\n  }\\n  function d3_geom_polygonClosed(coordinates) {\\n    var a = coordinates[0], b = coordinates[coordinates.length - 1];\\n    return !(a[0] - b[0] || a[1] - b[1]);\\n  }\\n  var d3_geom_voronoiEdges, d3_geom_voronoiCells, d3_geom_voronoiBeaches, d3_geom_voronoiBeachPool = [], d3_geom_voronoiFirstCircle, d3_geom_voronoiCircles, d3_geom_voronoiCirclePool = [];\\n  function d3_geom_voronoiBeach() {\\n    d3_geom_voronoiRedBlackNode(this);\\n    this.edge = this.site = this.circle = null;\\n  }\\n  function d3_geom_voronoiCreateBeach(site) {\\n    var beach = d3_geom_voronoiBeachPool.pop() || new d3_geom_voronoiBeach();\\n    beach.site = site;\\n    return beach;\\n  }\\n  function d3_geom_voronoiDetachBeach(beach) {\\n    d3_geom_voronoiDetachCircle(beach);\\n    d3_geom_voronoiBeaches.remove(beach);\\n    d3_geom_voronoiBeachPool.push(beach);\\n    d3_geom_voronoiRedBlackNode(beach);\\n  }\\n  function d3_geom_voronoiRemoveBeach(beach) {\\n    var circle = beach.circle, x = circle.x, y = circle.cy, vertex = {\\n      x: x,\\n      y: y\\n    }, previous = beach.P, next = beach.N, disappearing = [ beach ];\\n    d3_geom_voronoiDetachBeach(beach);\\n    var lArc = previous;\\n    while (lArc.circle && abs(x - lArc.circle.x) < ε && abs(y - lArc.circle.cy) < ε) {\\n      previous = lArc.P;\\n      disappearing.unshift(lArc);\\n      d3_geom_voronoiDetachBeach(lArc);\\n      lArc = previous;\\n    }\\n    disappearing.unshift(lArc);\\n    d3_geom_voronoiDetachCircle(lArc);\\n    var rArc = next;\\n    while (rArc.circle && abs(x - rArc.circle.x) < ε && abs(y - rArc.circle.cy) < ε) {\\n      next = rArc.N;\\n      disappearing.push(rArc);\\n      d3_geom_voronoiDetachBeach(rArc);\\n      rArc = next;\\n    }\\n    disappearing.push(rArc);\\n    d3_geom_voronoiDetachCircle(rArc);\\n    var nArcs = disappearing.length, iArc;\\n    for (iArc = 1; iArc < nArcs; ++iArc) {\\n      rArc = disappearing[iArc];\\n      lArc = disappearing[iArc - 1];\\n      d3_geom_voronoiSetEdgeEnd(rArc.edge, lArc.site, rArc.site, vertex);\\n    }\\n    lArc = disappearing[0];\\n    rArc = disappearing[nArcs - 1];\\n    rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, rArc.site, null, vertex);\\n    d3_geom_voronoiAttachCircle(lArc);\\n    d3_geom_voronoiAttachCircle(rArc);\\n  }\\n  function d3_geom_voronoiAddBeach(site) {\\n    var x = site.x, directrix = site.y, lArc, rArc, dxl, dxr, node = d3_geom_voronoiBeaches._;\\n    while (node) {\\n      dxl = d3_geom_voronoiLeftBreakPoint(node, directrix) - x;\\n      if (dxl > ε) node = node.L; else {\\n        dxr = x - d3_geom_voronoiRightBreakPoint(node, directrix);\\n        if (dxr > ε) {\\n          if (!node.R) {\\n            lArc = node;\\n            break;\\n          }\\n          node = node.R;\\n        } else {\\n          if (dxl > -ε) {\\n            lArc = node.P;\\n            rArc = node;\\n          } else if (dxr > -ε) {\\n            lArc = node;\\n            rArc = node.N;\\n          } else {\\n            lArc = rArc = node;\\n          }\\n          break;\\n        }\\n      }\\n    }\\n    var newArc = d3_geom_voronoiCreateBeach(site);\\n    d3_geom_voronoiBeaches.insert(lArc, newArc);\\n    if (!lArc && !rArc) return;\\n    if (lArc === rArc) {\\n      d3_geom_voronoiDetachCircle(lArc);\\n      rArc = d3_geom_voronoiCreateBeach(lArc.site);\\n      d3_geom_voronoiBeaches.insert(newArc, rArc);\\n      newArc.edge = rArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\\n      d3_geom_voronoiAttachCircle(lArc);\\n      d3_geom_voronoiAttachCircle(rArc);\\n      return;\\n    }\\n    if (!rArc) {\\n      newArc.edge = d3_geom_voronoiCreateEdge(lArc.site, newArc.site);\\n      return;\\n    }\\n    d3_geom_voronoiDetachCircle(lArc);\\n    d3_geom_voronoiDetachCircle(rArc);\\n    var lSite = lArc.site, ax = lSite.x, ay = lSite.y, bx = site.x - ax, by = site.y - ay, rSite = rArc.site, cx = rSite.x - ax, cy = rSite.y - ay, d = 2 * (bx * cy - by * cx), hb = bx * bx + by * by, hc = cx * cx + cy * cy, vertex = {\\n      x: (cy * hb - by * hc) / d + ax,\\n      y: (bx * hc - cx * hb) / d + ay\\n    };\\n    d3_geom_voronoiSetEdgeEnd(rArc.edge, lSite, rSite, vertex);\\n    newArc.edge = d3_geom_voronoiCreateEdge(lSite, site, null, vertex);\\n    rArc.edge = d3_geom_voronoiCreateEdge(site, rSite, null, vertex);\\n    d3_geom_voronoiAttachCircle(lArc);\\n    d3_geom_voronoiAttachCircle(rArc);\\n  }\\n  function d3_geom_voronoiLeftBreakPoint(arc, directrix) {\\n    var site = arc.site, rfocx = site.x, rfocy = site.y, pby2 = rfocy - directrix;\\n    if (!pby2) return rfocx;\\n    var lArc = arc.P;\\n    if (!lArc) return -Infinity;\\n    site = lArc.site;\\n    var lfocx = site.x, lfocy = site.y, plby2 = lfocy - directrix;\\n    if (!plby2) return lfocx;\\n    var hl = lfocx - rfocx, aby2 = 1 / pby2 - 1 / plby2, b = hl / plby2;\\n    if (aby2) return (-b + Math.sqrt(b * b - 2 * aby2 * (hl * hl / (-2 * plby2) - lfocy + plby2 / 2 + rfocy - pby2 / 2))) / aby2 + rfocx;\\n    return (rfocx + lfocx) / 2;\\n  }\\n  function d3_geom_voronoiRightBreakPoint(arc, directrix) {\\n    var rArc = arc.N;\\n    if (rArc) return d3_geom_voronoiLeftBreakPoint(rArc, directrix);\\n    var site = arc.site;\\n    return site.y === directrix ? site.x : Infinity;\\n  }\\n  function d3_geom_voronoiCell(site) {\\n    this.site = site;\\n    this.edges = [];\\n  }\\n  d3_geom_voronoiCell.prototype.prepare = function() {\\n    var halfEdges = this.edges, iHalfEdge = halfEdges.length, edge;\\n    while (iHalfEdge--) {\\n      edge = halfEdges[iHalfEdge].edge;\\n      if (!edge.b || !edge.a) halfEdges.splice(iHalfEdge, 1);\\n    }\\n    halfEdges.sort(d3_geom_voronoiHalfEdgeOrder);\\n    return halfEdges.length;\\n  };\\n  function d3_geom_voronoiCloseCells(extent) {\\n    var x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], x2, y2, x3, y3, cells = d3_geom_voronoiCells, iCell = cells.length, cell, iHalfEdge, halfEdges, nHalfEdges, start, end;\\n    while (iCell--) {\\n      cell = cells[iCell];\\n      if (!cell || !cell.prepare()) continue;\\n      halfEdges = cell.edges;\\n      nHalfEdges = halfEdges.length;\\n      iHalfEdge = 0;\\n      while (iHalfEdge < nHalfEdges) {\\n        end = halfEdges[iHalfEdge].end(), x3 = end.x, y3 = end.y;\\n        start = halfEdges[++iHalfEdge % nHalfEdges].start(), x2 = start.x, y2 = start.y;\\n        if (abs(x3 - x2) > ε || abs(y3 - y2) > ε) {\\n          halfEdges.splice(iHalfEdge, 0, new d3_geom_voronoiHalfEdge(d3_geom_voronoiCreateBorderEdge(cell.site, end, abs(x3 - x0) < ε && y1 - y3 > ε ? {\\n            x: x0,\\n            y: abs(x2 - x0) < ε ? y2 : y1\\n          } : abs(y3 - y1) < ε && x1 - x3 > ε ? {\\n            x: abs(y2 - y1) < ε ? x2 : x1,\\n            y: y1\\n          } : abs(x3 - x1) < ε && y3 - y0 > ε ? {\\n            x: x1,\\n            y: abs(x2 - x1) < ε ? y2 : y0\\n          } : abs(y3 - y0) < ε && x3 - x0 > ε ? {\\n            x: abs(y2 - y0) < ε ? x2 : x0,\\n            y: y0\\n          } : null), cell.site, null));\\n          ++nHalfEdges;\\n        }\\n      }\\n    }\\n  }\\n  function d3_geom_voronoiHalfEdgeOrder(a, b) {\\n    return b.angle - a.angle;\\n  }\\n  function d3_geom_voronoiCircle() {\\n    d3_geom_voronoiRedBlackNode(this);\\n    this.x = this.y = this.arc = this.site = this.cy = null;\\n  }\\n  function d3_geom_voronoiAttachCircle(arc) {\\n    var lArc = arc.P, rArc = arc.N;\\n    if (!lArc || !rArc) return;\\n    var lSite = lArc.site, cSite = arc.site, rSite = rArc.site;\\n    if (lSite === rSite) return;\\n    var bx = cSite.x, by = cSite.y, ax = lSite.x - bx, ay = lSite.y - by, cx = rSite.x - bx, cy = rSite.y - by;\\n    var d = 2 * (ax * cy - ay * cx);\\n    if (d >= -ε2) return;\\n    var ha = ax * ax + ay * ay, hc = cx * cx + cy * cy, x = (cy * ha - ay * hc) / d, y = (ax * hc - cx * ha) / d, cy = y + by;\\n    var circle = d3_geom_voronoiCirclePool.pop() || new d3_geom_voronoiCircle();\\n    circle.arc = arc;\\n    circle.site = cSite;\\n    circle.x = x + bx;\\n    circle.y = cy + Math.sqrt(x * x + y * y);\\n    circle.cy = cy;\\n    arc.circle = circle;\\n    var before = null, node = d3_geom_voronoiCircles._;\\n    while (node) {\\n      if (circle.y < node.y || circle.y === node.y && circle.x <= node.x) {\\n        if (node.L) node = node.L; else {\\n          before = node.P;\\n          break;\\n        }\\n      } else {\\n        if (node.R) node = node.R; else {\\n          before = node;\\n          break;\\n        }\\n      }\\n    }\\n    d3_geom_voronoiCircles.insert(before, circle);\\n    if (!before) d3_geom_voronoiFirstCircle = circle;\\n  }\\n  function d3_geom_voronoiDetachCircle(arc) {\\n    var circle = arc.circle;\\n    if (circle) {\\n      if (!circle.P) d3_geom_voronoiFirstCircle = circle.N;\\n      d3_geom_voronoiCircles.remove(circle);\\n      d3_geom_voronoiCirclePool.push(circle);\\n      d3_geom_voronoiRedBlackNode(circle);\\n      arc.circle = null;\\n    }\\n  }\\n  function d3_geom_voronoiClipEdges(extent) {\\n    var edges = d3_geom_voronoiEdges, clip = d3_geom_clipLine(extent[0][0], extent[0][1], extent[1][0], extent[1][1]), i = edges.length, e;\\n    while (i--) {\\n      e = edges[i];\\n      if (!d3_geom_voronoiConnectEdge(e, extent) || !clip(e) || abs(e.a.x - e.b.x) < ε && abs(e.a.y - e.b.y) < ε) {\\n        e.a = e.b = null;\\n        edges.splice(i, 1);\\n      }\\n    }\\n  }\\n  function d3_geom_voronoiConnectEdge(edge, extent) {\\n    var vb = edge.b;\\n    if (vb) return true;\\n    var va = edge.a, x0 = extent[0][0], x1 = extent[1][0], y0 = extent[0][1], y1 = extent[1][1], lSite = edge.l, rSite = edge.r, lx = lSite.x, ly = lSite.y, rx = rSite.x, ry = rSite.y, fx = (lx + rx) / 2, fy = (ly + ry) / 2, fm, fb;\\n    if (ry === ly) {\\n      if (fx < x0 || fx >= x1) return;\\n      if (lx > rx) {\\n        if (!va) va = {\\n          x: fx,\\n          y: y0\\n        }; else if (va.y >= y1) return;\\n        vb = {\\n          x: fx,\\n          y: y1\\n        };\\n      } else {\\n        if (!va) va = {\\n          x: fx,\\n          y: y1\\n        }; else if (va.y < y0) return;\\n        vb = {\\n          x: fx,\\n          y: y0\\n        };\\n      }\\n    } else {\\n      fm = (lx - rx) / (ry - ly);\\n      fb = fy - fm * fx;\\n      if (fm < -1 || fm > 1) {\\n        if (lx > rx) {\\n          if (!va) va = {\\n            x: (y0 - fb) / fm,\\n            y: y0\\n          }; else if (va.y >= y1) return;\\n          vb = {\\n            x: (y1 - fb) / fm,\\n            y: y1\\n          };\\n        } else {\\n          if (!va) va = {\\n            x: (y1 - fb) / fm,\\n            y: y1\\n          }; else if (va.y < y0) return;\\n          vb = {\\n            x: (y0 - fb) / fm,\\n            y: y0\\n          };\\n        }\\n      } else {\\n        if (ly < ry) {\\n          if (!va) va = {\\n            x: x0,\\n            y: fm * x0 + fb\\n          }; else if (va.x >= x1) return;\\n          vb = {\\n            x: x1,\\n            y: fm * x1 + fb\\n          };\\n        } else {\\n          if (!va) va = {\\n            x: x1,\\n            y: fm * x1 + fb\\n          }; else if (va.x < x0) return;\\n          vb = {\\n            x: x0,\\n            y: fm * x0 + fb\\n          };\\n        }\\n      }\\n    }\\n    edge.a = va;\\n    edge.b = vb;\\n    return true;\\n  }\\n  function d3_geom_voronoiEdge(lSite, rSite) {\\n    this.l = lSite;\\n    this.r = rSite;\\n    this.a = this.b = null;\\n  }\\n  function d3_geom_voronoiCreateEdge(lSite, rSite, va, vb) {\\n    var edge = new d3_geom_voronoiEdge(lSite, rSite);\\n    d3_geom_voronoiEdges.push(edge);\\n    if (va) d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, va);\\n    if (vb) d3_geom_voronoiSetEdgeEnd(edge, rSite, lSite, vb);\\n    d3_geom_voronoiCells[lSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, lSite, rSite));\\n    d3_geom_voronoiCells[rSite.i].edges.push(new d3_geom_voronoiHalfEdge(edge, rSite, lSite));\\n    return edge;\\n  }\\n  function d3_geom_voronoiCreateBorderEdge(lSite, va, vb) {\\n    var edge = new d3_geom_voronoiEdge(lSite, null);\\n    edge.a = va;\\n    edge.b = vb;\\n    d3_geom_voronoiEdges.push(edge);\\n    return edge;\\n  }\\n  function d3_geom_voronoiSetEdgeEnd(edge, lSite, rSite, vertex) {\\n    if (!edge.a && !edge.b) {\\n      edge.a = vertex;\\n      edge.l = lSite;\\n      edge.r = rSite;\\n    } else if (edge.l === rSite) {\\n      edge.b = vertex;\\n    } else {\\n      edge.a = vertex;\\n    }\\n  }\\n  function d3_geom_voronoiHalfEdge(edge, lSite, rSite) {\\n    var va = edge.a, vb = edge.b;\\n    this.edge = edge;\\n    this.site = lSite;\\n    this.angle = rSite ? Math.atan2(rSite.y - lSite.y, rSite.x - lSite.x) : edge.l === lSite ? Math.atan2(vb.x - va.x, va.y - vb.y) : Math.atan2(va.x - vb.x, vb.y - va.y);\\n  }\\n  d3_geom_voronoiHalfEdge.prototype = {\\n    start: function() {\\n      return this.edge.l === this.site ? this.edge.a : this.edge.b;\\n    },\\n    end: function() {\\n      return this.edge.l === this.site ? this.edge.b : this.edge.a;\\n    }\\n  };\\n  function d3_geom_voronoiRedBlackTree() {\\n    this._ = null;\\n  }\\n  function d3_geom_voronoiRedBlackNode(node) {\\n    node.U = node.C = node.L = node.R = node.P = node.N = null;\\n  }\\n  d3_geom_voronoiRedBlackTree.prototype = {\\n    insert: function(after, node) {\\n      var parent, grandpa, uncle;\\n      if (after) {\\n        node.P = after;\\n        node.N = after.N;\\n        if (after.N) after.N.P = node;\\n        after.N = node;\\n        if (after.R) {\\n          after = after.R;\\n          while (after.L) after = after.L;\\n          after.L = node;\\n        } else {\\n          after.R = node;\\n        }\\n        parent = after;\\n      } else if (this._) {\\n        after = d3_geom_voronoiRedBlackFirst(this._);\\n        node.P = null;\\n        node.N = after;\\n        after.P = after.L = node;\\n        parent = after;\\n      } else {\\n        node.P = node.N = null;\\n        this._ = node;\\n        parent = null;\\n      }\\n      node.L = node.R = null;\\n      node.U = parent;\\n      node.C = true;\\n      after = node;\\n      while (parent && parent.C) {\\n        grandpa = parent.U;\\n        if (parent === grandpa.L) {\\n          uncle = grandpa.R;\\n          if (uncle && uncle.C) {\\n            parent.C = uncle.C = false;\\n            grandpa.C = true;\\n            after = grandpa;\\n          } else {\\n            if (after === parent.R) {\\n              d3_geom_voronoiRedBlackRotateLeft(this, parent);\\n              after = parent;\\n              parent = after.U;\\n            }\\n            parent.C = false;\\n            grandpa.C = true;\\n            d3_geom_voronoiRedBlackRotateRight(this, grandpa);\\n          }\\n        } else {\\n          uncle = grandpa.L;\\n          if (uncle && uncle.C) {\\n            parent.C = uncle.C = false;\\n            grandpa.C = true;\\n            after = grandpa;\\n          } else {\\n            if (after === parent.L) {\\n              d3_geom_voronoiRedBlackRotateRight(this, parent);\\n              after = parent;\\n              parent = after.U;\\n            }\\n            parent.C = false;\\n            grandpa.C = true;\\n            d3_geom_voronoiRedBlackRotateLeft(this, grandpa);\\n          }\\n        }\\n        parent = after.U;\\n      }\\n      this._.C = false;\\n    },\\n    remove: function(node) {\\n      if (node.N) node.N.P = node.P;\\n      if (node.P) node.P.N = node.N;\\n      node.N = node.P = null;\\n      var parent = node.U, sibling, left = node.L, right = node.R, next, red;\\n      if (!left) next = right; else if (!right) next = left; else next = d3_geom_voronoiRedBlackFirst(right);\\n      if (parent) {\\n        if (parent.L === node) parent.L = next; else parent.R = next;\\n      } else {\\n        this._ = next;\\n      }\\n      if (left && right) {\\n        red = next.C;\\n        next.C = node.C;\\n        next.L = left;\\n        left.U = next;\\n        if (next !== right) {\\n          parent = next.U;\\n          next.U = node.U;\\n          node = next.R;\\n          parent.L = node;\\n          next.R = right;\\n          right.U = next;\\n        } else {\\n          next.U = parent;\\n          parent = next;\\n          node = next.R;\\n        }\\n      } else {\\n        red = node.C;\\n        node = next;\\n      }\\n      if (node) node.U = parent;\\n      if (red) return;\\n      if (node && node.C) {\\n        node.C = false;\\n        return;\\n      }\\n      do {\\n        if (node === this._) break;\\n        if (node === parent.L) {\\n          sibling = parent.R;\\n          if (sibling.C) {\\n            sibling.C = false;\\n            parent.C = true;\\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\\n            sibling = parent.R;\\n          }\\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\\n            if (!sibling.R || !sibling.R.C) {\\n              sibling.L.C = false;\\n              sibling.C = true;\\n              d3_geom_voronoiRedBlackRotateRight(this, sibling);\\n              sibling = parent.R;\\n            }\\n            sibling.C = parent.C;\\n            parent.C = sibling.R.C = false;\\n            d3_geom_voronoiRedBlackRotateLeft(this, parent);\\n            node = this._;\\n            break;\\n          }\\n        } else {\\n          sibling = parent.L;\\n          if (sibling.C) {\\n            sibling.C = false;\\n            parent.C = true;\\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\\n            sibling = parent.L;\\n          }\\n          if (sibling.L && sibling.L.C || sibling.R && sibling.R.C) {\\n            if (!sibling.L || !sibling.L.C) {\\n              sibling.R.C = false;\\n              sibling.C = true;\\n              d3_geom_voronoiRedBlackRotateLeft(this, sibling);\\n              sibling = parent.L;\\n            }\\n            sibling.C = parent.C;\\n            parent.C = sibling.L.C = false;\\n            d3_geom_voronoiRedBlackRotateRight(this, parent);\\n            node = this._;\\n            break;\\n          }\\n        }\\n        sibling.C = true;\\n        node = parent;\\n        parent = parent.U;\\n      } while (!node.C);\\n      if (node) node.C = false;\\n    }\\n  };\\n  function d3_geom_voronoiRedBlackRotateLeft(tree, node) {\\n    var p = node, q = node.R, parent = p.U;\\n    if (parent) {\\n      if (parent.L === p) parent.L = q; else parent.R = q;\\n    } else {\\n      tree._ = q;\\n    }\\n    q.U = parent;\\n    p.U = q;\\n    p.R = q.L;\\n    if (p.R) p.R.U = p;\\n    q.L = p;\\n  }\\n  function d3_geom_voronoiRedBlackRotateRight(tree, node) {\\n    var p = node, q = node.L, parent = p.U;\\n    if (parent) {\\n      if (parent.L === p) parent.L = q; else parent.R = q;\\n    } else {\\n      tree._ = q;\\n    }\\n    q.U = parent;\\n    p.U = q;\\n    p.L = q.R;\\n    if (p.L) p.L.U = p;\\n    q.R = p;\\n  }\\n  function d3_geom_voronoiRedBlackFirst(node) {\\n    while (node.L) node = node.L;\\n    return node;\\n  }\\n  function d3_geom_voronoi(sites, bbox) {\\n    var site = sites.sort(d3_geom_voronoiVertexOrder).pop(), x0, y0, circle;\\n    d3_geom_voronoiEdges = [];\\n    d3_geom_voronoiCells = new Array(sites.length);\\n    d3_geom_voronoiBeaches = new d3_geom_voronoiRedBlackTree();\\n    d3_geom_voronoiCircles = new d3_geom_voronoiRedBlackTree();\\n    while (true) {\\n      circle = d3_geom_voronoiFirstCircle;\\n      if (site && (!circle || site.y < circle.y || site.y === circle.y && site.x < circle.x)) {\\n        if (site.x !== x0 || site.y !== y0) {\\n          d3_geom_voronoiCells[site.i] = new d3_geom_voronoiCell(site);\\n          d3_geom_voronoiAddBeach(site);\\n          x0 = site.x, y0 = site.y;\\n        }\\n        site = sites.pop();\\n      } else if (circle) {\\n        d3_geom_voronoiRemoveBeach(circle.arc);\\n      } else {\\n        break;\\n      }\\n    }\\n    if (bbox) d3_geom_voronoiClipEdges(bbox), d3_geom_voronoiCloseCells(bbox);\\n    var diagram = {\\n      cells: d3_geom_voronoiCells,\\n      edges: d3_geom_voronoiEdges\\n    };\\n    d3_geom_voronoiBeaches = d3_geom_voronoiCircles = d3_geom_voronoiEdges = d3_geom_voronoiCells = null;\\n    return diagram;\\n  }\\n  function d3_geom_voronoiVertexOrder(a, b) {\\n    return b.y - a.y || b.x - a.x;\\n  }\\n  d3.geom.voronoi = function(points) {\\n    var x = d3_geom_pointX, y = d3_geom_pointY, fx = x, fy = y, clipExtent = d3_geom_voronoiClipExtent;\\n    if (points) return voronoi(points);\\n    function voronoi(data) {\\n      var polygons = new Array(data.length), x0 = clipExtent[0][0], y0 = clipExtent[0][1], x1 = clipExtent[1][0], y1 = clipExtent[1][1];\\n      d3_geom_voronoi(sites(data), clipExtent).cells.forEach(function(cell, i) {\\n        var edges = cell.edges, site = cell.site, polygon = polygons[i] = edges.length ? edges.map(function(e) {\\n          var s = e.start();\\n          return [ s.x, s.y ];\\n        }) : site.x >= x0 && site.x <= x1 && site.y >= y0 && site.y <= y1 ? [ [ x0, y1 ], [ x1, y1 ], [ x1, y0 ], [ x0, y0 ] ] : [];\\n        polygon.point = data[i];\\n      });\\n      return polygons;\\n    }\\n    function sites(data) {\\n      return data.map(function(d, i) {\\n        return {\\n          x: Math.round(fx(d, i) / ε) * ε,\\n          y: Math.round(fy(d, i) / ε) * ε,\\n          i: i\\n        };\\n      });\\n    }\\n    voronoi.links = function(data) {\\n      return d3_geom_voronoi(sites(data)).edges.filter(function(edge) {\\n        return edge.l && edge.r;\\n      }).map(function(edge) {\\n        return {\\n          source: data[edge.l.i],\\n          target: data[edge.r.i]\\n        };\\n      });\\n    };\\n    voronoi.triangles = function(data) {\\n      var triangles = [];\\n      d3_geom_voronoi(sites(data)).cells.forEach(function(cell, i) {\\n        var site = cell.site, edges = cell.edges.sort(d3_geom_voronoiHalfEdgeOrder), j = -1, m = edges.length, e0, s0, e1 = edges[m - 1].edge, s1 = e1.l === site ? e1.r : e1.l;\\n        while (++j < m) {\\n          e0 = e1;\\n          s0 = s1;\\n          e1 = edges[j].edge;\\n          s1 = e1.l === site ? e1.r : e1.l;\\n          if (i < s0.i && i < s1.i && d3_geom_voronoiTriangleArea(site, s0, s1) < 0) {\\n            triangles.push([ data[i], data[s0.i], data[s1.i] ]);\\n          }\\n        }\\n      });\\n      return triangles;\\n    };\\n    voronoi.x = function(_) {\\n      return arguments.length ? (fx = d3_functor(x = _), voronoi) : x;\\n    };\\n    voronoi.y = function(_) {\\n      return arguments.length ? (fy = d3_functor(y = _), voronoi) : y;\\n    };\\n    voronoi.clipExtent = function(_) {\\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent;\\n      clipExtent = _ == null ? d3_geom_voronoiClipExtent : _;\\n      return voronoi;\\n    };\\n    voronoi.size = function(_) {\\n      if (!arguments.length) return clipExtent === d3_geom_voronoiClipExtent ? null : clipExtent && clipExtent[1];\\n      return voronoi.clipExtent(_ && [ [ 0, 0 ], _ ]);\\n    };\\n    return voronoi;\\n  };\\n  var d3_geom_voronoiClipExtent = [ [ -1e6, -1e6 ], [ 1e6, 1e6 ] ];\\n  function d3_geom_voronoiTriangleArea(a, b, c) {\\n    return (a.x - c.x) * (b.y - a.y) - (a.x - b.x) * (c.y - a.y);\\n  }\\n  d3.geom.delaunay = function(vertices) {\\n    return d3.geom.voronoi().triangles(vertices);\\n  };\\n  d3.geom.quadtree = function(points, x1, y1, x2, y2) {\\n    var x = d3_geom_pointX, y = d3_geom_pointY, compat;\\n    if (compat = arguments.length) {\\n      x = d3_geom_quadtreeCompatX;\\n      y = d3_geom_quadtreeCompatY;\\n      if (compat === 3) {\\n        y2 = y1;\\n        x2 = x1;\\n        y1 = x1 = 0;\\n      }\\n      return quadtree(points);\\n    }\\n    function quadtree(data) {\\n      var d, fx = d3_functor(x), fy = d3_functor(y), xs, ys, i, n, x1_, y1_, x2_, y2_;\\n      if (x1 != null) {\\n        x1_ = x1, y1_ = y1, x2_ = x2, y2_ = y2;\\n      } else {\\n        x2_ = y2_ = -(x1_ = y1_ = Infinity);\\n        xs = [], ys = [];\\n        n = data.length;\\n        if (compat) for (i = 0; i < n; ++i) {\\n          d = data[i];\\n          if (d.x < x1_) x1_ = d.x;\\n          if (d.y < y1_) y1_ = d.y;\\n          if (d.x > x2_) x2_ = d.x;\\n          if (d.y > y2_) y2_ = d.y;\\n          xs.push(d.x);\\n          ys.push(d.y);\\n        } else for (i = 0; i < n; ++i) {\\n          var x_ = +fx(d = data[i], i), y_ = +fy(d, i);\\n          if (x_ < x1_) x1_ = x_;\\n          if (y_ < y1_) y1_ = y_;\\n          if (x_ > x2_) x2_ = x_;\\n          if (y_ > y2_) y2_ = y_;\\n          xs.push(x_);\\n          ys.push(y_);\\n        }\\n      }\\n      var dx = x2_ - x1_, dy = y2_ - y1_;\\n      if (dx > dy) y2_ = y1_ + dx; else x2_ = x1_ + dy;\\n      function insert(n, d, x, y, x1, y1, x2, y2) {\\n        if (isNaN(x) || isNaN(y)) return;\\n        if (n.leaf) {\\n          var nx = n.x, ny = n.y;\\n          if (nx != null) {\\n            if (abs(nx - x) + abs(ny - y) < .01) {\\n              insertChild(n, d, x, y, x1, y1, x2, y2);\\n            } else {\\n              var nPoint = n.point;\\n              n.x = n.y = n.point = null;\\n              insertChild(n, nPoint, nx, ny, x1, y1, x2, y2);\\n              insertChild(n, d, x, y, x1, y1, x2, y2);\\n            }\\n          } else {\\n            n.x = x, n.y = y, n.point = d;\\n          }\\n        } else {\\n          insertChild(n, d, x, y, x1, y1, x2, y2);\\n        }\\n      }\\n      function insertChild(n, d, x, y, x1, y1, x2, y2) {\\n        var xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym, i = below << 1 | right;\\n        n.leaf = false;\\n        n = n.nodes[i] || (n.nodes[i] = d3_geom_quadtreeNode());\\n        if (right) x1 = xm; else x2 = xm;\\n        if (below) y1 = ym; else y2 = ym;\\n        insert(n, d, x, y, x1, y1, x2, y2);\\n      }\\n      var root = d3_geom_quadtreeNode();\\n      root.add = function(d) {\\n        insert(root, d, +fx(d, ++i), +fy(d, i), x1_, y1_, x2_, y2_);\\n      };\\n      root.visit = function(f) {\\n        d3_geom_quadtreeVisit(f, root, x1_, y1_, x2_, y2_);\\n      };\\n      root.find = function(point) {\\n        return d3_geom_quadtreeFind(root, point[0], point[1], x1_, y1_, x2_, y2_);\\n      };\\n      i = -1;\\n      if (x1 == null) {\\n        while (++i < n) {\\n          insert(root, data[i], xs[i], ys[i], x1_, y1_, x2_, y2_);\\n        }\\n        --i;\\n      } else data.forEach(root.add);\\n      xs = ys = data = d = null;\\n      return root;\\n    }\\n    quadtree.x = function(_) {\\n      return arguments.length ? (x = _, quadtree) : x;\\n    };\\n    quadtree.y = function(_) {\\n      return arguments.length ? (y = _, quadtree) : y;\\n    };\\n    quadtree.extent = function(_) {\\n      if (!arguments.length) return x1 == null ? null : [ [ x1, y1 ], [ x2, y2 ] ];\\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = +_[0][0], y1 = +_[0][1], x2 = +_[1][0], \\n      y2 = +_[1][1];\\n      return quadtree;\\n    };\\n    quadtree.size = function(_) {\\n      if (!arguments.length) return x1 == null ? null : [ x2 - x1, y2 - y1 ];\\n      if (_ == null) x1 = y1 = x2 = y2 = null; else x1 = y1 = 0, x2 = +_[0], y2 = +_[1];\\n      return quadtree;\\n    };\\n    return quadtree;\\n  };\\n  function d3_geom_quadtreeCompatX(d) {\\n    return d.x;\\n  }\\n  function d3_geom_quadtreeCompatY(d) {\\n    return d.y;\\n  }\\n  function d3_geom_quadtreeNode() {\\n    return {\\n      leaf: true,\\n      nodes: [],\\n      point: null,\\n      x: null,\\n      y: null\\n    };\\n  }\\n  function d3_geom_quadtreeVisit(f, node, x1, y1, x2, y2) {\\n    if (!f(node, x1, y1, x2, y2)) {\\n      var sx = (x1 + x2) * .5, sy = (y1 + y2) * .5, children = node.nodes;\\n      if (children[0]) d3_geom_quadtreeVisit(f, children[0], x1, y1, sx, sy);\\n      if (children[1]) d3_geom_quadtreeVisit(f, children[1], sx, y1, x2, sy);\\n      if (children[2]) d3_geom_quadtreeVisit(f, children[2], x1, sy, sx, y2);\\n      if (children[3]) d3_geom_quadtreeVisit(f, children[3], sx, sy, x2, y2);\\n    }\\n  }\\n  function d3_geom_quadtreeFind(root, x, y, x0, y0, x3, y3) {\\n    var minDistance2 = Infinity, closestPoint;\\n    (function find(node, x1, y1, x2, y2) {\\n      if (x1 > x3 || y1 > y3 || x2 < x0 || y2 < y0) return;\\n      if (point = node.point) {\\n        var point, dx = x - node.x, dy = y - node.y, distance2 = dx * dx + dy * dy;\\n        if (distance2 < minDistance2) {\\n          var distance = Math.sqrt(minDistance2 = distance2);\\n          x0 = x - distance, y0 = y - distance;\\n          x3 = x + distance, y3 = y + distance;\\n          closestPoint = point;\\n        }\\n      }\\n      var children = node.nodes, xm = (x1 + x2) * .5, ym = (y1 + y2) * .5, right = x >= xm, below = y >= ym;\\n      for (var i = below << 1 | right, j = i + 4; i < j; ++i) {\\n        if (node = children[i & 3]) switch (i & 3) {\\n         case 0:\\n          find(node, x1, y1, xm, ym);\\n          break;\\n\\n         case 1:\\n          find(node, xm, y1, x2, ym);\\n          break;\\n\\n         case 2:\\n          find(node, x1, ym, xm, y2);\\n          break;\\n\\n         case 3:\\n          find(node, xm, ym, x2, y2);\\n          break;\\n        }\\n      }\\n    })(root, x0, y0, x3, y3);\\n    return closestPoint;\\n  }\\n  d3.interpolateRgb = d3_interpolateRgb;\\n  function d3_interpolateRgb(a, b) {\\n    a = d3.rgb(a);\\n    b = d3.rgb(b);\\n    var ar = a.r, ag = a.g, ab = a.b, br = b.r - ar, bg = b.g - ag, bb = b.b - ab;\\n    return function(t) {\\n      return \\\"#\\\" + d3_rgb_hex(Math.round(ar + br * t)) + d3_rgb_hex(Math.round(ag + bg * t)) + d3_rgb_hex(Math.round(ab + bb * t));\\n    };\\n  }\\n  d3.interpolateObject = d3_interpolateObject;\\n  function d3_interpolateObject(a, b) {\\n    var i = {}, c = {}, k;\\n    for (k in a) {\\n      if (k in b) {\\n        i[k] = d3_interpolate(a[k], b[k]);\\n      } else {\\n        c[k] = a[k];\\n      }\\n    }\\n    for (k in b) {\\n      if (!(k in a)) {\\n        c[k] = b[k];\\n      }\\n    }\\n    return function(t) {\\n      for (k in i) c[k] = i[k](t);\\n      return c;\\n    };\\n  }\\n  d3.interpolateNumber = d3_interpolateNumber;\\n  function d3_interpolateNumber(a, b) {\\n    a = +a, b = +b;\\n    return function(t) {\\n      return a * (1 - t) + b * t;\\n    };\\n  }\\n  d3.interpolateString = d3_interpolateString;\\n  function d3_interpolateString(a, b) {\\n    var bi = d3_interpolate_numberA.lastIndex = d3_interpolate_numberB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];\\n    a = a + \\\"\\\", b = b + \\\"\\\";\\n    while ((am = d3_interpolate_numberA.exec(a)) && (bm = d3_interpolate_numberB.exec(b))) {\\n      if ((bs = bm.index) > bi) {\\n        bs = b.slice(bi, bs);\\n        if (s[i]) s[i] += bs; else s[++i] = bs;\\n      }\\n      if ((am = am[0]) === (bm = bm[0])) {\\n        if (s[i]) s[i] += bm; else s[++i] = bm;\\n      } else {\\n        s[++i] = null;\\n        q.push({\\n          i: i,\\n          x: d3_interpolateNumber(am, bm)\\n        });\\n      }\\n      bi = d3_interpolate_numberB.lastIndex;\\n    }\\n    if (bi < b.length) {\\n      bs = b.slice(bi);\\n      if (s[i]) s[i] += bs; else s[++i] = bs;\\n    }\\n    return s.length < 2 ? q[0] ? (b = q[0].x, function(t) {\\n      return b(t) + \\\"\\\";\\n    }) : function() {\\n      return b;\\n    } : (b = q.length, function(t) {\\n      for (var i = 0, o; i < b; ++i) s[(o = q[i]).i] = o.x(t);\\n      return s.join(\\\"\\\");\\n    });\\n  }\\n  var d3_interpolate_numberA = /[-+]?(?:\\\\d+\\\\.?\\\\d*|\\\\.?\\\\d+)(?:[eE][-+]?\\\\d+)?/g, d3_interpolate_numberB = new RegExp(d3_interpolate_numberA.source, \\\"g\\\");\\n  d3.interpolate = d3_interpolate;\\n  function d3_interpolate(a, b) {\\n    var i = d3.interpolators.length, f;\\n    while (--i >= 0 && !(f = d3.interpolators[i](a, b))) ;\\n    return f;\\n  }\\n  d3.interpolators = [ function(a, b) {\\n    var t = typeof b;\\n    return (t === \\\"string\\\" ? d3_rgb_names.has(b.toLowerCase()) || /^(#|rgb\\\\(|hsl\\\\()/i.test(b) ? d3_interpolateRgb : d3_interpolateString : b instanceof d3_color ? d3_interpolateRgb : Array.isArray(b) ? d3_interpolateArray : t === \\\"object\\\" && isNaN(b) ? d3_interpolateObject : d3_interpolateNumber)(a, b);\\n  } ];\\n  d3.interpolateArray = d3_interpolateArray;\\n  function d3_interpolateArray(a, b) {\\n    var x = [], c = [], na = a.length, nb = b.length, n0 = Math.min(a.length, b.length), i;\\n    for (i = 0; i < n0; ++i) x.push(d3_interpolate(a[i], b[i]));\\n    for (;i < na; ++i) c[i] = a[i];\\n    for (;i < nb; ++i) c[i] = b[i];\\n    return function(t) {\\n      for (i = 0; i < n0; ++i) c[i] = x[i](t);\\n      return c;\\n    };\\n  }\\n  var d3_ease_default = function() {\\n    return d3_identity;\\n  };\\n  var d3_ease = d3.map({\\n    linear: d3_ease_default,\\n    poly: d3_ease_poly,\\n    quad: function() {\\n      return d3_ease_quad;\\n    },\\n    cubic: function() {\\n      return d3_ease_cubic;\\n    },\\n    sin: function() {\\n      return d3_ease_sin;\\n    },\\n    exp: function() {\\n      return d3_ease_exp;\\n    },\\n    circle: function() {\\n      return d3_ease_circle;\\n    },\\n    elastic: d3_ease_elastic,\\n    back: d3_ease_back,\\n    bounce: function() {\\n      return d3_ease_bounce;\\n    }\\n  });\\n  var d3_ease_mode = d3.map({\\n    \\\"in\\\": d3_identity,\\n    out: d3_ease_reverse,\\n    \\\"in-out\\\": d3_ease_reflect,\\n    \\\"out-in\\\": function(f) {\\n      return d3_ease_reflect(d3_ease_reverse(f));\\n    }\\n  });\\n  d3.ease = function(name) {\\n    var i = name.indexOf(\\\"-\\\"), t = i >= 0 ? name.slice(0, i) : name, m = i >= 0 ? name.slice(i + 1) : \\\"in\\\";\\n    t = d3_ease.get(t) || d3_ease_default;\\n    m = d3_ease_mode.get(m) || d3_identity;\\n    return d3_ease_clamp(m(t.apply(null, d3_arraySlice.call(arguments, 1))));\\n  };\\n  function d3_ease_clamp(f) {\\n    return function(t) {\\n      return t <= 0 ? 0 : t >= 1 ? 1 : f(t);\\n    };\\n  }\\n  function d3_ease_reverse(f) {\\n    return function(t) {\\n      return 1 - f(1 - t);\\n    };\\n  }\\n  function d3_ease_reflect(f) {\\n    return function(t) {\\n      return .5 * (t < .5 ? f(2 * t) : 2 - f(2 - 2 * t));\\n    };\\n  }\\n  function d3_ease_quad(t) {\\n    return t * t;\\n  }\\n  function d3_ease_cubic(t) {\\n    return t * t * t;\\n  }\\n  function d3_ease_cubicInOut(t) {\\n    if (t <= 0) return 0;\\n    if (t >= 1) return 1;\\n    var t2 = t * t, t3 = t2 * t;\\n    return 4 * (t < .5 ? t3 : 3 * (t - t2) + t3 - .75);\\n  }\\n  function d3_ease_poly(e) {\\n    return function(t) {\\n      return Math.pow(t, e);\\n    };\\n  }\\n  function d3_ease_sin(t) {\\n    return 1 - Math.cos(t * halfπ);\\n  }\\n  function d3_ease_exp(t) {\\n    return Math.pow(2, 10 * (t - 1));\\n  }\\n  function d3_ease_circle(t) {\\n    return 1 - Math.sqrt(1 - t * t);\\n  }\\n  function d3_ease_elastic(a, p) {\\n    var s;\\n    if (arguments.length < 2) p = .45;\\n    if (arguments.length) s = p / τ * Math.asin(1 / a); else a = 1, s = p / 4;\\n    return function(t) {\\n      return 1 + a * Math.pow(2, -10 * t) * Math.sin((t - s) * τ / p);\\n    };\\n  }\\n  function d3_ease_back(s) {\\n    if (!s) s = 1.70158;\\n    return function(t) {\\n      return t * t * ((s + 1) * t - s);\\n    };\\n  }\\n  function d3_ease_bounce(t) {\\n    return t < 1 / 2.75 ? 7.5625 * t * t : t < 2 / 2.75 ? 7.5625 * (t -= 1.5 / 2.75) * t + .75 : t < 2.5 / 2.75 ? 7.5625 * (t -= 2.25 / 2.75) * t + .9375 : 7.5625 * (t -= 2.625 / 2.75) * t + .984375;\\n  }\\n  d3.interpolateHcl = d3_interpolateHcl;\\n  function d3_interpolateHcl(a, b) {\\n    a = d3.hcl(a);\\n    b = d3.hcl(b);\\n    var ah = a.h, ac = a.c, al = a.l, bh = b.h - ah, bc = b.c - ac, bl = b.l - al;\\n    if (isNaN(bc)) bc = 0, ac = isNaN(ac) ? b.c : ac;\\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\\n    return function(t) {\\n      return d3_hcl_lab(ah + bh * t, ac + bc * t, al + bl * t) + \\\"\\\";\\n    };\\n  }\\n  d3.interpolateHsl = d3_interpolateHsl;\\n  function d3_interpolateHsl(a, b) {\\n    a = d3.hsl(a);\\n    b = d3.hsl(b);\\n    var ah = a.h, as = a.s, al = a.l, bh = b.h - ah, bs = b.s - as, bl = b.l - al;\\n    if (isNaN(bs)) bs = 0, as = isNaN(as) ? b.s : as;\\n    if (isNaN(bh)) bh = 0, ah = isNaN(ah) ? b.h : ah; else if (bh > 180) bh -= 360; else if (bh < -180) bh += 360;\\n    return function(t) {\\n      return d3_hsl_rgb(ah + bh * t, as + bs * t, al + bl * t) + \\\"\\\";\\n    };\\n  }\\n  d3.interpolateLab = d3_interpolateLab;\\n  function d3_interpolateLab(a, b) {\\n    a = d3.lab(a);\\n    b = d3.lab(b);\\n    var al = a.l, aa = a.a, ab = a.b, bl = b.l - al, ba = b.a - aa, bb = b.b - ab;\\n    return function(t) {\\n      return d3_lab_rgb(al + bl * t, aa + ba * t, ab + bb * t) + \\\"\\\";\\n    };\\n  }\\n  d3.interpolateRound = d3_interpolateRound;\\n  function d3_interpolateRound(a, b) {\\n    b -= a;\\n    return function(t) {\\n      return Math.round(a + b * t);\\n    };\\n  }\\n  d3.transform = function(string) {\\n    var g = d3_document.createElementNS(d3.ns.prefix.svg, \\\"g\\\");\\n    return (d3.transform = function(string) {\\n      if (string != null) {\\n        g.setAttribute(\\\"transform\\\", string);\\n        var t = g.transform.baseVal.consolidate();\\n      }\\n      return new d3_transform(t ? t.matrix : d3_transformIdentity);\\n    })(string);\\n  };\\n  function d3_transform(m) {\\n    var r0 = [ m.a, m.b ], r1 = [ m.c, m.d ], kx = d3_transformNormalize(r0), kz = d3_transformDot(r0, r1), ky = d3_transformNormalize(d3_transformCombine(r1, r0, -kz)) || 0;\\n    if (r0[0] * r1[1] < r1[0] * r0[1]) {\\n      r0[0] *= -1;\\n      r0[1] *= -1;\\n      kx *= -1;\\n      kz *= -1;\\n    }\\n    this.rotate = (kx ? Math.atan2(r0[1], r0[0]) : Math.atan2(-r1[0], r1[1])) * d3_degrees;\\n    this.translate = [ m.e, m.f ];\\n    this.scale = [ kx, ky ];\\n    this.skew = ky ? Math.atan2(kz, ky) * d3_degrees : 0;\\n  }\\n  d3_transform.prototype.toString = function() {\\n    return \\\"translate(\\\" + this.translate + \\\")rotate(\\\" + this.rotate + \\\")skewX(\\\" + this.skew + \\\")scale(\\\" + this.scale + \\\")\\\";\\n  };\\n  function d3_transformDot(a, b) {\\n    return a[0] * b[0] + a[1] * b[1];\\n  }\\n  function d3_transformNormalize(a) {\\n    var k = Math.sqrt(d3_transformDot(a, a));\\n    if (k) {\\n      a[0] /= k;\\n      a[1] /= k;\\n    }\\n    return k;\\n  }\\n  function d3_transformCombine(a, b, k) {\\n    a[0] += k * b[0];\\n    a[1] += k * b[1];\\n    return a;\\n  }\\n  var d3_transformIdentity = {\\n    a: 1,\\n    b: 0,\\n    c: 0,\\n    d: 1,\\n    e: 0,\\n    f: 0\\n  };\\n  d3.interpolateTransform = d3_interpolateTransform;\\n  function d3_interpolateTransformPop(s) {\\n    return s.length ? s.pop() + \\\",\\\" : \\\"\\\";\\n  }\\n  function d3_interpolateTranslate(ta, tb, s, q) {\\n    if (ta[0] !== tb[0] || ta[1] !== tb[1]) {\\n      var i = s.push(\\\"translate(\\\", null, \\\",\\\", null, \\\")\\\");\\n      q.push({\\n        i: i - 4,\\n        x: d3_interpolateNumber(ta[0], tb[0])\\n      }, {\\n        i: i - 2,\\n        x: d3_interpolateNumber(ta[1], tb[1])\\n      });\\n    } else if (tb[0] || tb[1]) {\\n      s.push(\\\"translate(\\\" + tb + \\\")\\\");\\n    }\\n  }\\n  function d3_interpolateRotate(ra, rb, s, q) {\\n    if (ra !== rb) {\\n      if (ra - rb > 180) rb += 360; else if (rb - ra > 180) ra += 360;\\n      q.push({\\n        i: s.push(d3_interpolateTransformPop(s) + \\\"rotate(\\\", null, \\\")\\\") - 2,\\n        x: d3_interpolateNumber(ra, rb)\\n      });\\n    } else if (rb) {\\n      s.push(d3_interpolateTransformPop(s) + \\\"rotate(\\\" + rb + \\\")\\\");\\n    }\\n  }\\n  function d3_interpolateSkew(wa, wb, s, q) {\\n    if (wa !== wb) {\\n      q.push({\\n        i: s.push(d3_interpolateTransformPop(s) + \\\"skewX(\\\", null, \\\")\\\") - 2,\\n        x: d3_interpolateNumber(wa, wb)\\n      });\\n    } else if (wb) {\\n      s.push(d3_interpolateTransformPop(s) + \\\"skewX(\\\" + wb + \\\")\\\");\\n    }\\n  }\\n  function d3_interpolateScale(ka, kb, s, q) {\\n    if (ka[0] !== kb[0] || ka[1] !== kb[1]) {\\n      var i = s.push(d3_interpolateTransformPop(s) + \\\"scale(\\\", null, \\\",\\\", null, \\\")\\\");\\n      q.push({\\n        i: i - 4,\\n        x: d3_interpolateNumber(ka[0], kb[0])\\n      }, {\\n        i: i - 2,\\n        x: d3_interpolateNumber(ka[1], kb[1])\\n      });\\n    } else if (kb[0] !== 1 || kb[1] !== 1) {\\n      s.push(d3_interpolateTransformPop(s) + \\\"scale(\\\" + kb + \\\")\\\");\\n    }\\n  }\\n  function d3_interpolateTransform(a, b) {\\n    var s = [], q = [];\\n    a = d3.transform(a), b = d3.transform(b);\\n    d3_interpolateTranslate(a.translate, b.translate, s, q);\\n    d3_interpolateRotate(a.rotate, b.rotate, s, q);\\n    d3_interpolateSkew(a.skew, b.skew, s, q);\\n    d3_interpolateScale(a.scale, b.scale, s, q);\\n    a = b = null;\\n    return function(t) {\\n      var i = -1, n = q.length, o;\\n      while (++i < n) s[(o = q[i]).i] = o.x(t);\\n      return s.join(\\\"\\\");\\n    };\\n  }\\n  function d3_uninterpolateNumber(a, b) {\\n    b = (b -= a = +a) || 1 / b;\\n    return function(x) {\\n      return (x - a) / b;\\n    };\\n  }\\n  function d3_uninterpolateClamp(a, b) {\\n    b = (b -= a = +a) || 1 / b;\\n    return function(x) {\\n      return Math.max(0, Math.min(1, (x - a) / b));\\n    };\\n  }\\n  d3.layout = {};\\n  d3.layout.bundle = function() {\\n    return function(links) {\\n      var paths = [], i = -1, n = links.length;\\n      while (++i < n) paths.push(d3_layout_bundlePath(links[i]));\\n      return paths;\\n    };\\n  };\\n  function d3_layout_bundlePath(link) {\\n    var start = link.source, end = link.target, lca = d3_layout_bundleLeastCommonAncestor(start, end), points = [ start ];\\n    while (start !== lca) {\\n      start = start.parent;\\n      points.push(start);\\n    }\\n    var k = points.length;\\n    while (end !== lca) {\\n      points.splice(k, 0, end);\\n      end = end.parent;\\n    }\\n    return points;\\n  }\\n  function d3_layout_bundleAncestors(node) {\\n    var ancestors = [], parent = node.parent;\\n    while (parent != null) {\\n      ancestors.push(node);\\n      node = parent;\\n      parent = parent.parent;\\n    }\\n    ancestors.push(node);\\n    return ancestors;\\n  }\\n  function d3_layout_bundleLeastCommonAncestor(a, b) {\\n    if (a === b) return a;\\n    var aNodes = d3_layout_bundleAncestors(a), bNodes = d3_layout_bundleAncestors(b), aNode = aNodes.pop(), bNode = bNodes.pop(), sharedNode = null;\\n    while (aNode === bNode) {\\n      sharedNode = aNode;\\n      aNode = aNodes.pop();\\n      bNode = bNodes.pop();\\n    }\\n    return sharedNode;\\n  }\\n  d3.layout.chord = function() {\\n    var chord = {}, chords, groups, matrix, n, padding = 0, sortGroups, sortSubgroups, sortChords;\\n    function relayout() {\\n      var subgroups = {}, groupSums = [], groupIndex = d3.range(n), subgroupIndex = [], k, x, x0, i, j;\\n      chords = [];\\n      groups = [];\\n      k = 0, i = -1;\\n      while (++i < n) {\\n        x = 0, j = -1;\\n        while (++j < n) {\\n          x += matrix[i][j];\\n        }\\n        groupSums.push(x);\\n        subgroupIndex.push(d3.range(n));\\n        k += x;\\n      }\\n      if (sortGroups) {\\n        groupIndex.sort(function(a, b) {\\n          return sortGroups(groupSums[a], groupSums[b]);\\n        });\\n      }\\n      if (sortSubgroups) {\\n        subgroupIndex.forEach(function(d, i) {\\n          d.sort(function(a, b) {\\n            return sortSubgroups(matrix[i][a], matrix[i][b]);\\n          });\\n        });\\n      }\\n      k = (τ - padding * n) / k;\\n      x = 0, i = -1;\\n      while (++i < n) {\\n        x0 = x, j = -1;\\n        while (++j < n) {\\n          var di = groupIndex[i], dj = subgroupIndex[di][j], v = matrix[di][dj], a0 = x, a1 = x += v * k;\\n          subgroups[di + \\\"-\\\" + dj] = {\\n            index: di,\\n            subindex: dj,\\n            startAngle: a0,\\n            endAngle: a1,\\n            value: v\\n          };\\n        }\\n        groups[di] = {\\n          index: di,\\n          startAngle: x0,\\n          endAngle: x,\\n          value: groupSums[di]\\n        };\\n        x += padding;\\n      }\\n      i = -1;\\n      while (++i < n) {\\n        j = i - 1;\\n        while (++j < n) {\\n          var source = subgroups[i + \\\"-\\\" + j], target = subgroups[j + \\\"-\\\" + i];\\n          if (source.value || target.value) {\\n            chords.push(source.value < target.value ? {\\n              source: target,\\n              target: source\\n            } : {\\n              source: source,\\n              target: target\\n            });\\n          }\\n        }\\n      }\\n      if (sortChords) resort();\\n    }\\n    function resort() {\\n      chords.sort(function(a, b) {\\n        return sortChords((a.source.value + a.target.value) / 2, (b.source.value + b.target.value) / 2);\\n      });\\n    }\\n    chord.matrix = function(x) {\\n      if (!arguments.length) return matrix;\\n      n = (matrix = x) && matrix.length;\\n      chords = groups = null;\\n      return chord;\\n    };\\n    chord.padding = function(x) {\\n      if (!arguments.length) return padding;\\n      padding = x;\\n      chords = groups = null;\\n      return chord;\\n    };\\n    chord.sortGroups = function(x) {\\n      if (!arguments.length) return sortGroups;\\n      sortGroups = x;\\n      chords = groups = null;\\n      return chord;\\n    };\\n    chord.sortSubgroups = function(x) {\\n      if (!arguments.length) return sortSubgroups;\\n      sortSubgroups = x;\\n      chords = null;\\n      return chord;\\n    };\\n    chord.sortChords = function(x) {\\n      if (!arguments.length) return sortChords;\\n      sortChords = x;\\n      if (chords) resort();\\n      return chord;\\n    };\\n    chord.chords = function() {\\n      if (!chords) relayout();\\n      return chords;\\n    };\\n    chord.groups = function() {\\n      if (!groups) relayout();\\n      return groups;\\n    };\\n    return chord;\\n  };\\n  d3.layout.force = function() {\\n    var force = {}, event = d3.dispatch(\\\"start\\\", \\\"tick\\\", \\\"end\\\"), timer, size = [ 1, 1 ], drag, alpha, friction = .9, linkDistance = d3_layout_forceLinkDistance, linkStrength = d3_layout_forceLinkStrength, charge = -30, chargeDistance2 = d3_layout_forceChargeDistance2, gravity = .1, theta2 = .64, nodes = [], links = [], distances, strengths, charges;\\n    function repulse(node) {\\n      return function(quad, x1, _, x2) {\\n        if (quad.point !== node) {\\n          var dx = quad.cx - node.x, dy = quad.cy - node.y, dw = x2 - x1, dn = dx * dx + dy * dy;\\n          if (dw * dw / theta2 < dn) {\\n            if (dn < chargeDistance2) {\\n              var k = quad.charge / dn;\\n              node.px -= dx * k;\\n              node.py -= dy * k;\\n            }\\n            return true;\\n          }\\n          if (quad.point && dn && dn < chargeDistance2) {\\n            var k = quad.pointCharge / dn;\\n            node.px -= dx * k;\\n            node.py -= dy * k;\\n          }\\n        }\\n        return !quad.charge;\\n      };\\n    }\\n    force.tick = function() {\\n      if ((alpha *= .99) < .005) {\\n        timer = null;\\n        event.end({\\n          type: \\\"end\\\",\\n          alpha: alpha = 0\\n        });\\n        return true;\\n      }\\n      var n = nodes.length, m = links.length, q, i, o, s, t, l, k, x, y;\\n      for (i = 0; i < m; ++i) {\\n        o = links[i];\\n        s = o.source;\\n        t = o.target;\\n        x = t.x - s.x;\\n        y = t.y - s.y;\\n        if (l = x * x + y * y) {\\n          l = alpha * strengths[i] * ((l = Math.sqrt(l)) - distances[i]) / l;\\n          x *= l;\\n          y *= l;\\n          t.x -= x * (k = s.weight + t.weight ? s.weight / (s.weight + t.weight) : .5);\\n          t.y -= y * k;\\n          s.x += x * (k = 1 - k);\\n          s.y += y * k;\\n        }\\n      }\\n      if (k = alpha * gravity) {\\n        x = size[0] / 2;\\n        y = size[1] / 2;\\n        i = -1;\\n        if (k) while (++i < n) {\\n          o = nodes[i];\\n          o.x += (x - o.x) * k;\\n          o.y += (y - o.y) * k;\\n        }\\n      }\\n      if (charge) {\\n        d3_layout_forceAccumulate(q = d3.geom.quadtree(nodes), alpha, charges);\\n        i = -1;\\n        while (++i < n) {\\n          if (!(o = nodes[i]).fixed) {\\n            q.visit(repulse(o));\\n          }\\n        }\\n      }\\n      i = -1;\\n      while (++i < n) {\\n        o = nodes[i];\\n        if (o.fixed) {\\n          o.x = o.px;\\n          o.y = o.py;\\n        } else {\\n          o.x -= (o.px - (o.px = o.x)) * friction;\\n          o.y -= (o.py - (o.py = o.y)) * friction;\\n        }\\n      }\\n      event.tick({\\n        type: \\\"tick\\\",\\n        alpha: alpha\\n      });\\n    };\\n    force.nodes = function(x) {\\n      if (!arguments.length) return nodes;\\n      nodes = x;\\n      return force;\\n    };\\n    force.links = function(x) {\\n      if (!arguments.length) return links;\\n      links = x;\\n      return force;\\n    };\\n    force.size = function(x) {\\n      if (!arguments.length) return size;\\n      size = x;\\n      return force;\\n    };\\n    force.linkDistance = function(x) {\\n      if (!arguments.length) return linkDistance;\\n      linkDistance = typeof x === \\\"function\\\" ? x : +x;\\n      return force;\\n    };\\n    force.distance = force.linkDistance;\\n    force.linkStrength = function(x) {\\n      if (!arguments.length) return linkStrength;\\n      linkStrength = typeof x === \\\"function\\\" ? x : +x;\\n      return force;\\n    };\\n    force.friction = function(x) {\\n      if (!arguments.length) return friction;\\n      friction = +x;\\n      return force;\\n    };\\n    force.charge = function(x) {\\n      if (!arguments.length) return charge;\\n      charge = typeof x === \\\"function\\\" ? x : +x;\\n      return force;\\n    };\\n    force.chargeDistance = function(x) {\\n      if (!arguments.length) return Math.sqrt(chargeDistance2);\\n      chargeDistance2 = x * x;\\n      return force;\\n    };\\n    force.gravity = function(x) {\\n      if (!arguments.length) return gravity;\\n      gravity = +x;\\n      return force;\\n    };\\n    force.theta = function(x) {\\n      if (!arguments.length) return Math.sqrt(theta2);\\n      theta2 = x * x;\\n      return force;\\n    };\\n    force.alpha = function(x) {\\n      if (!arguments.length) return alpha;\\n      x = +x;\\n      if (alpha) {\\n        if (x > 0) {\\n          alpha = x;\\n        } else {\\n          timer.c = null, timer.t = NaN, timer = null;\\n          event.end({\\n            type: \\\"end\\\",\\n            alpha: alpha = 0\\n          });\\n        }\\n      } else if (x > 0) {\\n        event.start({\\n          type: \\\"start\\\",\\n          alpha: alpha = x\\n        });\\n        timer = d3_timer(force.tick);\\n      }\\n      return force;\\n    };\\n    force.start = function() {\\n      var i, n = nodes.length, m = links.length, w = size[0], h = size[1], neighbors, o;\\n      for (i = 0; i < n; ++i) {\\n        (o = nodes[i]).index = i;\\n        o.weight = 0;\\n      }\\n      for (i = 0; i < m; ++i) {\\n        o = links[i];\\n        if (typeof o.source == \\\"number\\\") o.source = nodes[o.source];\\n        if (typeof o.target == \\\"number\\\") o.target = nodes[o.target];\\n        ++o.source.weight;\\n        ++o.target.weight;\\n      }\\n      for (i = 0; i < n; ++i) {\\n        o = nodes[i];\\n        if (isNaN(o.x)) o.x = position(\\\"x\\\", w);\\n        if (isNaN(o.y)) o.y = position(\\\"y\\\", h);\\n        if (isNaN(o.px)) o.px = o.x;\\n        if (isNaN(o.py)) o.py = o.y;\\n      }\\n      distances = [];\\n      if (typeof linkDistance === \\\"function\\\") for (i = 0; i < m; ++i) distances[i] = +linkDistance.call(this, links[i], i); else for (i = 0; i < m; ++i) distances[i] = linkDistance;\\n      strengths = [];\\n      if (typeof linkStrength === \\\"function\\\") for (i = 0; i < m; ++i) strengths[i] = +linkStrength.call(this, links[i], i); else for (i = 0; i < m; ++i) strengths[i] = linkStrength;\\n      charges = [];\\n      if (typeof charge === \\\"function\\\") for (i = 0; i < n; ++i) charges[i] = +charge.call(this, nodes[i], i); else for (i = 0; i < n; ++i) charges[i] = charge;\\n      function position(dimension, size) {\\n        if (!neighbors) {\\n          neighbors = new Array(n);\\n          for (j = 0; j < n; ++j) {\\n            neighbors[j] = [];\\n          }\\n          for (j = 0; j < m; ++j) {\\n            var o = links[j];\\n            neighbors[o.source.index].push(o.target);\\n            neighbors[o.target.index].push(o.source);\\n          }\\n        }\\n        var candidates = neighbors[i], j = -1, l = candidates.length, x;\\n        while (++j < l) if (!isNaN(x = candidates[j][dimension])) return x;\\n        return Math.random() * size;\\n      }\\n      return force.resume();\\n    };\\n    force.resume = function() {\\n      return force.alpha(.1);\\n    };\\n    force.stop = function() {\\n      return force.alpha(0);\\n    };\\n    force.drag = function() {\\n      if (!drag) drag = d3.behavior.drag().origin(d3_identity).on(\\\"dragstart.force\\\", d3_layout_forceDragstart).on(\\\"drag.force\\\", dragmove).on(\\\"dragend.force\\\", d3_layout_forceDragend);\\n      if (!arguments.length) return drag;\\n      this.on(\\\"mouseover.force\\\", d3_layout_forceMouseover).on(\\\"mouseout.force\\\", d3_layout_forceMouseout).call(drag);\\n    };\\n    function dragmove(d) {\\n      d.px = d3.event.x, d.py = d3.event.y;\\n      force.resume();\\n    }\\n    return d3.rebind(force, event, \\\"on\\\");\\n  };\\n  function d3_layout_forceDragstart(d) {\\n    d.fixed |= 2;\\n  }\\n  function d3_layout_forceDragend(d) {\\n    d.fixed &= ~6;\\n  }\\n  function d3_layout_forceMouseover(d) {\\n    d.fixed |= 4;\\n    d.px = d.x, d.py = d.y;\\n  }\\n  function d3_layout_forceMouseout(d) {\\n    d.fixed &= ~4;\\n  }\\n  function d3_layout_forceAccumulate(quad, alpha, charges) {\\n    var cx = 0, cy = 0;\\n    quad.charge = 0;\\n    if (!quad.leaf) {\\n      var nodes = quad.nodes, n = nodes.length, i = -1, c;\\n      while (++i < n) {\\n        c = nodes[i];\\n        if (c == null) continue;\\n        d3_layout_forceAccumulate(c, alpha, charges);\\n        quad.charge += c.charge;\\n        cx += c.charge * c.cx;\\n        cy += c.charge * c.cy;\\n      }\\n    }\\n    if (quad.point) {\\n      if (!quad.leaf) {\\n        quad.point.x += Math.random() - .5;\\n        quad.point.y += Math.random() - .5;\\n      }\\n      var k = alpha * charges[quad.point.index];\\n      quad.charge += quad.pointCharge = k;\\n      cx += k * quad.point.x;\\n      cy += k * quad.point.y;\\n    }\\n    quad.cx = cx / quad.charge;\\n    quad.cy = cy / quad.charge;\\n  }\\n  var d3_layout_forceLinkDistance = 20, d3_layout_forceLinkStrength = 1, d3_layout_forceChargeDistance2 = Infinity;\\n  d3.layout.hierarchy = function() {\\n    var sort = d3_layout_hierarchySort, children = d3_layout_hierarchyChildren, value = d3_layout_hierarchyValue;\\n    function hierarchy(root) {\\n      var stack = [ root ], nodes = [], node;\\n      root.depth = 0;\\n      while ((node = stack.pop()) != null) {\\n        nodes.push(node);\\n        if ((childs = children.call(hierarchy, node, node.depth)) && (n = childs.length)) {\\n          var n, childs, child;\\n          while (--n >= 0) {\\n            stack.push(child = childs[n]);\\n            child.parent = node;\\n            child.depth = node.depth + 1;\\n          }\\n          if (value) node.value = 0;\\n          node.children = childs;\\n        } else {\\n          if (value) node.value = +value.call(hierarchy, node, node.depth) || 0;\\n          delete node.children;\\n        }\\n      }\\n      d3_layout_hierarchyVisitAfter(root, function(node) {\\n        var childs, parent;\\n        if (sort && (childs = node.children)) childs.sort(sort);\\n        if (value && (parent = node.parent)) parent.value += node.value;\\n      });\\n      return nodes;\\n    }\\n    hierarchy.sort = function(x) {\\n      if (!arguments.length) return sort;\\n      sort = x;\\n      return hierarchy;\\n    };\\n    hierarchy.children = function(x) {\\n      if (!arguments.length) return children;\\n      children = x;\\n      return hierarchy;\\n    };\\n    hierarchy.value = function(x) {\\n      if (!arguments.length) return value;\\n      value = x;\\n      return hierarchy;\\n    };\\n    hierarchy.revalue = function(root) {\\n      if (value) {\\n        d3_layout_hierarchyVisitBefore(root, function(node) {\\n          if (node.children) node.value = 0;\\n        });\\n        d3_layout_hierarchyVisitAfter(root, function(node) {\\n          var parent;\\n          if (!node.children) node.value = +value.call(hierarchy, node, node.depth) || 0;\\n          if (parent = node.parent) parent.value += node.value;\\n        });\\n      }\\n      return root;\\n    };\\n    return hierarchy;\\n  };\\n  function d3_layout_hierarchyRebind(object, hierarchy) {\\n    d3.rebind(object, hierarchy, \\\"sort\\\", \\\"children\\\", \\\"value\\\");\\n    object.nodes = object;\\n    object.links = d3_layout_hierarchyLinks;\\n    return object;\\n  }\\n  function d3_layout_hierarchyVisitBefore(node, callback) {\\n    var nodes = [ node ];\\n    while ((node = nodes.pop()) != null) {\\n      callback(node);\\n      if ((children = node.children) && (n = children.length)) {\\n        var n, children;\\n        while (--n >= 0) nodes.push(children[n]);\\n      }\\n    }\\n  }\\n  function d3_layout_hierarchyVisitAfter(node, callback) {\\n    var nodes = [ node ], nodes2 = [];\\n    while ((node = nodes.pop()) != null) {\\n      nodes2.push(node);\\n      if ((children = node.children) && (n = children.length)) {\\n        var i = -1, n, children;\\n        while (++i < n) nodes.push(children[i]);\\n      }\\n    }\\n    while ((node = nodes2.pop()) != null) {\\n      callback(node);\\n    }\\n  }\\n  function d3_layout_hierarchyChildren(d) {\\n    return d.children;\\n  }\\n  function d3_layout_hierarchyValue(d) {\\n    return d.value;\\n  }\\n  function d3_layout_hierarchySort(a, b) {\\n    return b.value - a.value;\\n  }\\n  function d3_layout_hierarchyLinks(nodes) {\\n    return d3.merge(nodes.map(function(parent) {\\n      return (parent.children || []).map(function(child) {\\n        return {\\n          source: parent,\\n          target: child\\n        };\\n      });\\n    }));\\n  }\\n  d3.layout.partition = function() {\\n    var hierarchy = d3.layout.hierarchy(), size = [ 1, 1 ];\\n    function position(node, x, dx, dy) {\\n      var children = node.children;\\n      node.x = x;\\n      node.y = node.depth * dy;\\n      node.dx = dx;\\n      node.dy = dy;\\n      if (children && (n = children.length)) {\\n        var i = -1, n, c, d;\\n        dx = node.value ? dx / node.value : 0;\\n        while (++i < n) {\\n          position(c = children[i], x, d = c.value * dx, dy);\\n          x += d;\\n        }\\n      }\\n    }\\n    function depth(node) {\\n      var children = node.children, d = 0;\\n      if (children && (n = children.length)) {\\n        var i = -1, n;\\n        while (++i < n) d = Math.max(d, depth(children[i]));\\n      }\\n      return 1 + d;\\n    }\\n    function partition(d, i) {\\n      var nodes = hierarchy.call(this, d, i);\\n      position(nodes[0], 0, size[0], size[1] / depth(nodes[0]));\\n      return nodes;\\n    }\\n    partition.size = function(x) {\\n      if (!arguments.length) return size;\\n      size = x;\\n      return partition;\\n    };\\n    return d3_layout_hierarchyRebind(partition, hierarchy);\\n  };\\n  d3.layout.pie = function() {\\n    var value = Number, sort = d3_layout_pieSortByValue, startAngle = 0, endAngle = τ, padAngle = 0;\\n    function pie(data) {\\n      var n = data.length, values = data.map(function(d, i) {\\n        return +value.call(pie, d, i);\\n      }), a = +(typeof startAngle === \\\"function\\\" ? startAngle.apply(this, arguments) : startAngle), da = (typeof endAngle === \\\"function\\\" ? endAngle.apply(this, arguments) : endAngle) - a, p = Math.min(Math.abs(da) / n, +(typeof padAngle === \\\"function\\\" ? padAngle.apply(this, arguments) : padAngle)), pa = p * (da < 0 ? -1 : 1), sum = d3.sum(values), k = sum ? (da - n * pa) / sum : 0, index = d3.range(n), arcs = [], v;\\n      if (sort != null) index.sort(sort === d3_layout_pieSortByValue ? function(i, j) {\\n        return values[j] - values[i];\\n      } : function(i, j) {\\n        return sort(data[i], data[j]);\\n      });\\n      index.forEach(function(i) {\\n        arcs[i] = {\\n          data: data[i],\\n          value: v = values[i],\\n          startAngle: a,\\n          endAngle: a += v * k + pa,\\n          padAngle: p\\n        };\\n      });\\n      return arcs;\\n    }\\n    pie.value = function(_) {\\n      if (!arguments.length) return value;\\n      value = _;\\n      return pie;\\n    };\\n    pie.sort = function(_) {\\n      if (!arguments.length) return sort;\\n      sort = _;\\n      return pie;\\n    };\\n    pie.startAngle = function(_) {\\n      if (!arguments.length) return startAngle;\\n      startAngle = _;\\n      return pie;\\n    };\\n    pie.endAngle = function(_) {\\n      if (!arguments.length) return endAngle;\\n      endAngle = _;\\n      return pie;\\n    };\\n    pie.padAngle = function(_) {\\n      if (!arguments.length) return padAngle;\\n      padAngle = _;\\n      return pie;\\n    };\\n    return pie;\\n  };\\n  var d3_layout_pieSortByValue = {};\\n  d3.layout.stack = function() {\\n    var values = d3_identity, order = d3_layout_stackOrderDefault, offset = d3_layout_stackOffsetZero, out = d3_layout_stackOut, x = d3_layout_stackX, y = d3_layout_stackY;\\n    function stack(data, index) {\\n      if (!(n = data.length)) return data;\\n      var series = data.map(function(d, i) {\\n        return values.call(stack, d, i);\\n      });\\n      var points = series.map(function(d) {\\n        return d.map(function(v, i) {\\n          return [ x.call(stack, v, i), y.call(stack, v, i) ];\\n        });\\n      });\\n      var orders = order.call(stack, points, index);\\n      series = d3.permute(series, orders);\\n      points = d3.permute(points, orders);\\n      var offsets = offset.call(stack, points, index);\\n      var m = series[0].length, n, i, j, o;\\n      for (j = 0; j < m; ++j) {\\n        out.call(stack, series[0][j], o = offsets[j], points[0][j][1]);\\n        for (i = 1; i < n; ++i) {\\n          out.call(stack, series[i][j], o += points[i - 1][j][1], points[i][j][1]);\\n        }\\n      }\\n      return data;\\n    }\\n    stack.values = function(x) {\\n      if (!arguments.length) return values;\\n      values = x;\\n      return stack;\\n    };\\n    stack.order = function(x) {\\n      if (!arguments.length) return order;\\n      order = typeof x === \\\"function\\\" ? x : d3_layout_stackOrders.get(x) || d3_layout_stackOrderDefault;\\n      return stack;\\n    };\\n    stack.offset = function(x) {\\n      if (!arguments.length) return offset;\\n      offset = typeof x === \\\"function\\\" ? x : d3_layout_stackOffsets.get(x) || d3_layout_stackOffsetZero;\\n      return stack;\\n    };\\n    stack.x = function(z) {\\n      if (!arguments.length) return x;\\n      x = z;\\n      return stack;\\n    };\\n    stack.y = function(z) {\\n      if (!arguments.length) return y;\\n      y = z;\\n      return stack;\\n    };\\n    stack.out = function(z) {\\n      if (!arguments.length) return out;\\n      out = z;\\n      return stack;\\n    };\\n    return stack;\\n  };\\n  function d3_layout_stackX(d) {\\n    return d.x;\\n  }\\n  function d3_layout_stackY(d) {\\n    return d.y;\\n  }\\n  function d3_layout_stackOut(d, y0, y) {\\n    d.y0 = y0;\\n    d.y = y;\\n  }\\n  var d3_layout_stackOrders = d3.map({\\n    \\\"inside-out\\\": function(data) {\\n      var n = data.length, i, j, max = data.map(d3_layout_stackMaxIndex), sums = data.map(d3_layout_stackReduceSum), index = d3.range(n).sort(function(a, b) {\\n        return max[a] - max[b];\\n      }), top = 0, bottom = 0, tops = [], bottoms = [];\\n      for (i = 0; i < n; ++i) {\\n        j = index[i];\\n        if (top < bottom) {\\n          top += sums[j];\\n          tops.push(j);\\n        } else {\\n          bottom += sums[j];\\n          bottoms.push(j);\\n        }\\n      }\\n      return bottoms.reverse().concat(tops);\\n    },\\n    reverse: function(data) {\\n      return d3.range(data.length).reverse();\\n    },\\n    \\\"default\\\": d3_layout_stackOrderDefault\\n  });\\n  var d3_layout_stackOffsets = d3.map({\\n    silhouette: function(data) {\\n      var n = data.length, m = data[0].length, sums = [], max = 0, i, j, o, y0 = [];\\n      for (j = 0; j < m; ++j) {\\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\\n        if (o > max) max = o;\\n        sums.push(o);\\n      }\\n      for (j = 0; j < m; ++j) {\\n        y0[j] = (max - sums[j]) / 2;\\n      }\\n      return y0;\\n    },\\n    wiggle: function(data) {\\n      var n = data.length, x = data[0], m = x.length, i, j, k, s1, s2, s3, dx, o, o0, y0 = [];\\n      y0[0] = o = o0 = 0;\\n      for (j = 1; j < m; ++j) {\\n        for (i = 0, s1 = 0; i < n; ++i) s1 += data[i][j][1];\\n        for (i = 0, s2 = 0, dx = x[j][0] - x[j - 1][0]; i < n; ++i) {\\n          for (k = 0, s3 = (data[i][j][1] - data[i][j - 1][1]) / (2 * dx); k < i; ++k) {\\n            s3 += (data[k][j][1] - data[k][j - 1][1]) / dx;\\n          }\\n          s2 += s3 * data[i][j][1];\\n        }\\n        y0[j] = o -= s1 ? s2 / s1 * dx : 0;\\n        if (o < o0) o0 = o;\\n      }\\n      for (j = 0; j < m; ++j) y0[j] -= o0;\\n      return y0;\\n    },\\n    expand: function(data) {\\n      var n = data.length, m = data[0].length, k = 1 / n, i, j, o, y0 = [];\\n      for (j = 0; j < m; ++j) {\\n        for (i = 0, o = 0; i < n; i++) o += data[i][j][1];\\n        if (o) for (i = 0; i < n; i++) data[i][j][1] /= o; else for (i = 0; i < n; i++) data[i][j][1] = k;\\n      }\\n      for (j = 0; j < m; ++j) y0[j] = 0;\\n      return y0;\\n    },\\n    zero: d3_layout_stackOffsetZero\\n  });\\n  function d3_layout_stackOrderDefault(data) {\\n    return d3.range(data.length);\\n  }\\n  function d3_layout_stackOffsetZero(data) {\\n    var j = -1, m = data[0].length, y0 = [];\\n    while (++j < m) y0[j] = 0;\\n    return y0;\\n  }\\n  function d3_layout_stackMaxIndex(array) {\\n    var i = 1, j = 0, v = array[0][1], k, n = array.length;\\n    for (;i < n; ++i) {\\n      if ((k = array[i][1]) > v) {\\n        j = i;\\n        v = k;\\n      }\\n    }\\n    return j;\\n  }\\n  function d3_layout_stackReduceSum(d) {\\n    return d.reduce(d3_layout_stackSum, 0);\\n  }\\n  function d3_layout_stackSum(p, d) {\\n    return p + d[1];\\n  }\\n  d3.layout.histogram = function() {\\n    var frequency = true, valuer = Number, ranger = d3_layout_histogramRange, binner = d3_layout_histogramBinSturges;\\n    function histogram(data, i) {\\n      var bins = [], values = data.map(valuer, this), range = ranger.call(this, values, i), thresholds = binner.call(this, range, values, i), bin, i = -1, n = values.length, m = thresholds.length - 1, k = frequency ? 1 : 1 / n, x;\\n      while (++i < m) {\\n        bin = bins[i] = [];\\n        bin.dx = thresholds[i + 1] - (bin.x = thresholds[i]);\\n        bin.y = 0;\\n      }\\n      if (m > 0) {\\n        i = -1;\\n        while (++i < n) {\\n          x = values[i];\\n          if (x >= range[0] && x <= range[1]) {\\n            bin = bins[d3.bisect(thresholds, x, 1, m) - 1];\\n            bin.y += k;\\n            bin.push(data[i]);\\n          }\\n        }\\n      }\\n      return bins;\\n    }\\n    histogram.value = function(x) {\\n      if (!arguments.length) return valuer;\\n      valuer = x;\\n      return histogram;\\n    };\\n    histogram.range = function(x) {\\n      if (!arguments.length) return ranger;\\n      ranger = d3_functor(x);\\n      return histogram;\\n    };\\n    histogram.bins = function(x) {\\n      if (!arguments.length) return binner;\\n      binner = typeof x === \\\"number\\\" ? function(range) {\\n        return d3_layout_histogramBinFixed(range, x);\\n      } : d3_functor(x);\\n      return histogram;\\n    };\\n    histogram.frequency = function(x) {\\n      if (!arguments.length) return frequency;\\n      frequency = !!x;\\n      return histogram;\\n    };\\n    return histogram;\\n  };\\n  function d3_layout_histogramBinSturges(range, values) {\\n    return d3_layout_histogramBinFixed(range, Math.ceil(Math.log(values.length) / Math.LN2 + 1));\\n  }\\n  function d3_layout_histogramBinFixed(range, n) {\\n    var x = -1, b = +range[0], m = (range[1] - b) / n, f = [];\\n    while (++x <= n) f[x] = m * x + b;\\n    return f;\\n  }\\n  function d3_layout_histogramRange(values) {\\n    return [ d3.min(values), d3.max(values) ];\\n  }\\n  d3.layout.pack = function() {\\n    var hierarchy = d3.layout.hierarchy().sort(d3_layout_packSort), padding = 0, size = [ 1, 1 ], radius;\\n    function pack(d, i) {\\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], w = size[0], h = size[1], r = radius == null ? Math.sqrt : typeof radius === \\\"function\\\" ? radius : function() {\\n        return radius;\\n      };\\n      root.x = root.y = 0;\\n      d3_layout_hierarchyVisitAfter(root, function(d) {\\n        d.r = +r(d.value);\\n      });\\n      d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\\n      if (padding) {\\n        var dr = padding * (radius ? 1 : Math.max(2 * root.r / w, 2 * root.r / h)) / 2;\\n        d3_layout_hierarchyVisitAfter(root, function(d) {\\n          d.r += dr;\\n        });\\n        d3_layout_hierarchyVisitAfter(root, d3_layout_packSiblings);\\n        d3_layout_hierarchyVisitAfter(root, function(d) {\\n          d.r -= dr;\\n        });\\n      }\\n      d3_layout_packTransform(root, w / 2, h / 2, radius ? 1 : 1 / Math.max(2 * root.r / w, 2 * root.r / h));\\n      return nodes;\\n    }\\n    pack.size = function(_) {\\n      if (!arguments.length) return size;\\n      size = _;\\n      return pack;\\n    };\\n    pack.radius = function(_) {\\n      if (!arguments.length) return radius;\\n      radius = _ == null || typeof _ === \\\"function\\\" ? _ : +_;\\n      return pack;\\n    };\\n    pack.padding = function(_) {\\n      if (!arguments.length) return padding;\\n      padding = +_;\\n      return pack;\\n    };\\n    return d3_layout_hierarchyRebind(pack, hierarchy);\\n  };\\n  function d3_layout_packSort(a, b) {\\n    return a.value - b.value;\\n  }\\n  function d3_layout_packInsert(a, b) {\\n    var c = a._pack_next;\\n    a._pack_next = b;\\n    b._pack_prev = a;\\n    b._pack_next = c;\\n    c._pack_prev = b;\\n  }\\n  function d3_layout_packSplice(a, b) {\\n    a._pack_next = b;\\n    b._pack_prev = a;\\n  }\\n  function d3_layout_packIntersects(a, b) {\\n    var dx = b.x - a.x, dy = b.y - a.y, dr = a.r + b.r;\\n    return .999 * dr * dr > dx * dx + dy * dy;\\n  }\\n  function d3_layout_packSiblings(node) {\\n    if (!(nodes = node.children) || !(n = nodes.length)) return;\\n    var nodes, xMin = Infinity, xMax = -Infinity, yMin = Infinity, yMax = -Infinity, a, b, c, i, j, k, n;\\n    function bound(node) {\\n      xMin = Math.min(node.x - node.r, xMin);\\n      xMax = Math.max(node.x + node.r, xMax);\\n      yMin = Math.min(node.y - node.r, yMin);\\n      yMax = Math.max(node.y + node.r, yMax);\\n    }\\n    nodes.forEach(d3_layout_packLink);\\n    a = nodes[0];\\n    a.x = -a.r;\\n    a.y = 0;\\n    bound(a);\\n    if (n > 1) {\\n      b = nodes[1];\\n      b.x = b.r;\\n      b.y = 0;\\n      bound(b);\\n      if (n > 2) {\\n        c = nodes[2];\\n        d3_layout_packPlace(a, b, c);\\n        bound(c);\\n        d3_layout_packInsert(a, c);\\n        a._pack_prev = c;\\n        d3_layout_packInsert(c, b);\\n        b = a._pack_next;\\n        for (i = 3; i < n; i++) {\\n          d3_layout_packPlace(a, b, c = nodes[i]);\\n          var isect = 0, s1 = 1, s2 = 1;\\n          for (j = b._pack_next; j !== b; j = j._pack_next, s1++) {\\n            if (d3_layout_packIntersects(j, c)) {\\n              isect = 1;\\n              break;\\n            }\\n          }\\n          if (isect == 1) {\\n            for (k = a._pack_prev; k !== j._pack_prev; k = k._pack_prev, s2++) {\\n              if (d3_layout_packIntersects(k, c)) {\\n                break;\\n              }\\n            }\\n          }\\n          if (isect) {\\n            if (s1 < s2 || s1 == s2 && b.r < a.r) d3_layout_packSplice(a, b = j); else d3_layout_packSplice(a = k, b);\\n            i--;\\n          } else {\\n            d3_layout_packInsert(a, c);\\n            b = c;\\n            bound(c);\\n          }\\n        }\\n      }\\n    }\\n    var cx = (xMin + xMax) / 2, cy = (yMin + yMax) / 2, cr = 0;\\n    for (i = 0; i < n; i++) {\\n      c = nodes[i];\\n      c.x -= cx;\\n      c.y -= cy;\\n      cr = Math.max(cr, c.r + Math.sqrt(c.x * c.x + c.y * c.y));\\n    }\\n    node.r = cr;\\n    nodes.forEach(d3_layout_packUnlink);\\n  }\\n  function d3_layout_packLink(node) {\\n    node._pack_next = node._pack_prev = node;\\n  }\\n  function d3_layout_packUnlink(node) {\\n    delete node._pack_next;\\n    delete node._pack_prev;\\n  }\\n  function d3_layout_packTransform(node, x, y, k) {\\n    var children = node.children;\\n    node.x = x += k * node.x;\\n    node.y = y += k * node.y;\\n    node.r *= k;\\n    if (children) {\\n      var i = -1, n = children.length;\\n      while (++i < n) d3_layout_packTransform(children[i], x, y, k);\\n    }\\n  }\\n  function d3_layout_packPlace(a, b, c) {\\n    var db = a.r + c.r, dx = b.x - a.x, dy = b.y - a.y;\\n    if (db && (dx || dy)) {\\n      var da = b.r + c.r, dc = dx * dx + dy * dy;\\n      da *= da;\\n      db *= db;\\n      var x = .5 + (db - da) / (2 * dc), y = Math.sqrt(Math.max(0, 2 * da * (db + dc) - (db -= dc) * db - da * da)) / (2 * dc);\\n      c.x = a.x + x * dx + y * dy;\\n      c.y = a.y + x * dy - y * dx;\\n    } else {\\n      c.x = a.x + db;\\n      c.y = a.y;\\n    }\\n  }\\n  d3.layout.tree = function() {\\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = null;\\n    function tree(d, i) {\\n      var nodes = hierarchy.call(this, d, i), root0 = nodes[0], root1 = wrapTree(root0);\\n      d3_layout_hierarchyVisitAfter(root1, firstWalk), root1.parent.m = -root1.z;\\n      d3_layout_hierarchyVisitBefore(root1, secondWalk);\\n      if (nodeSize) d3_layout_hierarchyVisitBefore(root0, sizeNode); else {\\n        var left = root0, right = root0, bottom = root0;\\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\\n          if (node.x < left.x) left = node;\\n          if (node.x > right.x) right = node;\\n          if (node.depth > bottom.depth) bottom = node;\\n        });\\n        var tx = separation(left, right) / 2 - left.x, kx = size[0] / (right.x + separation(right, left) / 2 + tx), ky = size[1] / (bottom.depth || 1);\\n        d3_layout_hierarchyVisitBefore(root0, function(node) {\\n          node.x = (node.x + tx) * kx;\\n          node.y = node.depth * ky;\\n        });\\n      }\\n      return nodes;\\n    }\\n    function wrapTree(root0) {\\n      var root1 = {\\n        A: null,\\n        children: [ root0 ]\\n      }, queue = [ root1 ], node1;\\n      while ((node1 = queue.pop()) != null) {\\n        for (var children = node1.children, child, i = 0, n = children.length; i < n; ++i) {\\n          queue.push((children[i] = child = {\\n            _: children[i],\\n            parent: node1,\\n            children: (child = children[i].children) && child.slice() || [],\\n            A: null,\\n            a: null,\\n            z: 0,\\n            m: 0,\\n            c: 0,\\n            s: 0,\\n            t: null,\\n            i: i\\n          }).a = child);\\n        }\\n      }\\n      return root1.children[0];\\n    }\\n    function firstWalk(v) {\\n      var children = v.children, siblings = v.parent.children, w = v.i ? siblings[v.i - 1] : null;\\n      if (children.length) {\\n        d3_layout_treeShift(v);\\n        var midpoint = (children[0].z + children[children.length - 1].z) / 2;\\n        if (w) {\\n          v.z = w.z + separation(v._, w._);\\n          v.m = v.z - midpoint;\\n        } else {\\n          v.z = midpoint;\\n        }\\n      } else if (w) {\\n        v.z = w.z + separation(v._, w._);\\n      }\\n      v.parent.A = apportion(v, w, v.parent.A || siblings[0]);\\n    }\\n    function secondWalk(v) {\\n      v._.x = v.z + v.parent.m;\\n      v.m += v.parent.m;\\n    }\\n    function apportion(v, w, ancestor) {\\n      if (w) {\\n        var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;\\n        while (vim = d3_layout_treeRight(vim), vip = d3_layout_treeLeft(vip), vim && vip) {\\n          vom = d3_layout_treeLeft(vom);\\n          vop = d3_layout_treeRight(vop);\\n          vop.a = v;\\n          shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);\\n          if (shift > 0) {\\n            d3_layout_treeMove(d3_layout_treeAncestor(vim, v, ancestor), v, shift);\\n            sip += shift;\\n            sop += shift;\\n          }\\n          sim += vim.m;\\n          sip += vip.m;\\n          som += vom.m;\\n          sop += vop.m;\\n        }\\n        if (vim && !d3_layout_treeRight(vop)) {\\n          vop.t = vim;\\n          vop.m += sim - sop;\\n        }\\n        if (vip && !d3_layout_treeLeft(vom)) {\\n          vom.t = vip;\\n          vom.m += sip - som;\\n          ancestor = v;\\n        }\\n      }\\n      return ancestor;\\n    }\\n    function sizeNode(node) {\\n      node.x *= size[0];\\n      node.y = node.depth * size[1];\\n    }\\n    tree.separation = function(x) {\\n      if (!arguments.length) return separation;\\n      separation = x;\\n      return tree;\\n    };\\n    tree.size = function(x) {\\n      if (!arguments.length) return nodeSize ? null : size;\\n      nodeSize = (size = x) == null ? sizeNode : null;\\n      return tree;\\n    };\\n    tree.nodeSize = function(x) {\\n      if (!arguments.length) return nodeSize ? size : null;\\n      nodeSize = (size = x) == null ? null : sizeNode;\\n      return tree;\\n    };\\n    return d3_layout_hierarchyRebind(tree, hierarchy);\\n  };\\n  function d3_layout_treeSeparation(a, b) {\\n    return a.parent == b.parent ? 1 : 2;\\n  }\\n  function d3_layout_treeLeft(v) {\\n    var children = v.children;\\n    return children.length ? children[0] : v.t;\\n  }\\n  function d3_layout_treeRight(v) {\\n    var children = v.children, n;\\n    return (n = children.length) ? children[n - 1] : v.t;\\n  }\\n  function d3_layout_treeMove(wm, wp, shift) {\\n    var change = shift / (wp.i - wm.i);\\n    wp.c -= change;\\n    wp.s += shift;\\n    wm.c += change;\\n    wp.z += shift;\\n    wp.m += shift;\\n  }\\n  function d3_layout_treeShift(v) {\\n    var shift = 0, change = 0, children = v.children, i = children.length, w;\\n    while (--i >= 0) {\\n      w = children[i];\\n      w.z += shift;\\n      w.m += shift;\\n      shift += w.s + (change += w.c);\\n    }\\n  }\\n  function d3_layout_treeAncestor(vim, v, ancestor) {\\n    return vim.a.parent === v.parent ? vim.a : ancestor;\\n  }\\n  d3.layout.cluster = function() {\\n    var hierarchy = d3.layout.hierarchy().sort(null).value(null), separation = d3_layout_treeSeparation, size = [ 1, 1 ], nodeSize = false;\\n    function cluster(d, i) {\\n      var nodes = hierarchy.call(this, d, i), root = nodes[0], previousNode, x = 0;\\n      d3_layout_hierarchyVisitAfter(root, function(node) {\\n        var children = node.children;\\n        if (children && children.length) {\\n          node.x = d3_layout_clusterX(children);\\n          node.y = d3_layout_clusterY(children);\\n        } else {\\n          node.x = previousNode ? x += separation(node, previousNode) : 0;\\n          node.y = 0;\\n          previousNode = node;\\n        }\\n      });\\n      var left = d3_layout_clusterLeft(root), right = d3_layout_clusterRight(root), x0 = left.x - separation(left, right) / 2, x1 = right.x + separation(right, left) / 2;\\n      d3_layout_hierarchyVisitAfter(root, nodeSize ? function(node) {\\n        node.x = (node.x - root.x) * size[0];\\n        node.y = (root.y - node.y) * size[1];\\n      } : function(node) {\\n        node.x = (node.x - x0) / (x1 - x0) * size[0];\\n        node.y = (1 - (root.y ? node.y / root.y : 1)) * size[1];\\n      });\\n      return nodes;\\n    }\\n    cluster.separation = function(x) {\\n      if (!arguments.length) return separation;\\n      separation = x;\\n      return cluster;\\n    };\\n    cluster.size = function(x) {\\n      if (!arguments.length) return nodeSize ? null : size;\\n      nodeSize = (size = x) == null;\\n      return cluster;\\n    };\\n    cluster.nodeSize = function(x) {\\n      if (!arguments.length) return nodeSize ? size : null;\\n      nodeSize = (size = x) != null;\\n      return cluster;\\n    };\\n    return d3_layout_hierarchyRebind(cluster, hierarchy);\\n  };\\n  function d3_layout_clusterY(children) {\\n    return 1 + d3.max(children, function(child) {\\n      return child.y;\\n    });\\n  }\\n  function d3_layout_clusterX(children) {\\n    return children.reduce(function(x, child) {\\n      return x + child.x;\\n    }, 0) / children.length;\\n  }\\n  function d3_layout_clusterLeft(node) {\\n    var children = node.children;\\n    return children && children.length ? d3_layout_clusterLeft(children[0]) : node;\\n  }\\n  function d3_layout_clusterRight(node) {\\n    var children = node.children, n;\\n    return children && (n = children.length) ? d3_layout_clusterRight(children[n - 1]) : node;\\n  }\\n  d3.layout.treemap = function() {\\n    var hierarchy = d3.layout.hierarchy(), round = Math.round, size = [ 1, 1 ], padding = null, pad = d3_layout_treemapPadNull, sticky = false, stickies, mode = \\\"squarify\\\", ratio = .5 * (1 + Math.sqrt(5));\\n    function scale(children, k) {\\n      var i = -1, n = children.length, child, area;\\n      while (++i < n) {\\n        area = (child = children[i]).value * (k < 0 ? 0 : k);\\n        child.area = isNaN(area) || area <= 0 ? 0 : area;\\n      }\\n    }\\n    function squarify(node) {\\n      var children = node.children;\\n      if (children && children.length) {\\n        var rect = pad(node), row = [], remaining = children.slice(), child, best = Infinity, score, u = mode === \\\"slice\\\" ? rect.dx : mode === \\\"dice\\\" ? rect.dy : mode === \\\"slice-dice\\\" ? node.depth & 1 ? rect.dy : rect.dx : Math.min(rect.dx, rect.dy), n;\\n        scale(remaining, rect.dx * rect.dy / node.value);\\n        row.area = 0;\\n        while ((n = remaining.length) > 0) {\\n          row.push(child = remaining[n - 1]);\\n          row.area += child.area;\\n          if (mode !== \\\"squarify\\\" || (score = worst(row, u)) <= best) {\\n            remaining.pop();\\n            best = score;\\n          } else {\\n            row.area -= row.pop().area;\\n            position(row, u, rect, false);\\n            u = Math.min(rect.dx, rect.dy);\\n            row.length = row.area = 0;\\n            best = Infinity;\\n          }\\n        }\\n        if (row.length) {\\n          position(row, u, rect, true);\\n          row.length = row.area = 0;\\n        }\\n        children.forEach(squarify);\\n      }\\n    }\\n    function stickify(node) {\\n      var children = node.children;\\n      if (children && children.length) {\\n        var rect = pad(node), remaining = children.slice(), child, row = [];\\n        scale(remaining, rect.dx * rect.dy / node.value);\\n        row.area = 0;\\n        while (child = remaining.pop()) {\\n          row.push(child);\\n          row.area += child.area;\\n          if (child.z != null) {\\n            position(row, child.z ? rect.dx : rect.dy, rect, !remaining.length);\\n            row.length = row.area = 0;\\n          }\\n        }\\n        children.forEach(stickify);\\n      }\\n    }\\n    function worst(row, u) {\\n      var s = row.area, r, rmax = 0, rmin = Infinity, i = -1, n = row.length;\\n      while (++i < n) {\\n        if (!(r = row[i].area)) continue;\\n        if (r < rmin) rmin = r;\\n        if (r > rmax) rmax = r;\\n      }\\n      s *= s;\\n      u *= u;\\n      return s ? Math.max(u * rmax * ratio / s, s / (u * rmin * ratio)) : Infinity;\\n    }\\n    function position(row, u, rect, flush) {\\n      var i = -1, n = row.length, x = rect.x, y = rect.y, v = u ? round(row.area / u) : 0, o;\\n      if (u == rect.dx) {\\n        if (flush || v > rect.dy) v = rect.dy;\\n        while (++i < n) {\\n          o = row[i];\\n          o.x = x;\\n          o.y = y;\\n          o.dy = v;\\n          x += o.dx = Math.min(rect.x + rect.dx - x, v ? round(o.area / v) : 0);\\n        }\\n        o.z = true;\\n        o.dx += rect.x + rect.dx - x;\\n        rect.y += v;\\n        rect.dy -= v;\\n      } else {\\n        if (flush || v > rect.dx) v = rect.dx;\\n        while (++i < n) {\\n          o = row[i];\\n          o.x = x;\\n          o.y = y;\\n          o.dx = v;\\n          y += o.dy = Math.min(rect.y + rect.dy - y, v ? round(o.area / v) : 0);\\n        }\\n        o.z = false;\\n        o.dy += rect.y + rect.dy - y;\\n        rect.x += v;\\n        rect.dx -= v;\\n      }\\n    }\\n    function treemap(d) {\\n      var nodes = stickies || hierarchy(d), root = nodes[0];\\n      root.x = root.y = 0;\\n      if (root.value) root.dx = size[0], root.dy = size[1]; else root.dx = root.dy = 0;\\n      if (stickies) hierarchy.revalue(root);\\n      scale([ root ], root.dx * root.dy / root.value);\\n      (stickies ? stickify : squarify)(root);\\n      if (sticky) stickies = nodes;\\n      return nodes;\\n    }\\n    treemap.size = function(x) {\\n      if (!arguments.length) return size;\\n      size = x;\\n      return treemap;\\n    };\\n    treemap.padding = function(x) {\\n      if (!arguments.length) return padding;\\n      function padFunction(node) {\\n        var p = x.call(treemap, node, node.depth);\\n        return p == null ? d3_layout_treemapPadNull(node) : d3_layout_treemapPad(node, typeof p === \\\"number\\\" ? [ p, p, p, p ] : p);\\n      }\\n      function padConstant(node) {\\n        return d3_layout_treemapPad(node, x);\\n      }\\n      var type;\\n      pad = (padding = x) == null ? d3_layout_treemapPadNull : (type = typeof x) === \\\"function\\\" ? padFunction : type === \\\"number\\\" ? (x = [ x, x, x, x ], \\n      padConstant) : padConstant;\\n      return treemap;\\n    };\\n    treemap.round = function(x) {\\n      if (!arguments.length) return round != Number;\\n      round = x ? Math.round : Number;\\n      return treemap;\\n    };\\n    treemap.sticky = function(x) {\\n      if (!arguments.length) return sticky;\\n      sticky = x;\\n      stickies = null;\\n      return treemap;\\n    };\\n    treemap.ratio = function(x) {\\n      if (!arguments.length) return ratio;\\n      ratio = x;\\n      return treemap;\\n    };\\n    treemap.mode = function(x) {\\n      if (!arguments.length) return mode;\\n      mode = x + \\\"\\\";\\n      return treemap;\\n    };\\n    return d3_layout_hierarchyRebind(treemap, hierarchy);\\n  };\\n  function d3_layout_treemapPadNull(node) {\\n    return {\\n      x: node.x,\\n      y: node.y,\\n      dx: node.dx,\\n      dy: node.dy\\n    };\\n  }\\n  function d3_layout_treemapPad(node, padding) {\\n    var x = node.x + padding[3], y = node.y + padding[0], dx = node.dx - padding[1] - padding[3], dy = node.dy - padding[0] - padding[2];\\n    if (dx < 0) {\\n      x += dx / 2;\\n      dx = 0;\\n    }\\n    if (dy < 0) {\\n      y += dy / 2;\\n      dy = 0;\\n    }\\n    return {\\n      x: x,\\n      y: y,\\n      dx: dx,\\n      dy: dy\\n    };\\n  }\\n  d3.random = {\\n    normal: function(µ, σ) {\\n      var n = arguments.length;\\n      if (n < 2) σ = 1;\\n      if (n < 1) µ = 0;\\n      return function() {\\n        var x, y, r;\\n        do {\\n          x = Math.random() * 2 - 1;\\n          y = Math.random() * 2 - 1;\\n          r = x * x + y * y;\\n        } while (!r || r > 1);\\n        return µ + σ * x * Math.sqrt(-2 * Math.log(r) / r);\\n      };\\n    },\\n    logNormal: function() {\\n      var random = d3.random.normal.apply(d3, arguments);\\n      return function() {\\n        return Math.exp(random());\\n      };\\n    },\\n    bates: function(m) {\\n      var random = d3.random.irwinHall(m);\\n      return function() {\\n        return random() / m;\\n      };\\n    },\\n    irwinHall: function(m) {\\n      return function() {\\n        for (var s = 0, j = 0; j < m; j++) s += Math.random();\\n        return s;\\n      };\\n    }\\n  };\\n  d3.scale = {};\\n  function d3_scaleExtent(domain) {\\n    var start = domain[0], stop = domain[domain.length - 1];\\n    return start < stop ? [ start, stop ] : [ stop, start ];\\n  }\\n  function d3_scaleRange(scale) {\\n    return scale.rangeExtent ? scale.rangeExtent() : d3_scaleExtent(scale.range());\\n  }\\n  function d3_scale_bilinear(domain, range, uninterpolate, interpolate) {\\n    var u = uninterpolate(domain[0], domain[1]), i = interpolate(range[0], range[1]);\\n    return function(x) {\\n      return i(u(x));\\n    };\\n  }\\n  function d3_scale_nice(domain, nice) {\\n    var i0 = 0, i1 = domain.length - 1, x0 = domain[i0], x1 = domain[i1], dx;\\n    if (x1 < x0) {\\n      dx = i0, i0 = i1, i1 = dx;\\n      dx = x0, x0 = x1, x1 = dx;\\n    }\\n    domain[i0] = nice.floor(x0);\\n    domain[i1] = nice.ceil(x1);\\n    return domain;\\n  }\\n  function d3_scale_niceStep(step) {\\n    return step ? {\\n      floor: function(x) {\\n        return Math.floor(x / step) * step;\\n      },\\n      ceil: function(x) {\\n        return Math.ceil(x / step) * step;\\n      }\\n    } : d3_scale_niceIdentity;\\n  }\\n  var d3_scale_niceIdentity = {\\n    floor: d3_identity,\\n    ceil: d3_identity\\n  };\\n  function d3_scale_polylinear(domain, range, uninterpolate, interpolate) {\\n    var u = [], i = [], j = 0, k = Math.min(domain.length, range.length) - 1;\\n    if (domain[k] < domain[0]) {\\n      domain = domain.slice().reverse();\\n      range = range.slice().reverse();\\n    }\\n    while (++j <= k) {\\n      u.push(uninterpolate(domain[j - 1], domain[j]));\\n      i.push(interpolate(range[j - 1], range[j]));\\n    }\\n    return function(x) {\\n      var j = d3.bisect(domain, x, 1, k) - 1;\\n      return i[j](u[j](x));\\n    };\\n  }\\n  d3.scale.linear = function() {\\n    return d3_scale_linear([ 0, 1 ], [ 0, 1 ], d3_interpolate, false);\\n  };\\n  function d3_scale_linear(domain, range, interpolate, clamp) {\\n    var output, input;\\n    function rescale() {\\n      var linear = Math.min(domain.length, range.length) > 2 ? d3_scale_polylinear : d3_scale_bilinear, uninterpolate = clamp ? d3_uninterpolateClamp : d3_uninterpolateNumber;\\n      output = linear(domain, range, uninterpolate, interpolate);\\n      input = linear(range, domain, uninterpolate, d3_interpolate);\\n      return scale;\\n    }\\n    function scale(x) {\\n      return output(x);\\n    }\\n    scale.invert = function(y) {\\n      return input(y);\\n    };\\n    scale.domain = function(x) {\\n      if (!arguments.length) return domain;\\n      domain = x.map(Number);\\n      return rescale();\\n    };\\n    scale.range = function(x) {\\n      if (!arguments.length) return range;\\n      range = x;\\n      return rescale();\\n    };\\n    scale.rangeRound = function(x) {\\n      return scale.range(x).interpolate(d3_interpolateRound);\\n    };\\n    scale.clamp = function(x) {\\n      if (!arguments.length) return clamp;\\n      clamp = x;\\n      return rescale();\\n    };\\n    scale.interpolate = function(x) {\\n      if (!arguments.length) return interpolate;\\n      interpolate = x;\\n      return rescale();\\n    };\\n    scale.ticks = function(m) {\\n      return d3_scale_linearTicks(domain, m);\\n    };\\n    scale.tickFormat = function(m, format) {\\n      return d3_scale_linearTickFormat(domain, m, format);\\n    };\\n    scale.nice = function(m) {\\n      d3_scale_linearNice(domain, m);\\n      return rescale();\\n    };\\n    scale.copy = function() {\\n      return d3_scale_linear(domain, range, interpolate, clamp);\\n    };\\n    return rescale();\\n  }\\n  function d3_scale_linearRebind(scale, linear) {\\n    return d3.rebind(scale, linear, \\\"range\\\", \\\"rangeRound\\\", \\\"interpolate\\\", \\\"clamp\\\");\\n  }\\n  function d3_scale_linearNice(domain, m) {\\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\\n    d3_scale_nice(domain, d3_scale_niceStep(d3_scale_linearTickRange(domain, m)[2]));\\n    return domain;\\n  }\\n  function d3_scale_linearTickRange(domain, m) {\\n    if (m == null) m = 10;\\n    var extent = d3_scaleExtent(domain), span = extent[1] - extent[0], step = Math.pow(10, Math.floor(Math.log(span / m) / Math.LN10)), err = m / span * step;\\n    if (err <= .15) step *= 10; else if (err <= .35) step *= 5; else if (err <= .75) step *= 2;\\n    extent[0] = Math.ceil(extent[0] / step) * step;\\n    extent[1] = Math.floor(extent[1] / step) * step + step * .5;\\n    extent[2] = step;\\n    return extent;\\n  }\\n  function d3_scale_linearTicks(domain, m) {\\n    return d3.range.apply(d3, d3_scale_linearTickRange(domain, m));\\n  }\\n  function d3_scale_linearTickFormat(domain, m, format) {\\n    var range = d3_scale_linearTickRange(domain, m);\\n    if (format) {\\n      var match = d3_format_re.exec(format);\\n      match.shift();\\n      if (match[8] === \\\"s\\\") {\\n        var prefix = d3.formatPrefix(Math.max(abs(range[0]), abs(range[1])));\\n        if (!match[7]) match[7] = \\\".\\\" + d3_scale_linearPrecision(prefix.scale(range[2]));\\n        match[8] = \\\"f\\\";\\n        format = d3.format(match.join(\\\"\\\"));\\n        return function(d) {\\n          return format(prefix.scale(d)) + prefix.symbol;\\n        };\\n      }\\n      if (!match[7]) match[7] = \\\".\\\" + d3_scale_linearFormatPrecision(match[8], range);\\n      format = match.join(\\\"\\\");\\n    } else {\\n      format = \\\",.\\\" + d3_scale_linearPrecision(range[2]) + \\\"f\\\";\\n    }\\n    return d3.format(format);\\n  }\\n  var d3_scale_linearFormatSignificant = {\\n    s: 1,\\n    g: 1,\\n    p: 1,\\n    r: 1,\\n    e: 1\\n  };\\n  function d3_scale_linearPrecision(value) {\\n    return -Math.floor(Math.log(value) / Math.LN10 + .01);\\n  }\\n  function d3_scale_linearFormatPrecision(type, range) {\\n    var p = d3_scale_linearPrecision(range[2]);\\n    return type in d3_scale_linearFormatSignificant ? Math.abs(p - d3_scale_linearPrecision(Math.max(abs(range[0]), abs(range[1])))) + +(type !== \\\"e\\\") : p - (type === \\\"%\\\") * 2;\\n  }\\n  d3.scale.log = function() {\\n    return d3_scale_log(d3.scale.linear().domain([ 0, 1 ]), 10, true, [ 1, 10 ]);\\n  };\\n  function d3_scale_log(linear, base, positive, domain) {\\n    function log(x) {\\n      return (positive ? Math.log(x < 0 ? 0 : x) : -Math.log(x > 0 ? 0 : -x)) / Math.log(base);\\n    }\\n    function pow(x) {\\n      return positive ? Math.pow(base, x) : -Math.pow(base, -x);\\n    }\\n    function scale(x) {\\n      return linear(log(x));\\n    }\\n    scale.invert = function(x) {\\n      return pow(linear.invert(x));\\n    };\\n    scale.domain = function(x) {\\n      if (!arguments.length) return domain;\\n      positive = x[0] >= 0;\\n      linear.domain((domain = x.map(Number)).map(log));\\n      return scale;\\n    };\\n    scale.base = function(_) {\\n      if (!arguments.length) return base;\\n      base = +_;\\n      linear.domain(domain.map(log));\\n      return scale;\\n    };\\n    scale.nice = function() {\\n      var niced = d3_scale_nice(domain.map(log), positive ? Math : d3_scale_logNiceNegative);\\n      linear.domain(niced);\\n      domain = niced.map(pow);\\n      return scale;\\n    };\\n    scale.ticks = function() {\\n      var extent = d3_scaleExtent(domain), ticks = [], u = extent[0], v = extent[1], i = Math.floor(log(u)), j = Math.ceil(log(v)), n = base % 1 ? 2 : base;\\n      if (isFinite(j - i)) {\\n        if (positive) {\\n          for (;i < j; i++) for (var k = 1; k < n; k++) ticks.push(pow(i) * k);\\n          ticks.push(pow(i));\\n        } else {\\n          ticks.push(pow(i));\\n          for (;i++ < j; ) for (var k = n - 1; k > 0; k--) ticks.push(pow(i) * k);\\n        }\\n        for (i = 0; ticks[i] < u; i++) {}\\n        for (j = ticks.length; ticks[j - 1] > v; j--) {}\\n        ticks = ticks.slice(i, j);\\n      }\\n      return ticks;\\n    };\\n    scale.tickFormat = function(n, format) {\\n      if (!arguments.length) return d3_scale_logFormat;\\n      if (arguments.length < 2) format = d3_scale_logFormat; else if (typeof format !== \\\"function\\\") format = d3.format(format);\\n      var k = Math.max(1, base * n / scale.ticks().length);\\n      return function(d) {\\n        var i = d / pow(Math.round(log(d)));\\n        if (i * base < base - .5) i *= base;\\n        return i <= k ? format(d) : \\\"\\\";\\n      };\\n    };\\n    scale.copy = function() {\\n      return d3_scale_log(linear.copy(), base, positive, domain);\\n    };\\n    return d3_scale_linearRebind(scale, linear);\\n  }\\n  var d3_scale_logFormat = d3.format(\\\".0e\\\"), d3_scale_logNiceNegative = {\\n    floor: function(x) {\\n      return -Math.ceil(-x);\\n    },\\n    ceil: function(x) {\\n      return -Math.floor(-x);\\n    }\\n  };\\n  d3.scale.pow = function() {\\n    return d3_scale_pow(d3.scale.linear(), 1, [ 0, 1 ]);\\n  };\\n  function d3_scale_pow(linear, exponent, domain) {\\n    var powp = d3_scale_powPow(exponent), powb = d3_scale_powPow(1 / exponent);\\n    function scale(x) {\\n      return linear(powp(x));\\n    }\\n    scale.invert = function(x) {\\n      return powb(linear.invert(x));\\n    };\\n    scale.domain = function(x) {\\n      if (!arguments.length) return domain;\\n      linear.domain((domain = x.map(Number)).map(powp));\\n      return scale;\\n    };\\n    scale.ticks = function(m) {\\n      return d3_scale_linearTicks(domain, m);\\n    };\\n    scale.tickFormat = function(m, format) {\\n      return d3_scale_linearTickFormat(domain, m, format);\\n    };\\n    scale.nice = function(m) {\\n      return scale.domain(d3_scale_linearNice(domain, m));\\n    };\\n    scale.exponent = function(x) {\\n      if (!arguments.length) return exponent;\\n      powp = d3_scale_powPow(exponent = x);\\n      powb = d3_scale_powPow(1 / exponent);\\n      linear.domain(domain.map(powp));\\n      return scale;\\n    };\\n    scale.copy = function() {\\n      return d3_scale_pow(linear.copy(), exponent, domain);\\n    };\\n    return d3_scale_linearRebind(scale, linear);\\n  }\\n  function d3_scale_powPow(e) {\\n    return function(x) {\\n      return x < 0 ? -Math.pow(-x, e) : Math.pow(x, e);\\n    };\\n  }\\n  d3.scale.sqrt = function() {\\n    return d3.scale.pow().exponent(.5);\\n  };\\n  d3.scale.ordinal = function() {\\n    return d3_scale_ordinal([], {\\n      t: \\\"range\\\",\\n      a: [ [] ]\\n    });\\n  };\\n  function d3_scale_ordinal(domain, ranger) {\\n    var index, range, rangeBand;\\n    function scale(x) {\\n      return range[((index.get(x) || (ranger.t === \\\"range\\\" ? index.set(x, domain.push(x)) : NaN)) - 1) % range.length];\\n    }\\n    function steps(start, step) {\\n      return d3.range(domain.length).map(function(i) {\\n        return start + step * i;\\n      });\\n    }\\n    scale.domain = function(x) {\\n      if (!arguments.length) return domain;\\n      domain = [];\\n      index = new d3_Map();\\n      var i = -1, n = x.length, xi;\\n      while (++i < n) if (!index.has(xi = x[i])) index.set(xi, domain.push(xi));\\n      return scale[ranger.t].apply(scale, ranger.a);\\n    };\\n    scale.range = function(x) {\\n      if (!arguments.length) return range;\\n      range = x;\\n      rangeBand = 0;\\n      ranger = {\\n        t: \\\"range\\\",\\n        a: arguments\\n      };\\n      return scale;\\n    };\\n    scale.rangePoints = function(x, padding) {\\n      if (arguments.length < 2) padding = 0;\\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = (start + stop) / 2, \\n      0) : (stop - start) / (domain.length - 1 + padding);\\n      range = steps(start + step * padding / 2, step);\\n      rangeBand = 0;\\n      ranger = {\\n        t: \\\"rangePoints\\\",\\n        a: arguments\\n      };\\n      return scale;\\n    };\\n    scale.rangeRoundPoints = function(x, padding) {\\n      if (arguments.length < 2) padding = 0;\\n      var start = x[0], stop = x[1], step = domain.length < 2 ? (start = stop = Math.round((start + stop) / 2), \\n      0) : (stop - start) / (domain.length - 1 + padding) | 0;\\n      range = steps(start + Math.round(step * padding / 2 + (stop - start - (domain.length - 1 + padding) * step) / 2), step);\\n      rangeBand = 0;\\n      ranger = {\\n        t: \\\"rangeRoundPoints\\\",\\n        a: arguments\\n      };\\n      return scale;\\n    };\\n    scale.rangeBands = function(x, padding, outerPadding) {\\n      if (arguments.length < 2) padding = 0;\\n      if (arguments.length < 3) outerPadding = padding;\\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = (stop - start) / (domain.length - padding + 2 * outerPadding);\\n      range = steps(start + step * outerPadding, step);\\n      if (reverse) range.reverse();\\n      rangeBand = step * (1 - padding);\\n      ranger = {\\n        t: \\\"rangeBands\\\",\\n        a: arguments\\n      };\\n      return scale;\\n    };\\n    scale.rangeRoundBands = function(x, padding, outerPadding) {\\n      if (arguments.length < 2) padding = 0;\\n      if (arguments.length < 3) outerPadding = padding;\\n      var reverse = x[1] < x[0], start = x[reverse - 0], stop = x[1 - reverse], step = Math.floor((stop - start) / (domain.length - padding + 2 * outerPadding));\\n      range = steps(start + Math.round((stop - start - (domain.length - padding) * step) / 2), step);\\n      if (reverse) range.reverse();\\n      rangeBand = Math.round(step * (1 - padding));\\n      ranger = {\\n        t: \\\"rangeRoundBands\\\",\\n        a: arguments\\n      };\\n      return scale;\\n    };\\n    scale.rangeBand = function() {\\n      return rangeBand;\\n    };\\n    scale.rangeExtent = function() {\\n      return d3_scaleExtent(ranger.a[0]);\\n    };\\n    scale.copy = function() {\\n      return d3_scale_ordinal(domain, ranger);\\n    };\\n    return scale.domain(domain);\\n  }\\n  d3.scale.category10 = function() {\\n    return d3.scale.ordinal().range(d3_category10);\\n  };\\n  d3.scale.category20 = function() {\\n    return d3.scale.ordinal().range(d3_category20);\\n  };\\n  d3.scale.category20b = function() {\\n    return d3.scale.ordinal().range(d3_category20b);\\n  };\\n  d3.scale.category20c = function() {\\n    return d3.scale.ordinal().range(d3_category20c);\\n  };\\n  var d3_category10 = [ 2062260, 16744206, 2924588, 14034728, 9725885, 9197131, 14907330, 8355711, 12369186, 1556175 ].map(d3_rgbString);\\n  var d3_category20 = [ 2062260, 11454440, 16744206, 16759672, 2924588, 10018698, 14034728, 16750742, 9725885, 12955861, 9197131, 12885140, 14907330, 16234194, 8355711, 13092807, 12369186, 14408589, 1556175, 10410725 ].map(d3_rgbString);\\n  var d3_category20b = [ 3750777, 5395619, 7040719, 10264286, 6519097, 9216594, 11915115, 13556636, 9202993, 12426809, 15186514, 15190932, 8666169, 11356490, 14049643, 15177372, 8077683, 10834324, 13528509, 14589654 ].map(d3_rgbString);\\n  var d3_category20c = [ 3244733, 7057110, 10406625, 13032431, 15095053, 16616764, 16625259, 16634018, 3253076, 7652470, 10607003, 13101504, 7695281, 10394312, 12369372, 14342891, 6513507, 9868950, 12434877, 14277081 ].map(d3_rgbString);\\n  d3.scale.quantile = function() {\\n    return d3_scale_quantile([], []);\\n  };\\n  function d3_scale_quantile(domain, range) {\\n    var thresholds;\\n    function rescale() {\\n      var k = 0, q = range.length;\\n      thresholds = [];\\n      while (++k < q) thresholds[k - 1] = d3.quantile(domain, k / q);\\n      return scale;\\n    }\\n    function scale(x) {\\n      if (!isNaN(x = +x)) return range[d3.bisect(thresholds, x)];\\n    }\\n    scale.domain = function(x) {\\n      if (!arguments.length) return domain;\\n      domain = x.map(d3_number).filter(d3_numeric).sort(d3_ascending);\\n      return rescale();\\n    };\\n    scale.range = function(x) {\\n      if (!arguments.length) return range;\\n      range = x;\\n      return rescale();\\n    };\\n    scale.quantiles = function() {\\n      return thresholds;\\n    };\\n    scale.invertExtent = function(y) {\\n      y = range.indexOf(y);\\n      return y < 0 ? [ NaN, NaN ] : [ y > 0 ? thresholds[y - 1] : domain[0], y < thresholds.length ? thresholds[y] : domain[domain.length - 1] ];\\n    };\\n    scale.copy = function() {\\n      return d3_scale_quantile(domain, range);\\n    };\\n    return rescale();\\n  }\\n  d3.scale.quantize = function() {\\n    return d3_scale_quantize(0, 1, [ 0, 1 ]);\\n  };\\n  function d3_scale_quantize(x0, x1, range) {\\n    var kx, i;\\n    function scale(x) {\\n      return range[Math.max(0, Math.min(i, Math.floor(kx * (x - x0))))];\\n    }\\n    function rescale() {\\n      kx = range.length / (x1 - x0);\\n      i = range.length - 1;\\n      return scale;\\n    }\\n    scale.domain = function(x) {\\n      if (!arguments.length) return [ x0, x1 ];\\n      x0 = +x[0];\\n      x1 = +x[x.length - 1];\\n      return rescale();\\n    };\\n    scale.range = function(x) {\\n      if (!arguments.length) return range;\\n      range = x;\\n      return rescale();\\n    };\\n    scale.invertExtent = function(y) {\\n      y = range.indexOf(y);\\n      y = y < 0 ? NaN : y / kx + x0;\\n      return [ y, y + 1 / kx ];\\n    };\\n    scale.copy = function() {\\n      return d3_scale_quantize(x0, x1, range);\\n    };\\n    return rescale();\\n  }\\n  d3.scale.threshold = function() {\\n    return d3_scale_threshold([ .5 ], [ 0, 1 ]);\\n  };\\n  function d3_scale_threshold(domain, range) {\\n    function scale(x) {\\n      if (x <= x) return range[d3.bisect(domain, x)];\\n    }\\n    scale.domain = function(_) {\\n      if (!arguments.length) return domain;\\n      domain = _;\\n      return scale;\\n    };\\n    scale.range = function(_) {\\n      if (!arguments.length) return range;\\n      range = _;\\n      return scale;\\n    };\\n    scale.invertExtent = function(y) {\\n      y = range.indexOf(y);\\n      return [ domain[y - 1], domain[y] ];\\n    };\\n    scale.copy = function() {\\n      return d3_scale_threshold(domain, range);\\n    };\\n    return scale;\\n  }\\n  d3.scale.identity = function() {\\n    return d3_scale_identity([ 0, 1 ]);\\n  };\\n  function d3_scale_identity(domain) {\\n    function identity(x) {\\n      return +x;\\n    }\\n    identity.invert = identity;\\n    identity.domain = identity.range = function(x) {\\n      if (!arguments.length) return domain;\\n      domain = x.map(identity);\\n      return identity;\\n    };\\n    identity.ticks = function(m) {\\n      return d3_scale_linearTicks(domain, m);\\n    };\\n    identity.tickFormat = function(m, format) {\\n      return d3_scale_linearTickFormat(domain, m, format);\\n    };\\n    identity.copy = function() {\\n      return d3_scale_identity(domain);\\n    };\\n    return identity;\\n  }\\n  d3.svg = {};\\n  function d3_zero() {\\n    return 0;\\n  }\\n  d3.svg.arc = function() {\\n    var innerRadius = d3_svg_arcInnerRadius, outerRadius = d3_svg_arcOuterRadius, cornerRadius = d3_zero, padRadius = d3_svg_arcAuto, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle, padAngle = d3_svg_arcPadAngle;\\n    function arc() {\\n      var r0 = Math.max(0, +innerRadius.apply(this, arguments)), r1 = Math.max(0, +outerRadius.apply(this, arguments)), a0 = startAngle.apply(this, arguments) - halfπ, a1 = endAngle.apply(this, arguments) - halfπ, da = Math.abs(a1 - a0), cw = a0 > a1 ? 0 : 1;\\n      if (r1 < r0) rc = r1, r1 = r0, r0 = rc;\\n      if (da >= τε) return circleSegment(r1, cw) + (r0 ? circleSegment(r0, 1 - cw) : \\\"\\\") + \\\"Z\\\";\\n      var rc, cr, rp, ap, p0 = 0, p1 = 0, x0, y0, x1, y1, x2, y2, x3, y3, path = [];\\n      if (ap = (+padAngle.apply(this, arguments) || 0) / 2) {\\n        rp = padRadius === d3_svg_arcAuto ? Math.sqrt(r0 * r0 + r1 * r1) : +padRadius.apply(this, arguments);\\n        if (!cw) p1 *= -1;\\n        if (r1) p1 = d3_asin(rp / r1 * Math.sin(ap));\\n        if (r0) p0 = d3_asin(rp / r0 * Math.sin(ap));\\n      }\\n      if (r1) {\\n        x0 = r1 * Math.cos(a0 + p1);\\n        y0 = r1 * Math.sin(a0 + p1);\\n        x1 = r1 * Math.cos(a1 - p1);\\n        y1 = r1 * Math.sin(a1 - p1);\\n        var l1 = Math.abs(a1 - a0 - 2 * p1) <= π ? 0 : 1;\\n        if (p1 && d3_svg_arcSweep(x0, y0, x1, y1) === cw ^ l1) {\\n          var h1 = (a0 + a1) / 2;\\n          x0 = r1 * Math.cos(h1);\\n          y0 = r1 * Math.sin(h1);\\n          x1 = y1 = null;\\n        }\\n      } else {\\n        x0 = y0 = 0;\\n      }\\n      if (r0) {\\n        x2 = r0 * Math.cos(a1 - p0);\\n        y2 = r0 * Math.sin(a1 - p0);\\n        x3 = r0 * Math.cos(a0 + p0);\\n        y3 = r0 * Math.sin(a0 + p0);\\n        var l0 = Math.abs(a0 - a1 + 2 * p0) <= π ? 0 : 1;\\n        if (p0 && d3_svg_arcSweep(x2, y2, x3, y3) === 1 - cw ^ l0) {\\n          var h0 = (a0 + a1) / 2;\\n          x2 = r0 * Math.cos(h0);\\n          y2 = r0 * Math.sin(h0);\\n          x3 = y3 = null;\\n        }\\n      } else {\\n        x2 = y2 = 0;\\n      }\\n      if (da > ε && (rc = Math.min(Math.abs(r1 - r0) / 2, +cornerRadius.apply(this, arguments))) > .001) {\\n        cr = r0 < r1 ^ cw ? 0 : 1;\\n        var rc1 = rc, rc0 = rc;\\n        if (da < π) {\\n          var oc = x3 == null ? [ x2, y2 ] : x1 == null ? [ x0, y0 ] : d3_geom_polygonIntersect([ x0, y0 ], [ x3, y3 ], [ x1, y1 ], [ x2, y2 ]), ax = x0 - oc[0], ay = y0 - oc[1], bx = x1 - oc[0], by = y1 - oc[1], kc = 1 / Math.sin(Math.acos((ax * bx + ay * by) / (Math.sqrt(ax * ax + ay * ay) * Math.sqrt(bx * bx + by * by))) / 2), lc = Math.sqrt(oc[0] * oc[0] + oc[1] * oc[1]);\\n          rc0 = Math.min(rc, (r0 - lc) / (kc - 1));\\n          rc1 = Math.min(rc, (r1 - lc) / (kc + 1));\\n        }\\n        if (x1 != null) {\\n          var t30 = d3_svg_arcCornerTangents(x3 == null ? [ x2, y2 ] : [ x3, y3 ], [ x0, y0 ], r1, rc1, cw), t12 = d3_svg_arcCornerTangents([ x1, y1 ], [ x2, y2 ], r1, rc1, cw);\\n          if (rc === rc1) {\\n            path.push(\\\"M\\\", t30[0], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 0,\\\", cr, \\\" \\\", t30[1], \\\"A\\\", r1, \\\",\\\", r1, \\\" 0 \\\", 1 - cw ^ d3_svg_arcSweep(t30[1][0], t30[1][1], t12[1][0], t12[1][1]), \\\",\\\", cw, \\\" \\\", t12[1], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 0,\\\", cr, \\\" \\\", t12[0]);\\n          } else {\\n            path.push(\\\"M\\\", t30[0], \\\"A\\\", rc1, \\\",\\\", rc1, \\\" 0 1,\\\", cr, \\\" \\\", t12[0]);\\n          }\\n        } else {\\n          path.push(\\\"M\\\", x0, \\\",\\\", y0);\\n        }\\n        if (x3 != null) {\\n          var t03 = d3_svg_arcCornerTangents([ x0, y0 ], [ x3, y3 ], r0, -rc0, cw), t21 = d3_svg_arcCornerTangents([ x2, y2 ], x1 == null ? [ x0, y0 ] : [ x1, y1 ], r0, -rc0, cw);\\n          if (rc === rc0) {\\n            path.push(\\\"L\\\", t21[0], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t21[1], \\\"A\\\", r0, \\\",\\\", r0, \\\" 0 \\\", cw ^ d3_svg_arcSweep(t21[1][0], t21[1][1], t03[1][0], t03[1][1]), \\\",\\\", 1 - cw, \\\" \\\", t03[1], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t03[0]);\\n          } else {\\n            path.push(\\\"L\\\", t21[0], \\\"A\\\", rc0, \\\",\\\", rc0, \\\" 0 0,\\\", cr, \\\" \\\", t03[0]);\\n          }\\n        } else {\\n          path.push(\\\"L\\\", x2, \\\",\\\", y2);\\n        }\\n      } else {\\n        path.push(\\\"M\\\", x0, \\\",\\\", y0);\\n        if (x1 != null) path.push(\\\"A\\\", r1, \\\",\\\", r1, \\\" 0 \\\", l1, \\\",\\\", cw, \\\" \\\", x1, \\\",\\\", y1);\\n        path.push(\\\"L\\\", x2, \\\",\\\", y2);\\n        if (x3 != null) path.push(\\\"A\\\", r0, \\\",\\\", r0, \\\" 0 \\\", l0, \\\",\\\", 1 - cw, \\\" \\\", x3, \\\",\\\", y3);\\n      }\\n      path.push(\\\"Z\\\");\\n      return path.join(\\\"\\\");\\n    }\\n    function circleSegment(r1, cw) {\\n      return \\\"M0,\\\" + r1 + \\\"A\\\" + r1 + \\\",\\\" + r1 + \\\" 0 1,\\\" + cw + \\\" 0,\\\" + -r1 + \\\"A\\\" + r1 + \\\",\\\" + r1 + \\\" 0 1,\\\" + cw + \\\" 0,\\\" + r1;\\n    }\\n    arc.innerRadius = function(v) {\\n      if (!arguments.length) return innerRadius;\\n      innerRadius = d3_functor(v);\\n      return arc;\\n    };\\n    arc.outerRadius = function(v) {\\n      if (!arguments.length) return outerRadius;\\n      outerRadius = d3_functor(v);\\n      return arc;\\n    };\\n    arc.cornerRadius = function(v) {\\n      if (!arguments.length) return cornerRadius;\\n      cornerRadius = d3_functor(v);\\n      return arc;\\n    };\\n    arc.padRadius = function(v) {\\n      if (!arguments.length) return padRadius;\\n      padRadius = v == d3_svg_arcAuto ? d3_svg_arcAuto : d3_functor(v);\\n      return arc;\\n    };\\n    arc.startAngle = function(v) {\\n      if (!arguments.length) return startAngle;\\n      startAngle = d3_functor(v);\\n      return arc;\\n    };\\n    arc.endAngle = function(v) {\\n      if (!arguments.length) return endAngle;\\n      endAngle = d3_functor(v);\\n      return arc;\\n    };\\n    arc.padAngle = function(v) {\\n      if (!arguments.length) return padAngle;\\n      padAngle = d3_functor(v);\\n      return arc;\\n    };\\n    arc.centroid = function() {\\n      var r = (+innerRadius.apply(this, arguments) + +outerRadius.apply(this, arguments)) / 2, a = (+startAngle.apply(this, arguments) + +endAngle.apply(this, arguments)) / 2 - halfπ;\\n      return [ Math.cos(a) * r, Math.sin(a) * r ];\\n    };\\n    return arc;\\n  };\\n  var d3_svg_arcAuto = \\\"auto\\\";\\n  function d3_svg_arcInnerRadius(d) {\\n    return d.innerRadius;\\n  }\\n  function d3_svg_arcOuterRadius(d) {\\n    return d.outerRadius;\\n  }\\n  function d3_svg_arcStartAngle(d) {\\n    return d.startAngle;\\n  }\\n  function d3_svg_arcEndAngle(d) {\\n    return d.endAngle;\\n  }\\n  function d3_svg_arcPadAngle(d) {\\n    return d && d.padAngle;\\n  }\\n  function d3_svg_arcSweep(x0, y0, x1, y1) {\\n    return (x0 - x1) * y0 - (y0 - y1) * x0 > 0 ? 0 : 1;\\n  }\\n  function d3_svg_arcCornerTangents(p0, p1, r1, rc, cw) {\\n    var x01 = p0[0] - p1[0], y01 = p0[1] - p1[1], lo = (cw ? rc : -rc) / Math.sqrt(x01 * x01 + y01 * y01), ox = lo * y01, oy = -lo * x01, x1 = p0[0] + ox, y1 = p0[1] + oy, x2 = p1[0] + ox, y2 = p1[1] + oy, x3 = (x1 + x2) / 2, y3 = (y1 + y2) / 2, dx = x2 - x1, dy = y2 - y1, d2 = dx * dx + dy * dy, r = r1 - rc, D = x1 * y2 - x2 * y1, d = (dy < 0 ? -1 : 1) * Math.sqrt(Math.max(0, r * r * d2 - D * D)), cx0 = (D * dy - dx * d) / d2, cy0 = (-D * dx - dy * d) / d2, cx1 = (D * dy + dx * d) / d2, cy1 = (-D * dx + dy * d) / d2, dx0 = cx0 - x3, dy0 = cy0 - y3, dx1 = cx1 - x3, dy1 = cy1 - y3;\\n    if (dx0 * dx0 + dy0 * dy0 > dx1 * dx1 + dy1 * dy1) cx0 = cx1, cy0 = cy1;\\n    return [ [ cx0 - ox, cy0 - oy ], [ cx0 * r1 / r, cy0 * r1 / r ] ];\\n  }\\n  function d3_svg_line(projection) {\\n    var x = d3_geom_pointX, y = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, tension = .7;\\n    function line(data) {\\n      var segments = [], points = [], i = -1, n = data.length, d, fx = d3_functor(x), fy = d3_functor(y);\\n      function segment() {\\n        segments.push(\\\"M\\\", interpolate(projection(points), tension));\\n      }\\n      while (++i < n) {\\n        if (defined.call(this, d = data[i], i)) {\\n          points.push([ +fx.call(this, d, i), +fy.call(this, d, i) ]);\\n        } else if (points.length) {\\n          segment();\\n          points = [];\\n        }\\n      }\\n      if (points.length) segment();\\n      return segments.length ? segments.join(\\\"\\\") : null;\\n    }\\n    line.x = function(_) {\\n      if (!arguments.length) return x;\\n      x = _;\\n      return line;\\n    };\\n    line.y = function(_) {\\n      if (!arguments.length) return y;\\n      y = _;\\n      return line;\\n    };\\n    line.defined = function(_) {\\n      if (!arguments.length) return defined;\\n      defined = _;\\n      return line;\\n    };\\n    line.interpolate = function(_) {\\n      if (!arguments.length) return interpolateKey;\\n      if (typeof _ === \\\"function\\\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\\n      return line;\\n    };\\n    line.tension = function(_) {\\n      if (!arguments.length) return tension;\\n      tension = _;\\n      return line;\\n    };\\n    return line;\\n  }\\n  d3.svg.line = function() {\\n    return d3_svg_line(d3_identity);\\n  };\\n  var d3_svg_lineInterpolators = d3.map({\\n    linear: d3_svg_lineLinear,\\n    \\\"linear-closed\\\": d3_svg_lineLinearClosed,\\n    step: d3_svg_lineStep,\\n    \\\"step-before\\\": d3_svg_lineStepBefore,\\n    \\\"step-after\\\": d3_svg_lineStepAfter,\\n    basis: d3_svg_lineBasis,\\n    \\\"basis-open\\\": d3_svg_lineBasisOpen,\\n    \\\"basis-closed\\\": d3_svg_lineBasisClosed,\\n    bundle: d3_svg_lineBundle,\\n    cardinal: d3_svg_lineCardinal,\\n    \\\"cardinal-open\\\": d3_svg_lineCardinalOpen,\\n    \\\"cardinal-closed\\\": d3_svg_lineCardinalClosed,\\n    monotone: d3_svg_lineMonotone\\n  });\\n  d3_svg_lineInterpolators.forEach(function(key, value) {\\n    value.key = key;\\n    value.closed = /-closed$/.test(key);\\n  });\\n  function d3_svg_lineLinear(points) {\\n    return points.length > 1 ? points.join(\\\"L\\\") : points + \\\"Z\\\";\\n  }\\n  function d3_svg_lineLinearClosed(points) {\\n    return points.join(\\\"L\\\") + \\\"Z\\\";\\n  }\\n  function d3_svg_lineStep(points) {\\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n    while (++i < n) path.push(\\\"H\\\", (p[0] + (p = points[i])[0]) / 2, \\\"V\\\", p[1]);\\n    if (n > 1) path.push(\\\"H\\\", p[0]);\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineStepBefore(points) {\\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n    while (++i < n) path.push(\\\"V\\\", (p = points[i])[1], \\\"H\\\", p[0]);\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineStepAfter(points) {\\n    var i = 0, n = points.length, p = points[0], path = [ p[0], \\\",\\\", p[1] ];\\n    while (++i < n) path.push(\\\"H\\\", (p = points[i])[0], \\\"V\\\", p[1]);\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineCardinalOpen(points, tension) {\\n    return points.length < 4 ? d3_svg_lineLinear(points) : points[1] + d3_svg_lineHermite(points.slice(1, -1), d3_svg_lineCardinalTangents(points, tension));\\n  }\\n  function d3_svg_lineCardinalClosed(points, tension) {\\n    return points.length < 3 ? d3_svg_lineLinearClosed(points) : points[0] + d3_svg_lineHermite((points.push(points[0]), \\n    points), d3_svg_lineCardinalTangents([ points[points.length - 2] ].concat(points, [ points[1] ]), tension));\\n  }\\n  function d3_svg_lineCardinal(points, tension) {\\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineCardinalTangents(points, tension));\\n  }\\n  function d3_svg_lineHermite(points, tangents) {\\n    if (tangents.length < 1 || points.length != tangents.length && points.length != tangents.length + 2) {\\n      return d3_svg_lineLinear(points);\\n    }\\n    var quad = points.length != tangents.length, path = \\\"\\\", p0 = points[0], p = points[1], t0 = tangents[0], t = t0, pi = 1;\\n    if (quad) {\\n      path += \\\"Q\\\" + (p[0] - t0[0] * 2 / 3) + \\\",\\\" + (p[1] - t0[1] * 2 / 3) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n      p0 = points[1];\\n      pi = 2;\\n    }\\n    if (tangents.length > 1) {\\n      t = tangents[1];\\n      p = points[pi];\\n      pi++;\\n      path += \\\"C\\\" + (p0[0] + t0[0]) + \\\",\\\" + (p0[1] + t0[1]) + \\\",\\\" + (p[0] - t[0]) + \\\",\\\" + (p[1] - t[1]) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n      for (var i = 2; i < tangents.length; i++, pi++) {\\n        p = points[pi];\\n        t = tangents[i];\\n        path += \\\"S\\\" + (p[0] - t[0]) + \\\",\\\" + (p[1] - t[1]) + \\\",\\\" + p[0] + \\\",\\\" + p[1];\\n      }\\n    }\\n    if (quad) {\\n      var lp = points[pi];\\n      path += \\\"Q\\\" + (p[0] + t[0] * 2 / 3) + \\\",\\\" + (p[1] + t[1] * 2 / 3) + \\\",\\\" + lp[0] + \\\",\\\" + lp[1];\\n    }\\n    return path;\\n  }\\n  function d3_svg_lineCardinalTangents(points, tension) {\\n    var tangents = [], a = (1 - tension) / 2, p0, p1 = points[0], p2 = points[1], i = 1, n = points.length;\\n    while (++i < n) {\\n      p0 = p1;\\n      p1 = p2;\\n      p2 = points[i];\\n      tangents.push([ a * (p2[0] - p0[0]), a * (p2[1] - p0[1]) ]);\\n    }\\n    return tangents;\\n  }\\n  function d3_svg_lineBasis(points) {\\n    if (points.length < 3) return d3_svg_lineLinear(points);\\n    var i = 1, n = points.length, pi = points[0], x0 = pi[0], y0 = pi[1], px = [ x0, x0, x0, (pi = points[1])[0] ], py = [ y0, y0, y0, pi[1] ], path = [ x0, \\\",\\\", y0, \\\"L\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\\n    points.push(points[n - 1]);\\n    while (++i <= n) {\\n      pi = points[i];\\n      px.shift();\\n      px.push(pi[0]);\\n      py.shift();\\n      py.push(pi[1]);\\n      d3_svg_lineBasisBezier(path, px, py);\\n    }\\n    points.pop();\\n    path.push(\\\"L\\\", pi);\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineBasisOpen(points) {\\n    if (points.length < 4) return d3_svg_lineLinear(points);\\n    var path = [], i = -1, n = points.length, pi, px = [ 0 ], py = [ 0 ];\\n    while (++i < 3) {\\n      pi = points[i];\\n      px.push(pi[0]);\\n      py.push(pi[1]);\\n    }\\n    path.push(d3_svg_lineDot4(d3_svg_lineBasisBezier3, px) + \\\",\\\" + d3_svg_lineDot4(d3_svg_lineBasisBezier3, py));\\n    --i;\\n    while (++i < n) {\\n      pi = points[i];\\n      px.shift();\\n      px.push(pi[0]);\\n      py.shift();\\n      py.push(pi[1]);\\n      d3_svg_lineBasisBezier(path, px, py);\\n    }\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineBasisClosed(points) {\\n    var path, i = -1, n = points.length, m = n + 4, pi, px = [], py = [];\\n    while (++i < 4) {\\n      pi = points[i % n];\\n      px.push(pi[0]);\\n      py.push(pi[1]);\\n    }\\n    path = [ d3_svg_lineDot4(d3_svg_lineBasisBezier3, px), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, py) ];\\n    --i;\\n    while (++i < m) {\\n      pi = points[i % n];\\n      px.shift();\\n      px.push(pi[0]);\\n      py.shift();\\n      py.push(pi[1]);\\n      d3_svg_lineBasisBezier(path, px, py);\\n    }\\n    return path.join(\\\"\\\");\\n  }\\n  function d3_svg_lineBundle(points, tension) {\\n    var n = points.length - 1;\\n    if (n) {\\n      var x0 = points[0][0], y0 = points[0][1], dx = points[n][0] - x0, dy = points[n][1] - y0, i = -1, p, t;\\n      while (++i <= n) {\\n        p = points[i];\\n        t = i / n;\\n        p[0] = tension * p[0] + (1 - tension) * (x0 + t * dx);\\n        p[1] = tension * p[1] + (1 - tension) * (y0 + t * dy);\\n      }\\n    }\\n    return d3_svg_lineBasis(points);\\n  }\\n  function d3_svg_lineDot4(a, b) {\\n    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2] + a[3] * b[3];\\n  }\\n  var d3_svg_lineBasisBezier1 = [ 0, 2 / 3, 1 / 3, 0 ], d3_svg_lineBasisBezier2 = [ 0, 1 / 3, 2 / 3, 0 ], d3_svg_lineBasisBezier3 = [ 0, 1 / 6, 2 / 3, 1 / 6 ];\\n  function d3_svg_lineBasisBezier(path, x, y) {\\n    path.push(\\\"C\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, x), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier1, y), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, x), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier2, y), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, x), \\\",\\\", d3_svg_lineDot4(d3_svg_lineBasisBezier3, y));\\n  }\\n  function d3_svg_lineSlope(p0, p1) {\\n    return (p1[1] - p0[1]) / (p1[0] - p0[0]);\\n  }\\n  function d3_svg_lineFiniteDifferences(points) {\\n    var i = 0, j = points.length - 1, m = [], p0 = points[0], p1 = points[1], d = m[0] = d3_svg_lineSlope(p0, p1);\\n    while (++i < j) {\\n      m[i] = (d + (d = d3_svg_lineSlope(p0 = p1, p1 = points[i + 1]))) / 2;\\n    }\\n    m[i] = d;\\n    return m;\\n  }\\n  function d3_svg_lineMonotoneTangents(points) {\\n    var tangents = [], d, a, b, s, m = d3_svg_lineFiniteDifferences(points), i = -1, j = points.length - 1;\\n    while (++i < j) {\\n      d = d3_svg_lineSlope(points[i], points[i + 1]);\\n      if (abs(d) < ε) {\\n        m[i] = m[i + 1] = 0;\\n      } else {\\n        a = m[i] / d;\\n        b = m[i + 1] / d;\\n        s = a * a + b * b;\\n        if (s > 9) {\\n          s = d * 3 / Math.sqrt(s);\\n          m[i] = s * a;\\n          m[i + 1] = s * b;\\n        }\\n      }\\n    }\\n    i = -1;\\n    while (++i <= j) {\\n      s = (points[Math.min(j, i + 1)][0] - points[Math.max(0, i - 1)][0]) / (6 * (1 + m[i] * m[i]));\\n      tangents.push([ s || 0, m[i] * s || 0 ]);\\n    }\\n    return tangents;\\n  }\\n  function d3_svg_lineMonotone(points) {\\n    return points.length < 3 ? d3_svg_lineLinear(points) : points[0] + d3_svg_lineHermite(points, d3_svg_lineMonotoneTangents(points));\\n  }\\n  d3.svg.line.radial = function() {\\n    var line = d3_svg_line(d3_svg_lineRadial);\\n    line.radius = line.x, delete line.x;\\n    line.angle = line.y, delete line.y;\\n    return line;\\n  };\\n  function d3_svg_lineRadial(points) {\\n    var point, i = -1, n = points.length, r, a;\\n    while (++i < n) {\\n      point = points[i];\\n      r = point[0];\\n      a = point[1] - halfπ;\\n      point[0] = r * Math.cos(a);\\n      point[1] = r * Math.sin(a);\\n    }\\n    return points;\\n  }\\n  function d3_svg_area(projection) {\\n    var x0 = d3_geom_pointX, x1 = d3_geom_pointX, y0 = 0, y1 = d3_geom_pointY, defined = d3_true, interpolate = d3_svg_lineLinear, interpolateKey = interpolate.key, interpolateReverse = interpolate, L = \\\"L\\\", tension = .7;\\n    function area(data) {\\n      var segments = [], points0 = [], points1 = [], i = -1, n = data.length, d, fx0 = d3_functor(x0), fy0 = d3_functor(y0), fx1 = x0 === x1 ? function() {\\n        return x;\\n      } : d3_functor(x1), fy1 = y0 === y1 ? function() {\\n        return y;\\n      } : d3_functor(y1), x, y;\\n      function segment() {\\n        segments.push(\\\"M\\\", interpolate(projection(points1), tension), L, interpolateReverse(projection(points0.reverse()), tension), \\\"Z\\\");\\n      }\\n      while (++i < n) {\\n        if (defined.call(this, d = data[i], i)) {\\n          points0.push([ x = +fx0.call(this, d, i), y = +fy0.call(this, d, i) ]);\\n          points1.push([ +fx1.call(this, d, i), +fy1.call(this, d, i) ]);\\n        } else if (points0.length) {\\n          segment();\\n          points0 = [];\\n          points1 = [];\\n        }\\n      }\\n      if (points0.length) segment();\\n      return segments.length ? segments.join(\\\"\\\") : null;\\n    }\\n    area.x = function(_) {\\n      if (!arguments.length) return x1;\\n      x0 = x1 = _;\\n      return area;\\n    };\\n    area.x0 = function(_) {\\n      if (!arguments.length) return x0;\\n      x0 = _;\\n      return area;\\n    };\\n    area.x1 = function(_) {\\n      if (!arguments.length) return x1;\\n      x1 = _;\\n      return area;\\n    };\\n    area.y = function(_) {\\n      if (!arguments.length) return y1;\\n      y0 = y1 = _;\\n      return area;\\n    };\\n    area.y0 = function(_) {\\n      if (!arguments.length) return y0;\\n      y0 = _;\\n      return area;\\n    };\\n    area.y1 = function(_) {\\n      if (!arguments.length) return y1;\\n      y1 = _;\\n      return area;\\n    };\\n    area.defined = function(_) {\\n      if (!arguments.length) return defined;\\n      defined = _;\\n      return area;\\n    };\\n    area.interpolate = function(_) {\\n      if (!arguments.length) return interpolateKey;\\n      if (typeof _ === \\\"function\\\") interpolateKey = interpolate = _; else interpolateKey = (interpolate = d3_svg_lineInterpolators.get(_) || d3_svg_lineLinear).key;\\n      interpolateReverse = interpolate.reverse || interpolate;\\n      L = interpolate.closed ? \\\"M\\\" : \\\"L\\\";\\n      return area;\\n    };\\n    area.tension = function(_) {\\n      if (!arguments.length) return tension;\\n      tension = _;\\n      return area;\\n    };\\n    return area;\\n  }\\n  d3_svg_lineStepBefore.reverse = d3_svg_lineStepAfter;\\n  d3_svg_lineStepAfter.reverse = d3_svg_lineStepBefore;\\n  d3.svg.area = function() {\\n    return d3_svg_area(d3_identity);\\n  };\\n  d3.svg.area.radial = function() {\\n    var area = d3_svg_area(d3_svg_lineRadial);\\n    area.radius = area.x, delete area.x;\\n    area.innerRadius = area.x0, delete area.x0;\\n    area.outerRadius = area.x1, delete area.x1;\\n    area.angle = area.y, delete area.y;\\n    area.startAngle = area.y0, delete area.y0;\\n    area.endAngle = area.y1, delete area.y1;\\n    return area;\\n  };\\n  d3.svg.chord = function() {\\n    var source = d3_source, target = d3_target, radius = d3_svg_chordRadius, startAngle = d3_svg_arcStartAngle, endAngle = d3_svg_arcEndAngle;\\n    function chord(d, i) {\\n      var s = subgroup(this, source, d, i), t = subgroup(this, target, d, i);\\n      return \\\"M\\\" + s.p0 + arc(s.r, s.p1, s.a1 - s.a0) + (equals(s, t) ? curve(s.r, s.p1, s.r, s.p0) : curve(s.r, s.p1, t.r, t.p0) + arc(t.r, t.p1, t.a1 - t.a0) + curve(t.r, t.p1, s.r, s.p0)) + \\\"Z\\\";\\n    }\\n    function subgroup(self, f, d, i) {\\n      var subgroup = f.call(self, d, i), r = radius.call(self, subgroup, i), a0 = startAngle.call(self, subgroup, i) - halfπ, a1 = endAngle.call(self, subgroup, i) - halfπ;\\n      return {\\n        r: r,\\n        a0: a0,\\n        a1: a1,\\n        p0: [ r * Math.cos(a0), r * Math.sin(a0) ],\\n        p1: [ r * Math.cos(a1), r * Math.sin(a1) ]\\n      };\\n    }\\n    function equals(a, b) {\\n      return a.a0 == b.a0 && a.a1 == b.a1;\\n    }\\n    function arc(r, p, a) {\\n      return \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 \\\" + +(a > π) + \\\",1 \\\" + p;\\n    }\\n    function curve(r0, p0, r1, p1) {\\n      return \\\"Q 0,0 \\\" + p1;\\n    }\\n    chord.radius = function(v) {\\n      if (!arguments.length) return radius;\\n      radius = d3_functor(v);\\n      return chord;\\n    };\\n    chord.source = function(v) {\\n      if (!arguments.length) return source;\\n      source = d3_functor(v);\\n      return chord;\\n    };\\n    chord.target = function(v) {\\n      if (!arguments.length) return target;\\n      target = d3_functor(v);\\n      return chord;\\n    };\\n    chord.startAngle = function(v) {\\n      if (!arguments.length) return startAngle;\\n      startAngle = d3_functor(v);\\n      return chord;\\n    };\\n    chord.endAngle = function(v) {\\n      if (!arguments.length) return endAngle;\\n      endAngle = d3_functor(v);\\n      return chord;\\n    };\\n    return chord;\\n  };\\n  function d3_svg_chordRadius(d) {\\n    return d.radius;\\n  }\\n  d3.svg.diagonal = function() {\\n    var source = d3_source, target = d3_target, projection = d3_svg_diagonalProjection;\\n    function diagonal(d, i) {\\n      var p0 = source.call(this, d, i), p3 = target.call(this, d, i), m = (p0.y + p3.y) / 2, p = [ p0, {\\n        x: p0.x,\\n        y: m\\n      }, {\\n        x: p3.x,\\n        y: m\\n      }, p3 ];\\n      p = p.map(projection);\\n      return \\\"M\\\" + p[0] + \\\"C\\\" + p[1] + \\\" \\\" + p[2] + \\\" \\\" + p[3];\\n    }\\n    diagonal.source = function(x) {\\n      if (!arguments.length) return source;\\n      source = d3_functor(x);\\n      return diagonal;\\n    };\\n    diagonal.target = function(x) {\\n      if (!arguments.length) return target;\\n      target = d3_functor(x);\\n      return diagonal;\\n    };\\n    diagonal.projection = function(x) {\\n      if (!arguments.length) return projection;\\n      projection = x;\\n      return diagonal;\\n    };\\n    return diagonal;\\n  };\\n  function d3_svg_diagonalProjection(d) {\\n    return [ d.x, d.y ];\\n  }\\n  d3.svg.diagonal.radial = function() {\\n    var diagonal = d3.svg.diagonal(), projection = d3_svg_diagonalProjection, projection_ = diagonal.projection;\\n    diagonal.projection = function(x) {\\n      return arguments.length ? projection_(d3_svg_diagonalRadialProjection(projection = x)) : projection;\\n    };\\n    return diagonal;\\n  };\\n  function d3_svg_diagonalRadialProjection(projection) {\\n    return function() {\\n      var d = projection.apply(this, arguments), r = d[0], a = d[1] - halfπ;\\n      return [ r * Math.cos(a), r * Math.sin(a) ];\\n    };\\n  }\\n  d3.svg.symbol = function() {\\n    var type = d3_svg_symbolType, size = d3_svg_symbolSize;\\n    function symbol(d, i) {\\n      return (d3_svg_symbols.get(type.call(this, d, i)) || d3_svg_symbolCircle)(size.call(this, d, i));\\n    }\\n    symbol.type = function(x) {\\n      if (!arguments.length) return type;\\n      type = d3_functor(x);\\n      return symbol;\\n    };\\n    symbol.size = function(x) {\\n      if (!arguments.length) return size;\\n      size = d3_functor(x);\\n      return symbol;\\n    };\\n    return symbol;\\n  };\\n  function d3_svg_symbolSize() {\\n    return 64;\\n  }\\n  function d3_svg_symbolType() {\\n    return \\\"circle\\\";\\n  }\\n  function d3_svg_symbolCircle(size) {\\n    var r = Math.sqrt(size / π);\\n    return \\\"M0,\\\" + r + \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 1,1 0,\\\" + -r + \\\"A\\\" + r + \\\",\\\" + r + \\\" 0 1,1 0,\\\" + r + \\\"Z\\\";\\n  }\\n  var d3_svg_symbols = d3.map({\\n    circle: d3_svg_symbolCircle,\\n    cross: function(size) {\\n      var r = Math.sqrt(size / 5) / 2;\\n      return \\\"M\\\" + -3 * r + \\\",\\\" + -r + \\\"H\\\" + -r + \\\"V\\\" + -3 * r + \\\"H\\\" + r + \\\"V\\\" + -r + \\\"H\\\" + 3 * r + \\\"V\\\" + r + \\\"H\\\" + r + \\\"V\\\" + 3 * r + \\\"H\\\" + -r + \\\"V\\\" + r + \\\"H\\\" + -3 * r + \\\"Z\\\";\\n    },\\n    diamond: function(size) {\\n      var ry = Math.sqrt(size / (2 * d3_svg_symbolTan30)), rx = ry * d3_svg_symbolTan30;\\n      return \\\"M0,\\\" + -ry + \\\"L\\\" + rx + \\\",0\\\" + \\\" 0,\\\" + ry + \\\" \\\" + -rx + \\\",0\\\" + \\\"Z\\\";\\n    },\\n    square: function(size) {\\n      var r = Math.sqrt(size) / 2;\\n      return \\\"M\\\" + -r + \\\",\\\" + -r + \\\"L\\\" + r + \\\",\\\" + -r + \\\" \\\" + r + \\\",\\\" + r + \\\" \\\" + -r + \\\",\\\" + r + \\\"Z\\\";\\n    },\\n    \\\"triangle-down\\\": function(size) {\\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\\n      return \\\"M0,\\\" + ry + \\\"L\\\" + rx + \\\",\\\" + -ry + \\\" \\\" + -rx + \\\",\\\" + -ry + \\\"Z\\\";\\n    },\\n    \\\"triangle-up\\\": function(size) {\\n      var rx = Math.sqrt(size / d3_svg_symbolSqrt3), ry = rx * d3_svg_symbolSqrt3 / 2;\\n      return \\\"M0,\\\" + -ry + \\\"L\\\" + rx + \\\",\\\" + ry + \\\" \\\" + -rx + \\\",\\\" + ry + \\\"Z\\\";\\n    }\\n  });\\n  d3.svg.symbolTypes = d3_svg_symbols.keys();\\n  var d3_svg_symbolSqrt3 = Math.sqrt(3), d3_svg_symbolTan30 = Math.tan(30 * d3_radians);\\n  d3_selectionPrototype.transition = function(name) {\\n    var id = d3_transitionInheritId || ++d3_transitionId, ns = d3_transitionNamespace(name), subgroups = [], subgroup, node, transition = d3_transitionInherit || {\\n      time: Date.now(),\\n      ease: d3_ease_cubicInOut,\\n      delay: 0,\\n      duration: 250\\n    };\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      subgroups.push(subgroup = []);\\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n        if (node = group[i]) d3_transitionNode(node, i, ns, id, transition);\\n        subgroup.push(node);\\n      }\\n    }\\n    return d3_transition(subgroups, ns, id);\\n  };\\n  d3_selectionPrototype.interrupt = function(name) {\\n    return this.each(name == null ? d3_selection_interrupt : d3_selection_interruptNS(d3_transitionNamespace(name)));\\n  };\\n  var d3_selection_interrupt = d3_selection_interruptNS(d3_transitionNamespace());\\n  function d3_selection_interruptNS(ns) {\\n    return function() {\\n      var lock, activeId, active;\\n      if ((lock = this[ns]) && (active = lock[activeId = lock.active])) {\\n        active.timer.c = null;\\n        active.timer.t = NaN;\\n        if (--lock.count) delete lock[activeId]; else delete this[ns];\\n        lock.active += .5;\\n        active.event && active.event.interrupt.call(this, this.__data__, active.index);\\n      }\\n    };\\n  }\\n  function d3_transition(groups, ns, id) {\\n    d3_subclass(groups, d3_transitionPrototype);\\n    groups.namespace = ns;\\n    groups.id = id;\\n    return groups;\\n  }\\n  var d3_transitionPrototype = [], d3_transitionId = 0, d3_transitionInheritId, d3_transitionInherit;\\n  d3_transitionPrototype.call = d3_selectionPrototype.call;\\n  d3_transitionPrototype.empty = d3_selectionPrototype.empty;\\n  d3_transitionPrototype.node = d3_selectionPrototype.node;\\n  d3_transitionPrototype.size = d3_selectionPrototype.size;\\n  d3.transition = function(selection, name) {\\n    return selection && selection.transition ? d3_transitionInheritId ? selection.transition(name) : selection : d3.selection().transition(selection);\\n  };\\n  d3.transition.prototype = d3_transitionPrototype;\\n  d3_transitionPrototype.select = function(selector) {\\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnode, node;\\n    selector = d3_selection_selector(selector);\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      subgroups.push(subgroup = []);\\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n        if ((node = group[i]) && (subnode = selector.call(node, node.__data__, i, j))) {\\n          if (\\\"__data__\\\" in node) subnode.__data__ = node.__data__;\\n          d3_transitionNode(subnode, i, ns, id, node[ns][id]);\\n          subgroup.push(subnode);\\n        } else {\\n          subgroup.push(null);\\n        }\\n      }\\n    }\\n    return d3_transition(subgroups, ns, id);\\n  };\\n  d3_transitionPrototype.selectAll = function(selector) {\\n    var id = this.id, ns = this.namespace, subgroups = [], subgroup, subnodes, node, subnode, transition;\\n    selector = d3_selection_selectorAll(selector);\\n    for (var j = -1, m = this.length; ++j < m; ) {\\n      for (var group = this[j], i = -1, n = group.length; ++i < n; ) {\\n        if (node = group[i]) {\\n          transition = node[ns][id];\\n          subnodes = selector.call(node, node.__data__, i, j);\\n          subgroups.push(subgroup = []);\\n          for (var k = -1, o = subnodes.length; ++k < o; ) {\\n            if (subnode = subnodes[k]) d3_transitionNode(subnode, k, ns, id, transition);\\n            subgroup.push(subnode);\\n          }\\n        }\\n      }\\n    }\\n    return d3_transition(subgroups, ns, id);\\n  };\\n  d3_transitionPrototype.filter = function(filter) {\\n    var subgroups = [], subgroup, group, node;\\n    if (typeof filter !== \\\"function\\\") filter = d3_selection_filter(filter);\\n    for (var j = 0, m = this.length; j < m; j++) {\\n      subgroups.push(subgroup = []);\\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\\n        if ((node = group[i]) && filter.call(node, node.__data__, i, j)) {\\n          subgroup.push(node);\\n        }\\n      }\\n    }\\n    return d3_transition(subgroups, this.namespace, this.id);\\n  };\\n  d3_transitionPrototype.tween = function(name, tween) {\\n    var id = this.id, ns = this.namespace;\\n    if (arguments.length < 2) return this.node()[ns][id].tween.get(name);\\n    return d3_selection_each(this, tween == null ? function(node) {\\n      node[ns][id].tween.remove(name);\\n    } : function(node) {\\n      node[ns][id].tween.set(name, tween);\\n    });\\n  };\\n  function d3_transition_tween(groups, name, value, tween) {\\n    var id = groups.id, ns = groups.namespace;\\n    return d3_selection_each(groups, typeof value === \\\"function\\\" ? function(node, i, j) {\\n      node[ns][id].tween.set(name, tween(value.call(node, node.__data__, i, j)));\\n    } : (value = tween(value), function(node) {\\n      node[ns][id].tween.set(name, value);\\n    }));\\n  }\\n  d3_transitionPrototype.attr = function(nameNS, value) {\\n    if (arguments.length < 2) {\\n      for (value in nameNS) this.attr(value, nameNS[value]);\\n      return this;\\n    }\\n    var interpolate = nameNS == \\\"transform\\\" ? d3_interpolateTransform : d3_interpolate, name = d3.ns.qualify(nameNS);\\n    function attrNull() {\\n      this.removeAttribute(name);\\n    }\\n    function attrNullNS() {\\n      this.removeAttributeNS(name.space, name.local);\\n    }\\n    function attrTween(b) {\\n      return b == null ? attrNull : (b += \\\"\\\", function() {\\n        var a = this.getAttribute(name), i;\\n        return a !== b && (i = interpolate(a, b), function(t) {\\n          this.setAttribute(name, i(t));\\n        });\\n      });\\n    }\\n    function attrTweenNS(b) {\\n      return b == null ? attrNullNS : (b += \\\"\\\", function() {\\n        var a = this.getAttributeNS(name.space, name.local), i;\\n        return a !== b && (i = interpolate(a, b), function(t) {\\n          this.setAttributeNS(name.space, name.local, i(t));\\n        });\\n      });\\n    }\\n    return d3_transition_tween(this, \\\"attr.\\\" + nameNS, value, name.local ? attrTweenNS : attrTween);\\n  };\\n  d3_transitionPrototype.attrTween = function(nameNS, tween) {\\n    var name = d3.ns.qualify(nameNS);\\n    function attrTween(d, i) {\\n      var f = tween.call(this, d, i, this.getAttribute(name));\\n      return f && function(t) {\\n        this.setAttribute(name, f(t));\\n      };\\n    }\\n    function attrTweenNS(d, i) {\\n      var f = tween.call(this, d, i, this.getAttributeNS(name.space, name.local));\\n      return f && function(t) {\\n        this.setAttributeNS(name.space, name.local, f(t));\\n      };\\n    }\\n    return this.tween(\\\"attr.\\\" + nameNS, name.local ? attrTweenNS : attrTween);\\n  };\\n  d3_transitionPrototype.style = function(name, value, priority) {\\n    var n = arguments.length;\\n    if (n < 3) {\\n      if (typeof name !== \\\"string\\\") {\\n        if (n < 2) value = \\\"\\\";\\n        for (priority in name) this.style(priority, name[priority], value);\\n        return this;\\n      }\\n      priority = \\\"\\\";\\n    }\\n    function styleNull() {\\n      this.style.removeProperty(name);\\n    }\\n    function styleString(b) {\\n      return b == null ? styleNull : (b += \\\"\\\", function() {\\n        var a = d3_window(this).getComputedStyle(this, null).getPropertyValue(name), i;\\n        return a !== b && (i = d3_interpolate(a, b), function(t) {\\n          this.style.setProperty(name, i(t), priority);\\n        });\\n      });\\n    }\\n    return d3_transition_tween(this, \\\"style.\\\" + name, value, styleString);\\n  };\\n  d3_transitionPrototype.styleTween = function(name, tween, priority) {\\n    if (arguments.length < 3) priority = \\\"\\\";\\n    function styleTween(d, i) {\\n      var f = tween.call(this, d, i, d3_window(this).getComputedStyle(this, null).getPropertyValue(name));\\n      return f && function(t) {\\n        this.style.setProperty(name, f(t), priority);\\n      };\\n    }\\n    return this.tween(\\\"style.\\\" + name, styleTween);\\n  };\\n  d3_transitionPrototype.text = function(value) {\\n    return d3_transition_tween(this, \\\"text\\\", value, d3_transition_text);\\n  };\\n  function d3_transition_text(b) {\\n    if (b == null) b = \\\"\\\";\\n    return function() {\\n      this.textContent = b;\\n    };\\n  }\\n  d3_transitionPrototype.remove = function() {\\n    var ns = this.namespace;\\n    return this.each(\\\"end.transition\\\", function() {\\n      var p;\\n      if (this[ns].count < 2 && (p = this.parentNode)) p.removeChild(this);\\n    });\\n  };\\n  d3_transitionPrototype.ease = function(value) {\\n    var id = this.id, ns = this.namespace;\\n    if (arguments.length < 1) return this.node()[ns][id].ease;\\n    if (typeof value !== \\\"function\\\") value = d3.ease.apply(d3, arguments);\\n    return d3_selection_each(this, function(node) {\\n      node[ns][id].ease = value;\\n    });\\n  };\\n  d3_transitionPrototype.delay = function(value) {\\n    var id = this.id, ns = this.namespace;\\n    if (arguments.length < 1) return this.node()[ns][id].delay;\\n    return d3_selection_each(this, typeof value === \\\"function\\\" ? function(node, i, j) {\\n      node[ns][id].delay = +value.call(node, node.__data__, i, j);\\n    } : (value = +value, function(node) {\\n      node[ns][id].delay = value;\\n    }));\\n  };\\n  d3_transitionPrototype.duration = function(value) {\\n    var id = this.id, ns = this.namespace;\\n    if (arguments.length < 1) return this.node()[ns][id].duration;\\n    return d3_selection_each(this, typeof value === \\\"function\\\" ? function(node, i, j) {\\n      node[ns][id].duration = Math.max(1, value.call(node, node.__data__, i, j));\\n    } : (value = Math.max(1, value), function(node) {\\n      node[ns][id].duration = value;\\n    }));\\n  };\\n  d3_transitionPrototype.each = function(type, listener) {\\n    var id = this.id, ns = this.namespace;\\n    if (arguments.length < 2) {\\n      var inherit = d3_transitionInherit, inheritId = d3_transitionInheritId;\\n      try {\\n        d3_transitionInheritId = id;\\n        d3_selection_each(this, function(node, i, j) {\\n          d3_transitionInherit = node[ns][id];\\n          type.call(node, node.__data__, i, j);\\n        });\\n      } finally {\\n        d3_transitionInherit = inherit;\\n        d3_transitionInheritId = inheritId;\\n      }\\n    } else {\\n      d3_selection_each(this, function(node) {\\n        var transition = node[ns][id];\\n        (transition.event || (transition.event = d3.dispatch(\\\"start\\\", \\\"end\\\", \\\"interrupt\\\"))).on(type, listener);\\n      });\\n    }\\n    return this;\\n  };\\n  d3_transitionPrototype.transition = function() {\\n    var id0 = this.id, id1 = ++d3_transitionId, ns = this.namespace, subgroups = [], subgroup, group, node, transition;\\n    for (var j = 0, m = this.length; j < m; j++) {\\n      subgroups.push(subgroup = []);\\n      for (var group = this[j], i = 0, n = group.length; i < n; i++) {\\n        if (node = group[i]) {\\n          transition = node[ns][id0];\\n          d3_transitionNode(node, i, ns, id1, {\\n            time: transition.time,\\n            ease: transition.ease,\\n            delay: transition.delay + transition.duration,\\n            duration: transition.duration\\n          });\\n        }\\n        subgroup.push(node);\\n      }\\n    }\\n    return d3_transition(subgroups, ns, id1);\\n  };\\n  function d3_transitionNamespace(name) {\\n    return name == null ? \\\"__transition__\\\" : \\\"__transition_\\\" + name + \\\"__\\\";\\n  }\\n  function d3_transitionNode(node, i, ns, id, inherit) {\\n    var lock = node[ns] || (node[ns] = {\\n      active: 0,\\n      count: 0\\n    }), transition = lock[id], time, timer, duration, ease, tweens;\\n    function schedule(elapsed) {\\n      var delay = transition.delay;\\n      timer.t = delay + time;\\n      if (delay <= elapsed) return start(elapsed - delay);\\n      timer.c = start;\\n    }\\n    function start(elapsed) {\\n      var activeId = lock.active, active = lock[activeId];\\n      if (active) {\\n        active.timer.c = null;\\n        active.timer.t = NaN;\\n        --lock.count;\\n        delete lock[activeId];\\n        active.event && active.event.interrupt.call(node, node.__data__, active.index);\\n      }\\n      for (var cancelId in lock) {\\n        if (+cancelId < id) {\\n          var cancel = lock[cancelId];\\n          cancel.timer.c = null;\\n          cancel.timer.t = NaN;\\n          --lock.count;\\n          delete lock[cancelId];\\n        }\\n      }\\n      timer.c = tick;\\n      d3_timer(function() {\\n        if (timer.c && tick(elapsed || 1)) {\\n          timer.c = null;\\n          timer.t = NaN;\\n        }\\n        return 1;\\n      }, 0, time);\\n      lock.active = id;\\n      transition.event && transition.event.start.call(node, node.__data__, i);\\n      tweens = [];\\n      transition.tween.forEach(function(key, value) {\\n        if (value = value.call(node, node.__data__, i)) {\\n          tweens.push(value);\\n        }\\n      });\\n      ease = transition.ease;\\n      duration = transition.duration;\\n    }\\n    function tick(elapsed) {\\n      var t = elapsed / duration, e = ease(t), n = tweens.length;\\n      while (n > 0) {\\n        tweens[--n].call(node, e);\\n      }\\n      if (t >= 1) {\\n        transition.event && transition.event.end.call(node, node.__data__, i);\\n        if (--lock.count) delete lock[id]; else delete node[ns];\\n        return 1;\\n      }\\n    }\\n    if (!transition) {\\n      time = inherit.time;\\n      timer = d3_timer(schedule, 0, time);\\n      transition = lock[id] = {\\n        tween: new d3_Map(),\\n        time: time,\\n        timer: timer,\\n        delay: inherit.delay,\\n        duration: inherit.duration,\\n        ease: inherit.ease,\\n        index: i\\n      };\\n      inherit = null;\\n      ++lock.count;\\n    }\\n  }\\n  d3.svg.axis = function() {\\n    var scale = d3.scale.linear(), orient = d3_svg_axisDefaultOrient, innerTickSize = 6, outerTickSize = 6, tickPadding = 3, tickArguments_ = [ 10 ], tickValues = null, tickFormat_;\\n    function axis(g) {\\n      g.each(function() {\\n        var g = d3.select(this);\\n        var scale0 = this.__chart__ || scale, scale1 = this.__chart__ = scale.copy();\\n        var ticks = tickValues == null ? scale1.ticks ? scale1.ticks.apply(scale1, tickArguments_) : scale1.domain() : tickValues, tickFormat = tickFormat_ == null ? scale1.tickFormat ? scale1.tickFormat.apply(scale1, tickArguments_) : d3_identity : tickFormat_, tick = g.selectAll(\\\".tick\\\").data(ticks, scale1), tickEnter = tick.enter().insert(\\\"g\\\", \\\".domain\\\").attr(\\\"class\\\", \\\"tick\\\").style(\\\"opacity\\\", ε), tickExit = d3.transition(tick.exit()).style(\\\"opacity\\\", ε).remove(), tickUpdate = d3.transition(tick.order()).style(\\\"opacity\\\", 1), tickSpacing = Math.max(innerTickSize, 0) + tickPadding, tickTransform;\\n        var range = d3_scaleRange(scale1), path = g.selectAll(\\\".domain\\\").data([ 0 ]), pathUpdate = (path.enter().append(\\\"path\\\").attr(\\\"class\\\", \\\"domain\\\"), \\n        d3.transition(path));\\n        tickEnter.append(\\\"line\\\");\\n        tickEnter.append(\\\"text\\\");\\n        var lineEnter = tickEnter.select(\\\"line\\\"), lineUpdate = tickUpdate.select(\\\"line\\\"), text = tick.select(\\\"text\\\").text(tickFormat), textEnter = tickEnter.select(\\\"text\\\"), textUpdate = tickUpdate.select(\\\"text\\\"), sign = orient === \\\"top\\\" || orient === \\\"left\\\" ? -1 : 1, x1, x2, y1, y2;\\n        if (orient === \\\"bottom\\\" || orient === \\\"top\\\") {\\n          tickTransform = d3_svg_axisX, x1 = \\\"x\\\", y1 = \\\"y\\\", x2 = \\\"x2\\\", y2 = \\\"y2\\\";\\n          text.attr(\\\"dy\\\", sign < 0 ? \\\"0em\\\" : \\\".71em\\\").style(\\\"text-anchor\\\", \\\"middle\\\");\\n          pathUpdate.attr(\\\"d\\\", \\\"M\\\" + range[0] + \\\",\\\" + sign * outerTickSize + \\\"V0H\\\" + range[1] + \\\"V\\\" + sign * outerTickSize);\\n        } else {\\n          tickTransform = d3_svg_axisY, x1 = \\\"y\\\", y1 = \\\"x\\\", x2 = \\\"y2\\\", y2 = \\\"x2\\\";\\n          text.attr(\\\"dy\\\", \\\".32em\\\").style(\\\"text-anchor\\\", sign < 0 ? \\\"end\\\" : \\\"start\\\");\\n          pathUpdate.attr(\\\"d\\\", \\\"M\\\" + sign * outerTickSize + \\\",\\\" + range[0] + \\\"H0V\\\" + range[1] + \\\"H\\\" + sign * outerTickSize);\\n        }\\n        lineEnter.attr(y2, sign * innerTickSize);\\n        textEnter.attr(y1, sign * tickSpacing);\\n        lineUpdate.attr(x2, 0).attr(y2, sign * innerTickSize);\\n        textUpdate.attr(x1, 0).attr(y1, sign * tickSpacing);\\n        if (scale1.rangeBand) {\\n          var x = scale1, dx = x.rangeBand() / 2;\\n          scale0 = scale1 = function(d) {\\n            return x(d) + dx;\\n          };\\n        } else if (scale0.rangeBand) {\\n          scale0 = scale1;\\n        } else {\\n          tickExit.call(tickTransform, scale1, scale0);\\n        }\\n        tickEnter.call(tickTransform, scale0, scale1);\\n        tickUpdate.call(tickTransform, scale1, scale1);\\n      });\\n    }\\n    axis.scale = function(x) {\\n      if (!arguments.length) return scale;\\n      scale = x;\\n      return axis;\\n    };\\n    axis.orient = function(x) {\\n      if (!arguments.length) return orient;\\n      orient = x in d3_svg_axisOrients ? x + \\\"\\\" : d3_svg_axisDefaultOrient;\\n      return axis;\\n    };\\n    axis.ticks = function() {\\n      if (!arguments.length) return tickArguments_;\\n      tickArguments_ = d3_array(arguments);\\n      return axis;\\n    };\\n    axis.tickValues = function(x) {\\n      if (!arguments.length) return tickValues;\\n      tickValues = x;\\n      return axis;\\n    };\\n    axis.tickFormat = function(x) {\\n      if (!arguments.length) return tickFormat_;\\n      tickFormat_ = x;\\n      return axis;\\n    };\\n    axis.tickSize = function(x) {\\n      var n = arguments.length;\\n      if (!n) return innerTickSize;\\n      innerTickSize = +x;\\n      outerTickSize = +arguments[n - 1];\\n      return axis;\\n    };\\n    axis.innerTickSize = function(x) {\\n      if (!arguments.length) return innerTickSize;\\n      innerTickSize = +x;\\n      return axis;\\n    };\\n    axis.outerTickSize = function(x) {\\n      if (!arguments.length) return outerTickSize;\\n      outerTickSize = +x;\\n      return axis;\\n    };\\n    axis.tickPadding = function(x) {\\n      if (!arguments.length) return tickPadding;\\n      tickPadding = +x;\\n      return axis;\\n    };\\n    axis.tickSubdivide = function() {\\n      return arguments.length && axis;\\n    };\\n    return axis;\\n  };\\n  var d3_svg_axisDefaultOrient = \\\"bottom\\\", d3_svg_axisOrients = {\\n    top: 1,\\n    right: 1,\\n    bottom: 1,\\n    left: 1\\n  };\\n  function d3_svg_axisX(selection, x0, x1) {\\n    selection.attr(\\\"transform\\\", function(d) {\\n      var v0 = x0(d);\\n      return \\\"translate(\\\" + (isFinite(v0) ? v0 : x1(d)) + \\\",0)\\\";\\n    });\\n  }\\n  function d3_svg_axisY(selection, y0, y1) {\\n    selection.attr(\\\"transform\\\", function(d) {\\n      var v0 = y0(d);\\n      return \\\"translate(0,\\\" + (isFinite(v0) ? v0 : y1(d)) + \\\")\\\";\\n    });\\n  }\\n  d3.svg.brush = function() {\\n    var event = d3_eventDispatch(brush, \\\"brushstart\\\", \\\"brush\\\", \\\"brushend\\\"), x = null, y = null, xExtent = [ 0, 0 ], yExtent = [ 0, 0 ], xExtentDomain, yExtentDomain, xClamp = true, yClamp = true, resizes = d3_svg_brushResizes[0];\\n    function brush(g) {\\n      g.each(function() {\\n        var g = d3.select(this).style(\\\"pointer-events\\\", \\\"all\\\").style(\\\"-webkit-tap-highlight-color\\\", \\\"rgba(0,0,0,0)\\\").on(\\\"mousedown.brush\\\", brushstart).on(\\\"touchstart.brush\\\", brushstart);\\n        var background = g.selectAll(\\\".background\\\").data([ 0 ]);\\n        background.enter().append(\\\"rect\\\").attr(\\\"class\\\", \\\"background\\\").style(\\\"visibility\\\", \\\"hidden\\\").style(\\\"cursor\\\", \\\"crosshair\\\");\\n        g.selectAll(\\\".extent\\\").data([ 0 ]).enter().append(\\\"rect\\\").attr(\\\"class\\\", \\\"extent\\\").style(\\\"cursor\\\", \\\"move\\\");\\n        var resize = g.selectAll(\\\".resize\\\").data(resizes, d3_identity);\\n        resize.exit().remove();\\n        resize.enter().append(\\\"g\\\").attr(\\\"class\\\", function(d) {\\n          return \\\"resize \\\" + d;\\n        }).style(\\\"cursor\\\", function(d) {\\n          return d3_svg_brushCursor[d];\\n        }).append(\\\"rect\\\").attr(\\\"x\\\", function(d) {\\n          return /[ew]$/.test(d) ? -3 : null;\\n        }).attr(\\\"y\\\", function(d) {\\n          return /^[ns]/.test(d) ? -3 : null;\\n        }).attr(\\\"width\\\", 6).attr(\\\"height\\\", 6).style(\\\"visibility\\\", \\\"hidden\\\");\\n        resize.style(\\\"display\\\", brush.empty() ? \\\"none\\\" : null);\\n        var gUpdate = d3.transition(g), backgroundUpdate = d3.transition(background), range;\\n        if (x) {\\n          range = d3_scaleRange(x);\\n          backgroundUpdate.attr(\\\"x\\\", range[0]).attr(\\\"width\\\", range[1] - range[0]);\\n          redrawX(gUpdate);\\n        }\\n        if (y) {\\n          range = d3_scaleRange(y);\\n          backgroundUpdate.attr(\\\"y\\\", range[0]).attr(\\\"height\\\", range[1] - range[0]);\\n          redrawY(gUpdate);\\n        }\\n        redraw(gUpdate);\\n      });\\n    }\\n    brush.event = function(g) {\\n      g.each(function() {\\n        var event_ = event.of(this, arguments), extent1 = {\\n          x: xExtent,\\n          y: yExtent,\\n          i: xExtentDomain,\\n          j: yExtentDomain\\n        }, extent0 = this.__chart__ || extent1;\\n        this.__chart__ = extent1;\\n        if (d3_transitionInheritId) {\\n          d3.select(this).transition().each(\\\"start.brush\\\", function() {\\n            xExtentDomain = extent0.i;\\n            yExtentDomain = extent0.j;\\n            xExtent = extent0.x;\\n            yExtent = extent0.y;\\n            event_({\\n              type: \\\"brushstart\\\"\\n            });\\n          }).tween(\\\"brush:brush\\\", function() {\\n            var xi = d3_interpolateArray(xExtent, extent1.x), yi = d3_interpolateArray(yExtent, extent1.y);\\n            xExtentDomain = yExtentDomain = null;\\n            return function(t) {\\n              xExtent = extent1.x = xi(t);\\n              yExtent = extent1.y = yi(t);\\n              event_({\\n                type: \\\"brush\\\",\\n                mode: \\\"resize\\\"\\n              });\\n            };\\n          }).each(\\\"end.brush\\\", function() {\\n            xExtentDomain = extent1.i;\\n            yExtentDomain = extent1.j;\\n            event_({\\n              type: \\\"brush\\\",\\n              mode: \\\"resize\\\"\\n            });\\n            event_({\\n              type: \\\"brushend\\\"\\n            });\\n          });\\n        } else {\\n          event_({\\n            type: \\\"brushstart\\\"\\n          });\\n          event_({\\n            type: \\\"brush\\\",\\n            mode: \\\"resize\\\"\\n          });\\n          event_({\\n            type: \\\"brushend\\\"\\n          });\\n        }\\n      });\\n    };\\n    function redraw(g) {\\n      g.selectAll(\\\".resize\\\").attr(\\\"transform\\\", function(d) {\\n        return \\\"translate(\\\" + xExtent[+/e$/.test(d)] + \\\",\\\" + yExtent[+/^s/.test(d)] + \\\")\\\";\\n      });\\n    }\\n    function redrawX(g) {\\n      g.select(\\\".extent\\\").attr(\\\"x\\\", xExtent[0]);\\n      g.selectAll(\\\".extent,.n>rect,.s>rect\\\").attr(\\\"width\\\", xExtent[1] - xExtent[0]);\\n    }\\n    function redrawY(g) {\\n      g.select(\\\".extent\\\").attr(\\\"y\\\", yExtent[0]);\\n      g.selectAll(\\\".extent,.e>rect,.w>rect\\\").attr(\\\"height\\\", yExtent[1] - yExtent[0]);\\n    }\\n    function brushstart() {\\n      var target = this, eventTarget = d3.select(d3.event.target), event_ = event.of(target, arguments), g = d3.select(target), resizing = eventTarget.datum(), resizingX = !/^(n|s)$/.test(resizing) && x, resizingY = !/^(e|w)$/.test(resizing) && y, dragging = eventTarget.classed(\\\"extent\\\"), dragRestore = d3_event_dragSuppress(target), center, origin = d3.mouse(target), offset;\\n      var w = d3.select(d3_window(target)).on(\\\"keydown.brush\\\", keydown).on(\\\"keyup.brush\\\", keyup);\\n      if (d3.event.changedTouches) {\\n        w.on(\\\"touchmove.brush\\\", brushmove).on(\\\"touchend.brush\\\", brushend);\\n      } else {\\n        w.on(\\\"mousemove.brush\\\", brushmove).on(\\\"mouseup.brush\\\", brushend);\\n      }\\n      g.interrupt().selectAll(\\\"*\\\").interrupt();\\n      if (dragging) {\\n        origin[0] = xExtent[0] - origin[0];\\n        origin[1] = yExtent[0] - origin[1];\\n      } else if (resizing) {\\n        var ex = +/w$/.test(resizing), ey = +/^n/.test(resizing);\\n        offset = [ xExtent[1 - ex] - origin[0], yExtent[1 - ey] - origin[1] ];\\n        origin[0] = xExtent[ex];\\n        origin[1] = yExtent[ey];\\n      } else if (d3.event.altKey) center = origin.slice();\\n      g.style(\\\"pointer-events\\\", \\\"none\\\").selectAll(\\\".resize\\\").style(\\\"display\\\", null);\\n      d3.select(\\\"body\\\").style(\\\"cursor\\\", eventTarget.style(\\\"cursor\\\"));\\n      event_({\\n        type: \\\"brushstart\\\"\\n      });\\n      brushmove();\\n      function keydown() {\\n        if (d3.event.keyCode == 32) {\\n          if (!dragging) {\\n            center = null;\\n            origin[0] -= xExtent[1];\\n            origin[1] -= yExtent[1];\\n            dragging = 2;\\n          }\\n          d3_eventPreventDefault();\\n        }\\n      }\\n      function keyup() {\\n        if (d3.event.keyCode == 32 && dragging == 2) {\\n          origin[0] += xExtent[1];\\n          origin[1] += yExtent[1];\\n          dragging = 0;\\n          d3_eventPreventDefault();\\n        }\\n      }\\n      function brushmove() {\\n        var point = d3.mouse(target), moved = false;\\n        if (offset) {\\n          point[0] += offset[0];\\n          point[1] += offset[1];\\n        }\\n        if (!dragging) {\\n          if (d3.event.altKey) {\\n            if (!center) center = [ (xExtent[0] + xExtent[1]) / 2, (yExtent[0] + yExtent[1]) / 2 ];\\n            origin[0] = xExtent[+(point[0] < center[0])];\\n            origin[1] = yExtent[+(point[1] < center[1])];\\n          } else center = null;\\n        }\\n        if (resizingX && move1(point, x, 0)) {\\n          redrawX(g);\\n          moved = true;\\n        }\\n        if (resizingY && move1(point, y, 1)) {\\n          redrawY(g);\\n          moved = true;\\n        }\\n        if (moved) {\\n          redraw(g);\\n          event_({\\n            type: \\\"brush\\\",\\n            mode: dragging ? \\\"move\\\" : \\\"resize\\\"\\n          });\\n        }\\n      }\\n      function move1(point, scale, i) {\\n        var range = d3_scaleRange(scale), r0 = range[0], r1 = range[1], position = origin[i], extent = i ? yExtent : xExtent, size = extent[1] - extent[0], min, max;\\n        if (dragging) {\\n          r0 -= position;\\n          r1 -= size + position;\\n        }\\n        min = (i ? yClamp : xClamp) ? Math.max(r0, Math.min(r1, point[i])) : point[i];\\n        if (dragging) {\\n          max = (min += position) + size;\\n        } else {\\n          if (center) position = Math.max(r0, Math.min(r1, 2 * center[i] - min));\\n          if (position < min) {\\n            max = min;\\n            min = position;\\n          } else {\\n            max = position;\\n          }\\n        }\\n        if (extent[0] != min || extent[1] != max) {\\n          if (i) yExtentDomain = null; else xExtentDomain = null;\\n          extent[0] = min;\\n          extent[1] = max;\\n          return true;\\n        }\\n      }\\n      function brushend() {\\n        brushmove();\\n        g.style(\\\"pointer-events\\\", \\\"all\\\").selectAll(\\\".resize\\\").style(\\\"display\\\", brush.empty() ? \\\"none\\\" : null);\\n        d3.select(\\\"body\\\").style(\\\"cursor\\\", null);\\n        w.on(\\\"mousemove.brush\\\", null).on(\\\"mouseup.brush\\\", null).on(\\\"touchmove.brush\\\", null).on(\\\"touchend.brush\\\", null).on(\\\"keydown.brush\\\", null).on(\\\"keyup.brush\\\", null);\\n        dragRestore();\\n        event_({\\n          type: \\\"brushend\\\"\\n        });\\n      }\\n    }\\n    brush.x = function(z) {\\n      if (!arguments.length) return x;\\n      x = z;\\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\\n      return brush;\\n    };\\n    brush.y = function(z) {\\n      if (!arguments.length) return y;\\n      y = z;\\n      resizes = d3_svg_brushResizes[!x << 1 | !y];\\n      return brush;\\n    };\\n    brush.clamp = function(z) {\\n      if (!arguments.length) return x && y ? [ xClamp, yClamp ] : x ? xClamp : y ? yClamp : null;\\n      if (x && y) xClamp = !!z[0], yClamp = !!z[1]; else if (x) xClamp = !!z; else if (y) yClamp = !!z;\\n      return brush;\\n    };\\n    brush.extent = function(z) {\\n      var x0, x1, y0, y1, t;\\n      if (!arguments.length) {\\n        if (x) {\\n          if (xExtentDomain) {\\n            x0 = xExtentDomain[0], x1 = xExtentDomain[1];\\n          } else {\\n            x0 = xExtent[0], x1 = xExtent[1];\\n            if (x.invert) x0 = x.invert(x0), x1 = x.invert(x1);\\n            if (x1 < x0) t = x0, x0 = x1, x1 = t;\\n          }\\n        }\\n        if (y) {\\n          if (yExtentDomain) {\\n            y0 = yExtentDomain[0], y1 = yExtentDomain[1];\\n          } else {\\n            y0 = yExtent[0], y1 = yExtent[1];\\n            if (y.invert) y0 = y.invert(y0), y1 = y.invert(y1);\\n            if (y1 < y0) t = y0, y0 = y1, y1 = t;\\n          }\\n        }\\n        return x && y ? [ [ x0, y0 ], [ x1, y1 ] ] : x ? [ x0, x1 ] : y && [ y0, y1 ];\\n      }\\n      if (x) {\\n        x0 = z[0], x1 = z[1];\\n        if (y) x0 = x0[0], x1 = x1[0];\\n        xExtentDomain = [ x0, x1 ];\\n        if (x.invert) x0 = x(x0), x1 = x(x1);\\n        if (x1 < x0) t = x0, x0 = x1, x1 = t;\\n        if (x0 != xExtent[0] || x1 != xExtent[1]) xExtent = [ x0, x1 ];\\n      }\\n      if (y) {\\n        y0 = z[0], y1 = z[1];\\n        if (x) y0 = y0[1], y1 = y1[1];\\n        yExtentDomain = [ y0, y1 ];\\n        if (y.invert) y0 = y(y0), y1 = y(y1);\\n        if (y1 < y0) t = y0, y0 = y1, y1 = t;\\n        if (y0 != yExtent[0] || y1 != yExtent[1]) yExtent = [ y0, y1 ];\\n      }\\n      return brush;\\n    };\\n    brush.clear = function() {\\n      if (!brush.empty()) {\\n        xExtent = [ 0, 0 ], yExtent = [ 0, 0 ];\\n        xExtentDomain = yExtentDomain = null;\\n      }\\n      return brush;\\n    };\\n    brush.empty = function() {\\n      return !!x && xExtent[0] == xExtent[1] || !!y && yExtent[0] == yExtent[1];\\n    };\\n    return d3.rebind(brush, event, \\\"on\\\");\\n  };\\n  var d3_svg_brushCursor = {\\n    n: \\\"ns-resize\\\",\\n    e: \\\"ew-resize\\\",\\n    s: \\\"ns-resize\\\",\\n    w: \\\"ew-resize\\\",\\n    nw: \\\"nwse-resize\\\",\\n    ne: \\\"nesw-resize\\\",\\n    se: \\\"nwse-resize\\\",\\n    sw: \\\"nesw-resize\\\"\\n  };\\n  var d3_svg_brushResizes = [ [ \\\"n\\\", \\\"e\\\", \\\"s\\\", \\\"w\\\", \\\"nw\\\", \\\"ne\\\", \\\"se\\\", \\\"sw\\\" ], [ \\\"e\\\", \\\"w\\\" ], [ \\\"n\\\", \\\"s\\\" ], [] ];\\n  var d3_time_format = d3_time.format = d3_locale_enUS.timeFormat;\\n  var d3_time_formatUtc = d3_time_format.utc;\\n  var d3_time_formatIso = d3_time_formatUtc(\\\"%Y-%m-%dT%H:%M:%S.%LZ\\\");\\n  d3_time_format.iso = Date.prototype.toISOString && +new Date(\\\"2000-01-01T00:00:00.000Z\\\") ? d3_time_formatIsoNative : d3_time_formatIso;\\n  function d3_time_formatIsoNative(date) {\\n    return date.toISOString();\\n  }\\n  d3_time_formatIsoNative.parse = function(string) {\\n    var date = new Date(string);\\n    return isNaN(date) ? null : date;\\n  };\\n  d3_time_formatIsoNative.toString = d3_time_formatIso.toString;\\n  d3_time.second = d3_time_interval(function(date) {\\n    return new d3_date(Math.floor(date / 1e3) * 1e3);\\n  }, function(date, offset) {\\n    date.setTime(date.getTime() + Math.floor(offset) * 1e3);\\n  }, function(date) {\\n    return date.getSeconds();\\n  });\\n  d3_time.seconds = d3_time.second.range;\\n  d3_time.seconds.utc = d3_time.second.utc.range;\\n  d3_time.minute = d3_time_interval(function(date) {\\n    return new d3_date(Math.floor(date / 6e4) * 6e4);\\n  }, function(date, offset) {\\n    date.setTime(date.getTime() + Math.floor(offset) * 6e4);\\n  }, function(date) {\\n    return date.getMinutes();\\n  });\\n  d3_time.minutes = d3_time.minute.range;\\n  d3_time.minutes.utc = d3_time.minute.utc.range;\\n  d3_time.hour = d3_time_interval(function(date) {\\n    var timezone = date.getTimezoneOffset() / 60;\\n    return new d3_date((Math.floor(date / 36e5 - timezone) + timezone) * 36e5);\\n  }, function(date, offset) {\\n    date.setTime(date.getTime() + Math.floor(offset) * 36e5);\\n  }, function(date) {\\n    return date.getHours();\\n  });\\n  d3_time.hours = d3_time.hour.range;\\n  d3_time.hours.utc = d3_time.hour.utc.range;\\n  d3_time.month = d3_time_interval(function(date) {\\n    date = d3_time.day(date);\\n    date.setDate(1);\\n    return date;\\n  }, function(date, offset) {\\n    date.setMonth(date.getMonth() + offset);\\n  }, function(date) {\\n    return date.getMonth();\\n  });\\n  d3_time.months = d3_time.month.range;\\n  d3_time.months.utc = d3_time.month.utc.range;\\n  function d3_time_scale(linear, methods, format) {\\n    function scale(x) {\\n      return linear(x);\\n    }\\n    scale.invert = function(x) {\\n      return d3_time_scaleDate(linear.invert(x));\\n    };\\n    scale.domain = function(x) {\\n      if (!arguments.length) return linear.domain().map(d3_time_scaleDate);\\n      linear.domain(x);\\n      return scale;\\n    };\\n    function tickMethod(extent, count) {\\n      var span = extent[1] - extent[0], target = span / count, i = d3.bisect(d3_time_scaleSteps, target);\\n      return i == d3_time_scaleSteps.length ? [ methods.year, d3_scale_linearTickRange(extent.map(function(d) {\\n        return d / 31536e6;\\n      }), count)[2] ] : !i ? [ d3_time_scaleMilliseconds, d3_scale_linearTickRange(extent, count)[2] ] : methods[target / d3_time_scaleSteps[i - 1] < d3_time_scaleSteps[i] / target ? i - 1 : i];\\n    }\\n    scale.nice = function(interval, skip) {\\n      var domain = scale.domain(), extent = d3_scaleExtent(domain), method = interval == null ? tickMethod(extent, 10) : typeof interval === \\\"number\\\" && tickMethod(extent, interval);\\n      if (method) interval = method[0], skip = method[1];\\n      function skipped(date) {\\n        return !isNaN(date) && !interval.range(date, d3_time_scaleDate(+date + 1), skip).length;\\n      }\\n      return scale.domain(d3_scale_nice(domain, skip > 1 ? {\\n        floor: function(date) {\\n          while (skipped(date = interval.floor(date))) date = d3_time_scaleDate(date - 1);\\n          return date;\\n        },\\n        ceil: function(date) {\\n          while (skipped(date = interval.ceil(date))) date = d3_time_scaleDate(+date + 1);\\n          return date;\\n        }\\n      } : interval));\\n    };\\n    scale.ticks = function(interval, skip) {\\n      var extent = d3_scaleExtent(scale.domain()), method = interval == null ? tickMethod(extent, 10) : typeof interval === \\\"number\\\" ? tickMethod(extent, interval) : !interval.range && [ {\\n        range: interval\\n      }, skip ];\\n      if (method) interval = method[0], skip = method[1];\\n      return interval.range(extent[0], d3_time_scaleDate(+extent[1] + 1), skip < 1 ? 1 : skip);\\n    };\\n    scale.tickFormat = function() {\\n      return format;\\n    };\\n    scale.copy = function() {\\n      return d3_time_scale(linear.copy(), methods, format);\\n    };\\n    return d3_scale_linearRebind(scale, linear);\\n  }\\n  function d3_time_scaleDate(t) {\\n    return new Date(t);\\n  }\\n  var d3_time_scaleSteps = [ 1e3, 5e3, 15e3, 3e4, 6e4, 3e5, 9e5, 18e5, 36e5, 108e5, 216e5, 432e5, 864e5, 1728e5, 6048e5, 2592e6, 7776e6, 31536e6 ];\\n  var d3_time_scaleLocalMethods = [ [ d3_time.second, 1 ], [ d3_time.second, 5 ], [ d3_time.second, 15 ], [ d3_time.second, 30 ], [ d3_time.minute, 1 ], [ d3_time.minute, 5 ], [ d3_time.minute, 15 ], [ d3_time.minute, 30 ], [ d3_time.hour, 1 ], [ d3_time.hour, 3 ], [ d3_time.hour, 6 ], [ d3_time.hour, 12 ], [ d3_time.day, 1 ], [ d3_time.day, 2 ], [ d3_time.week, 1 ], [ d3_time.month, 1 ], [ d3_time.month, 3 ], [ d3_time.year, 1 ] ];\\n  var d3_time_scaleLocalFormat = d3_time_format.multi([ [ \\\".%L\\\", function(d) {\\n    return d.getMilliseconds();\\n  } ], [ \\\":%S\\\", function(d) {\\n    return d.getSeconds();\\n  } ], [ \\\"%I:%M\\\", function(d) {\\n    return d.getMinutes();\\n  } ], [ \\\"%I %p\\\", function(d) {\\n    return d.getHours();\\n  } ], [ \\\"%a %d\\\", function(d) {\\n    return d.getDay() && d.getDate() != 1;\\n  } ], [ \\\"%b %d\\\", function(d) {\\n    return d.getDate() != 1;\\n  } ], [ \\\"%B\\\", function(d) {\\n    return d.getMonth();\\n  } ], [ \\\"%Y\\\", d3_true ] ]);\\n  var d3_time_scaleMilliseconds = {\\n    range: function(start, stop, step) {\\n      return d3.range(Math.ceil(start / step) * step, +stop, step).map(d3_time_scaleDate);\\n    },\\n    floor: d3_identity,\\n    ceil: d3_identity\\n  };\\n  d3_time_scaleLocalMethods.year = d3_time.year;\\n  d3_time.scale = function() {\\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleLocalMethods, d3_time_scaleLocalFormat);\\n  };\\n  var d3_time_scaleUtcMethods = d3_time_scaleLocalMethods.map(function(m) {\\n    return [ m[0].utc, m[1] ];\\n  });\\n  var d3_time_scaleUtcFormat = d3_time_formatUtc.multi([ [ \\\".%L\\\", function(d) {\\n    return d.getUTCMilliseconds();\\n  } ], [ \\\":%S\\\", function(d) {\\n    return d.getUTCSeconds();\\n  } ], [ \\\"%I:%M\\\", function(d) {\\n    return d.getUTCMinutes();\\n  } ], [ \\\"%I %p\\\", function(d) {\\n    return d.getUTCHours();\\n  } ], [ \\\"%a %d\\\", function(d) {\\n    return d.getUTCDay() && d.getUTCDate() != 1;\\n  } ], [ \\\"%b %d\\\", function(d) {\\n    return d.getUTCDate() != 1;\\n  } ], [ \\\"%B\\\", function(d) {\\n    return d.getUTCMonth();\\n  } ], [ \\\"%Y\\\", d3_true ] ]);\\n  d3_time_scaleUtcMethods.year = d3_time.year.utc;\\n  d3_time.scale.utc = function() {\\n    return d3_time_scale(d3.scale.linear(), d3_time_scaleUtcMethods, d3_time_scaleUtcFormat);\\n  };\\n  d3.text = d3_xhrType(function(request) {\\n    return request.responseText;\\n  });\\n  d3.json = function(url, callback) {\\n    return d3_xhr(url, \\\"application/json\\\", d3_json, callback);\\n  };\\n  function d3_json(request) {\\n    return JSON.parse(request.responseText);\\n  }\\n  d3.html = function(url, callback) {\\n    return d3_xhr(url, \\\"text/html\\\", d3_html, callback);\\n  };\\n  function d3_html(request) {\\n    var range = d3_document.createRange();\\n    range.selectNode(d3_document.body);\\n    return range.createContextualFragment(request.responseText);\\n  }\\n  d3.xml = d3_xhrType(function(request) {\\n    return request.responseXML;\\n  });\\n  if (typeof define === \\\"function\\\" && define.amd) this.d3 = d3, define(d3); else if (typeof module === \\\"object\\\" && module.exports) module.exports = d3; else this.d3 = d3;\\n}();\"","module.exports = \"(function(global, factory) {\\n  if (typeof module === \\\"object\\\" && typeof module.exports === \\\"object\\\") {\\n    module.exports = global.document? factory(global, true ): factory(global);\\n  } else {\\n    factory(global);\\n  }\\n}(typeof window !== \\\"undefined\\\" ? window: this, function(window, noGlobal) {\\n  \\\"use strict\\\";\\n  var uv = {};\\n\\nuv.util = {};\\n\\n/**\\n* Utility method to extend prototype for JavaScript classes, to act like inheritance\\n* @param  {Class} f Original class which is being extended\\n* @return {Prototype}   Prototype containing the functions from the super class\\n*/\\nuv.util.inherits = function (f) {\\n  function G() {}\\n  G.prototype = f.prototype || f;\\n  return new G();\\n};\\n\\n/**\\n* Utility method to return a unique identification id\\n* @return {number} Timestamp in ms is returned as a unique id\\n*/\\nuv.util.getUniqueId = function () {\\n  return new Date().getTime();\\n};\\n\\nuv.util.getMax = function (graphdef, classification) {\\n  switch (classification) {\\n    case 'stepup':\\n      return this.getStepMaxValue(graphdef);\\n    case 'normal':\\n      return this.getMaxValue(graphdef);\\n    case 'percent':\\n      return 100;\\n    case 'waterfall':\\n      return this.getWaterfallMaxValue(graphdef);\\n    default:\\n      console.error(\\\"Unknown classification for chart\\\", classification);\\n  }\\n}\\n\\n/**\\n*\\n*/\\nuv.util.getMaxValue = function (graphdef) {\\n  return d3.max(graphdef.categories.map(function (d) {\\n    return d3.max(graphdef.dataset[d].map(function (d) {\\n      return d.value;\\n    }));\\n  }));\\n};\\n\\nuv.util.getStepMaxValue = function (graphdef) {\\n  var sumMap = graphdef.dataset[graphdef.categories[0]].map(function () {return 0; }),\\n    maxMap = sumMap.map(function () { return 0; });\\n\\n  graphdef.categories.map(function (d) {\\n    graphdef.dataset[d].map(function (d, i) {\\n      if (d.resetSum === true) {\\n        sumMap[i] = 0;\\n      }\\n      sumMap[i] += d.value;\\n      maxMap[i] = d3.max([sumMap[i], maxMap[i]]);\\n    });\\n  });\\n\\n  return d3.max(maxMap);\\n};\\n\\nuv.util.getWaterfallMaxValue = function(graphdef) {\\n  var sumMap = graphdef.categories.map(function() {return 0;});\\n  graphdef.categories.map(function (d, i) {\\n    var localMax = 0;\\n    graphdef.dataset[d].map(function(d) {\\n      localMax += d.value;\\n      if(sumMap[i] < localMax) {\\n        sumMap[i] = localMax;\\n      }\\n    });\\n  });\\n\\n  return d3.max(sumMap);\\n};\\n\\nuv.util.getMin = function (graphdef, classification) {\\n  switch (classification) {\\n    case 'normal':\\n      return this.getMinValue(graphdef);\\n    case 'stepup':\\n      return this.getStepMinValue(graphdef);\\n    default:\\n      return 0;\\n  }\\n}\\n\\n/**\\n*\\n*/\\nuv.util.getMinValue = function (graphdef) {\\n  return d3.min([0, d3.min(graphdef.categories.map(function (d) {\\n      return d3.min(graphdef.dataset[d].map(function (d) {\\n        return d.value;\\n      }));\\n    }))\\n  ]);\\n};\\n\\nuv.util.getStepMinValue = function (graphdef) {\\n  var sumMap = graphdef.dataset[graphdef.categories[0]].map(function () {return 0; }),\\n    minMap = sumMap.map(function () { return 0; });\\n\\n  graphdef.categories.map(function (d) {\\n    graphdef.dataset[d].map(function (d, i) {\\n      sumMap[i] += d.value;\\n      minMap[i] = d3.min([sumMap[i], minMap[i]]);\\n    });\\n  });\\n\\n  return d3.min(minMap);\\n}\\n\\nuv.util.getSumUpArray = function (graphdef) {\\n  var sumMap = graphdef.dataset[graphdef.categories[0]].map(function () {return 0; });\\n  graphdef.categories.map(function (d) {\\n    graphdef.dataset[d].map(function (d, i) {\\n      sumMap[i] += d.value;\\n    });\\n  });\\n\\n  return sumMap;\\n};\\n\\nuv.util.getPercentage = function (value, total) {\\n  return value* 100 / total;\\n};\\n\\nuv.util.getDataArray = function (graphdef) {\\n  return graphdef.categories.map(function (d) { return graphdef.dataset[d]; });\\n};\\n\\nuv.util.getTabularArray = function (graphdef) {\\n  var table = [], i, j, catlen, len, arr = [];\\n  for (i = 0, len = graphdef.dataset[graphdef.categories[0]].length; i < len; i = i + 1) {\\n    arr = [];\\n    arr.push(graphdef.dataset[graphdef.categories[0]][i].name);\\n    for (j = 0, catlen = graphdef.categories.length; j < catlen; j = j + 1) {\\n      arr.push(graphdef.dataset[graphdef.categories[j]][i].value);\\n    }\\n    table.push(arr);\\n  }\\n  return table;\\n};\\n\\nuv.util.getLabelArray = function (graphdef, idx) {\\n  return graphdef.dataset[graphdef.categories[idx ? idx : 0]].map(function (d) { return d.name; });\\n};\\n\\nuv.util.getCategoryArray = function (graphdef) {\\n  return graphdef.categories.map(function (d) { return d; });\\n};\\n\\nuv.util.getCategoryData = function (graphdef, categories) {\\n  return categories.map(function (d) {\\n    return graphdef.dataset[d].map(function (d) {\\n      return d.value;\\n    });\\n  });\\n};\\n\\nuv.util.transposeData = function (graphdef) {\\n  var dataset = {}, i, j, length, jlength, resetSum,\\n    name, label, value, categories = graphdef.dataset[graphdef.categories[0]].map(function (d) { return d.name; });\\n\\n  for (i = 0, length = categories.length; i < length; i = i + 1) {\\n    dataset[categories[i]] = [];\\n  }\\n\\n  for (i = 0, length = graphdef.categories.length; i < length; i = i + 1) {\\n    name = graphdef.categories[i];\\n    for (j = 0, jlength = graphdef.dataset[name].length; j < jlength; j = j + 1) {\\n      label = graphdef.dataset[name][j].name;\\n      value = graphdef.dataset[name][j].value;\\n      resetSum = graphdef.dataset[name][j].resetSum;\\n      dataset[label].push({ 'name' : name, 'value' : value, 'resetSum': resetSum });\\n    }\\n  }\\n\\n  graphdef.categories = categories;\\n  graphdef.dataset = dataset;\\n};\\n\\nuv.util.getPascalCasedName = function (name) {\\n  return name.substring(0, 1).toUpperCase() + name.substring(1);\\n};\\n\\nuv.util.getColorBand = function (config, index) {\\n  var len = 0,\\n    palette = config.graph.palette || 'Default';\\n\\n  if (config.graph.custompalette && config.graph.custompalette.length !== 0) {\\n    len = config.graph.custompalette.length;\\n    return config.graph.custompalette[index % len];\\n  } else {\\n    len = uv.palette[config.graph.palette].length;\\n    return uv.palette[config.graph.palette][index % len];\\n  }\\n};\\n\\n/**\\n* This function finds regular expressions other than Alphabets, Numbers,\\n* \\\"_\\\" and \\\"-\\\" and replaces it with \\\"-\\\".\\n* @param  {string} name The string which needs to be formatted\\n* @return {string}      Returns the formatted String\\n*/\\nuv.util.formatClassName = function(name){\\n  var returnName = name.trim().replace(/[^A-Za-z0-9_\\\\-]/g,\\\"-\\\").toLowerCase();\\n  return returnName;\\n};\\n\\nuv.util.svgToPng = function (downloadElmtRef, callback) {\\n  if (this.isCanvasSupported()) {\\n    var svgContent = d3.select(downloadElmtRef.frame.node().parentNode).html();\\n    var canvas = document.createElement('canvas');\\n    var ctx = canvas.getContext(\\\"2d\\\");\\n    canvas.setAttribute('width',d3.select(downloadElmtRef.frame.node()).attr('width'));\\n    canvas.setAttribute('height',d3.select(downloadElmtRef.frame.node()).attr('height'));\\n    ctx.drawSvg(svgContent);\\n    canvas.toBlob(function(blob) {\\n      //saveAs(blob, \\\"png_download\\\"+Math.ceil(Math.random()*100000)+\\\".png\\\");\\n      var a = document.createElement(\\\"a\\\");\\n      document.body.appendChild(a);\\n      a.style = \\\"display: none\\\";\\n      var url = window.URL.createObjectURL(blob);\\n      a.href = url;\\n      a.download = \\\"png_download\\\"+Math.ceil(Math.random()*100000)+\\\".png\\\";\\n      a.click();\\n      //window.URL.revokeObjectURL(url);\\n    }, \\\"image/png\\\");\\n    callback.call();\\n  } else {\\n    console.log('uvCharts: Download feature is not supported in this version of browser');\\n  }\\n};\\n\\nuv.util.isDownloadSupported = function() {\\n  var canvas = document.createElement('canvas');\\n  var ctx = canvas.getContext(\\\"2d\\\");\\n  return typeof(ctx.drawSvg) === 'function' && typeof(canvas.toBlob) === 'function';\\n};\\n\\nuv.util.isCanvasSupported = function () {\\n  var elem = document.createElement('canvas');\\n  return !!(elem.getContext && elem.getContext('2d'));\\n};\\n\\n/**\\n* This function waits till the end of the transition and then call the callback\\n* function which is passed as an argument\\n* @param  {transition}   transition It's the current transition\\n* @param  {Function} callback   function which is called at the end of\\n*                               transition\\n*/\\nuv.util.endAll = function (transition, callback){\\n  var n = 0;\\n  transition.each(function() { ++n; }).each(\\\"end\\\", function() {\\n    if (!--n) {\\n      callback.apply(this, arguments);\\n    }\\n  });\\n};\\n\\n/**\\n* This function returns all class names of the element including new class name.\\n* Useful in cases where we need to avoid over-writting of classes.\\n* @param  {} self this referring to svgElement\\n* @param  {String} name new class name to be added\\n* @return {String}      All class names as string.\\n*/\\nuv.util.getClassName = function(self, name) {\\n  var formattedName = uv.util.formatClassName(name);\\n  if( !d3.select(self).attr('class')) {\\n    return formattedName;\\n  }\\n  if(d3.select(self).attr('class').split(' ').indexOf(formattedName) !== -1) {\\n    return d3.select(self).attr('class');\\n  }\\n  return d3.select(self).attr('class') + \\\" \\\" + formattedName;\\n};\\n\\n/**\\n* Returns specified value of given data object if integer, else returns formatted value considering precision.\\n* @param  self\\n* @param  {Number} d    data object\\n* @return {Strinig}     value with precision\\n*/\\nuv.util.getLabelValue = function(self, d) {\\n  // if(typeof d.value !== 'number') return null;\\n  if (self.config.label.formatter !== undefined) {\\n    return self.config.label.formatter(d.value);\\n  }\\n\\n  var val = (d.value % 1 === 0) ? d.value : d.value.toFixed(self.config.label.precision);\\n  return self.config.label.prefix + String(val) + self.config.label.suffix;\\n};\\n\\nuv.util._deepClone = function(target, src) {\\n    if(typeof src === 'object') {\\n        var isEmpty = true;\\n        for(var key in src) {\\n            isEmpty = false;\\n            if(src.hasOwnProperty(key)) {\\n              if(target === undefined) {\\n                  target = Array.isArray(src) ? [] : {};\\n              }\\n              target[key] = uv.util._deepClone(target[key], src[key]);\\n            }\\n        }\\n        if(isEmpty){\\n            target = Array.isArray(src) ? [] : {};\\n        }\\n    } else {\\n        target = src;\\n    }\\n    return target;\\n};\\n\\n\\n/**\\n* Extends properies of rest of the arguments to the first argument.\\n* @param  {Object} target\\n* @param  {Object} argument1\\n* @param  {Object} argumentN\\n* @return target object\\n*/\\nuv.util.extend = function() {\\n  if(arguments[0] === undefined || arguments[0] === null) {\\n    return arguments[0];\\n  }\\n    for(var i=1; i<arguments.length; i++) {\\n        for(var key in arguments[i]) {\\n            if(arguments[i].hasOwnProperty(key)) {\\n                arguments[0][key] = uv.util._deepClone(arguments[0][key], arguments[i][key]);\\n            }\\n        }\\n    }\\n    return arguments[0];\\n};\\n\\n/**\\n* This method returns tool tip text value if config option ‘show tooltiptext’ is true else returns empty string.\\n* The text is as per the format specified using %c, %l, %v for category, label and values respectively.\\n* Default format is - ‘%c [%l] : %v’\\n* @param   self\\n* @param  {String} category\\n* @param  {String} label\\n* @param  {String} value\\n* @return {[String]}  tool tip text with specified format.\\n*/\\nuv.util.getTooltipText = function(self, category, label, value) {\\n  if(!self.config.tooltip.show) {\\n    return '';\\n  }\\n  var format = self.config.tooltip.format;\\n  if(format === '') {\\n    return category + ' [' + label + '] : ' + uv.util.getLabelValue(value);\\n  }\\n  return format.replace(/%c/gi, category).replace(/%l/gi, label).replace(/%v/gi, uv.util.getLabelValue(self, value));\\n};\\n\\nuv.config = {\\n  graph: {\\n    palette: 'Default',\\n    bgcolor: '#FFFFFF',\\n    orientation: 'Horizontal',\\n    max: 0,\\n    min: 0,\\n    custompalette: [],\\n    opacity: 1,\\n    responsive: false,\\n    align: 'xMinYMin',\\n    meetOrSlice: 'meet'\\n  },\\n\\n  meta: {\\n    position: '#uv-div',\\n    caption: '',\\n    subcaption: '',\\n    hlabel: '',\\n    vlabel: '',\\n    hsublabel: '',\\n    vsublabel: '',\\n    isDownloadable: false,\\n    downloadLabel: 'Download'\\n  },\\n\\n  dimension: {\\n    width: 400,\\n    height: 400\\n  },\\n\\n  margin: {\\n    top: 50,\\n    bottom: 150,\\n    left: 100,\\n    right: 100\\n  },\\n\\n  frame: {\\n    bgcolor: '#FFFFFF'\\n  },\\n\\n  axis: {\\n    ticks: 8,\\n    subticks: 2,\\n    padding: 5,\\n    minor: -10,\\n    strokecolor: '#000000',\\n    fontfamily: 'Arial',\\n    fontsize: '14',\\n    fontweight: 'bold',\\n    showticks: true,\\n    showsubticks: true,\\n    showtext: true,\\n    showhortext: true,\\n    showvertext: true,\\n    opacity: 0.1\\n  },\\n\\n  label: {\\n    fontfamily: 'Arial',\\n    fontsize: '11',\\n    fontweight: 'normal',\\n    strokecolor: '#000000',\\n    showlabel: true,\\n    precision: 2,\\n    prefix: '',\\n    suffix: '',\\n    formatter: undefined\\n  },\\n\\n  tooltip: {\\n    show: true,\\n    format: '%c [%l]: %v'\\n  },\\n\\n  scale: {\\n    type: 'linear',\\n    ordinality: 0.2\\n  },\\n\\n  bar: {\\n    strokecolor: 'none',\\n    fontfamily: 'Arial',\\n    fontsize: '10',\\n    fontweight: 'bold',\\n    textcolor: '#000'\\n  },\\n\\n  line: {\\n    interpolation: 'linear',\\n    showcircles: true,\\n    circleradius: 3.5,\\n    circleopacity: 0.6,\\n    fontfamily: 'Arial',\\n    fontsize : '10',\\n    fontweight: 'bold',\\n    textcolor: '#000',\\n    strokewidth: 1.5,\\n    strokeopacity: 1\\n  },\\n\\n  area: {\\n    interpolation: 'cardinal',\\n    offset: 'zero',\\n    opacity: 0.2\\n  },\\n\\n  pie: {\\n    fontfamily: 'Arial',\\n    fontsize: '14',\\n    fontweight: 'normal',\\n    fontvariant: 'small-caps',\\n    fontfill: '#FFFFFF',\\n    strokecolor: '#FFFFFF',\\n    strokewidth: 1\\n  },\\n\\n  donut: {\\n    fontfamily: 'Arial',\\n    fontsize: '14',\\n    fontweight: 'normal',\\n    fontvariant: 'small-caps',\\n    fontfill: '#000',\\n    factor: 0.4,\\n    strokecolor: '#FFFFFF',\\n    strokewidth: 1\\n  },\\n\\n  caption: {\\n    fontfamily: 'Arial',\\n    fontsize: '14',\\n    fontweight: 'bold',\\n    fontvariant: 'small-caps',\\n    textdecoration: 'none',\\n    hovercolor: '#696969',\\n    strokecolor: '#0000FF',\\n    textanchor: 'middle',\\n    cursor: 'pointer'\\n  },\\n\\n  subCaption: {\\n    fontfamily: 'Arial',\\n    fontsize: '9',\\n    fontweight: 'normal',\\n    fontvariant: 'normal',\\n    textdecoration: 'none',\\n    textanchor: 'middle'\\n  },\\n\\n  legend: {\\n    position: 'bottom',\\n    fontfamily: 'Arial',\\n    fontsize: '11',\\n    fontweight: 'normal',\\n    color: \\\"#000000\\\",\\n    strokewidth: 0.15,\\n    textmargin: 15,\\n    symbolsize: 10,\\n    inactivecolor: '#DDD',\\n    legendstart: 0,\\n    legendtype: 'categories',\\n    showlegends: true,\\n  },\\n\\n  effects: {\\n    hovercolor: '#FF0000',\\n    strokecolor: 'none',\\n    textcolor: '#000000',\\n    duration: 800,\\n    hover: 400,\\n    showhovertext: false\\n  }\\n};\\n\\nuv.constants = {};\\n\\nuv.constants.classes = {\\n  uv : 'uv',\\n  pos : 'uv-div',\\n  frame : 'uv-frame',\\n  panel : 'uv-panel',\\n  bg : 'uv-chart-bg',\\n  chart : 'uv-chart',\\n  axes : 'uv-axes',\\n  legend : 'uv-legend',\\n  framebg : 'uv-frame-bg',\\n  horaxis : 'uv-hor-axis',\\n  veraxis : 'uv-ver-axis',\\n  caption : 'uv-caption',\\n  captiontext : 'uv-caption-text',\\n  subcaption : 'uv-subcaption',\\n  subcaptiontext : 'uv-subcaption-text',\\n  axeslabelgroup : 'uv-axes-label-group',\\n  axeslabel : 'uv-axes-label',\\n  axessublabel : 'uv-axes-sub-label',\\n  legendsign : 'uv-legend-sign',\\n  legendlabel : 'uv-legend-label',\\n  hoverbg : 'uv-hover-bg',\\n  arc : 'uv-arc-',\\n  areapath : 'uv-areapath-',\\n  linepath :'uv-linepath-',\\n  area : 'uv-area-',\\n  line : 'uv-line-',\\n  dot : 'uv-dot',\\n  chartdiv : 'uv-chart-div',\\n  circleticks : 'circle-ticks',\\n  download : 'uv-download-options'\\n};\\n\\nuv.constants.downloads = {\\n  downloadLabel: 'Download'\\n};\\n\\nuv.types = {};\\n\\nuv.addChart = function (type, functionName) {\\n  uv.types[type] = functionName;\\n};\\n\\nuv.addChart('bar','BarGraph');\\nuv.addChart('line','LineGraph');\\nuv.addChart('stackedbar','StackedBarGraph');\\nuv.addChart('stepupbar','StepUpBarGraph');\\nuv.addChart('area','AreaGraph');\\nuv.addChart('stackedarea','StackedAreaGraph');\\nuv.addChart('percentbar','PercentBarGraph');\\nuv.addChart('percentarea','PercentAreaGraph');\\nuv.addChart('pie','PieGraph');\\nuv.addChart('donut','DonutGraph');\\nuv.addChart('waterfall','WaterfallGraph');\\nuv.addChart('polararea','PolarAreaGraph');\\n\\nuv.chart = function (type, graphdef, config) {\\n  type = type.toLowerCase()\\n  if (uv.types[type] !== undefined) {\\n    return new uv[uv.types[type]](graphdef, config);\\n  }\\n};\\n\\nuv.effects = {};\\n\\nuv.effects.bar = {};\\nuv.effects.bar.mouseover = function (graph, idx) {\\n  var config = graph.config,\\n    category = graph.categories[idx],\\n    label = graph.labels[idx];\\n\\n  var effect = function () {\\n    graph.frame.selectAll('rect.cr-' + uv.util.formatClassName(category))\\n      .transition().duration(config.effects.hover)\\n        .style('fill', config.effects.hovercolor)\\n        .style('stroke', config.effects.strokecolor);\\n\\n    if(config.effects.showhovertext){\\n      graph.frame.selectAll('text.cr-' + uv.util.formatClassName(category))\\n        .transition().duration(config.effects.hover)\\n          .style('fill', config.effects.textcolor)\\n          .style('opacity', 1);\\n    }\\n  };\\n\\n  if(config.legend.legendtype === 'categories'){\\n    graph.effects[category].mouseover = effect;\\n  }else{\\n    graph.effects[label].mouseover = effect;\\n  }\\n  return effect;\\n};\\n\\nuv.effects.bar.mouseout = function (graph, idx, defColor) {\\n  var config = graph.config,\\n    category = graph.categories[idx],\\n    barColor = uv.util.getColorBand(graph.config, idx),\\n    textColor = defColor || uv.util.getColorBand(graph.config, idx),\\n    label = graph.labels[idx];\\n\\n  var effect = function () {\\n    graph.frame.selectAll('rect.cr-' + uv.util.formatClassName(category))\\n      .transition().duration(config.effects.hover)\\n        .style('fill', barColor)\\n        .style('stroke', 'none');\\n\\n    graph.frame.selectAll('text.cr-' + uv.util.formatClassName(category))\\n      .transition().duration(config.effects.hover)\\n        .style('fill', graph.config.label.showlabel ? textColor : 'none');\\n  };\\n\\n  if(config.legend.legendtype === 'categories'){\\n    graph.effects[category].mouseout = effect;\\n  }else{\\n    graph.effects[label].mouseout = effect;\\n  }\\n  return effect;\\n};\\n\\nuv.effects.area = {};\\nuv.effects.area.mouseover = function (graph, idx) {\\n  var config = graph.config,\\n    category = graph.categories[idx];\\n\\n  var effect = function () {\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).select('path.' + uv.constants.classes.area + uv.util.formatClassName(category))\\n    .transition().duration(config.effects.hover)\\n    .style('fill',config.effects.hovercolor);\\n  };\\n\\n  graph.effects[category].mouseover = effect;\\n  return effect;\\n};\\n\\nuv.effects.area.mouseout = function (graph, idx) {\\n  var config = graph.config,\\n    category = graph.categories[idx];\\n\\n  var effect = function () {\\n    graph.frame.selectAll('.cge-'+ uv.util.formatClassName(category)).select('path.'+ uv.constants.classes.area + uv.util.formatClassName(category));\\n    graph.frame.selectAll('.cge-'+uv.util.formatClassName(category)).select('path.' + uv.constants.classes.area +uv.util.formatClassName(category))\\n    .transition().duration(config.effects.hover)\\n    .style('fill',uv.util.getColorBand(config,idx));\\n  };\\n\\n  graph.effects[category].mouseout = effect;\\n  return effect;\\n};\\n\\n\\nuv.effects.line = {};\\nuv.effects.line.mouseover = function (graph, idx) {\\n  var config = graph.config,\\n    category = graph.categories[idx];\\n\\n  var effect = function () {\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).selectAll('circle')\\n      .transition().duration(config.effects.hover)\\n        .style('fill', config.effects.hovercolor)\\n        .style('fill-opacity', 1)\\n        .style('stroke', config.effects.hovercolor);\\n\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).select('path')\\n      .transition().duration(config.effects.hover)\\n        .style('stroke', config.effects.hovercolor);\\n\\n    if(config.effects.showhovertext){\\n      graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).selectAll('text')\\n        .transition().duration(config.effects.hover)\\n          .style('fill', config.effects.textcolor);\\n    }\\n  };\\n  graph.effects[category].mouseover = effect;\\n\\n  return effect;\\n};\\n\\nuv.effects.line.mouseout = function (graph, idx, defColor) {\\n  var config = graph.config,\\n    category = graph.categories[idx],\\n    color = defColor || uv.util.getColorBand(graph.config, idx);\\n\\n  var effect = function () {\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).selectAll('circle')\\n      .transition().duration(config.effects.hover)\\n        .style('fill', color)\\n        .style('fill-opacity', 0.6)\\n        .style('stroke', '#fff');\\n\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).select('path')\\n      .transition().duration(config.effects.hover)\\n        .style('stroke', color);\\n\\n    graph.frame.selectAll('.cge-' + uv.util.formatClassName(category)).selectAll('text')\\n      .transition().duration(config.effects.hover)\\n        .style('fill', graph.config.label.showlabel ? color : 'none');\\n\\n  };\\n  graph.effects[category].mouseout = effect;\\n  return effect;\\n};\\n\\nuv.effects.caption = {};\\nuv.effects.caption.mouseover = function (config) {\\n  return function () {\\n    d3.select(this.parentNode.parentNode).select('.' + uv.constants.classes.hoverbg)\\n      .transition().duration(config.effects.duration)\\n        .style('fill', config.caption.hovercolor);\\n  };\\n};\\n\\nuv.effects.caption.mouseout = function (config) {\\n  return function () {\\n    d3.select(this.parentNode.parentNode).select('.' + uv.constants.classes.hoverbg)\\n      .transition().duration(config.effects.duration)\\n        .style('fill', config.graph.bgcolor);\\n  };\\n};\\n\\nuv.effects.donut = {};\\nuv.effects.donut.mouseover = function (center, arcfunc, config, d) {\\n  return function (d) {\\n    var dev = {\\n        x : arcfunc.centroid(d)[0] / 5,\\n        y : arcfunc.centroid(d)[1] / 5\\n      };\\n\\n    d3.select(this.parentNode)\\n      .transition().duration(config.effects.duration)\\n        .attr('transform', 'translate(' + (center.x + dev.x) + ',' + (center.y + dev.y) + ')');\\n  };\\n};\\n\\nuv.effects.donut.mouseout = function (center, config) {\\n  return function () {\\n    d3.select(this.parentNode)\\n      .transition().duration(config.effects.duration)\\n        .attr('transform', 'translate(' + center.x + ',' + center.y + ')');\\n  };\\n};\\n\\nuv.effects.pie = {};\\nuv.effects.pie.mouseover = function (graph ,center, arcfunc, config) {\\n  var effect =  function (d) {\\n    var dev = {\\n        x : arcfunc.centroid(d)[0] / 5,\\n        y : arcfunc.centroid(d)[1] / 5\\n      };\\n    d3.select(this.parentNode)\\n      .transition().duration(config.effects.duration)\\n        .attr('transform', 'translate(' + (center.x + dev.x) + ',' + (center.y + dev.y) + ')');\\n  };\\n  return effect;\\n};\\n\\nuv.effects.pie.mouseout = function (graph, center, config) {\\n  var effect =  function () {\\n    d3.select(this.parentNode)\\n      .transition().duration(config.effects.duration)\\n        .attr('transform', 'translate(' + center.x + ',' + center.y + ')');\\n  };\\n  return effect;\\n};\\n\\nuv.effects.legend = {};\\nuv.effects.legend.mouseover = function (self, idx) {\\n  if(self.config.legend.legendtype === 'categories'){\\n    return self.effects.group[self.categories[idx]].mouseover;\\n  }else{\\n    return self.effects.group[self.labels[idx]].mouseover;\\n  }\\n};\\n\\nuv.effects.legend.mouseout = function (self, idx) {\\n  if(self.config.legend.legendtype === 'categories'){\\n    return self.effects.group[self.categories[idx]].mouseout;\\n  }else{\\n    return self.effects.group[self.labels[idx]].mouseout;\\n  }\\n};\\n\\nuv.effects.legend.click = function (i, ctx, graph) {\\n  var disabled = (d3.select(ctx).attr('disabled') === 'false') ? false : true;\\n  graph.toggleGraphGroup(i);\\n  d3.select(ctx).select('rect').style('fill', disabled ? uv.util.getColorBand(graph.config, i) : uv.config.legend.inactivecolor);\\n  d3.select(ctx).select('text').style('fill', disabled ? null : uv.config.legend.inactivecolor);\\n  d3.select(ctx).attr('disabled', disabled ? 'false' : 'true');\\n};\\n\\nuv.palette = {\\n  'Default': ['#00BBC9', '#EC63AB', '#AA8AE4', '#83CE44', '#ff8f25', '#009EAA', '#CA4F7F', '#9C70C0', '#6BAF3B'],\\n  'OldDefault' : ['#7E6DA1', '#C2CF30', '#FF8900', '#FE2600', '#E3003F', '#8E1E5F', '#FE2AC2', '#CCF030', '#9900EC', '#3A1AA8', '#3932FE', '#3276FF', '#35B9F6', '#42BC6A', '#91E0CB'],\\n  'Plain' : ['#B1EB68', '#B1B9B5', '#FFA16C', '#9B64E7', '#CEE113', '#2F9CFA', '#CA6877', '#EC3D8C', '#9CC66D', '#C73640', '#7D9532', '#B064DC' ],\\n  'Android' : ['#33B5E5', '#AA66CC', '#99CC00', '#FFBB33', '#FF4444', '#0099CC', '#9933CC', '#669900', '#FF8800', '#CC0000'],\\n  'Soft' : [ '#9ED8D2', '#FFD478', '#F16D9A', '#A8D59D', '#FDC180', '#F05133', '#EDED8A', '#F6A0A5', '#9F218B' ],\\n  'Simple' : [ '#FF8181', '#FFB081', '#FFE081', '#EFFF81', '#BFFF81', '#90FF81', '#81FFA2', '#81FFD1', '#9681FF', '#C281FF', '#FF81DD' ],\\n  'Egypt' : [ '#3A3E04','#784818','#FCFCA8','#C03C0C','#F0A830','#A8783C','#FCFCFC','#FCE460','#540C00','#C0C084','#3C303C','#1EA34A','#606C54','#F06048' ],\\n  'Olive' : [ '#18240C','#3C6C18','#60A824','#90D824','#A8CC60','#789C60','#CCF030','#B4CCA8','#D8F078','#40190D','#E4F0CC' ],\\n  'Candid' : [ '#AF5E14','#81400C','#E5785D','#FEBFBF','#A66363','#C7B752','#EFF1A7','#83ADB7','#528F98','#BCEDF5','#446B3D','#8BD96F','#E4FFB9' ],\\n  'Sulphide' : [ '#594440','#0392A7','#FFC343','#E2492F','#007257','#B0BC4A','#2E5493','#7C2738','#FF538B','#A593A1','#EBBA86','#E2D9CA' ],\\n  'Lint' : ['#A8A878','#F0D89C','#60909C','#242418','#E49C30','#54483C','#306090','#C06C00','#C0C0C0','#847854','#6C3C00','#9C3C3C','#183C60','#FCCC00','#840000','#FCFCFC']\\n};\\n\\n/**\\n* uv.Graph is an abstract class of sorts which serves as the base for all other graphs. Instances of it wouldnt be anything except bare bones needed to create a chart.\\n* id          - unique id corresponding to the graph, created using current timestamp {#TODO: needs improved logic}\\n* graphdef    - definition of the graph, containing data on which the visualization is built\\n* config      - configuration of the graph, affecting the visual styling of the graph\\n* frame      - <svg> element acting as the parent graph container\\n* panel      - <g> element containing everything else, making it easier to move all elements across the svg\\n* bg          - <rect> element which acts as the background for the graph\\n* effects    - object containing functions which cause the various interactions on the graph\\n* labels      - labels from the dataset provided\\n* categories  - categories from the dataset provided\\n* axes        - object containing axes related stuff: group, func, scale, axis, line, label\\n*\\n*/\\nuv.Graph = function (graphdef, config) {\\n  var self = this;\\n  self.id = uv.util.getUniqueId();\\n  self.graphdef = null;\\n  self.config = null;\\n\\n  self.frame = null;\\n  self.panel = null;\\n  self.chart = null;\\n  self.bg = null;\\n  self.effects = {};\\n  self.axes = {\\n    hor: { group: null, scale : null, func: null, axis : null, line : null, label : null },\\n    ver: { group: null, scale : null, func: null, axis : null, line : null, label : null },\\n    meta: { min: null, max: null }\\n  };\\n\\n  self.labels = null;\\n  self.categories = null;\\n\\n  self.graphdef = graphdef;\\n  self.config = uv.util.extend({}, uv.config, config);\\n  return this;\\n};\\n\\n/**\\n* As the name suggests, this function initializes graph object construction based on the config and graphdef\\n* @param  {Object} graphdef Definition of the graph, take a look at constants.js for complete documentation\\n* @param  {Object} config   Configuration of the graph, take a look at config.js for complete documentation\\n* @return {Object}          The graph object itself, to support method chaining\\n*\\n* #TODO: Remove dependency on jQuery/$\\n*/\\nuv.Graph.prototype.init = function () {\\n  var self = this;\\n  self.max()\\n    .min()\\n    .position(self.config.meta.position || 'body')\\n    .setDimensions()\\n    .setFrame()\\n    .setPanel()\\n    .setBackground()\\n    .setCaption()\\n    .setSubCaption()\\n    .setMetadata()\\n    .setHorizontalAxis()\\n    .setVerticalAxis()\\n    .setEffectsObject();\\n\\n  if(self.config.meta.isDownloadable){\\n    self.setDownloadOptions();\\n  }\\n  if(self.config.legend.showlegends){\\n    self.setLegend();\\n  }\\n\\n  return self;\\n};\\n\\n/**\\n* Sets the dimensions of the graphs, namely height, width and margins: left, right, top and bottom\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setDimensions = function () {\\n  var self = this;\\n  self.height(self.config.dimension.height)\\n    .width(self.config.dimension.width)\\n    .top(self.config.margin.top)\\n    .bottom(self.config.margin.bottom)\\n    .left(self.config.margin.left)\\n    .right(self.config.margin.right);\\n\\n  return this;\\n};\\n\\n/**\\n* This function downloads the graph in png format.\\n*\\n*/\\nuv.Graph.prototype.setDownloadOptions = function () {\\n  if (uv.util.isDownloadSupported()) {\\n    var self = this;\\n    self.download = self.panel.append('g').classed(uv.constants.classes.download, true);\\n    self.download.append('text').classed(uv.constants.classes.download, true)\\n    .text(self.config.meta.downloadLabel)\\n    .attr('y', -self.config.margin.top / 2)\\n    .attr('x', self.config.dimension.width-25)\\n    .attr('text-anchor', self.config.caption.textanchor)\\n    .style('font-family', self.config.caption.fontfamily)\\n    .style('font-size', '12')\\n    .style('cursor', self.config.caption.cursor)\\n    .style('stroke', self.config.caption.strokecolor)\\n    .style('text-decoration', 'underline')\\n    .on('mouseover', function() {\\n      var dnldBtn = d3.select(this);\\n      dnldBtn.style('color','#0000FF');\\n    })\\n    .on('mouseout', function() {\\n      var dnldBtn = d3.select(this);\\n      dnldBtn.style('color','#8D8D8D');\\n    })\\n    .on('click', function () {\\n      var dnldBtn = d3.select(this);\\n      dnldBtn.style('display','none');\\n      uv.util.svgToPng(self, function() {\\n          dnldBtn.style('display',null);\\n      });\\n    });\\n  }\\n};\\n\\n\\n/**\\n* Sets the main <svg> element which contains rest of the graph elements\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setFrame = function () {\\n  var self = this;\\n  if (!self.frame) {\\n    self.frame = d3.select(self.position() || 'body').append('div')\\n      .classed(uv.constants.classes.chartdiv, true)\\n      .style('display','inline-block')\\n      .style('width', '100%')\\n      .style('height', '100%')\\n      .append('svg');\\n  }\\n\\n  self.frame.attr('id', uv.constants.classes.uv + '-' + self.id)\\n    .classed(uv.constants.classes.frame, true);\\n\\n  if (self.config.graph.responsive === true) {\\n    self.frame.attr('width', '100%')\\n      .attr('height', '100%')\\n      .attr('preserveAspectRatio', self.config.graph.align + ' ' + self.config.graph.meetOrSlice)\\n      .attr('viewBox', '0 0 ' + (self.width() + self.left() + self.right()) + ' ' + (self.height() + self.top() + self.bottom()));\\n  } else {\\n    self.frame.attr('width', self.width() + self.left() + self.right())\\n      .attr('height', self.height() + self.top() + self.bottom());\\n  }\\n\\n  self.frame.append('rect').classed(uv.constants.classes.framebg, true)\\n    .attr('width', self.width() + self.left() + self.right())\\n    .attr('height', self.height() + self.top() + self.bottom())\\n    .style('fill', self.config.frame.bgcolor);\\n\\n  return this;\\n};\\n\\n/**\\n* Sets the <g> element which serves as the base position for the graph elements\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setPanel = function () {\\n  var self = this;\\n  if (!self.panel) {\\n    self.panel = self.frame.append('g');\\n  }\\n\\n  self.panel.attr('id', uv.constants.classes.panel + '-' + self.id)\\n    .classed(uv.constants.classes.panel, true)\\n    .attr('transform', 'translate(' + self.left() + ',' + self.top() + ')');\\n\\n  return this;\\n};\\n\\n/**\\n* Sets the <rect> element which serves as the background for the chart\\n* @param {String} color Color code for the background, set to config value if not specified\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setBackground = function (color) {\\n  var self = this;\\n  if (!self.bg) {\\n    self.bg = self.panel.append('rect').classed(uv.constants.classes.bg, true)\\n            .attr('height', self.height())\\n            .attr('width', self.width());\\n  }\\n  self.bg.style('fill', color || self.config.graph.bgcolor);\\n\\n  self.chart = self.panel.append('g').classed(uv.constants.classes.chart, true)\\n          .style('opacity', self.config.graph.opacity);\\n  return this;\\n};\\n\\n/**\\n* Sets the caption for the graph\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setCaption = function () {\\n  var self = this;\\n  self.caption = self.panel.append('g').classed(uv.constants.classes.caption, true);\\n\\n  self.caption.append('text').classed(uv.constants.classes.captiontext, true)\\n    .text(self.config.meta.caption)\\n    .attr('y', -self.config.margin.top / 2)\\n    .attr('x', self.config.dimension.width / 2)\\n    .attr('text-anchor', self.config.caption.textanchor)\\n    .style('font-family', self.config.caption.fontfamily)\\n    .style('font-size', self.config.caption.fontsize)\\n    .style('font-weight', self.config.caption.fontweight)\\n    .style('font-variant', self.config.caption.fontvariant)\\n    .style('text-decoration', self.config.caption.textdecoration)\\n    .on('mouseover', uv.effects.caption.mouseover(self.config))\\n    .on('mouseout', uv.effects.caption.mouseout(self.config));\\n\\n  return this;\\n};\\n\\n\\n/**\\n* Sets the subcaption for the graph\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setSubCaption = function () {\\n  var self = this;\\n  self.subCaption = self.panel.append('g').classed(uv.constants.classes.subcaption, true);\\n\\n  self.subCaption.append('text').classed(uv.constants.classes.subcaptiontext, true)\\n    .text(self.config.meta.subcaption)\\n    .attr('y', -self.config.margin.top / 2 + 1*self.config.caption.fontsize)\\n    .attr('x', self.config.dimension.width / 2)\\n    .attr('text-anchor', self.config.caption.textanchor)\\n    .style('font-family', self.config.subCaption.fontfamily)\\n    .style('font-size', self.config.subCaption.fontsize)\\n    .style('font-weight', self.config.subCaption.fontweight)\\n    .style('font-variant', self.config.subCaption.fontvariant)\\n    .style('text-decoration', self.config.subCaption.textdecoration);\\n\\n  return this;\\n};\\n\\n\\n/**\\n* Sets the metadata for the graph, this includes the labels and the categories\\n* @return {Object}      The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setMetadata = function () {\\n  var self = this;\\n  self.labels = uv.util.getLabelArray(self.graphdef);\\n  self.categories = uv.util.getCategoryArray(self.graphdef);\\n  return this;\\n};\\n\\n/**\\n* Sets the Horizontal Axis functions but doesnt render it yet\\n* return {Object}      The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setHorizontalAxis = function () {\\n  var self = this;\\n  var graphdef = self.graphdef;\\n  if (!self.axes.hor.group) {\\n    self.axes.hor.group = self.panel.append('g').classed(uv.constants.classes.horaxis, true)\\n                  .attr('transform', 'translate(0,' + self.height() + ')')\\n                  .style('shape-rendering','crispEdges');\\n  }\\n\\n  if (self.config.graph.orientation === 'Horizontal') {\\n    self.axes.hor.scale  = d3.scale[self.config.scale.type]()\\n                .domain([self.config.scale.type === 'log' ? 1: self.min(), self.max()])\\n                .range([0, self.width()]);\\n\\n    if (self.axes.hor.scale.nice) {\\n      self.axes.hor.scale.nice();\\n    }\\n\\n    if(!self.config.axis.showsubticks){\\n      self.config.axis.subticks = 0;\\n    }\\n    self.axes.hor.func = d3.svg.axis()\\n                .scale(self.axes.hor.scale)\\n                .ticks(self.config.axis.ticks)\\n                .tickSize(-self.height(), self.config.axis.minor, 0)\\n                .tickPadding(self.config.axis.padding)\\n                .tickSubdivide(self.config.axis.subticks)\\n                .orient('bottom');\\n\\n  } else {\\n    self.axes.hor.scale = d3.scale.ordinal()\\n                .rangeRoundBands([0, self.width()], self.config.scale.ordinality);\\n\\n    self.axes.hor.func = d3.svg.axis()\\n                .scale(self.axes.hor.scale)\\n                .tickPadding(self.config.axis.padding)\\n                .orient('bottom');\\n\\n    if(!self.config.axis.showtext || !self.config.axis.showhortext) {\\n      self.axes.hor.func.tickSize(0);\\n    }\\n  }\\n  if(!self.config.axis.showtext || !self.config.axis.showhortext) {\\n      self.axes.hor.func.tickFormat(function (d) { return ''; });\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n* Sets the Vertical axis functions, but doesnt render it yet\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setVerticalAxis = function () {\\n  var self = this;\\n  var graphdef = self.graphdef;\\n  if (!self.axes.ver.group) {\\n    self.axes.ver.group = self.panel.append('g').classed(uv.constants.classes.veraxis, true)\\n                              .style('shape-rendering','crispEdges');\\n  }\\n\\n  if (self.config.graph.orientation === 'Vertical') {\\n    self.axes.ver.scale  = d3.scale[self.config.scale.type]()\\n                .domain([self.max(), self.config.scale.type === 'log' ? 1 : self.min()])\\n                .range([0, self.height()]);\\n\\n    if (self.axes.ver.scale.nice) {\\n      self.axes.ver.scale.nice();\\n    }\\n\\n    if(!self.config.axis.showsubticks){\\n      self.config.axis.subticks = 0;\\n    }\\n    self.axes.ver.func = d3.svg.axis()\\n                .scale(self.axes.ver.scale)\\n                .ticks(self.config.axis.ticks)\\n                .tickSize(-self.width(), self.config.axis.minor, 0)\\n                .tickPadding(self.config.axis.padding)\\n                .tickSubdivide(self.config.axis.subticks)\\n                .orient('left');\\n\\n\\n  } else {\\n    self.axes.ver.scale = d3.scale.ordinal()\\n                .rangeRoundBands([0, self.height()], self.config.scale.ordinality);\\n\\n    self.axes.ver.func = d3.svg.axis()\\n                .scale(self.axes.ver.scale)\\n                .tickPadding(self.config.axis.padding)\\n                .orient('left');\\n\\n    if(!self.config.axis.showtext || !self.config.axis.showvertext){\\n      self.axes.ver.func.tickSize(0);\\n    }\\n  }\\n  if(!self.config.axis.showtext || !self.config.axis.showvertext) {\\n    self.axes.ver.func.tickFormat(function (d) { return ''; });\\n  }\\n\\n  return this;\\n};\\n\\n/**\\n* Creates placeholders for functions which cause the various animations across the graph to be able invoke it from other places\\n* @return {Object}        The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setEffectsObject = function () {\\n  var self = this;\\n  var effectArray = (self.config.legend.legendtype === 'categories') ? self.categories : self.labels;\\n  for (var i = 0; i < effectArray.length ; i++) {\\n    self.effects[effectArray[i]] = {};\\n  }\\n  return self;\\n};\\n\\n/**\\n* Draws the horizontal axis within the frame based on the orientation and functions already created\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.drawHorizontalAxis = function () {\\n  var self = this;\\n  self.axes.hor.axis = self.axes.hor.group.append('g')\\n                .style('font-family', self.config.label.fontfamily)\\n                .style('font-size', self.config.label.fontsize)\\n                .style('font-weight', self.config.label.fontweight)\\n                .call(self.axes.hor.func);\\n\\n  if (self.config.axis.showticks) {\\n    self.axes.hor.axis.selectAll('line').style('stroke', self.config.axis.strokecolor)\\n                .style('opacity', self.config.axis.opacity);\\n  }\\n  self.axes.hor.axis.selectAll('path').style('fill','none');\\n\\n  self.axes.hor.line = self.panel.append('line')\\n                .classed(uv.constants.classes.horaxis, true)\\n                .attr('y1', self.config.graph.orientation === 'Horizontal' ? self.height() : self.axes.ver.scale(0))\\n                .attr('y2', self.config.graph.orientation === 'Horizontal' ? self.height() : self.axes.ver.scale(0))\\n                .attr('x1', '0')\\n                .attr('x2', self.width())\\n                .style('stroke', self.config.axis.strokecolor);\\n\\n  self.axes.hor.label = self.axes.hor.group.append('g')\\n                            .classed(uv.constants.classes.axeslabelgroup, true)\\n                            .attr('transform', 'translate(' + self.width()/2 + ',' + (1*self.config.margin.bottom/4 + 1*self.config.label.fontsize) + ')');\\n\\n  self.axes.hor.label.append('text')\\n                .attr('display','block')\\n                .classed(uv.constants.classes.axeslabel, true).classed('cal', true)\\n                .attr('text-anchor','middle')\\n                .style('font-size', self.config.axis.fontsize)\\n                .style('font-family', self.config.axis.fontfamily)\\n                .text(self.config.meta.hlabel);\\n\\n  self.axes.hor.label.append('text')\\n                .attr('display','block')\\n                .attr('y', 1*self.config.axis.fontsize)\\n                .attr(uv.constants.classes.axessublabel, true).classed('casl', true)\\n                .attr('text-anchor','middle')\\n                .style('font-size', self.config.axis.fontsize - 2)\\n                .style('font-family', self.config.axis.fontfamily)\\n                .text(self.config.meta.hsublabel);\\n\\n  return this;\\n};\\n\\n/**\\n* Draws the vertical axis within the frame based on the orientation and functions already created\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.drawVerticalAxis = function () {\\n  var self = this;\\n  self.axes.ver.axis = self.axes.ver.group.append('g')\\n                .classed(uv.constants.classes.axes, true)\\n                .style('font-family', self.config.label.fontfamily)\\n                .style('font-size', self.config.label.fontsize)\\n                .style('font-weight', self.config.label.fontweight)\\n                .call(self.axes.ver.func);\\n\\n  if (self.config.axis.showticks) {\\n    self.axes.ver.axis.selectAll('line').style('stroke', self.config.axis.strokecolor)\\n                .style('opacity', self.config.axis.opacity);\\n  }\\n  self.axes.ver.axis.selectAll('path').style('fill','none');\\n\\n  self.axes.ver.line = self.panel.append('line')\\n                .classed(uv.constants.classes.veraxis, true)\\n                .attr('x1', self.config.graph.orientation === 'Horizontal'? self.axes.hor.scale(0): 0)\\n                .attr('x2', self.config.graph.orientation === 'Horizontal'? self.axes.hor.scale(0): 0)\\n                .attr('y1', 0)\\n                .attr('y2', self.height())\\n                .style('stroke', self.config.axis.strokecolor);\\n\\n  self.axes.ver.label = self.axes.ver.group.append('g')\\n                .attr('transform', 'translate(' + -4*self.config.margin.left/5 + ',' + self.height()/2 + ')rotate(270)');\\n\\n  self.axes.ver.label.append('text').classed(uv.constants.classes.axeslabel, true)\\n                .attr('text-anchor', 'middle')\\n                .classed('cal', true)\\n                .style('font-family', self.config.axis.fontfamily)\\n                .style('font-size', self.config.axis.fontsize)\\n                .text(self.config.meta.vlabel);\\n\\n  self.axes.ver.label.append('text').classed(uv.constants.classes.axessublabel, true)\\n                .attr('text-anchor', 'middle')\\n                .attr('y', +self.config.axis.fontsize)\\n                .classed('casl', true)\\n                .style('font-family', self.config.axis.fontfamily)\\n                .style('font-size', self.config.axis.fontsize - 2)\\n                .text(self.config.meta.vsublabel);\\n\\n  return this;\\n};\\n\\n/**\\n* Sets the legend and related interactions for the graph based on the configuration\\n* @return {Object}  The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.setLegend = function () {\\n  var self = this;\\n\\n  var legendgroup = self.panel.append('g').classed(uv.constants.classes.legend, true)\\n            .attr('transform', function(d, i){\\n              if(self.config.legend.position === 'right'){\\n                return 'translate(' + self.width() + ', 10)';\\n              }else if(self.config.legend.position === 'bottom'){\\n                var pos =  self.height() + self.config.margin.bottom/2 + Number(self.config.axis.fontsize);\\n                return 'translate(0, ' + pos +  ')';\\n              }\\n            });\\n\\n  self.legends = legendgroup.selectAll('g').data(\\n    (self.config.legend.legendtype === 'categories') ? self.categories:self.labels\\n  );\\n\\n\\n  self.legends.enter().append('g')\\n      .attr('transform', function (d, i) {\\n        if(self.config.legend.position === 'right'){\\n          return 'translate(10,' + 10* (2* i - 1) + ')';\\n        }else if(self.config.legend.position === 'bottom'){\\n          var hPos = 100*i - self.config.dimension.width*self.config.legend.legendstart;\\n          var vPos = 20*self.config.legend.legendstart;\\n          if(hPos >= self.config.dimension.width){\\n            self.config.legend.legendstart = self.config.legend.legendstart + 1;\\n            hPos = 100*i - self.config.dimension.width*self.config.legend.legendstart;\\n            vPos = 20*self.config.legend.legendstart;\\n          }\\n          return 'translate(' + hPos + ',' + vPos + ')';\\n        }\\n      })\\n      .attr('class', function (d, i) {\\n        var className = (self.config.legend.legendtype === 'categories') ? self.categories[i]:self.labels[i];\\n        return uv.util.getClassName(this, 'cl-' + className);\\n      })\\n      .attr('disabled', 'false')\\n      .on('mouseover', function (d, i) {\\n        if (self.effects[d].mouseover && typeof self.effects[d].mouseover === 'function') {\\n          self.effects[d].mouseover();\\n        }\\n      })\\n      .on('mouseout', function (d, i) {\\n        if (self.effects[d].mouseout && typeof self.effects[d].mouseout === 'function') {\\n          self.effects[d].mouseout();\\n        }\\n      })\\n      .on('click', function (d, i) {\\n        uv.effects.legend.click(i, this, self);\\n      });\\n\\n  self.legends.append('rect').classed(uv.constants.classes.legendsign, true)\\n        .attr('height', self.config.legend.symbolsize)\\n        .attr('width', self.config.legend.symbolsize)\\n        .style('fill', function (d, i) { return uv.util.getColorBand(self.config, i); })\\n        .style('stroke', 'none');\\n\\n  self.legends.append('text').classed(uv.constants.classes.legendlabel, true)\\n        .text(function (d, i) { return (self.config.legend.legendtype === 'categories') ? self.categories[i]:self.labels[i]; })\\n        .attr('dx', self.config.legend.textmargin)\\n        .attr('dy', '.71em')\\n        .attr('text-anchor', 'start')\\n        .style('stroke', self.config.legend.color)\\n        .style('fill', self.config.legend.color)\\n        .style('stroke-width', self.config.legend.strokewidth)\\n        .style('font-family', self.config.legend.fontfamily)\\n        .style('font-size', self.config.legend.fontsize)\\n        .style('font-weight', self.config.legend.fontweight);\\n\\n  return this;\\n};\\n\\n/**\\n* Finalizes stuff related to graph, used in conjuction with init to setup all the generic graph stuff\\n* @param  {Boolean} isLoggable Specifies whether the graph object should be logged or not, for debug purpose only\\n* @return {Object}             The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.finalize = function (isLoggable) {\\n  var self = this;\\n  self.drawHorizontalAxis()\\n    .drawVerticalAxis();\\n  //  .setLegend();\\n\\n  // Cursor for text is unset from text to normal\\n  self.frame.selectAll('text').style('cursor', 'default');\\n\\n  //Log Graph object if flag set to truthy value\\n  if (isLoggable) {\\n    console.log(self);\\n  }\\n  return this;\\n};\\n\\n/*\\n* Functions to remove individual elements of an graph\\n*/\\n\\n/**\\n* Removes the entire graph object\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.remove = function () {\\n  this.frame.remove();\\n  return this;\\n};\\n\\n/**\\n* Removes the caption component of the graph\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.removeCaption = function () {\\n  this.caption.remove();\\n  return this;\\n};\\n\\n/**\\n* Removes the legend component of the graph\\n* @return {Object} The graph object itself, to support method chaining\\n*/\\nuv.Graph.prototype.removeLegend = function () {\\n  if (this.legends[0]) {\\n    this.legends[0].parentNode.remove();\\n  }\\n\\n  return this;\\n};\\n\\nuv.Graph.prototype.removePanel = function () {\\n  this.panel.remove();\\n  return this;\\n};\\n\\nuv.Graph.prototype.removeHorAxis = function () {\\n  this.panel.selectAll('g.' + uv.constants.classes.horaxis + \\\" >*\\\").remove();\\n  this.panel.selectAll('line.' + uv.constants.classes.horaxis).remove();\\n  return this;\\n};\\n\\nuv.Graph.prototype.removeVerAxis = function () {\\n  this.panel.selectAll('g.' + uv.constants.classes.veraxis + \\\" >*\\\").remove();\\n  this.panel.selectAll('line.' + uv.constants.classes.veraxis).remove();\\n  return this;\\n};\\n\\n/*\\n* Setters and getters for various common properties of the graph\\n*/\\n\\nuv.Graph.prototype.width = function (w) {\\n  if (w) {\\n    this.config.dimension.width = w;\\n    return this;\\n  }\\n\\n  return this.config.dimension.width;\\n};\\n\\nuv.Graph.prototype.height = function (h) {\\n  if (h) {\\n    this.config.dimension.height = h;\\n    return this;\\n  }\\n\\n  return this.config.dimension.height;\\n};\\n\\nuv.Graph.prototype.top = function (t) {\\n  if (t) {\\n    this.config.margin.top = t;\\n    return this;\\n  }\\n\\n  return this.config.margin.top;\\n};\\n\\nuv.Graph.prototype.bottom = function (b) {\\n  if (b) {\\n    this.config.margin.bottom = b;\\n    return this;\\n  }\\n\\n  return this.config.margin.bottom;\\n};\\n\\nuv.Graph.prototype.left = function (l) {\\n  if (l) {\\n    this.config.margin.left = l;\\n    return this;\\n  }\\n\\n  return this.config.margin.left;\\n};\\n\\nuv.Graph.prototype.right = function (r) {\\n  if (r) {\\n    this.config.margin.right = r;\\n    return this;\\n  }\\n\\n  return this.config.margin.right;\\n};\\n\\nuv.Graph.prototype.position = function (pos) {\\n  if (pos) {\\n    this.config.meta.position = pos;\\n    return this;\\n  }\\n\\n  return this.config.meta.position;\\n};\\n\\nuv.Graph.prototype.caption = function (caption) {\\n  if (caption) {\\n    this.config.meta.caption = caption;\\n    return this;\\n  }\\n\\n  return this.config.meta.caption;\\n};\\n\\nuv.Graph.prototype.subCaption = function (subCaption) {\\n  if (subCaption) {\\n    this.config.meta.subCaption = subCaption;\\n    return this;\\n  }\\n\\n  return this.config.meta.caption;\\n};\\n\\nuv.Graph.prototype.isDownloadable = function (isDownload) {\\n  if (isDownload) {\\n    this.config.meta.isDownload = isDownload;\\n    return this;\\n  }\\n\\n  return this.config.meta.isDownload;\\n};\\n\\nuv.Graph.prototype.max = function () {\\n  if (this.axes.meta.max !== null) {\\n    return this.axes.meta.max;\\n  }\\n\\n  this.axes.meta.max = uv.util.getMax(this.graphdef, this.graphdef.stepup);\\n  return this;\\n}\\n\\nuv.Graph.prototype.min = function () {\\n  if (this.axes.meta.min !== null) {\\n    return this.axes.meta.min;\\n  }\\n\\n  this.axes.meta.min = uv.util.getMin(this.graphdef, this.graphdef.stepup);\\n  return this;\\n}\\n\\n/* Additional Graph functions*/\\nuv.Graph.prototype.toggleGraphGroup = function (i) {\\n  var self = this, category = self.categories[i],\\n      state = self.frame.select('g.cge-' + uv.util.formatClassName(category)).style('display'),\\n      color = uv.util.getColorBand(self.config, i);\\n\\n  self.frame.selectAll('g.cge-' + uv.util.formatClassName(category)).style('display', (state === 'none')? null : 'none');\\n  return this;\\n};\\n\\nuv.AreaGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.areagroups = [];\\n  self.dataset = uv.util.getDataArray(self.graphdef);\\n\\n  var areagroup, areapath, areafunc, idx, len,\\n    domainData = self.graphdef.dataset[self.graphdef.categories[0]];\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(domainData.map(function (d) { return d.name; }));\\n\\n  for (idx = 0, len = self.dataset.length; idx < len; idx = idx + 1) {\\n    areapath = self.chart.append('g').classed('cg-' + uv.util.formatClassName(self.categories[idx]), true)\\n                        .append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true).datum(self.dataset[idx]);\\n    areagroup = { path: areapath, linefunc: undefined, areafunc: undefined, line: undefined, area: undefined };\\n    self['draw' + self.config.graph.orientation + 'Area'](areagroup, idx);\\n    self.areagroups.push(areagroup);\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.AreaGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.AreaGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  return this;\\n};\\n\\nuv.AreaGraph.prototype.drawHorizontalArea = function (areagroup, idx) {\\n  var self = this,\\n    color = uv.util.getColorBand(self.config, idx);\\n\\n  self.axes.ver.scale.rangePoints([0, self.height()]);\\n\\n  areagroup.linefunc = d3.svg.line()\\n        .x(function (d) { return self.axes.hor.scale(d.value); })\\n        .y(function (d) { return self.axes.ver.scale(d.name) + self.axes.ver.scale.rangeBand() / 2; })\\n        .interpolate(self.config.area.interpolation);\\n\\n  areagroup.areafunc = d3.svg.area()\\n        .x0(self.axes.hor.scale(0))\\n        .x1(areagroup.linefunc.x())\\n        .y(areagroup.linefunc.y())\\n        .interpolate(self.config.area.interpolation);\\n\\n  areagroup.area = areagroup.path.append('svg:path')\\n        .classed(uv.constants.classes.areapath + idx, true)\\n        .attr('d', areagroup.areafunc)\\n        .style('opacity', self.config.area.opacity)\\n        .style('-moz-opacity', self.config.area.opacity)\\n        .style('fill', color);\\n\\n  areagroup.line = areagroup.path.append('svg:path')\\n        .classed(uv.constants.classes.linepath + idx, true)\\n        .attr('d', areagroup.linefunc)\\n        .style('stroke', 'white')\\n        .style('fill', 'none');\\n\\n  areagroup.path.selectAll('.' + uv.constants.classes.dot)\\n        .data(self.dataset[idx])\\n        .enter().append('circle')\\n        .classed(uv.constants.classes.dot, true)\\n        .attr('cx', areagroup.linefunc.x())\\n        .attr('cy', areagroup.linefunc.y())\\n        .attr('r', 3.5)\\n        .style('fill', 'white');\\n};\\n\\nuv.AreaGraph.prototype.drawVerticalArea = function (areagroup, idx) {\\n  var self = this,\\n    color = uv.util.getColorBand(self.config, idx);\\n\\n  self.axes.hor.scale.rangePoints([0, self.width()]);\\n\\n  areagroup.linefunc = d3.svg.line()\\n        .x(function (d) { return self.axes.hor.scale(d.name) + self.axes.hor.scale.rangeBand() / 2; })\\n        .y(function (d) { return self.axes.ver.scale(d.value); })\\n        .interpolate(self.config.area.interpolation);\\n\\n  areagroup.areafunc = d3.svg.area()\\n        .x(areagroup.linefunc.x())\\n        .y0(areagroup.linefunc.y())\\n        .y1(self.axes.ver.scale(0))\\n        .interpolate(self.config.area.interpolation);\\n\\n  areagroup.area = areagroup.path.append('svg:path')\\n        .classed(uv.constants.classes.areapath + idx, true)\\n        .attr('d', areagroup.areafunc)\\n        .style('opacity', self.config.area.opacity)\\n        .style('-moz-opacity', self.config.area.opacity)\\n        .style('fill', color);\\n\\n  areagroup.line = areagroup.path.append('svg:path')\\n        .classed(uv.constants.classes.linepath + idx, true)\\n        .attr('d', areagroup.linefunc)\\n        .style('stroke', 'white')\\n        .style('fill', 'none');\\n\\n  areagroup.path.selectAll('.' + uv.constants.classes.dot)\\n        .data(self.dataset[idx])\\n        .enter().append('circle')\\n        .classed(uv.constants.classes.dot, true)\\n        .attr('cx', areagroup.linefunc.x())\\n        .attr('cy', areagroup.linefunc.y())\\n        .attr('r', 3.5)\\n        .style('fill', 'white');\\n};\\n\\n/**\\n* A normal 2d bar chart capable of being rendered in horizontal and vertical manner\\n* @param {Object} graphdef Definition of the graph being rendered\\n* @param {Object} config   Configuration of the graph being rendered\\n*/\\nuv.BarGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.bargroups = {};\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(self.labels);\\n\\n  var idx, length = self.categories.length, category;\\n  for (idx = 0; idx < length; idx = idx + 1) {\\n    category = self.categories[idx];\\n    self.bargroups[category] = self.chart.append('g').classed('cg-' + uv.util.formatClassName(category), true);\\n    self['draw' + self.config.graph.orientation + 'Bars'](idx);\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.BarGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.BarGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  return this;\\n};\\n\\nuv.BarGraph.prototype.drawHorizontalBars = function (idx) {\\n  var self = this,\\n    color = uv.util.getColorBand(this.config, idx),\\n    len = self.categories.length;\\n\\n  var bars = self.bargroups[self.categories[idx]].selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter()\\n        .append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true)\\n        .attr('transform', function (d) { if (d.value < 0) return 'scale(-1,1)'; });\\n\\n  bars.append('rect')\\n    .classed(uv.util.formatClassName(self.categories[idx]), true)\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .attr('height', self.axes.ver.scale.rangeBand() / len)\\n    .attr('x', function (d) {\\n      return (d.value < 0) ? (-self.axes.hor.scale(0)) : self.axes.hor.scale(0);\\n    })\\n    .attr('y', function (d) {return self.axes.ver.scale(d.name); })\\n    .attr('width', 0)\\n    .style('stroke', self.config.bar.strokecolor)\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(function (d, i) { return i * self.config.effects.duration; })\\n      .attr('width', function (d) { return self.axes.hor.scale(Math.abs(d.value)) - self.axes.hor.scale(0); })\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n        if (typeof self.config.graph.clickCallback === \\\"function\\\") {\\n          d3.select(this.parentNode.parentNode).selectAll('rect').on('click', function(_d){\\n              self.config.graph.clickCallback.apply(null, [_d]);\\n          });\\n        }\\n      });\\n\\n  bars.append('text')\\n    .attr('x', function(d) { return self.axes.hor.scale(0); })\\n    .attr('y', function(d) { return self.axes.ver.scale(d.name) + (self.axes.ver.scale.rangeBand()/len)/2; })\\n    .attr('dx', function (d) { return (d.value < 0)? '-20px': '4px' })\\n    .attr('dy', '.35em')\\n    .attr('text-anchor', 'start')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n    .style('font-family', self.config.bar.fontfamily)\\n    .style('font-size', self.config.bar.fontsize)\\n    .style('font-weight', self.config.bar.fontweight)\\n    .style('transform', function (d) { return d.value < 0? 'scale(-1,1)': 'scale(1,1)'; })\\n    .style('opacity', 0)\\n    .text(function(d) { return uv.util.getLabelValue(self, d); })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(function (d, i) { return i * self.config.effects.duration; })\\n      .style('opacity', 1)\\n      .attr('x', function (d) { return self.axes.hor.scale(d.value); });\\n\\n\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  self.bargroups[self.categories[idx]].attr('transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')');\\n};\\n\\nuv.BarGraph.prototype.drawVerticalBars = function (idx) {\\n  var self = this,\\n    color = uv.util.getColorBand(this.config, idx),\\n    len = self.categories.length;\\n\\n  var bars = self.bargroups[self.categories[idx]].selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter()\\n      .append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true)\\n      .attr('transform', function (d) { if (d.value < 0) return 'scale(1, -1)'; });\\n\\n  bars.append('rect')\\n      .classed(uv.util.formatClassName(self.categories[idx]), true)\\n      .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n      .attr('height', 0)\\n      .attr('width', self.axes.hor.scale.rangeBand() / len)\\n      .attr('x', function (d) { return self.axes.hor.scale(d.name); })\\n      .attr('y', function (d) { return (d.value < 0? -1: 1) * (self.height() - self.axes.ver.scale(0)); })\\n      .style('stroke', self.config.bar.strokecolor).style('fill', color)\\n      .transition()\\n        .duration(self.config.effects.duration)\\n        .delay(idx * self.config.effects.duration)\\n        .attr('height', function (d) { return Math.abs(self.axes.ver.scale(0) - self.axes.ver.scale(d.value)); })\\n        .call(uv.util.endAll, function (d,i){\\n          d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n          d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n          if(typeof self.config.graph.clickCallback === \\\"function\\\") {\\n            d3.select(this.parentNode.parentNode).selectAll('rect').on('click', function(_d){\\n              self.config.graph.clickCallback.apply(null, [_d]);\\n          });\\n        }\\n        });\\n\\n\\n  bars.append('text').attr('transform', function (d) { return (d.value < 0) ? 'scale(1,1)': 'scale(1,-1)'; })\\n      .attr('x', function(d) { return self.axes.hor.scale(d.name) + (self.axes.hor.scale.rangeBand()/len)/2; })\\n      .attr('y', function(d) { return self.height() - self.axes.ver.scale(0) })\\n      .attr('dx', 0)\\n      .attr('dy', function (d) { return d.value < 0 ? '2em' : '.35em' })\\n      .attr('text-anchor', 'middle')\\n      .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n      .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n      .style('font-family', self.config.bar.fontfamily)\\n      .style('font-size', self.config.bar.fontsize)\\n      .style('font-weight', self.config.bar.fontweight)\\n      .style('opacity', 0)\\n      .text(function(d) { return uv.util.getLabelValue(self, d); })\\n      .transition()\\n        .duration(self.config.effects.duration)\\n        .delay(idx * self.config.effects.duration)\\n        .style('opacity', 1)\\n        .attr('y', function (d) { return -(self.height() - self.axes.ver.scale(d.value)) - 10; });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n\\n  self.bargroups[self.categories[idx]].attr('transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + self.height() + ') scale(1,-1)');\\n};\\n\\nuv.DonutGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.radius = Math.min(self.height(), self.width()) * 2 / 5;\\n  self.center = {\\n    x : self.width() / 2,\\n    y : self.height() / 2\\n  };\\n\\n  self.category = graphdef.categories[0];\\n\\n  var data = uv.util.getCategoryData(self.graphdef, [self.category]),\\n    arcfunc = d3.svg.arc().innerRadius(self.radius * self.config.donut.factor).outerRadius(self.radius),\\n    layout = d3.layout.pie();\\n\\n  self.chart.data(data);\\n  self.arcs = self.chart.selectAll('g.arc')\\n          .data(layout).enter()\\n          .append('g').classed(uv.constants.classes.arc + uv.util.formatClassName(self.category), true)\\n          .attr('transform', 'translate(' + self.center.x + ',' + self.center.y + ')');\\n\\n  self.arcs.append('path')\\n      .attr('d', arcfunc)\\n      .style('fill', function (d, i) { return uv.util.getColorBand(self.config, i); })\\n      .style('stroke', self.config.donut.strokecolor)\\n      .style('stroke-width', self.config.donut.strokewidth)\\n    .on('mouseover', uv.effects.donut.mouseover(self.center, arcfunc, self.config))\\n    .on('mouseout', uv.effects.donut.mouseout(self.center, self.config))\\n\\n  if (typeof self.config.graph.clickCallback === \\\"function\\\") {\\n    self.arcs.on('click', function (d) {\\n      self.config.graph.clickCallback.apply(null, [d]);\\n    });\\n  }\\n\\n  self.arcs.append('text')\\n      .attr('transform', function (d) { return 'translate(' + arcfunc.centroid(d) + ')'; })\\n      .attr('dy', '.35em')\\n      .attr('text-anchor', 'middle')\\n      .style('fill', self.config.label.showlabel ? self.config.donut.fontfill : 'none')\\n      .style('font-family', self.config.donut.fontfamily)\\n      .style('font-size', self.config.donut.fontsize)\\n      .style('font-weight', self.config.donut.fontweight)\\n      .style('font-variant', self.config.donut.fontvariant)\\n      .text(function (d) { return uv.util.getLabelValue(self, d); });\\n\\n  self.arcs.append('svg:title')\\n    .text(function (d, i) { return uv.util.getTooltipText(self, self.category, self.labels[i], d);});\\n\\n};\\n\\nuv.DonutGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.DonutGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  self.config.legend.legendtype = 'labels';\\n  return this;\\n};\\n\\nuv.LineGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.linegroups = {};\\n  self.dataset = uv.util.getDataArray(self.graphdef);\\n\\n  var linegroup, linepath, linefunc, idx, len = self.categories.length,\\n    domainData = self.labels;\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(domainData);\\n\\n  for (idx = 0; idx < len; idx = idx + 1) {\\n    linepath = self.chart.append('g').classed('cg-' + uv.util.formatClassName(self.categories[idx]), true)\\n                        .append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true).datum(self.dataset[idx]);\\n    linegroup = {\\n      path: linepath,\\n      func: undefined\\n    };\\n\\n    self['draw' + self.config.graph.orientation + 'Lines'](linegroup, idx);\\n    self.linegroups[self.categories[idx]] = linegroup;\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.LineGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.LineGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  self.config.scale.ordinality = 0;\\n  return this;\\n};\\n\\nuv.LineGraph.prototype.drawHorizontalLines = function (linegroup, idx) {\\n  var self = this,\\n    axes = self.axes,\\n    config = self.config,\\n    color = uv.util.getColorBand(self.config, idx);\\n\\n  self.axes.ver.scale.rangePoints([0, self.height()]);\\n\\n  linegroup.func = d3.svg.line()\\n        .x(function (d) { return axes.hor.scale(d.value); })\\n        .y(function (d) { return axes.ver.scale(d.name) + axes.ver.scale.rangeBand() / 2; })\\n        .interpolate(uv.config.line.interpolation);\\n\\n  linegroup.path.append('path')\\n        .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n        .attr('d', linegroup.func)\\n        .style('fill', 'none')\\n        .style('stroke', color)\\n        .style('stroke-width', self.config.line.strokewidth)\\n        .style('stroke-opacity', self.config.line.strokeopacity)\\n        .transition()\\n          .duration(3 * self.config.effects.duration)\\n          .delay(2 * idx * self.config.effects.duration)\\n          .style('stroke-opacity', 1)\\n          .call(uv.util.endAll, function (d,i){\\n            d3.select(this.parentNode.parentNode).selectAll('path').on('mouseover', uv.effects.line.mouseover(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('path').on('mouseout', uv.effects.line.mouseout(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('circle').on('mouseover', uv.effects.line.mouseover(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('circle').on('mouseout', uv.effects.line.mouseout(self, idx));\\n          });\\n\\n  if (self.config.line.showcircles) {\\n    linegroup.path.selectAll('circle')\\n          .data(self.dataset[idx])\\n          .enter().append('circle')\\n          .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n          .attr('cx', linegroup.func.x())\\n          .attr('cy', linegroup.func.y())\\n          .attr('r', self.config.line.circleradius)\\n          .style('fill', color)\\n          .style('fill-opacity', self.config.line.circleopacity)\\n          .style('stroke', '#fff')\\n            .append('svg:title')\\n            .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n  }\\n\\n  linegroup.path.selectAll('text')\\n        .data(self.dataset[idx])\\n        .enter().append('text')\\n        .attr('x', function (d) { return axes.hor.scale(d.value); })\\n        .attr('y', function(d) { return axes.ver.scale(d.name) + axes.ver.scale.rangeBand()/2; })\\n        .attr('dx', 10)\\n        .attr('dy', '.35em')\\n        .attr('text-anchor', 'start')\\n        .style('opacity', 0)\\n        .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n        .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n        .style('font-family', self.config.line.fontfamily)\\n        .style('font-size', self.config.line.fontsize)\\n        .style('font-weight', self.config.line.fontweight)\\n        .text(function(d) { return uv.util.getLabelValue(self, d); })\\n        .transition()\\n          .duration(3 * self.config.effects.duration)\\n          .delay(2 * idx * self.config.effects.duration)\\n          .style('opacity', 1);\\n\\n  return this;\\n};\\n\\nuv.LineGraph.prototype.drawVerticalLines = function (linegroup, idx) {\\n  var self = this,\\n    axes = self.axes,\\n    config = self.config,\\n    color = uv.util.getColorBand(self.config, idx);\\n\\n  self.axes.hor.scale.rangePoints([0, self.width()]);\\n\\n  linegroup.func = d3.svg.line()\\n        .x(function (d) { return axes.hor.scale(d.name) + axes.hor.scale.rangeBand() / 2; })\\n        .y(function (d) { return axes.ver.scale(d.value); })\\n        .interpolate(uv.config.line.interpolation);\\n\\n  linegroup.path.append('path')\\n        .attr('d', linegroup.func)\\n        .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n        .style('fill', 'none')\\n        .style('stroke', color)\\n        .style('stroke-width', self.config.line.strokewidth)\\n        .style('stroke-opacity', self.config.line.strokeopacity)\\n        .transition()\\n          .duration(self.config.effects.duration)\\n          .delay(2 * idx * self.config.effects.duration)\\n          .style('stroke-opacity', 1)\\n          .call(uv.util.endAll, function (d,i){\\n            d3.select(this.parentNode.parentNode).selectAll('path').on('mouseover', uv.effects.line.mouseover(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('path').on('mouseout', uv.effects.line.mouseout(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('circle').on('mouseover', uv.effects.line.mouseover(self, idx));\\n            d3.select(this.parentNode.parentNode).selectAll('circle').on('mouseout', uv.effects.line.mouseout(self, idx));\\n          });\\n\\n  if (self.config.line.showcircles) {\\n    linegroup.path.selectAll('circle')\\n          .data(self.dataset[idx])\\n          .enter().append('circle')\\n          .attr('cx', linegroup.func.x())\\n          .attr('cy', linegroup.func.y())\\n          .attr('r', self.config.line.circleradius)\\n          .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n          .style('fill', color)\\n          .style('fill-opacity', self.config.line.circleopacity)\\n          .style('stroke', '#fff')\\n            .append('svg:title')\\n            .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n  }\\n\\n  linegroup.path.selectAll('text')\\n        .data(self.dataset[idx])\\n        .enter().append('text')\\n        .attr('x', function (d) { return axes.hor.scale(d.name) + axes.hor.scale.rangeBand() / 2; })\\n        .attr('y', function (d) { return axes.ver.scale(d.value) - 20; })\\n        .attr('dx', 0)\\n        .attr('dy', '.71em')\\n        .attr('text-anchor', 'middle')\\n        .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n        .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n        .style('font-family', self.config.line.fontfamily)\\n        .style('font-size', self.config.line.fontsize)\\n        .style('font-weight', self.config.line.fontweight)\\n        .style('opacity', 0)\\n        .text(function(d) { return uv.util.getLabelValue(self, d); })\\n        .transition()\\n          .duration(3 * self.config.effects.duration)\\n          .delay(2 * idx * self.config.effects.duration)\\n          .style('opacity', 1);\\n\\n  return this;\\n};\\n\\nuv.PercentAreaGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  var stacklayout = d3.layout.stack().offset('zero')(\\n    self.categories.map(function (d) {\\n      return graphdef.dataset[d].map(function (d) {\\n        return {x: d.name, y: +d.value};\\n      });\\n    })\\n  );\\n\\n  var areagroup, areapath, areafunc,\\n    domainData = self.labels,\\n    categories = self.categories;\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(domainData);\\n  self.areagroup = self.chart.selectAll('g.areagroup').data(stacklayout).enter().append('g')\\n                .attr('class', function (d,i) {\\n                  return uv.util.getClassName(this, 'cge-' + self.categories[i]);\\n                });\\n\\n  self['draw' + self.config.graph.orientation + 'Area']();\\n\\n  self.finalize();\\n};\\n\\nuv.PercentAreaGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.PercentAreaGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'percent';\\n  return this;\\n};\\n\\nuv.PercentAreaGraph.prototype.drawHorizontalArea = function () {\\n  var self = this, axes = self.axes,\\n    categories = self.categories,\\n    config = self.config,\\n    sumMap = uv.util.getSumUpArray(self.graphdef);\\n\\n  axes.ver.scale.rangePoints([0, self.height()]);\\n\\n  for(var i = 0; i < categories.length; i = i + 1) {\\n    uv.effects.area.mouseover(self, i);\\n    uv.effects.area.mouseout(self,i);\\n  }\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.area + uv.util.formatClassName(categories[i]));\\n      })\\n      .style('fill', function (d, i) { return uv.util.getColorBand(config, i); })\\n      .attr('d', d3.svg.area()\\n        .y(function (d) { return axes.ver.scale(d.x) + axes.ver.scale.rangeBand() / 2; })\\n        .x0(function (d, i) { return axes.hor.scale(uv.util.getPercentage(d.y0, sumMap[i])); })\\n        .x1(function (d, i) { return axes.hor.scale(uv.util.getPercentage(d.y0 + d.y, sumMap[i])); })\\n        .interpolate(self.config.area.interpolation)\\n    )\\n    .on('mouseover', function (d,i) { self.effects[categories[i]].mouseover(); })\\n    .on('mouseout', function (d,i) { self.effects[categories[i]].mouseout(); });\\n\\n  self.areagroup.append('path')\\n    .attr('class', function (d, i) {\\n      return uv.util.getClassName(this, uv.constants.classes.line + uv.util.formatClassName(categories[i]));\\n    })\\n    .style('stroke', 'white')\\n    .style('fill', 'none')\\n    .style('stroke-width', 2)\\n    .attr('d', d3.svg.line()\\n        .y(function (d) { return axes.ver.scale(d.x) + axes.ver.scale.rangeBand() / 2; })\\n        .x(function (d, i) { return axes.hor.scale(uv.util.getPercentage(d.y0 + d.y, sumMap[i])); })\\n        .interpolate(self.config.area.interpolation)\\n    );\\n};\\n\\nuv.PercentAreaGraph.prototype.drawVerticalArea = function () {\\n  var self = this, axes = self.axes,\\n    categories = self.categories,\\n    config = self.config,\\n    sumMap = uv.util.getSumUpArray(self.graphdef);\\n\\n  axes.hor.scale.rangePoints([0, self.width()]);\\n\\n  for(var i = 0; i < categories.length; i = i + 1){\\n    uv.effects.area.mouseover(self, i);\\n    uv.effects.area.mouseout(self,i);\\n  }\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.area + uv.util.formatClassName(categories[i]));\\n      })\\n      .style('fill', function (d, i) { return uv.util.getColorBand(config, i); })\\n      .attr('d', d3.svg.area()\\n        .x(function (d) { return axes.hor.scale(d.x) + axes.hor.scale.rangeBand() / 2; })\\n        .y0(function (d, i) { return axes.ver.scale(uv.util.getPercentage(d.y0, sumMap[i])); })\\n        .y1(function (d, i) { return axes.ver.scale(uv.util.getPercentage(d.y0 + d.y, sumMap[i])); })\\n        .interpolate(self.config.area.interpolation)\\n      )\\n    .on('mouseover', function (d,i) {self.effects[categories[i]].mouseover(); })\\n    .on('mouseout', function (d,i) { self.effects[categories[i]].mouseout(); });\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.line + uv.util.formatClassName(categories[i]));\\n      })\\n      .style('stroke', 'white')\\n      .style('fill', 'none')\\n      .style('stroke-width', 2)\\n      .attr('d', d3.svg.line()\\n        .x(function (d, i) { return axes.hor.scale(d.x) + axes.hor.scale.rangeBand() / 2; })\\n        .y(function (d, i) { return axes.ver.scale(uv.util.getPercentage(d.y0 + d.y, sumMap[i])); })\\n        .interpolate(self.config.area.interpolation)\\n      );\\n};\\n\\nuv.PercentBarGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.bargroups = [];\\n\\n  var bargroup, bars, idx, len, color,\\n    domainData = self.labels,\\n    csum = domainData.map(function (d) {return 0; }),\\n    tsum = domainData.map(function (d) {return 0; });\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(domainData);\\n\\n  for (idx = 0, len = self.categories.length; idx < len; idx = idx + 1) {\\n    color = uv.util.getColorBand(self.config, idx);\\n    bargroup = self.chart.append('g').classed('cg-' + self.categories[idx], true);\\n    bars = bargroup.selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n\\n    self['draw' + uv.util.getPascalCasedName(self.config.graph.orientation) + 'Bars'](bars, csum, tsum, idx);\\n\\n    if (self.config.graph.orientation === 'Vertical') {\\n      bargroup.attr('transform', 'translate(0,' + 2 * self.height() + ') scale(1,-1)');\\n    }\\n\\n    self.bargroups.push(bargroup);\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.PercentBarGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.PercentBarGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'percent';\\n  self.config.scale.ordinality = 0;\\n  return this;\\n};\\n\\nuv.PercentBarGraph.prototype.drawHorizontalBars = function (bars, csum, tsum, idx) {\\n  var self = this,\\n    axes = this.axes,\\n    color = uv.util.getColorBand(this.config, idx),\\n    config = this.config,\\n    sumMap = uv.util.getSumUpArray(this.graphdef);\\n\\n  bars.append('rect')\\n    .attr('height', axes.ver.scale.rangeBand())\\n    .attr('width', 0)\\n    .attr('x', function (d, i) { var value = axes.hor.scale(uv.util.getPercentage(csum[i], sumMap[i])); csum[i] += d.value; return value; })\\n    .attr('y', function (d) {return axes.ver.scale(d.name); })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('width', function (d, i) { return axes.hor.scale(uv.util.getPercentage(d.value, sumMap[i]));})\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx, self.config.effects.textcolor));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx, self.config.effects.textcolor));\\n      });\\n\\n\\n  bars.append('text')\\n    .attr('y', function(d) { return axes.ver.scale(d.name) + axes.ver.scale.rangeBand()/2; })\\n    .attr('dx', 0)\\n    .attr('dy', '.35em')\\n    .attr('text-anchor', 'end')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none')\\n    .style('font-family', this.config.bar.fontfamily)\\n    .style('font-size', this.config.bar.fontsize)\\n    .style('font-weight', this.config.bar.fontweight)\\n    .text(function(d, i) { return ( axes.hor.scale(uv.util.getPercentage(csum[i], sumMap[i])) > 15 ) ? String(Math.round(uv.util.getPercentage(d.value, sumMap[i]))) : null; })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('x', function (d, i) { tsum[i] += d.value; return axes.hor.scale(uv.util.getPercentage(tsum[i], sumMap[i])) - 5; });\\n};\\n\\nuv.PercentBarGraph.prototype.drawVerticalBars = function (bars, csum, tsum, idx) {\\n  var self = this,\\n    height = this.height(),\\n    axes = this.axes,\\n    color = uv.util.getColorBand(this.config, idx),\\n    config = this.config,\\n    sumMap = uv.util.getSumUpArray(this.graphdef);\\n\\n  bars.append('rect')\\n    .attr('height', 0)\\n    .attr('width', axes.hor.scale.rangeBand())\\n    .attr('x', function (d) { return axes.hor.scale(d.name); })\\n    .attr('y', function (d, i) { var value = axes.ver.scale(uv.util.getPercentage(csum[i], sumMap[i])); csum[i] -= d.value; return value; })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('height', function (d, i) { return height - axes.ver.scale(uv.util.getPercentage(d.value, sumMap[i])); })\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx, self.config.effects.textcolor));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx, self.config.effects.textcolor));\\n      });\\n\\n  bars.append('text').attr('transform','scale(1,-1)')\\n    .attr('x', function(d) { return axes.hor.scale(d.name) + axes.hor.scale.rangeBand()/2; })\\n    .attr('y', -height + 5)\\n    .attr('dy', '.71em')\\n    .attr('text-anchor', 'middle')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none')\\n    .style('font-family', this.config.bar.fontfamily)\\n    .style('font-size', this.config.bar.fontsize)\\n    .style('font-weight', this.config.bar.fontweight)\\n    .text(function(d, i) { return ( height - axes.ver.scale(uv.util.getPercentage(d.value, sumMap[i])) > 15) ? String(Math.round(uv.util.getPercentage(d.value, sumMap[i]))) : null; })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('y', function (d, i) { tsum[i] += d.value; return -(2*height - axes.ver.scale(uv.util.getPercentage(tsum[i], sumMap[i]))) + 5; });\\n};\\n\\nuv.PieGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.radius = Math.min(self.height(), self.width()) * 2 / 5;\\n  self.center = {\\n    x : self.width() / 2,\\n    y : self.height() / 2\\n  };\\n\\n  self.category = graphdef.categories[0];\\n\\n  var data = uv.util.getCategoryData(self.graphdef, [self.category]),\\n    arcfunc = d3.svg.arc().innerRadius(0).outerRadius(self.radius),\\n    layout = d3.layout.pie();\\n\\n  self.chart.data(data);\\n  self.arcs = self.chart.selectAll('g.arc')\\n          .data(layout).enter()\\n          .append('g').classed(uv.constants.classes.arc + uv.util.formatClassName(self.category), true)\\n          .attr('class', function (d, i){\\n            return uv.util.getClassName(this, 'cge-' + self.labels[i]);\\n          })\\n          .attr('transform', 'translate(' + self.center.x + ',' + self.center.y + ')');\\n\\n  self.arcs.append('path')\\n      .attr('d', arcfunc)\\n      .style('fill', function (d, i) { return uv.util.getColorBand(self.config, i); })\\n      .style('stroke', self.config.pie.strokecolor)\\n      .style('stroke-width', self.config.pie.strokewidth)\\n    .on('mouseover', uv.effects.pie.mouseover(self, self.center, arcfunc, self.config))\\n    .on('mouseout', uv.effects.pie.mouseout(self, self.center, self.config));\\n\\n  self.arcs.append('text')\\n      .attr('transform', function (d) { return 'translate(' + arcfunc.centroid(d) + ')'; })\\n      .attr('dy', '.35em')\\n      .attr('text-anchor', 'middle')\\n      .style('fill', self.config.label.showlabel ? self.config.pie.fontfill : 'none')\\n      .style('font-family', self.config.pie.fontfamily)\\n      .style('font-size', self.config.pie.fontsize)\\n      .style('font-weight', self.config.pie.fontweight)\\n      .style('font-variant', self.config.pie.fontvariant)\\n      .text(function (d) { return uv.util.getLabelValue(self, d); });\\n\\n  self.arcs.append('svg:title')\\n    .text(function (d, i) { return uv.util.getTooltipText(self, self.category, self.labels[i], d);});\\n\\n  if (typeof self.config.graph.clickCallback === \\\"function\\\") {\\n    self.arcs.on('click', function (d) {\\n      self.config.graph.clickCallback.apply(null, [d]);\\n    });\\n  }\\n};\\n\\nuv.PieGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.PieGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  self.config.legend.legendtype = 'labels';\\n  return this;\\n};\\n\\nuv.PolarAreaGraph = function (graphdef, config) {\\n  var self = this;\\n\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.maxRadius = Math.min(self.height(), self.width()) * 2/5;\\n  self.center = {\\n    x : self.width() / 2,\\n    y : self.height() / 2\\n  };\\n\\n  self.category = self.categories[0];\\n\\n  var data = uv.util.getCategoryData(self.graphdef, [self.category]),\\n    dataMap = data[0].map(function(d,i){ return d; }),\\n    layout = d3.layout.pie().value(function(d){return self.max()/ data[0].length; }),\\n    tickRadius = [],\\n    arcfuncs = d3.svg.arc().innerRadius(0)\\n            .outerRadius(function(d,i){return ((dataMap[i] * self.maxRadius) / self.max());});\\n\\n  for (var i=1; i<=self.config.axis.ticks; i++) {\\n    tickRadius[i] = (self.maxRadius/self.config.axis.ticks) * i;\\n  }\\n\\n  self.chart.data(data);\\n  self.arcs = self.chart.selectAll('g.arc')\\n                  .data(layout).enter()\\n                  .append('g').classed(uv.constants.classes.arc + uv.util.formatClassName(self.category), true)\\n                  .attr('transform', 'translate(' + self.center.x + ',' + self.center.y + ')');\\n\\n  self.arcs.append('path')\\n    .attr('d', arcfuncs)\\n    .style('fill', function (d, i) { return uv.util.getColorBand(self.config, i);})\\n    .style('stroke', self.config.pie.strokecolor)\\n    .style('stroke-width', self.config.pie.strokewidth);\\n\\n  /*self.arcs.append('text')\\n      .attr('transform', function (d, i) { return 'translate(' + arcfuncs.centroid(d) + ')'; })\\n      .attr('dy', '.35em')\\n      .attr('text-anchor', 'middle')\\n      .style('fill', self.config.pie.fontfill)\\n      .style('font-family', self.config.pie.fontfamily)\\n      .style('font-size', self.config.pie.fontsize)\\n      .style('font-weight', self.config.pie.fontweight)\\n      .style('font-variant', self.config.pie.fontvariant)\\n      .text(function (d) { return uv.util.getLabelValue(self, d); }); */\\n\\n  self.arcs.append('svg:title')\\n    .text(function (d, i) { return uv.util.getTooltipText(self, self.category, self.labels[i], d);});\\n\\n  self.chart.selectAll('.' + uv.constants.classes.circleticks)\\n    .data(tickRadius)\\n    .enter().append('svg:g').classed(uv.constants.classes.circleticks, true)\\n    .append(\\\"svg:circle\\\")\\n    .attr(\\\"r\\\", function (d, i) { return d; })\\n    .style(\\\"stroke\\\", self.config.axis.strokecolor)\\n    .style(\\\"opacity\\\", self.config.axis.opacity)\\n    .style(\\\"fill\\\", \\\"none\\\")\\n    .attr('transform', 'translate(' + self.center.x + ',' + self.center.y + ')');\\n\\n  if (typeof self.config.graph.clickCallback === \\\"function\\\") {\\n    self.arcs.on('click', function (d) {\\n      self.config.graph.clickCallback.apply(null, [d]);\\n    });\\n  }\\n};\\n\\nuv.PolarAreaGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.PolarAreaGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'normal';\\n  self.config.legend.legendtype = 'labels';\\n  return this;\\n};\\n\\nuv.StackedAreaGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  var stacklayout = d3.layout.stack().offset(self.config.area.offset)(self.categories.map(function (d) {\\n      return graphdef.dataset[d].map(function (d) { return {x: d.name, y: +d.value}; });\\n  }));\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(self.labels.map(function (d) { return d; }));\\n  self.areagroup = self.chart.append('g').selectAll('g')\\n                      .data(stacklayout).enter().append('g').attr('class', function (d, i) {\\n                        return uv.util.getClassName(this, 'cge-' + self.categories[i]);\\n                      });\\n\\n  self['draw' + self.config.graph.orientation + 'Area']();\\n\\n  self.finalize();\\n};\\n\\nuv.StackedAreaGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.StackedAreaGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'stepup';\\n  return this;\\n};\\n\\nuv.StackedAreaGraph.prototype.drawHorizontalArea = function () {\\n  var self = this, axes = self.axes,\\n    categories = self.categories,\\n    config = self.config;\\n\\n  axes.ver.scale.rangePoints([0, self.height()]);\\n\\n  for(var i = 0; i < categories.length; i = i + 1){\\n    uv.effects.area.mouseover(self, i);\\n    uv.effects.area.mouseout(self, i);\\n  }\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.area + categories[i]);\\n      })\\n      .style('fill', function (d, i) { return uv.util.getColorBand(config, i); })\\n      .attr('d', d3.svg.area()\\n        .y(function (d) { return axes.ver.scale(d.x) + axes.ver.scale.rangeBand() / 2; })\\n        .x0(function (d) { return axes.hor.scale(d.y0); })\\n        .x1(function (d) { return axes.hor.scale(d.y0 + d.y); })\\n        .interpolate(self.config.area.interpolation)\\n      )\\n    .on('mouseover', function (d,i){ self.effects[categories[i]].mouseover(); })\\n    .on('mouseout',  function (d,i) { self.effects[categories[i]].mouseout(); });\\n\\n  self.areagroup.append('path')\\n    .attr('class', function (d, i) {\\n      return uv.util.getClassName(this, uv.constants.classes.line + categories[i]);\\n    })\\n    .style('stroke', 'white')\\n    .style('fill', 'none')\\n    .style('stroke-width', 2)\\n    .attr('d', d3.svg.line()\\n      .y(function (d) { return axes.ver.scale(d.x) + axes.ver.scale.rangeBand() / 2; })\\n      .x(function (d) { return axes.hor.scale(d.y0 + d.y); })\\n      .interpolate(self.config.area.interpolation)\\n    );\\n\\n  return self;\\n};\\n\\nuv.StackedAreaGraph.prototype.drawVerticalArea = function () {\\n  var self = this, axes = self.axes,\\n    categories = self.categories,\\n    config = self.config;\\n\\n  axes.hor.scale.rangePoints([0, self.width()]);\\n\\n  for(var i = 0; i < categories.length; i = i + 1){\\n    uv.effects.area.mouseover(self, i);\\n    uv.effects.area.mouseout(self, i);\\n  }\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.area + categories[i]);\\n      })\\n      .style('fill', function (d, i) { return uv.util.getColorBand(config, i); })\\n      .attr('d', d3.svg.area()\\n        .x(function (d) { return axes.hor.scale(d.x) + axes.hor.scale.rangeBand() / 2; })\\n        .y0(function (d) { return axes.ver.scale(d.y0); })\\n        .y1(function (d) { return axes.ver.scale(d.y0 + d.y); })\\n        .interpolate(self.config.area.interpolation)\\n      )\\n    .on('mouseover', function (d,i){ self.effects[categories[i]].mouseover(); })\\n    .on('mouseout',  function (d,i) { self.effects[categories[i]].mouseout(); });\\n\\n\\n  self.areagroup.append('path')\\n      .attr('class', function (d, i) {\\n        return uv.util.getClassName(this, uv.constants.classes.line + categories[i]);\\n      })\\n      .style('stroke', 'white')\\n      .style('fill', 'none')\\n      .style('stroke-width', 2)\\n      .attr('d', d3.svg.line()\\n        .x(function (d) { return axes.hor.scale(d.x) + axes.hor.scale.rangeBand() / 2; })\\n        .y(function (d) { return axes.ver.scale(d.y0 + d.y); })\\n        .interpolate(self.config.area.interpolation)\\n      );\\n\\n  return self;\\n};\\n\\nuv.StackedBarGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.bargroups = {};\\n\\n  var bargroup, bars, idx, len, color,\\n    domainData = self.labels,\\n    csum = domainData.map(function (d) {return 0; }),\\n    tsum = domainData.map(function (d) {return 0; });\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(domainData);\\n\\n  for (idx = 0, len = self.categories.length; idx < len; idx = idx + 1) {\\n    self.bargroups[self.categories[idx]] = self.chart.append('g').classed('cg-' + uv.util.formatClassName(self.categories[idx]), true);\\n    self['draw' + self.config.graph.orientation + 'Bars'](idx, csum, tsum);\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.StackedBarGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.StackedBarGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'stepup';\\n  return this;\\n};\\n\\nuv.StackedBarGraph.prototype.drawHorizontalBars = function (idx, csum, tsum) {\\n  var self = this,\\n    axes = this.axes,\\n    color = uv.util.getColorBand(this.config, idx),\\n    config = this.config,\\n    bargroup = this.bargroups[this.categories[idx]];\\n\\n  var bars = bargroup.selectAll('g').data(this.graphdef.dataset[self.categories[idx]])\\n        .enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n\\n  bars.append('rect')\\n    .attr('height', axes.ver.scale.rangeBand())\\n    .attr('width', 0)\\n    .attr('x', function (d, i) { var value = axes.hor.scale(csum[i]); csum[i] += d.value; return value; })\\n    .attr('y', function (d) {return axes.ver.scale(d.name); })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('width', function (d,i) { return axes.hor.scale(csum[i]) - axes.hor.scale(csum[i]-d.value); })\\n      .each(\\\"end\\\", function (d,i){\\n        d3.select(this).on('mouseover', uv.effects.bar.mouseover(self, idx, self.config.effects.textcolor));\\n        d3.select(this).on('mouseout', uv.effects.bar.mouseout(self, idx, self.config.effects.textcolor));\\n        if(typeof self.config.graph.clickCallback === \\\"function\\\") {\\n          d3.select(this).on('click', function(_d){\\n              self.config.graph.clickCallback.apply(null, [_d]);\\n          });\\n        }\\n      });\\n\\n\\n  bars.append('text')\\n    .attr('y', function(d) { return axes.ver.scale(d.name) + axes.ver.scale.rangeBand()/2; })\\n    .attr('dx', 0)\\n    .attr('dy', '.35em')\\n    .attr('text-anchor', 'end')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none')\\n    .style('font-family', config.bar.fontfamily)\\n    .style('font-size', config.bar.fontsize)\\n    .style('font-weight', config.bar.fontweight)\\n    .style('opacity', 0)\\n    .text(function(d) { return ( axes.hor.scale(d.value) > 15 ) ? uv.util.getLabelValue(self, d) : null; })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .style('opacity', 1)\\n      .attr('x', function (d, i) { tsum[i] += d.value; return axes.hor.scale(tsum[i]) - 5; });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n};\\n\\nuv.StackedBarGraph.prototype.drawVerticalBars = function (idx, csum, tsum) {\\n  var self = this,\\n    height = this.height(),\\n    axes = this.axes,\\n    color = uv.util.getColorBand(this.config, idx),\\n    config = this.config,\\n    bargroup = this.bargroups[self.categories[idx]];\\n\\n  var bars = bargroup.selectAll('g').data(this.graphdef.dataset[self.categories[idx]])\\n        .enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n\\n  bars.append('rect')\\n    .attr('height', 0)\\n    .attr('width', axes.hor.scale.rangeBand())\\n    .attr('x', function (d) { return axes.hor.scale(d.name); })\\n    .attr('y', function (d, i) { var value = axes.ver.scale(csum[i]); csum[i] -= d.value; return value; })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('height', function (d,i) { return -(axes.ver.scale(-csum[i]) - axes.ver.scale(-csum[i]-d.value)); })\\n      .each(\\\"end\\\", function (d,i){\\n        d3.select(this).on('mouseover', uv.effects.bar.mouseover(self, idx, self.config.effects.textcolor));\\n        d3.select(this).on('mouseout', uv.effects.bar.mouseout(self, idx, self.config.effects.textcolor));\\n        if(typeof self.config.graph.clickCallback === \\\"function\\\") {\\n          d3.select(this).on('click', function(_d){\\n            self.config.graph.clickCallback.apply(null, [_d]);\\n          });\\n        }\\n      });\\n\\n\\n  bars.append('text').attr('transform','scale(1,-1)')\\n    .attr('x', function(d) { return axes.hor.scale(d.name) + axes.hor.scale.rangeBand()/2; })\\n    .attr('y', -height + 5)\\n    .attr('dy', '.71em')\\n    .attr('text-anchor', 'middle')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? self.config.effects.textcolor : 'none')\\n    .style('font-family', config.bar.fontfamily)\\n    .style('font-size', config.bar.fontsize)\\n    .style('font-weight', config.bar.fontweight)\\n    .style('opacity', 0)\\n    .text(function(d) { return ( height - axes.ver.scale(d.value) > 15) ? uv.util.getLabelValue(self, d) : null; })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .style('opacity', 1)\\n      .attr('y', function (d, i) { tsum[i] += d.value; return -(2*height - axes.ver.scale(tsum[i])) + 5; });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  bargroup.attr('transform', 'translate(0,' + 2 * this.height() + ') scale(1,-1)');\\n};\\n\\nuv.StepUpBarGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  this.bargroups = {};\\n\\n  var idx, length = self.categories.length,\\n    csum = self.labels.map(function (d) {return 0; }),\\n    tsum = self.labels.map(function (d) {return 0; });\\n\\n  self.axes[this.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(this.labels);\\n\\n  for (idx = 0; idx < length; idx = idx + 1) {\\n    self.bargroups[self.categories[idx]] = this.chart.append('g').classed('cg-' + uv.util.formatClassName(self.categories[idx]), true);\\n    self['draw' + self.config.graph.orientation + 'Bars'](idx, csum, tsum);\\n  }\\n\\n  self.finalize();\\n};\\n\\nuv.StepUpBarGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.StepUpBarGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'stepup';\\n  return this;\\n};\\n\\nuv.StepUpBarGraph.prototype.drawHorizontalBars = function (idx, csum, tsum) {\\n  var self = this, len = self.categories.length,\\n    color = uv.util.getColorBand(self.config, idx),\\n    bargroup = self.bargroups[self.categories[idx]];\\n\\n  var bars = bargroup.selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n  bars.append('rect')\\n    .attr('height', self.axes.ver.scale.rangeBand() / len)\\n    .attr('width', 0)\\n    .attr('transform',\\n      function (d) {\\n      return (d.value < 0) ? 'scale(-1,1)': 'scale(1,1)';\\n    })\\n    .attr('x', function (d, i) {\\n      if (d.resetSum === true) csum[i] = 0;\\n      var value = self.axes.hor.scale(csum[i]);\\n      csum[i] += d.value;\\n      return d.value < 0 ? -value: value;\\n    })\\n    .attr('y', function (d) {return self.axes.ver.scale(d.name); })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('width', function (d, i) { return Math.abs(self.axes.hor.scale(csum[i]) - self.axes.hor.scale(csum[i]-d.value)); })\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n      });\\n\\n  bars.append('text')\\n    .attr('y', function(d) { return self.axes.ver.scale(d.name) + (self.axes.ver.scale.rangeBand()/len)/2; })\\n    .attr('dx', function (d) { return (d.value < 0)? -16: 4; })\\n    .attr('dy', '.35em')\\n    .attr('text-anchor', 'start')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n    .style('opacity', 0)\\n    .style('font-family', self.config.bar.fontfamily)\\n    .style('font-size', self.config.bar.fontsize)\\n    .style('font-weight', self.config.bar.fontweight)\\n    .text(function(d) { return uv.util.getLabelValue(self, d); })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .style('opacity', 1)\\n      .attr('x', function (d, i) {\\n        if (d.resetSum === true) tsum[i] = 0;\\n        tsum[i] += d.value;\\n        return self.axes.hor.scale(tsum[i]);\\n      });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  bargroup.attr('transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')');\\n};\\n\\nuv.StepUpBarGraph.prototype.drawVerticalBars = function (idx, csum, tsum) {\\n  var self = this, len = self.categories.length,\\n    color = uv.util.getColorBand(self.config, idx),\\n    bargroup = self.bargroups[self.categories[idx]],\\n    scaledSum = 0;\\n\\n  var bars = bargroup.selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n\\n  bars.append('rect')\\n    .attr('height', 0)\\n    .attr('width', self.axes.hor.scale.rangeBand() / len)\\n    .attr('transform',\\n      function (d) {\\n      return (d.value < 0) ? 'scale(1,-1)': 'scale(1,1)';\\n    })\\n    .attr('x', function (d) { return self.axes.hor.scale(d.name); })\\n    .attr('y', function (d, i) {\\n      if (d.resetSum === true) csum[i] = 0;\\n      var value = (2*self.height() - self.axes.ver.scale(csum[i]));\\n      csum[i] += d.value;\\n      return (d.value < 0)? -value: value;\\n    })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('height', function (d, i) {\\n        return Math.abs(self.axes.ver.scale(-csum[i]) - self.axes.ver.scale(-csum[i]-d.value));\\n      })\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n      });\\n\\n  bars.append('text').attr('transform','scale(1,-1)')\\n    .attr('x', function(d) { return self.axes.hor.scale(d.name) + (self.axes.hor.scale.rangeBand()/len)/2; })\\n    .attr('y', -self.height() - 10)\\n    .attr('dy', function (d) { return (d.value < 0)? '2.3em': '.71em'})\\n    .attr('text-anchor', 'middle')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n    .style('font-family', self.config.bar.fontfamily)\\n    .style('font-size', self.config.bar.fontsize)\\n    .style('font-weight', self.config.bar.fontweight)\\n    .style('opacity', 0)\\n    .text(function(d) { return uv.util.getLabelValue(self, d); })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .style('opacity', 1)\\n      .attr('y', function (d, i) {\\n        if (d.resetSum === true) tsum[i] = 0;\\n        tsum[i] += d.value;\\n        return -(2*self.height() - self.axes.ver.scale(tsum[i])) - 10;\\n      });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  bargroup.attr('transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + 2 * self.height() + ') scale(1,-1)');\\n};\\n\\nuv.Table = function () {\\n  this.caption = undefined;\\n  this.position = undefined;\\n  this.graphdef = undefined;\\n\\n  this.table = undefined;\\n  this.header = undefined;\\n  this.body = undefined;\\n  this.bodyrows = {};\\n};\\n\\nuv.Table.prototype.init = function (graphdef, config) {\\n  this.graphdef = graphdef;\\n  this.config = uv.util.extend({}, config);\\n  this.position = this.config.meta.pos || 'body';\\n\\n  this.table = d3.select(this.position).append('table').classed(this.config.table.tableclass, true);\\n  this.header = this.table.append('thead').classed(this.config.table.headerclass, true);\\n  this.body = this.table.append('tbody').classed(this.config.table.bodyclass, true);\\n  this.footer = this.table.append('tfoot').classed(this.config.table.footerclass, true);\\n};\\n\\nuv.Table.prototype.finalize = function () {\\n  //console.log(this);\\n};\\n\\nuv.TableGraph = function (graphdef, config) {\\n  uv.Table.apply(this, [graphdef]);\\n  this.init(graphdef, config);\\n\\n  if (this.config.graph.orientation === 'Horizontal') {\\n    this.setHorTable();\\n  } else {\\n    this.setVerTable();\\n  }\\n\\n  this.finalize();\\n};\\n\\nuv.TableGraph.prototype = uv.util.inherits(uv.Table);\\n\\nuv.TableGraph.prototype.setHorTable = function () {\\n  var categories = this.graphdef.categories, tableData = uv.util.getTabularArray(this.graphdef);\\n\\n  categories.unshift('');\\n  this.header.append('tr').selectAll('td').data(categories).enter().append('td').text(function (d) { return d; });\\n  categories.shift();\\n\\n  this.bodyrows = this.body.selectAll('tr').data(tableData)\\n          .enter().append('tr');\\n\\n  this.bodyrows.selectAll('td').data(function (d, i) { return tableData[i]; })\\n          .enter().append('td')\\n          .attr('class', function (d, i) {\\n            var classNameString = (i === 0) ? 'chart3rtablelabel' : 'chart3rtabledata';\\n            return d3.select(this).attr('class') + classNameString;\\n          })\\n          .text(function (d) {return d; });\\n};\\n\\nuv.TableGraph.prototype.setVerTable = function () {\\n  var labels = uv.util.getLabelArray(this.graphdef), dataset = this.graphdef.dataset;\\n\\n  labels.unshift('');\\n  this.header.append('tr').selectAll('td').data(labels).enter().append('td').text(function (d) { return d; });\\n  labels.shift();\\n\\n  this.bodyrows = this.body.selectAll('tr').data(this.graphdef.categories)\\n          .enter().append('tr');\\n\\n  this.bodyrows.selectAll('td')\\n    .data(function (d) {\\n      var arr = [], i, len;\\n      arr.push(d);\\n      for (i = 0, len = dataset[d].length; i < len; i = i + 1) { arr.push(dataset[d][i].value); }\\n      return arr;\\n    }).enter().append('td')\\n      .attr('class', function (d, i) {\\n        var classNameString = (i === 0) ? 'chart3rtablelabel' : 'chart3rtabledata';\\n        return d3.select(this).attr('class') + classNameString;\\n      })\\n      .text(function (d) {return d; });\\n};\\n\\n/**\\n* A waterfall chart capable of being rendered in horizontal and vertical manner\\n* @param {Object} graphdef Definition of the graph being rendered\\n* @param {Object} config   Configuration of the graph being rendered\\n*/\\nuv.WaterfallGraph = function (graphdef, config) {\\n  var self = this;\\n  uv.Graph.call(self, graphdef, config).setDefaults().init();\\n\\n  self.bargroups = {};\\n\\n  self.axes[self.config.graph.orientation === 'Horizontal' ? 'ver' : 'hor'].scale.domain(self.labels);\\n\\n  var idx, length = self.categories.length, category;\\n\\n  category = self.categories[0];\\n  self.bargroups[category] = self.chart.append('g').classed('cg-' + uv.util.formatClassName(category), true);\\n  self['draw' + self.config.graph.orientation + 'Bars'](0);\\n\\n  self.finalize();\\n};\\n\\nuv.WaterfallGraph.prototype = uv.util.inherits(uv.Graph);\\n\\nuv.WaterfallGraph.prototype.setDefaults = function () {\\n  var self = this;\\n  self.graphdef.stepup = 'waterfall';\\n  self.config.legend.showlegends = false;\\n  return this;\\n};\\n\\nuv.WaterfallGraph.prototype.drawHorizontalBars = function (idx) {\\n  var self = this, len = self.categories.length,\\n    color = uv.util.getColorBand(self.config, idx),\\n    bargroup = self.bargroups[self.categories[idx]];\\n  var  csum = 0, tsum =0;\\n\\n  var bars = bargroup.selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter().append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n  bars.append('rect')\\n    .attr('height', (self.axes.ver.scale.rangeBand() / len)-2)\\n    .attr('width', 0)\\n    .attr('x', function (d, i) {\\n      var value = (d.value < 0) ? csum + d.value : csum;\\n      csum += d.value;\\n      return self.axes.hor.scale(value); })\\n    .attr('y', function (d) {return self.axes.ver.scale(d.name); })\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('stroke', 'none')\\n    .style('fill', color)\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('width', function (d) { return  self.axes.hor.scale(Math.abs(d.value)); })\\n      .call(uv.util.endAll, function (d,i){\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n        d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n      });\\n\\n  bars.append('text')\\n    .attr('y', function(d) { return self.axes.ver.scale(d.name) + (self.axes.ver.scale.rangeBand()/len)/2; })\\n    .attr('dx', 4)\\n    .attr('dy', '.35em')\\n    .attr('text-anchor', 'start')\\n    .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n    .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n    .style('font-family', self.config.bar.fontfamily)\\n    .style('font-size', self.config.bar.fontsize)\\n    .style('font-weight', self.config.bar.fontweight)\\n    .text(function(d) { return uv.util.getLabelValue(self, d); })\\n    .transition()\\n      .duration(self.config.effects.duration)\\n      .delay(idx * self.config.effects.duration)\\n      .attr('x', function (d, i) {\\n        var value = d.value < 0 ? tsum : tsum + d.value;\\n        tsum += d.value;\\n        return self.axes.hor.scale(value);\\n      });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  bargroup.attr('transform', 'translate(0,' + idx * self.axes.ver.scale.rangeBand() / len + ')');\\n};\\n\\nuv.WaterfallGraph.prototype.drawVerticalBars = function (idx) {\\n  var self = this,\\n    color = uv.util.getColorBand(this.config, idx),\\n    len = self.categories.length;\\n  var csum =0, tsum = 0;\\n\\n  var bars = self.bargroups[self.categories[idx]].selectAll('g').data(self.graphdef.dataset[self.categories[idx]]).enter()\\n      .append('g').classed('cge-' + uv.util.formatClassName(self.categories[idx]), true);\\n\\n  bars.append('rect')\\n      .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n      .attr('height', 0)\\n      .attr('width', 0)\\n      .attr('x', function (d) {return self.axes.hor.scale(d.name); })\\n      .attr('y', function(d) {\\n        var value = (d.value < 0) ? csum + d.value : csum;\\n        csum += d.value;\\n        return self.height() - self.axes.ver.scale(value);\\n      })\\n      .style('stroke', self.config.bar.strokecolor).style('fill', color)\\n      .transition()\\n        .duration(self.config.effects.duration)\\n        .delay(idx * self.config.effects.duration)\\n        .attr('height', function (d) {  return self.height() - self.axes.ver.scale(Math.abs(d.value)); })\\n        .attr('width', (self.axes.hor.scale.rangeBand() / len)-2)\\n        .call(uv.util.endAll, function (d,i){\\n          d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseover', uv.effects.bar.mouseover(self, idx));\\n          d3.select(this.parentNode.parentNode).selectAll('rect').on('mouseout', uv.effects.bar.mouseout(self, idx));\\n        });\\n\\n\\n  bars.append('text').attr('transform','scale(1,-1)')\\n      .attr('x', function(d) { return self.axes.hor.scale(d.name) + (self.axes.hor.scale.rangeBand()/len)/2; })\\n      .attr('y', -10)\\n      .attr('dx', 0)\\n      .attr('dy', '.35em')\\n      .attr('text-anchor', 'middle')\\n      .classed('cr-' + uv.util.formatClassName(self.categories[idx]), true)\\n      .style('fill', self.config.label.showlabel ? uv.util.getColorBand(self.config, idx) : 'none')\\n      .style('font-family', self.config.bar.fontfamily)\\n      .style('font-size', self.config.bar.fontsize)\\n      .style('font-weight', self.config.bar.fontweight)\\n      .text(function(d) { return uv.util.getLabelValue(self, d); })\\n      .transition()\\n        .duration(self.config.effects.duration)\\n        .delay(idx * self.config.effects.duration)\\n        .attr('y', function (d) {\\n          tsum += d.value;\\n          var value = d.value < 0 ? tsum - d.value : tsum;\\n          return -(self.height() - self.axes.ver.scale(value)) - 10; });\\n\\n  bars.append('svg:title')\\n    .text( function (d, i) { return uv.util.getTooltipText(self, self.categories[idx], self.labels[i], d);});\\n\\n  self.bargroups[self.categories[idx]].attr('transform', 'translate(' + idx * self.axes.hor.scale.rangeBand() / len + ',' + self.height() + ') scale(1,-1)');\\n};\\n\\n  if (!noGlobal) {\\n    window.uv = {\\n      chart: uv.chart\\n    };\\n  }\\n\\n  return {\\n    chart: uv.chart\\n  };\\n}));\"","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\nmodule.exports = function(src) {\n\tfunction log(error) {\n\t\t(typeof console !== \"undefined\")\n\t\t&& (console.error || console.log)(\"[Script Loader]\", error);\n\t}\n\n\t// Check for IE =< 8\n\tfunction isIE() {\n\t\treturn typeof attachEvent !== \"undefined\" && typeof addEventListener === \"undefined\";\n\t}\n\n\ttry {\n\t\tif (typeof execScript !== \"undefined\" && isIE()) {\n\t\t\texecScript(src);\n\t\t} else if (typeof eval !== \"undefined\") {\n\t\t\teval.call(null, src);\n\t\t} else {\n\t\t\tlog(\"EvalError: No eval function available\");\n\t\t}\n\t} catch (error) {\n\t\tlog(error);\n\t}\n}\n","require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/script-loader/addScript.js\")(require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/raw-loader/index.js!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/src/js/dependencies/d3.js\"))","require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/script-loader/addScript.js\")(require(\"!!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/node_modules/raw-loader/index.js!/Users/kiranpotphode/Documents/websites/test/wp-content/plugins/easy-charts/src/js/dependencies/uvcharts.js\"))","/* canvas-toBlob.js\n * A canvas.toBlob() implementation.\n * 2011-07-13\n * \n * By Eli Grey, http://eligrey.com and Devin Samarin, https://github.com/eboyjr\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/canvas-toBlob.js/blob/master/canvas-toBlob.js */\n\n(function(view) {\n\"use strict\";\nvar\n\t  Uint8Array = view.Uint8Array\n\t, HTMLCanvasElement = view.HTMLCanvasElement\n\t, is_base64_regex = /\\s*;\\s*base64\\s*(?:;|$)/i\n\t, base64_ranks\n\t, decode_base64 = function(base64) {\n\t\tvar\n\t\t\t  len = base64.length\n\t\t\t, buffer = new Uint8Array(len / 4 * 3 | 0)\n\t\t\t, i = 0\n\t\t\t, outptr = 0\n\t\t\t, last = [0, 0]\n\t\t\t, state = 0\n\t\t\t, save = 0\n\t\t\t, rank\n\t\t\t, code\n\t\t\t, undef\n\t\t;\n\t\twhile (len--) {\n\t\t\tcode = base64.charCodeAt(i++);\n\t\t\trank = base64_ranks[code-43];\n\t\t\tif (rank !== 255 && rank !== undef) {\n\t\t\t\tlast[1] = last[0];\n\t\t\t\tlast[0] = code;\n\t\t\t\tsave = (save << 6) | rank;\n\t\t\t\tstate++;\n\t\t\t\tif (state === 4) {\n\t\t\t\t\tbuffer[outptr++] = save >>> 16;\n\t\t\t\t\tif (last[1] !== 61 /* padding character */) {\n\t\t\t\t\t\tbuffer[outptr++] = save >>> 8;\n\t\t\t\t\t}\n\t\t\t\t\tif (last[0] !== 61 /* padding character */) {\n\t\t\t\t\t\tbuffer[outptr++] = save;\n\t\t\t\t\t}\n\t\t\t\t\tstate = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// 2/3 chance there's going to be some null bytes at the end, but that\n\t\t// doesn't really matter with most image formats.\n\t\t// If it somehow matters for you, truncate the buffer up outptr.\n\t\treturn buffer.buffer;\n\t}\n;\nif (Uint8Array) {\n\tbase64_ranks = new Uint8Array([\n\t\t  62, -1, -1, -1, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, -1\n\t\t, -1, -1,  0, -1, -1, -1,  0,  1,  2,  3,  4,  5,  6,  7,  8,  9\n\t\t, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25\n\t\t, -1, -1, -1, -1, -1, -1, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35\n\t\t, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51\n\t]);\n}\nif (HTMLCanvasElement && !HTMLCanvasElement.prototype.toBlob) {\n\tHTMLCanvasElement.prototype.toBlob = function(callback, type /*, ...args*/) {\n\t\t  if (!type) {\n\t\t\ttype = \"image/png\";\n\t\t} if (this.mozGetAsFile) {\n\t\t\tcallback(this.mozGetAsFile(\"canvas\", type));\n\t\t\treturn;\n\t\t}\n\t\tvar\n\t\t\t  args = Array.prototype.slice.call(arguments, 1)\n\t\t\t, dataURI = this.toDataURL.apply(this, args)\n\t\t\t, header_end = dataURI.indexOf(\",\")\n\t\t\t, data = dataURI.substring(header_end + 1)\n\t\t\t, is_base64 = is_base64_regex.test(dataURI.substring(0, header_end))\n\t\t\t, blob\n\t\t;\n\t\tif (Blob.fake) {\n\t\t\t// no reason to decode a data: URI that's just going to become a data URI again\n\t\t\tblob = new Blob\n\t\t\tif (is_base64) {\n\t\t\t\tblob.encoding = \"base64\";\n\t\t\t} else {\n\t\t\t\tblob.encoding = \"URI\";\n\t\t\t}\n\t\t\tblob.data = data;\n\t\t\tblob.size = data.length;\n\t\t} else if (Uint8Array) {\n\t\t\tif (is_base64) {\n\t\t\t\tblob = new Blob([decode_base64(data)], {type: type});\n\t\t\t} else {\n\t\t\t\tblob = new Blob([decodeURIComponent(data)], {type: type});\n\t\t\t}\n\t\t}\n\t\tcallback(blob);\n\t};\n}\n}(self));","/*\n * canvg.js - Javascript SVG parser and renderer on Canvas\n * MIT Licensed\n * Gabe Lerner (gabelerner@gmail.com)\n * http://code.google.com/p/canvg/\n *\n * Requires: rgbcolor.js - http://www.phpied.com/rgb-color-parser-in-javascript/\n */\n(function(){\n\t// canvg(target, s)\n\t// empty parameters: replace all 'svg' elements on page with 'canvas' elements\n\t// target: canvas element or the id of a canvas element\n\t// s: svg string, url to svg file, or xml document\n\t// opts: optional hash of options\n\t//\t\t ignoreMouse: true => ignore mouse events\n\t//\t\t ignoreAnimation: true => ignore animations\n\t//\t\t ignoreDimensions: true => does not try to resize canvas\n\t//\t\t ignoreClear: true => does not clear canvas\n\t//\t\t offsetX: int => draws at a x offset\n\t//\t\t offsetY: int => draws at a y offset\n\t//\t\t scaleWidth: int => scales horizontally to width\n\t//\t\t scaleHeight: int => scales vertically to height\n\t//\t\t renderCallback: function => will call the function after the first render is completed\n\t//\t\t forceRedraw: function => will call the function on every frame, if it returns true, will redraw\n\tthis.canvg = function (target, s, opts) {\n\t\t// no parameters\n\t\tif (target == null && s == null && opts == null) {\n\t\t\tvar svgTags = document.getElementsByTagName('svg');\n\t\t\tfor (var i=0; i<svgTags.length; i++) {\n\t\t\t\tvar svgTag = svgTags[i];\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = svgTag.clientWidth;\n\t\t\t\tc.height = svgTag.clientHeight;\n\t\t\t\tsvgTag.parentNode.insertBefore(c, svgTag);\n\t\t\t\tsvgTag.parentNode.removeChild(svgTag);\n\t\t\t\tvar div = document.createElement('div');\n\t\t\t\tdiv.appendChild(svgTag);\n\t\t\t\tcanvg(c, div.innerHTML);\n\t\t\t}\n\t\t\treturn;\n\t\t}\n\t\topts = opts || {};\n\n\t\tif (typeof target == 'string') {\n\t\t\ttarget = document.getElementById(target);\n\t\t}\n\n\t\t// store class on canvas\n\t\tif (target.svg != null) target.svg.stop();\n\t\tvar svg = build();\n\t\t// on i.e. 8 for flash canvas, we can't assign the property so check for it\n\t\tif (!(target.childNodes.length == 1 && target.childNodes[0].nodeName == 'OBJECT')) target.svg = svg;\n\t\tsvg.opts = opts;\n\n\t\tvar ctx = target.getContext('2d');\n\t\tif (typeof(s.documentElement) != 'undefined') {\n\t\t\t// load from xml doc\n\t\t\tsvg.loadXmlDoc(ctx, s);\n\t\t}\n\t\telse if (s.substr(0,1) == '<') {\n\t\t\t// load from xml string\n\t\t\tsvg.loadXml(ctx, s);\n\t\t}\n\t\telse {\n\t\t\t// load from url\n\t\t\tsvg.load(ctx, s);\n\t\t}\n\t}\n\n\tfunction build() {\n\t\tvar svg = { };\n\n\t\tsvg.FRAMERATE = 30;\n\t\tsvg.MAX_VIRTUAL_PIXELS = 30000;\n\n\t\t// globals\n\t\tsvg.init = function(ctx) {\n\t\t\tvar uniqueId = 0;\n\t\t\tsvg.UniqueId = function () { uniqueId++; return 'canvg' + uniqueId;\t};\n\t\t\tsvg.Definitions = {};\n\t\t\tsvg.Styles = {};\n\t\t\tsvg.Animations = [];\n\t\t\tsvg.Images = [];\n\t\t\tsvg.ctx = ctx;\n\t\t\tsvg.ViewPort = new (function () {\n\t\t\t\tthis.viewPorts = [];\n\t\t\t\tthis.Clear = function() { this.viewPorts = []; }\n\t\t\t\tthis.SetCurrent = function(width, height) { this.viewPorts.push({ width: width, height: height }); }\n\t\t\t\tthis.RemoveCurrent = function() { this.viewPorts.pop(); }\n\t\t\t\tthis.Current = function() { return this.viewPorts[this.viewPorts.length - 1]; }\n\t\t\t\tthis.width = function() { return this.Current().width; }\n\t\t\t\tthis.height = function() { return this.Current().height; }\n\t\t\t\tthis.ComputeSize = function(d) {\n\t\t\t\t\tif (d != null && typeof(d) == 'number') return d;\n\t\t\t\t\tif (d == 'x') return this.width();\n\t\t\t\t\tif (d == 'y') return this.height();\n\t\t\t\t\treturn Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\tsvg.init();\n\n\t\t// images loaded\n\t\tsvg.ImagesLoaded = function() {\n\t\t\tfor (var i=0; i<svg.Images.length; i++) {\n\t\t\t\tif (!svg.Images[i].loaded) return false;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\t// trim\n\t\tsvg.trim = function(s) { return s.replace(/^\\s+|\\s+$/g, ''); }\n\n\t\t// compress spaces\n\t\tsvg.compressSpaces = function(s) { return s.replace(/[\\s\\r\\t\\n]+/gm,' '); }\n\n\t\t// ajax\n\t\tsvg.ajax = function(url) {\n\t\t\tvar AJAX;\n\t\t\tif(window.XMLHttpRequest){AJAX=new XMLHttpRequest();}\n\t\t\telse{AJAX=new ActiveXObject('Microsoft.XMLHTTP');}\n\t\t\tif(AJAX){\n\t\t\t   AJAX.open('GET',url,false);\n\t\t\t   AJAX.send(null);\n\t\t\t   return AJAX.responseText;\n\t\t\t}\n\t\t\treturn null;\n\t\t}\n\n\t\t// parse xml\n\t\tsvg.parseXml = function(xml) {\n\t\t\tif (window.DOMParser)\n\t\t\t{\n\t\t\t\tvar parser = new DOMParser();\n\t\t\t\treturn parser.parseFromString(xml, 'text/xml');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\txml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');\n\t\t\t\tvar xmlDoc = new ActiveXObject('Microsoft.XMLDOM');\n\t\t\t\txmlDoc.async = 'false';\n\t\t\t\txmlDoc.loadXML(xml);\n\t\t\t\treturn xmlDoc;\n\t\t\t}\n\t\t}\n\n\t\tsvg.Property = function(name, value) {\n\t\t\tthis.name = name;\n\t\t\tthis.value = value;\n\t\t}\n\t\t\tsvg.Property.prototype.getValue = function() {\n\t\t\t\treturn this.value;\n\t\t\t}\n\n\t\t\tsvg.Property.prototype.hasValue = function() {\n\t\t\t\treturn (this.value != null && this.value !== '');\n\t\t\t}\n\n\t\t\t// return the numerical value of the property\n\t\t\tsvg.Property.prototype.numValue = function() {\n\t\t\t\tif (!this.hasValue()) return 0;\n\n\t\t\t\tvar n = parseFloat(this.value);\n\t\t\t\tif ((this.value + '').match(/%$/)) {\n\t\t\t\t\tn = n / 100.0;\n\t\t\t\t}\n\t\t\t\treturn n;\n\t\t\t}\n\n\t\t\tsvg.Property.prototype.valueOrDefault = function(def) {\n\t\t\t\tif (this.hasValue()) return this.value;\n\t\t\t\treturn def;\n\t\t\t}\n\n\t\t\tsvg.Property.prototype.numValueOrDefault = function(def) {\n\t\t\t\tif (this.hasValue()) return this.numValue();\n\t\t\t\treturn def;\n\t\t\t}\n\n\t\t\t// color extensions\n\t\t\t\t// augment the current color value with the opacity\n\t\t\t\tsvg.Property.prototype.addOpacity = function(opacity) {\n\t\t\t\t\tvar newValue = this.value;\n\t\t\t\t\tif (opacity != null && opacity != '' && typeof(this.value)=='string') { // can only add opacity to colors, not patterns\n\t\t\t\t\t\tvar color = new RGBColor(this.value);\n\t\t\t\t\t\tif (color.ok) {\n\t\t\t\t\t\t\tnewValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')';\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn new svg.Property(this.name, newValue);\n\t\t\t\t}\n\n\t\t\t// definition extensions\n\t\t\t\t// get the definition from the definitions table\n\t\t\t\tsvg.Property.prototype.getDefinition = function() {\n\t\t\t\t\tvar name = this.value.match(/#([^\\)'\"]+)/);\n\t\t\t\t\tif (name) { name = name[1]; }\n\t\t\t\t\tif (!name) { name = this.value; }\n\t\t\t\t\treturn svg.Definitions[name];\n\t\t\t\t}\n\n\t\t\t\tsvg.Property.prototype.isUrlDefinition = function() {\n\t\t\t\t\treturn this.value.indexOf('url(') == 0\n\t\t\t\t}\n\n\t\t\t\tsvg.Property.prototype.getFillStyleDefinition = function(e, opacityProp) {\n\t\t\t\t\tvar def = this.getDefinition();\n\n\t\t\t\t\t// gradient\n\t\t\t\t\tif (def != null && def.createGradient) {\n\t\t\t\t\t\treturn def.createGradient(svg.ctx, e, opacityProp);\n\t\t\t\t\t}\n\n\t\t\t\t\t// pattern\n\t\t\t\t\tif (def != null && def.createPattern) {\n\t\t\t\t\t\tif (def.getHrefAttribute().hasValue()) {\n\t\t\t\t\t\t\tvar pt = def.attribute('patternTransform');\n\t\t\t\t\t\t\tdef = def.getHrefAttribute().getDefinition();\n\t\t\t\t\t\t\tif (pt.hasValue()) { def.attribute('patternTransform', true).value = pt.value; }\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn def.createPattern(svg.ctx, e);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn null;\n\t\t\t\t}\n\n\t\t\t// length extensions\n\t\t\t\tsvg.Property.prototype.getDPI = function(viewPort) {\n\t\t\t\t\treturn 96.0; // TODO: compute?\n\t\t\t\t}\n\n\t\t\t\tsvg.Property.prototype.getEM = function(viewPort) {\n\t\t\t\t\tvar em = 12;\n\n\t\t\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tif (fontSize.hasValue()) em = fontSize.toPixels(viewPort);\n\n\t\t\t\t\treturn em;\n\t\t\t\t}\n\n\t\t\t\tsvg.Property.prototype.getUnits = function() {\n\t\t\t\t\tvar s = this.value+'';\n\t\t\t\t\treturn s.replace(/[0-9\\.\\-]/g,'');\n\t\t\t\t}\n\n\t\t\t\t// get the length as pixels\n\t\t\t\tsvg.Property.prototype.toPixels = function(viewPort, processPercent) {\n\t\t\t\t\tif (!this.hasValue()) return 0;\n\t\t\t\t\tvar s = this.value+'';\n\t\t\t\t\tif (s.match(/em$/)) return this.numValue() * this.getEM(viewPort);\n\t\t\t\t\tif (s.match(/ex$/)) return this.numValue() * this.getEM(viewPort) / 2.0;\n\t\t\t\t\tif (s.match(/px$/)) return this.numValue();\n\t\t\t\t\tif (s.match(/pt$/)) return this.numValue() * this.getDPI(viewPort) * (1.0 / 72.0);\n\t\t\t\t\tif (s.match(/pc$/)) return this.numValue() * 15;\n\t\t\t\t\tif (s.match(/cm$/)) return this.numValue() * this.getDPI(viewPort) / 2.54;\n\t\t\t\t\tif (s.match(/mm$/)) return this.numValue() * this.getDPI(viewPort) / 25.4;\n\t\t\t\t\tif (s.match(/in$/)) return this.numValue() * this.getDPI(viewPort);\n\t\t\t\t\tif (s.match(/%$/)) return this.numValue() * svg.ViewPort.ComputeSize(viewPort);\n\t\t\t\t\tvar n = this.numValue();\n\t\t\t\t\tif (processPercent && n < 1.0) return n * svg.ViewPort.ComputeSize(viewPort);\n\t\t\t\t\treturn n;\n\t\t\t\t}\n\n\t\t\t// time extensions\n\t\t\t\t// get the time as milliseconds\n\t\t\t\tsvg.Property.prototype.toMilliseconds = function() {\n\t\t\t\t\tif (!this.hasValue()) return 0;\n\t\t\t\t\tvar s = this.value+'';\n\t\t\t\t\tif (s.match(/s$/)) return this.numValue() * 1000;\n\t\t\t\t\tif (s.match(/ms$/)) return this.numValue();\n\t\t\t\t\treturn this.numValue();\n\t\t\t\t}\n\n\t\t\t// angle extensions\n\t\t\t\t// get the angle as radians\n\t\t\t\tsvg.Property.prototype.toRadians = function() {\n\t\t\t\t\tif (!this.hasValue()) return 0;\n\t\t\t\t\tvar s = this.value+'';\n\t\t\t\t\tif (s.match(/deg$/)) return this.numValue() * (Math.PI / 180.0);\n\t\t\t\t\tif (s.match(/grad$/)) return this.numValue() * (Math.PI / 200.0);\n\t\t\t\t\tif (s.match(/rad$/)) return this.numValue();\n\t\t\t\t\treturn this.numValue() * (Math.PI / 180.0);\n\t\t\t\t}\n\n\t\t// fonts\n\t\tsvg.Font = new (function() {\n\t\t\tthis.Styles = 'normal|italic|oblique|inherit';\n\t\t\tthis.Variants = 'normal|small-caps|inherit';\n\t\t\tthis.Weights = 'normal|bold|bolder|lighter|100|200|300|400|500|600|700|800|900|inherit';\n\n\t\t\tthis.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit) {\n\t\t\t\tvar f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);\n\t\t\t\treturn {\n\t\t\t\t\tfontFamily: fontFamily || f.fontFamily,\n\t\t\t\t\tfontSize: fontSize || f.fontSize,\n\t\t\t\t\tfontStyle: fontStyle || f.fontStyle,\n\t\t\t\t\tfontWeight: fontWeight || f.fontWeight,\n\t\t\t\t\tfontVariant: fontVariant || f.fontVariant,\n\t\t\t\t\ttoString: function () { return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ') }\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar that = this;\n\t\t\tthis.Parse = function(s) {\n\t\t\t\tvar f = {};\n\t\t\t\tvar d = svg.trim(svg.compressSpaces(s || '')).split(' ');\n\t\t\t\tvar set = { fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false }\n\t\t\t\tvar ff = '';\n\t\t\t\tfor (var i=0; i<d.length; i++) {\n\t\t\t\t\tif (!set.fontStyle && that.Styles.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontStyle = d[i]; set.fontStyle = true; }\n\t\t\t\t\telse if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1) { if (d[i] != 'inherit') f.fontVariant = d[i]; set.fontStyle = set.fontVariant = true;\t}\n\t\t\t\t\telse if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1) {\tif (d[i] != 'inherit') f.fontWeight = d[i]; set.fontStyle = set.fontVariant = set.fontWeight = true; }\n\t\t\t\t\telse if (!set.fontSize) { if (d[i] != 'inherit') f.fontSize = d[i].split('/')[0]; set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true; }\n\t\t\t\t\telse { if (d[i] != 'inherit') ff += d[i]; }\n\t\t\t\t} if (ff != '') f.fontFamily = ff;\n\t\t\t\treturn f;\n\t\t\t}\n\t\t});\n\n\t\t// points and paths\n\t\tsvg.ToNumberArray = function(s) {\n\t\t\tvar a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');\n\t\t\tfor (var i=0; i<a.length; i++) {\n\t\t\t\ta[i] = parseFloat(a[i]);\n\t\t\t}\n\t\t\treturn a;\n\t\t}\n\t\tsvg.Point = function(x, y) {\n\t\t\tthis.x = x;\n\t\t\tthis.y = y;\n\t\t}\n\t\t\tsvg.Point.prototype.angleTo = function(p) {\n\t\t\t\treturn Math.atan2(p.y - this.y, p.x - this.x);\n\t\t\t}\n\n\t\t\tsvg.Point.prototype.applyTransform = function(v) {\n\t\t\t\tvar xp = this.x * v[0] + this.y * v[2] + v[4];\n\t\t\t\tvar yp = this.x * v[1] + this.y * v[3] + v[5];\n\t\t\t\tthis.x = xp;\n\t\t\t\tthis.y = yp;\n\t\t\t}\n\n\t\tsvg.CreatePoint = function(s) {\n\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\treturn new svg.Point(a[0], a[1]);\n\t\t}\n\t\tsvg.CreatePath = function(s) {\n\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\tvar path = [];\n\t\t\tfor (var i=0; i<a.length; i+=2) {\n\t\t\t\tpath.push(new svg.Point(a[i], a[i+1]));\n\t\t\t}\n\t\t\treturn path;\n\t\t}\n\n\t\t// bounding box\n\t\tsvg.BoundingBox = function(x1, y1, x2, y2) { // pass in initial points if you want\n\t\t\tthis.x1 = Number.NaN;\n\t\t\tthis.y1 = Number.NaN;\n\t\t\tthis.x2 = Number.NaN;\n\t\t\tthis.y2 = Number.NaN;\n\n\t\t\tthis.x = function() { return this.x1; }\n\t\t\tthis.y = function() { return this.y1; }\n\t\t\tthis.width = function() { return this.x2 - this.x1; }\n\t\t\tthis.height = function() { return this.y2 - this.y1; }\n\n\t\t\tthis.addPoint = function(x, y) {\n\t\t\t\tif (x != null) {\n\t\t\t\t\tif (isNaN(this.x1) || isNaN(this.x2)) {\n\t\t\t\t\t\tthis.x1 = x;\n\t\t\t\t\t\tthis.x2 = x;\n\t\t\t\t\t}\n\t\t\t\t\tif (x < this.x1) this.x1 = x;\n\t\t\t\t\tif (x > this.x2) this.x2 = x;\n\t\t\t\t}\n\n\t\t\t\tif (y != null) {\n\t\t\t\t\tif (isNaN(this.y1) || isNaN(this.y2)) {\n\t\t\t\t\t\tthis.y1 = y;\n\t\t\t\t\t\tthis.y2 = y;\n\t\t\t\t\t}\n\t\t\t\t\tif (y < this.y1) this.y1 = y;\n\t\t\t\t\tif (y > this.y2) this.y2 = y;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.addX = function(x) { this.addPoint(x, null); }\n\t\t\tthis.addY = function(y) { this.addPoint(null, y); }\n\n\t\t\tthis.addBoundingBox = function(bb) {\n\t\t\t\tthis.addPoint(bb.x1, bb.y1);\n\t\t\t\tthis.addPoint(bb.x2, bb.y2);\n\t\t\t}\n\n\t\t\tthis.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y) {\n\t\t\t\tvar cp1x = p0x + 2/3 * (p1x - p0x); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp1y = p0y + 2/3 * (p1y - p0y); // CP1 = QP0 + 2/3 *(QP1-QP0)\n\t\t\t\tvar cp2x = cp1x + 1/3 * (p2x - p0x); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tvar cp2y = cp1y + 1/3 * (p2y - p0y); // CP2 = CP1 + 1/3 *(QP2-QP0)\n\t\t\t\tthis.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y,\tcp2y, p2x, p2y);\n\t\t\t}\n\n\t\t\tthis.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y) {\n\t\t\t\t// from http://blog.hackers-cafe.net/2009/06/how-to-calculate-bezier-curves-bounding.html\n\t\t\t\tvar p0 = [p0x, p0y], p1 = [p1x, p1y], p2 = [p2x, p2y], p3 = [p3x, p3y];\n\t\t\t\tthis.addPoint(p0[0], p0[1]);\n\t\t\t\tthis.addPoint(p3[0], p3[1]);\n\n\t\t\t\tfor (i=0; i<=1; i++) {\n\t\t\t\t\tvar f = function(t) {\n\t\t\t\t\t\treturn Math.pow(1-t, 3) * p0[i]\n\t\t\t\t\t\t+ 3 * Math.pow(1-t, 2) * t * p1[i]\n\t\t\t\t\t\t+ 3 * (1-t) * Math.pow(t, 2) * p2[i]\n\t\t\t\t\t\t+ Math.pow(t, 3) * p3[i];\n\t\t\t\t\t}\n\n\t\t\t\t\tvar b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];\n\t\t\t\t\tvar a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];\n\t\t\t\t\tvar c = 3 * p1[i] - 3 * p0[i];\n\n\t\t\t\t\tif (a == 0) {\n\t\t\t\t\t\tif (b == 0) continue;\n\t\t\t\t\t\tvar t = -c / b;\n\t\t\t\t\t\tif (0 < t && t < 1) {\n\t\t\t\t\t\t\tif (i == 0) this.addX(f(t));\n\t\t\t\t\t\t\tif (i == 1) this.addY(f(t));\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar b2ac = Math.pow(b, 2) - 4 * c * a;\n\t\t\t\t\tif (b2ac < 0) continue;\n\t\t\t\t\tvar t1 = (-b + Math.sqrt(b2ac)) / (2 * a);\n\t\t\t\t\tif (0 < t1 && t1 < 1) {\n\t\t\t\t\t\tif (i == 0) this.addX(f(t1));\n\t\t\t\t\t\tif (i == 1) this.addY(f(t1));\n\t\t\t\t\t}\n\t\t\t\t\tvar t2 = (-b - Math.sqrt(b2ac)) / (2 * a);\n\t\t\t\t\tif (0 < t2 && t2 < 1) {\n\t\t\t\t\t\tif (i == 0) this.addX(f(t2));\n\t\t\t\t\t\tif (i == 1) this.addY(f(t2));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.isPointInBox = function(x, y) {\n\t\t\t\treturn (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2);\n\t\t\t}\n\n\t\t\tthis.addPoint(x1, y1);\n\t\t\tthis.addPoint(x2, y2);\n\t\t}\n\n\t\t// transforms\n\t\tsvg.Transform = function(v) {\n\t\t\tvar that = this;\n\t\t\tthis.Type = {}\n\n\t\t\t// translate\n\t\t\tthis.Type.translate = function(s) {\n\t\t\t\tthis.p = svg.CreatePoint(s);\n\t\t\t\tthis.apply = function(ctx) {\n\t\t\t\t\tctx.translate(this.p.x || 0.0, this.p.y || 0.0);\n\t\t\t\t}\n\t\t\t\tthis.unapply = function(ctx) {\n\t\t\t\t\tctx.translate(-1.0 * this.p.x || 0.0, -1.0 * this.p.y || 0.0);\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function(p) {\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// rotate\n\t\t\tthis.Type.rotate = function(s) {\n\t\t\t\tvar a = svg.ToNumberArray(s);\n\t\t\t\tthis.angle = new svg.Property('angle', a[0]);\n\t\t\t\tthis.cx = a[1] || 0;\n\t\t\t\tthis.cy = a[2] || 0;\n\t\t\t\tthis.apply = function(ctx) {\n\t\t\t\t\tctx.translate(this.cx, this.cy);\n\t\t\t\t\tctx.rotate(this.angle.toRadians());\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\n\t\t\t\t}\n\t\t\t\tthis.unapply = function(ctx) {\n\t\t\t\t\tctx.translate(this.cx, this.cy);\n\t\t\t\t\tctx.rotate(-1.0 * this.angle.toRadians());\n\t\t\t\t\tctx.translate(-this.cx, -this.cy);\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function(p) {\n\t\t\t\t\tvar a = this.angle.toRadians();\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);\n\t\t\t\t\tp.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);\n\t\t\t\t\tp.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.scale = function(s) {\n\t\t\t\tthis.p = svg.CreatePoint(s);\n\t\t\t\tthis.apply = function(ctx) {\n\t\t\t\t\tctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0);\n\t\t\t\t}\n\t\t\t\tthis.unapply = function(ctx) {\n\t\t\t\t\tctx.scale(1.0 / this.p.x || 1.0, 1.0 / this.p.y || this.p.x || 1.0);\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function(p) {\n\t\t\t\t\tp.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0]);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.matrix = function(s) {\n\t\t\t\tthis.m = svg.ToNumberArray(s);\n\t\t\t\tthis.apply = function(ctx) {\n\t\t\t\t\tctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5]);\n\t\t\t\t}\n\t\t\t\tthis.applyToPoint = function(p) {\n\t\t\t\t\tp.applyTransform(this.m);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.Type.SkewBase = function(s) {\n\t\t\t\tthis.base = that.Type.matrix;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.angle = new svg.Property('angle', s);\n\t\t\t}\n\t\t\tthis.Type.SkewBase.prototype = new this.Type.matrix;\n\n\t\t\tthis.Type.skewX = function(s) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.m = [1, 0, Math.tan(this.angle.toRadians()), 1, 0, 0];\n\t\t\t}\n\t\t\tthis.Type.skewX.prototype = new this.Type.SkewBase;\n\n\t\t\tthis.Type.skewY = function(s) {\n\t\t\t\tthis.base = that.Type.SkewBase;\n\t\t\t\tthis.base(s);\n\t\t\t\tthis.m = [1, Math.tan(this.angle.toRadians()), 0, 1, 0, 0];\n\t\t\t}\n\t\t\tthis.Type.skewY.prototype = new this.Type.SkewBase;\n\n\t\t\tthis.transforms = [];\n\n\t\t\tthis.apply = function(ctx) {\n\t\t\t\tfor (var i=0; i<this.transforms.length; i++) {\n\t\t\t\t\tthis.transforms[i].apply(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.unapply = function(ctx) {\n\t\t\t\tfor (var i=this.transforms.length-1; i>=0; i--) {\n\t\t\t\t\tthis.transforms[i].unapply(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.applyToPoint = function(p) {\n\t\t\t\tfor (var i=0; i<this.transforms.length; i++) {\n\t\t\t\t\tthis.transforms[i].applyToPoint(p);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar data = svg.trim(svg.compressSpaces(v)).replace(/\\)(\\s?,\\s?)/g,') ').split(/\\s(?=[a-z])/);\n\t\t\tfor (var i=0; i<data.length; i++) {\n\t\t\t\tvar type = svg.trim(data[i].split('(')[0]);\n\t\t\t\tvar s = data[i].split('(')[1].replace(')','');\n\t\t\t\tvar transform = new this.Type[type](s);\n\t\t\t\ttransform.type = type;\n\t\t\t\tthis.transforms.push(transform);\n\t\t\t}\n\t\t}\n\n\t\t// aspect ratio\n\t\tsvg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY) {\n\t\t\t// aspect ratio - http://www.w3.org/TR/SVG/coords.html#PreserveAspectRatioAttribute\n\t\t\taspectRatio = svg.compressSpaces(aspectRatio);\n\t\t\taspectRatio = aspectRatio.replace(/^defer\\s/,''); // ignore defer\n\t\t\tvar align = aspectRatio.split(' ')[0] || 'xMidYMid';\n\t\t\tvar meetOrSlice = aspectRatio.split(' ')[1] || 'meet';\n\n\t\t\t// calculate scale\n\t\t\tvar scaleX = width / desiredWidth;\n\t\t\tvar scaleY = height / desiredHeight;\n\t\t\tvar scaleMin = Math.min(scaleX, scaleY);\n\t\t\tvar scaleMax = Math.max(scaleX, scaleY);\n\t\t\tif (meetOrSlice == 'meet') { desiredWidth *= scaleMin; desiredHeight *= scaleMin; }\n\t\t\tif (meetOrSlice == 'slice') { desiredWidth *= scaleMax; desiredHeight *= scaleMax; }\n\n\t\t\trefX = new svg.Property('refX', refX);\n\t\t\trefY = new svg.Property('refY', refY);\n\t\t\tif (refX.hasValue() && refY.hasValue()) {\n\t\t\t\tctx.translate(-scaleMin * refX.toPixels('x'), -scaleMin * refY.toPixels('y'));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// align\n\t\t\t\tif (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);\n\t\t\t\tif (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height / 2.0 - desiredHeight / 2.0);\n\t\t\t\tif (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY))) ctx.translate(width - desiredWidth, 0);\n\t\t\t\tif (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX))) ctx.translate(0, height - desiredHeight);\n\t\t\t}\n\n\t\t\t// scale\n\t\t\tif (align == 'none') ctx.scale(scaleX, scaleY);\n\t\t\telse if (meetOrSlice == 'meet') ctx.scale(scaleMin, scaleMin);\n\t\t\telse if (meetOrSlice == 'slice') ctx.scale(scaleMax, scaleMax);\n\n\t\t\t// translate\n\t\t\tctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY);\n\t\t}\n\n\t\t// elements\n\t\tsvg.Element = {}\n\n\t\tsvg.EmptyProperty = new svg.Property('EMPTY', '');\n\n\t\tsvg.Element.ElementBase = function(node) {\n\t\t\tthis.attributes = {};\n\t\t\tthis.styles = {};\n\t\t\tthis.children = [];\n\n\t\t\t// get or create attribute\n\t\t\tthis.attribute = function(name, createIfNotExists) {\n\t\t\t\tvar a = this.attributes[name];\n\t\t\t\tif (a != null) return a;\n\n\t\t\t\tif (createIfNotExists == true) { a = new svg.Property(name, ''); this.attributes[name] = a; }\n\t\t\t\treturn a || svg.EmptyProperty;\n\t\t\t}\n\n\t\t\tthis.getHrefAttribute = function() {\n\t\t\t\tfor (var a in this.attributes) {\n\t\t\t\t\tif (a.match(/:href$/)) {\n\t\t\t\t\t\treturn this.attributes[a];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn svg.EmptyProperty;\n\t\t\t}\n\n\t\t\t// get or create style, crawls up node tree\n\t\t\tthis.style = function(name, createIfNotExists) {\n\t\t\t\tvar s = this.styles[name];\n\t\t\t\tif (s != null) return s;\n\n\t\t\t\tvar a = this.attribute(name);\n\t\t\t\tif (a != null && a.hasValue()) {\n\t\t\t\t\tthis.styles[name] = a; // move up to me to cache\n\t\t\t\t\treturn a;\n\t\t\t\t}\n\n\t\t\t\tvar p = this.parent;\n\t\t\t\tif (p != null) {\n\t\t\t\t\tvar ps = p.style(name);\n\t\t\t\t\tif (ps != null && ps.hasValue()) {\n\t\t\t\t\t\treturn ps;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (createIfNotExists == true) { s = new svg.Property(name, ''); this.styles[name] = s; }\n\t\t\t\treturn s || svg.EmptyProperty;\n\t\t\t}\n\n\t\t\t// base render\n\t\t\tthis.render = function(ctx) {\n\t\t\t\t// don't render display=none\n\t\t\t\tif (this.style('display').value == 'none') return;\n\n\t\t\t\t// don't render visibility=hidden\n\t\t\t\tif (this.attribute('visibility').value == 'hidden') return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif (this.attribute('mask').hasValue()) { // mask\n\t\t\t\t\tvar mask = this.attribute('mask').getDefinition();\n\t\t\t\t\tif (mask != null) mask.apply(ctx, this);\n\t\t\t\t}\n\t\t\t\telse if (this.style('filter').hasValue()) { // filter\n\t\t\t\t\tvar filter = this.style('filter').getDefinition();\n\t\t\t\t\tif (filter != null) filter.apply(ctx, this);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis.setContext(ctx);\n\t\t\t\t\tthis.renderChildren(ctx);\n\t\t\t\t\tthis.clearContext(ctx);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\t// base set context\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\t// base clear context\n\t\t\tthis.clearContext = function(ctx) {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\t// base render children\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tthis.children[i].render(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.addChild = function(childNode, create) {\n\t\t\t\tvar child = childNode;\n\t\t\t\tif (create) child = svg.CreateElement(childNode);\n\t\t\t\tchild.parent = this;\n\t\t\t\tthis.children.push(child);\n\t\t\t}\n\n\t\t\tif (node != null && node.nodeType == 1) { //ELEMENT_NODE\n\t\t\t\t// add children\n\t\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\n\t\t\t\t\tvar childNode = node.childNodes[i];\n\t\t\t\t\tif (childNode.nodeType == 1) this.addChild(childNode, true); //ELEMENT_NODE\n\t\t\t\t\tif (this.captureTextNodes && childNode.nodeType == 3) {\n\t\t\t\t\t\tvar text = childNode.nodeValue || childNode.text || '';\n\t\t\t\t\t\tif (svg.trim(svg.compressSpaces(text)) != '') {\n\t\t\t\t\t\t\tthis.addChild(new svg.Element.tspan(childNode), false); // TEXT_NODE\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add attributes\n\t\t\t\tfor (var i=0; i<node.attributes.length; i++) {\n\t\t\t\t\tvar attribute = node.attributes[i];\n\t\t\t\t\tthis.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue);\n\t\t\t\t}\n\n\t\t\t\t// add tag styles\n\t\t\t\tvar styles = svg.Styles[node.nodeName];\n\t\t\t\tif (styles != null) {\n\t\t\t\t\tfor (var name in styles) {\n\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add class styles\n\t\t\t\tif (this.attribute('class').hasValue()) {\n\t\t\t\t\tvar classes = svg.compressSpaces(this.attribute('class').value).split(' ');\n\t\t\t\t\tfor (var j=0; j<classes.length; j++) {\n\t\t\t\t\t\tstyles = svg.Styles['.'+classes[j]];\n\t\t\t\t\t\tif (styles != null) {\n\t\t\t\t\t\t\tfor (var name in styles) {\n\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tstyles = svg.Styles[node.nodeName+'.'+classes[j]];\n\t\t\t\t\t\tif (styles != null) {\n\t\t\t\t\t\t\tfor (var name in styles) {\n\t\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add id styles\n\t\t\t\tif (this.attribute('id').hasValue()) {\n\t\t\t\t\tvar styles = svg.Styles['#' + this.attribute('id').value];\n\t\t\t\t\tif (styles != null) {\n\t\t\t\t\t\tfor (var name in styles) {\n\t\t\t\t\t\t\tthis.styles[name] = styles[name];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add inline styles\n\t\t\t\tif (this.attribute('style').hasValue()) {\n\t\t\t\t\tvar styles = this.attribute('style').value.split(';');\n\t\t\t\t\tfor (var i=0; i<styles.length; i++) {\n\t\t\t\t\t\tif (svg.trim(styles[i]) != '') {\n\t\t\t\t\t\t\tvar style = styles[i].split(':');\n\t\t\t\t\t\t\tvar name = svg.trim(style[0]);\n\t\t\t\t\t\t\tvar value = svg.trim(style[1]);\n\t\t\t\t\t\t\tthis.styles[name] = new svg.Property(name, value);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// add id\n\t\t\t\tif (this.attribute('id').hasValue()) {\n\t\t\t\t\tif (svg.Definitions[this.attribute('id').value] == null) {\n\t\t\t\t\t\tsvg.Definitions[this.attribute('id').value] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tsvg.Element.RenderedElementBase = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\t// fill\n\t\t\t\tif (this.style('fill').isUrlDefinition()) {\n\t\t\t\t\tvar fs = this.style('fill').getFillStyleDefinition(this, this.style('fill-opacity'));\n\t\t\t\t\tif (fs != null) ctx.fillStyle = fs;\n\t\t\t\t}\n\t\t\t\telse if (this.style('fill').hasValue()) {\n\t\t\t\t\tvar fillStyle = this.style('fill');\n\t\t\t\t\tif (fillStyle.value == 'currentColor') fillStyle.value = this.style('color').value;\n\t\t\t\t\tctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value);\n\t\t\t\t}\n\t\t\t\tif (this.style('fill-opacity').hasValue()) {\n\t\t\t\t\tvar fillStyle = new svg.Property('fill', ctx.fillStyle);\n\t\t\t\t\tfillStyle = fillStyle.addOpacity(this.style('fill-opacity').value);\n\t\t\t\t\tctx.fillStyle = fillStyle.value;\n\t\t\t\t}\n\n\t\t\t\t// stroke\n\t\t\t\tif (this.style('stroke').isUrlDefinition()) {\n\t\t\t\t\tvar fs = this.style('stroke').getFillStyleDefinition(this, this.style('stroke-opacity'));\n\t\t\t\t\tif (fs != null) ctx.strokeStyle = fs;\n\t\t\t\t}\n\t\t\t\telse if (this.style('stroke').hasValue()) {\n\t\t\t\t\tvar strokeStyle = this.style('stroke');\n\t\t\t\t\tif (strokeStyle.value == 'currentColor') strokeStyle.value = this.style('color').value;\n\t\t\t\t\tctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value);\n\t\t\t\t}\n\t\t\t\tif (this.style('stroke-opacity').hasValue()) {\n\t\t\t\t\tvar strokeStyle = new svg.Property('stroke', ctx.strokeStyle);\n\t\t\t\t\tstrokeStyle = strokeStyle.addOpacity(this.style('stroke-opacity').value);\n\t\t\t\t\tctx.strokeStyle = strokeStyle.value;\n\t\t\t\t}\n\t\t\t\tif (this.style('stroke-width').hasValue()) {\n\t\t\t\t\tvar newLineWidth = this.style('stroke-width').toPixels();\n\t\t\t\t\tctx.lineWidth = newLineWidth == 0 ? 0.001 : newLineWidth; // browsers don't respect 0\n\t\t\t    }\n\t\t\t\tif (this.style('stroke-linecap').hasValue()) ctx.lineCap = this.style('stroke-linecap').value;\n\t\t\t\tif (this.style('stroke-linejoin').hasValue()) ctx.lineJoin = this.style('stroke-linejoin').value;\n\t\t\t\tif (this.style('stroke-miterlimit').hasValue()) ctx.miterLimit = this.style('stroke-miterlimit').value;\n\t\t\t\tif (this.style('stroke-dasharray').hasValue() && this.style('stroke-dasharray').value != 'none') {\n\t\t\t\t\tvar gaps = svg.ToNumberArray(this.style('stroke-dasharray').value);\n\t\t\t\t\tif (typeof(ctx.setLineDash) != 'undefined') { ctx.setLineDash(gaps); }\n\t\t\t\t\telse if (typeof(ctx.webkitLineDash) != 'undefined') { ctx.webkitLineDash = gaps; }\n\t\t\t\t\telse if (typeof(ctx.mozDash ) != 'undefined') { ctx.mozDash  = gaps; }\n\n\t\t\t\t\tvar offset = this.style('stroke-dashoffset').numValueOrDefault(1);\n\t\t\t\t\tif (typeof(ctx.lineDashOffset) != 'undefined') { ctx.lineDashOffset = offset; }\n\t\t\t\t\telse if (typeof(ctx.webkitLineDashOffset) != 'undefined') { ctx.webkitLineDashOffset = offset; }\n\t\t\t\t\telse if (typeof(ctx.mozDashOffset) != 'undefined') { ctx.mozDashOffset = offset; }\n\t\t\t\t}\n\n\t\t\t\t// font\n\t\t\t\tif (typeof(ctx.font) != 'undefined') {\n\t\t\t\t\tctx.font = svg.Font.CreateFont(\n\t\t\t\t\t\tthis.style('font-style').value,\n\t\t\t\t\t\tthis.style('font-variant').value,\n\t\t\t\t\t\tthis.style('font-weight').value,\n\t\t\t\t\t\tthis.style('font-size').hasValue() ? this.style('font-size').toPixels() + 'px' : '',\n\t\t\t\t\t\tthis.style('font-family').value).toString();\n\t\t\t\t}\n\n\t\t\t\t// transform\n\t\t\t\tif (this.attribute('transform').hasValue()) {\n\t\t\t\t\tvar transform = new svg.Transform(this.attribute('transform').value);\n\t\t\t\t\ttransform.apply(ctx);\n\t\t\t\t}\n\n\t\t\t\t// clip\n\t\t\t\tif (this.style('clip-path').hasValue()) {\n\t\t\t\t\tvar clip = this.style('clip-path').getDefinition();\n\t\t\t\t\tif (clip != null) clip.apply(ctx);\n\t\t\t\t}\n\n\t\t\t\t// opacity\n\t\t\t\tif (this.style('opacity').hasValue()) {\n\t\t\t\t\tctx.globalAlpha = this.style('opacity').numValue();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.PathElementBase = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tif (ctx != null) ctx.beginPath();\n\t\t\t\treturn new svg.BoundingBox();\n\t\t\t}\n\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tthis.path(ctx);\n\t\t\t\tsvg.Mouse.checkPath(this, ctx);\n\t\t\t\tif (ctx.fillStyle != '') {\n\t\t\t\t\tif (this.attribute('fill-rule').hasValue()) { ctx.fill(this.attribute('fill-rule').value); }\n\t\t\t\t\telse { ctx.fill(); }\n\t\t\t\t}\n\t\t\t\tif (ctx.strokeStyle != '') ctx.stroke();\n\n\t\t\t\tvar markers = this.getMarkers();\n\t\t\t\tif (markers != null) {\n\t\t\t\t\tif (this.style('marker-start').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-start').getDefinition();\n\t\t\t\t\t\tmarker.render(ctx, markers[0][0], markers[0][1]);\n\t\t\t\t\t}\n\t\t\t\t\tif (this.style('marker-mid').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-mid').getDefinition();\n\t\t\t\t\t\tfor (var i=1;i<markers.length-1;i++) {\n\t\t\t\t\t\t\tmarker.render(ctx, markers[i][0], markers[i][1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (this.style('marker-end').isUrlDefinition()) {\n\t\t\t\t\t\tvar marker = this.style('marker-end').getDefinition();\n\t\t\t\t\t\tmarker.render(ctx, markers[markers.length-1][0], markers[markers.length-1][1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\treturn this.path();\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\treturn null;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// svg element\n\t\tsvg.Element.svg = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseClearContext = this.clearContext;\n\t\t\tthis.clearContext = function(ctx) {\n\t\t\t\tthis.baseClearContext(ctx);\n\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t}\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\t// initial values\n\t\t\t\tctx.strokeStyle = 'rgba(0,0,0,0)';\n\t\t\t\tctx.lineCap = 'butt';\n\t\t\t\tctx.lineJoin = 'miter';\n\t\t\t\tctx.miterLimit = 4;\n\n\t\t\t\tthis.baseSetContext(ctx);\n\n\t\t\t\t// create new view port\n\t\t\t\tif (!this.attribute('x').hasValue()) this.attribute('x', true).value = 0;\n\t\t\t\tif (!this.attribute('y').hasValue()) this.attribute('y', true).value = 0;\n\t\t\t\tctx.translate(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'));\n\n\t\t\t\tvar width = svg.ViewPort.width();\n\t\t\t\tvar height = svg.ViewPort.height();\n\n\t\t\t\tif (!this.attribute('width').hasValue()) this.attribute('width', true).value = '100%';\n\t\t\t\tif (!this.attribute('height').hasValue()) this.attribute('height', true).value = '100%';\n\t\t\t\tif (typeof(this.root) == 'undefined') {\n\t\t\t\t\twidth = this.attribute('width').toPixels('x');\n\t\t\t\t\theight = this.attribute('height').toPixels('y');\n\n\t\t\t\t\tvar x = 0;\n\t\t\t\t\tvar y = 0;\n\t\t\t\t\tif (this.attribute('refX').hasValue() && this.attribute('refY').hasValue()) {\n\t\t\t\t\t\tx = -this.attribute('refX').toPixels('x');\n\t\t\t\t\t\ty = -this.attribute('refY').toPixels('y');\n\t\t\t\t\t}\n\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(x, y);\n\t\t\t\t\tctx.lineTo(width, y);\n\t\t\t\t\tctx.lineTo(width, height);\n\t\t\t\t\tctx.lineTo(x, height);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t\tctx.clip();\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent(width, height);\n\n\t\t\t\t// viewbox\n\t\t\t\tif (this.attribute('viewBox').hasValue()) {\n\t\t\t\t\tvar viewBox = svg.ToNumberArray(this.attribute('viewBox').value);\n\t\t\t\t\tvar minX = viewBox[0];\n\t\t\t\t\tvar minY = viewBox[1];\n\t\t\t\t\twidth = viewBox[2];\n\t\t\t\t\theight = viewBox[3];\n\n\t\t\t\t\tsvg.AspectRatio(ctx,\n\t\t\t\t\t\t\t\t\tthis.attribute('preserveAspectRatio').value,\n\t\t\t\t\t\t\t\t\tsvg.ViewPort.width(),\n\t\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\t\tsvg.ViewPort.height(),\n\t\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\t\tminX,\n\t\t\t\t\t\t\t\t\tminY,\n\t\t\t\t\t\t\t\t\tthis.attribute('refX').value,\n\t\t\t\t\t\t\t\t\tthis.attribute('refY').value);\n\n\t\t\t\t\tsvg.ViewPort.RemoveCurrent();\n\t\t\t\t\tsvg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.svg.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// rect element\n\t\tsvg.Element.rect = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\n\t\t\t\tif (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue()) ry = rx;\n\t\t\t\tif (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue()) rx = ry;\n\t\t\t\trx = Math.min(rx, width / 2.0);\n\t\t\t\try = Math.min(ry, height / 2.0);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(x + rx, y);\n\t\t\t\t\tctx.lineTo(x + width - rx, y);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + ry)\n\t\t\t\t\tctx.lineTo(x + width, y + height - ry);\n\t\t\t\t\tctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height)\n\t\t\t\t\tctx.lineTo(x + rx, y + height);\n\t\t\t\t\tctx.quadraticCurveTo(x, y + height, x, y + height - ry)\n\t\t\t\t\tctx.lineTo(x, y + ry);\n\t\t\t\t\tctx.quadraticCurveTo(x, y, x + rx, y)\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.rect.prototype = new svg.Element.PathElementBase;\n\n\t\t// circle element\n\t\tsvg.Element.circle = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\n\t\t\t\tvar r = this.attribute('r').toPixels();\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.arc(cx, cy, r, 0, Math.PI * 2, true);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.circle.prototype = new svg.Element.PathElementBase;\n\n\t\t// ellipse element\n\t\tsvg.Element.ellipse = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);\n\t\t\t\tvar rx = this.attribute('rx').toPixels('x');\n\t\t\t\tvar ry = this.attribute('ry').toPixels('y');\n\t\t\t\tvar cx = this.attribute('cx').toPixels('x');\n\t\t\t\tvar cy = this.attribute('cy').toPixels('y');\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(cx, cy - ry);\n\t\t\t\t\tctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry,  cx + rx, cy - (KAPPA * ry), cx + rx, cy);\n\t\t\t\t\tctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);\n\t\t\t\t\tctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);\n\t\t\t\t\tctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.ellipse.prototype = new svg.Element.PathElementBase;\n\n\t\t// line element\n\t\tsvg.Element.line = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getPoints = function() {\n\t\t\t\treturn [\n\t\t\t\t\tnew svg.Point(this.attribute('x1').toPixels('x'), this.attribute('y1').toPixels('y')),\n\t\t\t\t\tnew svg.Point(this.attribute('x2').toPixels('x'), this.attribute('y2').toPixels('y'))];\n\t\t\t}\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar points = this.getPoints();\n\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(points[0].x, points[0].y);\n\t\t\t\t\tctx.lineTo(points[1].x, points[1].y);\n\t\t\t\t}\n\n\t\t\t\treturn new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y);\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar points = this.getPoints();\n\t\t\t\tvar a = points[0].angleTo(points[1]);\n\t\t\t\treturn [[points[0], a], [points[1], a]];\n\t\t\t}\n\t\t}\n\t\tsvg.Element.line.prototype = new svg.Element.PathElementBase;\n\n\t\t// polyline element\n\t\tsvg.Element.polyline = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.points = svg.CreatePath(this.attribute('points').value);\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.beginPath();\n\t\t\t\t\tctx.moveTo(this.points[0].x, this.points[0].y);\n\t\t\t\t}\n\t\t\t\tfor (var i=1; i<this.points.length; i++) {\n\t\t\t\t\tbb.addPoint(this.points[i].x, this.points[i].y);\n\t\t\t\t\tif (ctx != null) ctx.lineTo(this.points[i].x, this.points[i].y);\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar markers = [];\n\t\t\t\tfor (var i=0; i<this.points.length - 1; i++) {\n\t\t\t\t\tmarkers.push([this.points[i], this.points[i].angleTo(this.points[i+1])]);\n\t\t\t\t}\n\t\t\t\tmarkers.push([this.points[this.points.length-1], markers[markers.length-1][1]]);\n\t\t\t\treturn markers;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.polyline.prototype = new svg.Element.PathElementBase;\n\n\t\t// polygon element\n\t\tsvg.Element.polygon = function(node) {\n\t\t\tthis.base = svg.Element.polyline;\n\t\t\tthis.base(node);\n\n\t\t\tthis.basePath = this.path;\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar bb = this.basePath(ctx);\n\t\t\t\tif (ctx != null) {\n\t\t\t\t\tctx.lineTo(this.points[0].x, this.points[0].y);\n\t\t\t\t\tctx.closePath();\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.polygon.prototype = new svg.Element.polyline;\n\n\t\t// path element\n\t\tsvg.Element.path = function(node) {\n\t\t\tthis.base = svg.Element.PathElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tvar d = this.attribute('d').value;\n\t\t\t// TODO: convert to real lexer based on http://www.w3.org/TR/SVG11/paths.html#PathDataBNF\n\t\t\td = d.replace(/,/gm,' '); // get rid of all commas\n\t\t\td = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands\n\t\t\td = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from commands\n\t\t\td = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\\s])/gm,'$1 $2'); // separate commands from points\n\t\t\td = d.replace(/([^\\s])([MmZzLlHhVvCcSsQqTtAa])/gm,'$1 $2'); // separate commands from points\n\t\t\td = d.replace(/([0-9])([+\\-])/gm,'$1 $2'); // separate digits when no comma\n\t\t\td = d.replace(/(\\.[0-9]*)(\\.)/gm,'$1 $2'); // separate digits when no comma\n\t\t\td = d.replace(/([Aa](\\s+[0-9]+){3})\\s+([01])\\s*([01])/gm,'$1 $3 $4 '); // shorthand elliptical arc path syntax\n\t\t\td = svg.compressSpaces(d); // compress multiple spaces\n\t\t\td = svg.trim(d);\n\t\t\tthis.PathParser = new (function(d) {\n\t\t\t\tthis.tokens = d.split(' ');\n\n\t\t\t\tthis.reset = function() {\n\t\t\t\t\tthis.i = -1;\n\t\t\t\t\tthis.command = '';\n\t\t\t\t\tthis.previousCommand = '';\n\t\t\t\t\tthis.start = new svg.Point(0, 0);\n\t\t\t\t\tthis.control = new svg.Point(0, 0);\n\t\t\t\t\tthis.current = new svg.Point(0, 0);\n\t\t\t\t\tthis.points = [];\n\t\t\t\t\tthis.angles = [];\n\t\t\t\t}\n\n\t\t\t\tthis.isEnd = function() {\n\t\t\t\t\treturn this.i >= this.tokens.length - 1;\n\t\t\t\t}\n\n\t\t\t\tthis.isCommandOrEnd = function() {\n\t\t\t\t\tif (this.isEnd()) return true;\n\t\t\t\t\treturn this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null;\n\t\t\t\t}\n\n\t\t\t\tthis.isRelativeCommand = function() {\n\t\t\t\t\tswitch(this.command)\n\t\t\t\t\t{\n\t\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tcase 'l':\n\t\t\t\t\t\tcase 'h':\n\t\t\t\t\t\tcase 'v':\n\t\t\t\t\t\tcase 'c':\n\t\t\t\t\t\tcase 's':\n\t\t\t\t\t\tcase 'q':\n\t\t\t\t\t\tcase 't':\n\t\t\t\t\t\tcase 'a':\n\t\t\t\t\t\tcase 'z':\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\tthis.getToken = function() {\n\t\t\t\t\tthis.i++;\n\t\t\t\t\treturn this.tokens[this.i];\n\t\t\t\t}\n\n\t\t\t\tthis.getScalar = function() {\n\t\t\t\t\treturn parseFloat(this.getToken());\n\t\t\t\t}\n\n\t\t\t\tthis.nextCommand = function() {\n\t\t\t\t\tthis.previousCommand = this.command;\n\t\t\t\t\tthis.command = this.getToken();\n\t\t\t\t}\n\n\t\t\t\tthis.getPoint = function() {\n\t\t\t\t\tvar p = new svg.Point(this.getScalar(), this.getScalar());\n\t\t\t\t\treturn this.makeAbsolute(p);\n\t\t\t\t}\n\n\t\t\t\tthis.getAsControlPoint = function() {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.control = p;\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.getAsCurrentPoint = function() {\n\t\t\t\t\tvar p = this.getPoint();\n\t\t\t\t\tthis.current = p;\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.getReflectedControlPoint = function() {\n\t\t\t\t\tif (this.previousCommand.toLowerCase() != 'c' &&\n\t\t\t\t\t    this.previousCommand.toLowerCase() != 's' &&\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 'q' &&\n\t\t\t\t\t\tthis.previousCommand.toLowerCase() != 't' ){\n\t\t\t\t\t\treturn this.current;\n\t\t\t\t\t}\n\n\t\t\t\t\t// reflect point\n\t\t\t\t\tvar p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.makeAbsolute = function(p) {\n\t\t\t\t\tif (this.isRelativeCommand()) {\n\t\t\t\t\t\tp.x += this.current.x;\n\t\t\t\t\t\tp.y += this.current.y;\n\t\t\t\t\t}\n\t\t\t\t\treturn p;\n\t\t\t\t}\n\n\t\t\t\tthis.addMarker = function(p, from, priorTo) {\n\t\t\t\t\t// if the last angle isn't filled in because we didn't have this point yet ...\n\t\t\t\t\tif (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length-1] == null) {\n\t\t\t\t\t\tthis.angles[this.angles.length-1] = this.points[this.points.length-1].angleTo(priorTo);\n\t\t\t\t\t}\n\t\t\t\t\tthis.addMarkerAngle(p, from == null ? null : from.angleTo(p));\n\t\t\t\t}\n\n\t\t\t\tthis.addMarkerAngle = function(p, a) {\n\t\t\t\t\tthis.points.push(p);\n\t\t\t\t\tthis.angles.push(a);\n\t\t\t\t}\n\n\t\t\t\tthis.getMarkerPoints = function() { return this.points; }\n\t\t\t\tthis.getMarkerAngles = function() {\n\t\t\t\t\tfor (var i=0; i<this.angles.length; i++) {\n\t\t\t\t\t\tif (this.angles[i] == null) {\n\t\t\t\t\t\t\tfor (var j=i+1; j<this.angles.length; j++) {\n\t\t\t\t\t\t\t\tif (this.angles[j] != null) {\n\t\t\t\t\t\t\t\t\tthis.angles[i] = this.angles[j];\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn this.angles;\n\t\t\t\t}\n\t\t\t})(d);\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar pp = this.PathParser;\n\t\t\t\tpp.reset();\n\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tif (ctx != null) ctx.beginPath();\n\t\t\t\twhile (!pp.isEnd()) {\n\t\t\t\t\tpp.nextCommand();\n\t\t\t\t\tswitch (pp.command) {\n\t\t\t\t\tcase 'M':\n\t\t\t\t\tcase 'm':\n\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\tpp.addMarker(p);\n\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\tif (ctx != null) ctx.moveTo(p.x, p.y);\n\t\t\t\t\t\tpp.start = pp.current;\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(p, pp.start);\n\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'L':\n\t\t\t\t\tcase 'l':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar c = pp.current;\n\t\t\t\t\t\t\tvar p = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(p, c);\n\t\t\t\t\t\t\tbb.addPoint(p.x, p.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(p.x, p.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'H':\n\t\t\t\t\tcase 'h':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);\n\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\n\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'V':\n\t\t\t\t\tcase 'v':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());\n\t\t\t\t\t\t\tpp.addMarker(newP, pp.current);\n\t\t\t\t\t\t\tpp.current = newP;\n\t\t\t\t\t\t\tbb.addPoint(pp.current.x, pp.current.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.lineTo(pp.current.x, pp.current.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'C':\n\t\t\t\t\tcase 'c':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar p1 = pp.getPoint();\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\n\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'S':\n\t\t\t\t\tcase 's':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar p1 = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, p1);\n\t\t\t\t\t\t\tbb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Q':\n\t\t\t\t\tcase 'q':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar cntrl = pp.getAsControlPoint();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\n\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'T':\n\t\t\t\t\tcase 't':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t\tvar curr = pp.current;\n\t\t\t\t\t\t\tvar cntrl = pp.getReflectedControlPoint();\n\t\t\t\t\t\t\tpp.control = cntrl;\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\t\t\t\t\t\t\tpp.addMarker(cp, cntrl, cntrl);\n\t\t\t\t\t\t\tbb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t\tif (ctx != null) ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'A':\n\t\t\t\t\tcase 'a':\n\t\t\t\t\t\twhile (!pp.isCommandOrEnd()) {\n\t\t\t\t\t\t    var curr = pp.current;\n\t\t\t\t\t\t\tvar rx = pp.getScalar();\n\t\t\t\t\t\t\tvar ry = pp.getScalar();\n\t\t\t\t\t\t\tvar xAxisRotation = pp.getScalar() * (Math.PI / 180.0);\n\t\t\t\t\t\t\tvar largeArcFlag = pp.getScalar();\n\t\t\t\t\t\t\tvar sweepFlag = pp.getScalar();\n\t\t\t\t\t\t\tvar cp = pp.getAsCurrentPoint();\n\n\t\t\t\t\t\t\t// Conversion from endpoint to center parameterization\n\t\t\t\t\t\t\t// http://www.w3.org/TR/SVG11/implnote.html#ArcImplementationNotes\n\t\t\t\t\t\t\t// x1', y1'\n\t\t\t\t\t\t\tvar currp = new svg.Point(\n\t\t\t\t\t\t\t\tMath.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,\n\t\t\t\t\t\t\t\t-Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t// adjust radii\n\t\t\t\t\t\t\tvar l = Math.pow(currp.x,2)/Math.pow(rx,2)+Math.pow(currp.y,2)/Math.pow(ry,2);\n\t\t\t\t\t\t\tif (l > 1) {\n\t\t\t\t\t\t\t\trx *= Math.sqrt(l);\n\t\t\t\t\t\t\t\try *= Math.sqrt(l);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// cx', cy'\n\t\t\t\t\t\t\tvar s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(\n\t\t\t\t\t\t\t\t((Math.pow(rx,2)*Math.pow(ry,2))-(Math.pow(rx,2)*Math.pow(currp.y,2))-(Math.pow(ry,2)*Math.pow(currp.x,2))) /\n\t\t\t\t\t\t\t\t(Math.pow(rx,2)*Math.pow(currp.y,2)+Math.pow(ry,2)*Math.pow(currp.x,2))\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tif (isNaN(s)) s = 0;\n\t\t\t\t\t\t\tvar cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);\n\t\t\t\t\t\t\t// cx, cy\n\t\t\t\t\t\t\tvar centp = new svg.Point(\n\t\t\t\t\t\t\t\t(curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,\n\t\t\t\t\t\t\t\t(curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t// vector magnitude\n\t\t\t\t\t\t\tvar m = function(v) { return Math.sqrt(Math.pow(v[0],2) + Math.pow(v[1],2)); }\n\t\t\t\t\t\t\t// ratio between two vectors\n\t\t\t\t\t\t\tvar r = function(u, v) { return (u[0]*v[0]+u[1]*v[1]) / (m(u)*m(v)) }\n\t\t\t\t\t\t\t// angle between two vectors\n\t\t\t\t\t\t\tvar a = function(u, v) { return (u[0]*v[1] < u[1]*v[0] ? -1 : 1) * Math.acos(r(u,v)); }\n\t\t\t\t\t\t\t// initial angle\n\t\t\t\t\t\t\tvar a1 = a([1,0], [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry]);\n\t\t\t\t\t\t\t// angle delta\n\t\t\t\t\t\t\tvar u = [(currp.x-cpp.x)/rx,(currp.y-cpp.y)/ry];\n\t\t\t\t\t\t\tvar v = [(-currp.x-cpp.x)/rx,(-currp.y-cpp.y)/ry];\n\t\t\t\t\t\t\tvar ad = a(u, v);\n\t\t\t\t\t\t\tif (r(u,v) <= -1) ad = Math.PI;\n\t\t\t\t\t\t\tif (r(u,v) >= 1) ad = 0;\n\n\t\t\t\t\t\t\t// for markers\n\t\t\t\t\t\t\tvar dir = 1 - sweepFlag ? 1.0 : -1.0;\n\t\t\t\t\t\t\tvar ah = a1 + dir * (ad / 2.0);\n\t\t\t\t\t\t\tvar halfWay = new svg.Point(\n\t\t\t\t\t\t\t\tcentp.x + rx * Math.cos(ah),\n\t\t\t\t\t\t\t\tcentp.y + ry * Math.sin(ah)\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tpp.addMarkerAngle(halfWay, ah - dir * Math.PI / 2);\n\t\t\t\t\t\t\tpp.addMarkerAngle(cp, ah - dir * Math.PI);\n\n\t\t\t\t\t\t\tbb.addPoint(cp.x, cp.y); // TODO: this is too naive, make it better\n\t\t\t\t\t\t\tif (ctx != null) {\n\t\t\t\t\t\t\t\tvar r = rx > ry ? rx : ry;\n\t\t\t\t\t\t\t\tvar sx = rx > ry ? 1 : rx / ry;\n\t\t\t\t\t\t\t\tvar sy = rx > ry ? ry / rx : 1;\n\n\t\t\t\t\t\t\t\tctx.translate(centp.x, centp.y);\n\t\t\t\t\t\t\t\tctx.rotate(xAxisRotation);\n\t\t\t\t\t\t\t\tctx.scale(sx, sy);\n\t\t\t\t\t\t\t\tctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);\n\t\t\t\t\t\t\t\tctx.scale(1/sx, 1/sy);\n\t\t\t\t\t\t\t\tctx.rotate(-xAxisRotation);\n\t\t\t\t\t\t\t\tctx.translate(-centp.x, -centp.y);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 'Z':\n\t\t\t\t\tcase 'z':\n\t\t\t\t\t\tif (ctx != null) ctx.closePath();\n\t\t\t\t\t\tpp.current = pp.start;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn bb;\n\t\t\t}\n\n\t\t\tthis.getMarkers = function() {\n\t\t\t\tvar points = this.PathParser.getMarkerPoints();\n\t\t\t\tvar angles = this.PathParser.getMarkerAngles();\n\n\t\t\t\tvar markers = [];\n\t\t\t\tfor (var i=0; i<points.length; i++) {\n\t\t\t\t\tmarkers.push([points[i], angles[i]]);\n\t\t\t\t}\n\t\t\t\treturn markers;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.path.prototype = new svg.Element.PathElementBase;\n\n\t\t// pattern element\n\t\tsvg.Element.pattern = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.createPattern = function(ctx, element) {\n\t\t\t\tvar width = this.attribute('width').toPixels('x', true);\n\t\t\t\tvar height = this.attribute('height').toPixels('y', true);\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', width + 'px');\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', height + 'px');\n\t\t\t\ttempSvg.attributes['transform'] = new svg.Property('transform', this.attribute('patternTransform').value);\n\t\t\t\ttempSvg.children = this.children;\n\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = width;\n\t\t\t\tc.height = height;\n\t\t\t\tvar cctx = c.getContext('2d');\n\t\t\t\tif (this.attribute('x').hasValue() && this.attribute('y').hasValue()) {\n\t\t\t\t\tcctx.translate(this.attribute('x').toPixels('x', true), this.attribute('y').toPixels('y', true));\n\t\t\t\t}\n\t\t\t\t// render 3x3 grid so when we transform there's no white space on edges\n\t\t\t\tfor (var x=-1; x<=1; x++) {\n\t\t\t\t\tfor (var y=-1; y<=1; y++) {\n\t\t\t\t\t\tcctx.save();\n\t\t\t\t\t\tcctx.translate(x * c.width, y * c.height);\n\t\t\t\t\t\ttempSvg.render(cctx);\n\t\t\t\t\t\tcctx.restore();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar pattern = ctx.createPattern(c, 'repeat');\n\t\t\t\treturn pattern;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.pattern.prototype = new svg.Element.ElementBase;\n\n\t\t// marker element\n\t\tsvg.Element.marker = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseRender = this.render;\n\t\t\tthis.render = function(ctx, point, angle) {\n\t\t\t\tctx.translate(point.x, point.y);\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(angle);\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(ctx.lineWidth, ctx.lineWidth);\n\t\t\t\tctx.save();\n\n\t\t\t\t// render me using a temporary svg element\n\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\ttempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);\n\t\t\t\ttempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);\n\t\t\t\ttempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);\n\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);\n\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);\n\t\t\t\ttempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));\n\t\t\t\ttempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));\n\t\t\t\ttempSvg.children = this.children;\n\t\t\t\ttempSvg.render(ctx);\n\n\t\t\t\tctx.restore();\n\t\t\t\tif (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth') ctx.scale(1/ctx.lineWidth, 1/ctx.lineWidth);\n\t\t\t\tif (this.attribute('orient').valueOrDefault('auto') == 'auto') ctx.rotate(-angle);\n\t\t\t\tctx.translate(-point.x, -point.y);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.marker.prototype = new svg.Element.ElementBase;\n\n\t\t// definitions element\n\t\tsvg.Element.defs = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.render = function(ctx) {\n\t\t\t\t// NOOP\n\t\t\t}\n\t\t}\n\t\tsvg.Element.defs.prototype = new svg.Element.ElementBase;\n\n\t\t// base for gradients\n\t\tsvg.Element.GradientBase = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');\n\n\t\t\tthis.stops = [];\n\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.type == 'stop') this.stops.push(child);\n\t\t\t}\n\n\t\t\tthis.getGradient = function() {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t}\n\n\t\t\tthis.createGradient = function(ctx, element, parentOpacityProp) {\n\t\t\t\tvar stopsContainer = this;\n\t\t\t\tif (this.getHrefAttribute().hasValue()) {\n\t\t\t\t\tstopsContainer = this.getHrefAttribute().getDefinition();\n\t\t\t\t}\n\n\t\t\t\tvar addParentOpacity = function (color) {\n\t\t\t\t\tif (parentOpacityProp.hasValue()) {\n\t\t\t\t\t\tvar p = new svg.Property('color', color);\n\t\t\t\t\t\treturn p.addOpacity(parentOpacityProp.value).value;\n\t\t\t\t\t}\n\t\t\t\t\treturn color;\n\t\t\t\t};\n\n\t\t\t\tvar g = this.getGradient(ctx, element);\n\t\t\t\tif (g == null) return addParentOpacity(stopsContainer.stops[stopsContainer.stops.length - 1].color);\n\t\t\t\tfor (var i=0; i<stopsContainer.stops.length; i++) {\n\t\t\t\t\tg.addColorStop(stopsContainer.stops[i].offset, addParentOpacity(stopsContainer.stops[i].color));\n\t\t\t\t}\n\n\t\t\t\tif (this.attribute('gradientTransform').hasValue()) {\n\t\t\t\t\t// render as transformed pattern on temporary canvas\n\t\t\t\t\tvar rootView = svg.ViewPort.viewPorts[0];\n\n\t\t\t\t\tvar rect = new svg.Element.rect();\n\t\t\t\t\trect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS/3.0);\n\t\t\t\t\trect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS/3.0);\n\t\t\t\t\trect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);\n\t\t\t\t\trect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);\n\n\t\t\t\t\tvar group = new svg.Element.g();\n\t\t\t\t\tgroup.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);\n\t\t\t\t\tgroup.children = [ rect ];\n\n\t\t\t\t\tvar tempSvg = new svg.Element.svg();\n\t\t\t\t\ttempSvg.attributes['x'] = new svg.Property('x', 0);\n\t\t\t\t\ttempSvg.attributes['y'] = new svg.Property('y', 0);\n\t\t\t\t\ttempSvg.attributes['width'] = new svg.Property('width', rootView.width);\n\t\t\t\t\ttempSvg.attributes['height'] = new svg.Property('height', rootView.height);\n\t\t\t\t\ttempSvg.children = [ group ];\n\n\t\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\t\tc.width = rootView.width;\n\t\t\t\t\tc.height = rootView.height;\n\t\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\t\ttempCtx.fillStyle = g;\n\t\t\t\t\ttempSvg.render(tempCtx);\n\t\t\t\t\treturn tempCtx.createPattern(c, 'no-repeat');\n\t\t\t\t}\n\n\t\t\t\treturn g;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.GradientBase.prototype = new svg.Element.ElementBase;\n\n\t\t// linear gradient element\n\t\tsvg.Element.linearGradient = function(node) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getGradient = function(ctx, element) {\n\t\t\t\tvar bb = element.getBoundingBox();\n\n\t\t\t\tif (!this.attribute('x1').hasValue()\n\t\t\t\t && !this.attribute('y1').hasValue()\n\t\t\t\t && !this.attribute('x2').hasValue()\n\t\t\t\t && !this.attribute('y2').hasValue()) {\n\t\t\t\t\tthis.attribute('x1', true).value = 0;\n\t\t\t\t\tthis.attribute('y1', true).value = 0;\n\t\t\t\t\tthis.attribute('x2', true).value = 1;\n\t\t\t\t\tthis.attribute('y2', true).value = 0;\n\t\t\t\t }\n\n\t\t\t\tvar x1 = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('x1').numValue()\n\t\t\t\t\t: this.attribute('x1').toPixels('x'));\n\t\t\t\tvar y1 = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('y1').numValue()\n\t\t\t\t\t: this.attribute('y1').toPixels('y'));\n\t\t\t\tvar x2 = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('x2').numValue()\n\t\t\t\t\t: this.attribute('x2').toPixels('x'));\n\t\t\t\tvar y2 = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('y2').numValue()\n\t\t\t\t\t: this.attribute('y2').toPixels('y'));\n\n\t\t\t\tif (x1 == x2 && y1 == y2) return null;\n\t\t\t\treturn ctx.createLinearGradient(x1, y1, x2, y2);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.linearGradient.prototype = new svg.Element.GradientBase;\n\n\t\t// radial gradient element\n\t\tsvg.Element.radialGradient = function(node) {\n\t\t\tthis.base = svg.Element.GradientBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getGradient = function(ctx, element) {\n\t\t\t\tvar bb = element.getBoundingBox();\n\n\t\t\t\tif (!this.attribute('cx').hasValue()) this.attribute('cx', true).value = '50%';\n\t\t\t\tif (!this.attribute('cy').hasValue()) this.attribute('cy', true).value = '50%';\n\t\t\t\tif (!this.attribute('r').hasValue()) this.attribute('r', true).value = '50%';\n\n\t\t\t\tvar cx = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('cx').numValue()\n\t\t\t\t\t: this.attribute('cx').toPixels('x'));\n\t\t\t\tvar cy = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('cy').numValue()\n\t\t\t\t\t: this.attribute('cy').toPixels('y'));\n\n\t\t\t\tvar fx = cx;\n\t\t\t\tvar fy = cy;\n\t\t\t\tif (this.attribute('fx').hasValue()) {\n\t\t\t\t\tfx = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.x() + bb.width() * this.attribute('fx').numValue()\n\t\t\t\t\t: this.attribute('fx').toPixels('x'));\n\t\t\t\t}\n\t\t\t\tif (this.attribute('fy').hasValue()) {\n\t\t\t\t\tfy = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? bb.y() + bb.height() * this.attribute('fy').numValue()\n\t\t\t\t\t: this.attribute('fy').toPixels('y'));\n\t\t\t\t}\n\n\t\t\t\tvar r = (this.gradientUnits == 'objectBoundingBox'\n\t\t\t\t\t? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue()\n\t\t\t\t\t: this.attribute('r').toPixels());\n\n\t\t\t\treturn ctx.createRadialGradient(fx, fy, 0, cx, cy, r);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.radialGradient.prototype = new svg.Element.GradientBase;\n\n\t\t// gradient stop element\n\t\tsvg.Element.stop = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.offset = this.attribute('offset').numValue();\n\t\t\tif (this.offset < 0) this.offset = 0;\n\t\t\tif (this.offset > 1) this.offset = 1;\n\n\t\t\tvar stopColor = this.style('stop-color');\n\t\t\tif (this.style('stop-opacity').hasValue()) stopColor = stopColor.addOpacity(this.style('stop-opacity').value);\n\t\t\tthis.color = stopColor.value;\n\t\t}\n\t\tsvg.Element.stop.prototype = new svg.Element.ElementBase;\n\n\t\t// animation base element\n\t\tsvg.Element.AnimateBase = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tsvg.Animations.push(this);\n\n\t\t\tthis.duration = 0.0;\n\t\t\tthis.begin = this.attribute('begin').toMilliseconds();\n\t\t\tthis.maxDuration = this.begin + this.attribute('dur').toMilliseconds();\n\n\t\t\tthis.getProperty = function() {\n\t\t\t\tvar attributeType = this.attribute('attributeType').value;\n\t\t\t\tvar attributeName = this.attribute('attributeName').value;\n\n\t\t\t\tif (attributeType == 'CSS') {\n\t\t\t\t\treturn this.parent.style(attributeName, true);\n\t\t\t\t}\n\t\t\t\treturn this.parent.attribute(attributeName, true);\n\t\t\t};\n\n\t\t\tthis.initialValue = null;\n\t\t\tthis.initialUnits = '';\n\t\t\tthis.removed = false;\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\t// OVERRIDE ME!\n\t\t\t\treturn '';\n\t\t\t}\n\n\t\t\tthis.update = function(delta) {\n\t\t\t\t// set initial value\n\t\t\t\tif (this.initialValue == null) {\n\t\t\t\t\tthis.initialValue = this.getProperty().value;\n\t\t\t\t\tthis.initialUnits = this.getProperty().getUnits();\n\t\t\t\t}\n\n\t\t\t\t// if we're past the end time\n\t\t\t\tif (this.duration > this.maxDuration) {\n\t\t\t\t\t// loop for indefinitely repeating animations\n\t\t\t\t\tif (this.attribute('repeatCount').value == 'indefinite'\n\t\t\t\t\t || this.attribute('repeatDur').value == 'indefinite') {\n\t\t\t\t\t\tthis.duration = 0.0\n\t\t\t\t\t}\n\t\t\t\t\telse if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed) {\n\t\t\t\t\t\tthis.removed = true;\n\t\t\t\t\t\tthis.getProperty().value = this.initialValue;\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn false; // no updates made\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tthis.duration = this.duration + delta;\n\n\t\t\t\t// if we're past the begin time\n\t\t\t\tvar updated = false;\n\t\t\t\tif (this.begin < this.duration) {\n\t\t\t\t\tvar newValue = this.calcValue(); // tween\n\n\t\t\t\t\tif (this.attribute('type').hasValue()) {\n\t\t\t\t\t\t// for transform, etc.\n\t\t\t\t\t\tvar type = this.attribute('type').value;\n\t\t\t\t\t\tnewValue = type + '(' + newValue + ')';\n\t\t\t\t\t}\n\n\t\t\t\t\tthis.getProperty().value = newValue;\n\t\t\t\t\tupdated = true;\n\t\t\t\t}\n\n\t\t\t\treturn updated;\n\t\t\t}\n\n\t\t\tthis.from = this.attribute('from');\n\t\t\tthis.to = this.attribute('to');\n\t\t\tthis.values = this.attribute('values');\n\t\t\tif (this.values.hasValue()) this.values.value = this.values.value.split(';');\n\n\t\t\t// fraction of duration we've covered\n\t\t\tthis.progress = function() {\n\t\t\t\tvar ret = { progress: (this.duration - this.begin) / (this.maxDuration - this.begin) };\n\t\t\t\tif (this.values.hasValue()) {\n\t\t\t\t\tvar p = ret.progress * (this.values.value.length - 1);\n\t\t\t\t\tvar lb = Math.floor(p), ub = Math.ceil(p);\n\t\t\t\t\tret.from = new svg.Property('from', parseFloat(this.values.value[lb]));\n\t\t\t\t\tret.to = new svg.Property('to', parseFloat(this.values.value[ub]));\n\t\t\t\t\tret.progress = (p - lb) / (ub - lb);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tret.from = this.from;\n\t\t\t\t\tret.to = this.to;\n\t\t\t\t}\n\t\t\t\treturn ret;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.AnimateBase.prototype = new svg.Element.ElementBase;\n\n\t\t// animate element\n\t\tsvg.Element.animate = function(node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar newValue = p.from.numValue() + (p.to.numValue() - p.from.numValue()) * p.progress;\n\t\t\t\treturn newValue + this.initialUnits;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animate.prototype = new svg.Element.AnimateBase;\n\n\t\t// animate color element\n\t\tsvg.Element.animateColor = function(node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\t\t\t\tvar from = new RGBColor(p.from.value);\n\t\t\t\tvar to = new RGBColor(p.to.value);\n\n\t\t\t\tif (from.ok && to.ok) {\n\t\t\t\t\t// tween color linearly\n\t\t\t\t\tvar r = from.r + (to.r - from.r) * p.progress;\n\t\t\t\t\tvar g = from.g + (to.g - from.g) * p.progress;\n\t\t\t\t\tvar b = from.b + (to.b - from.b) * p.progress;\n\t\t\t\t\treturn 'rgb('+parseInt(r,10)+','+parseInt(g,10)+','+parseInt(b,10)+')';\n\t\t\t\t}\n\t\t\t\treturn this.attribute('from').value;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animateColor.prototype = new svg.Element.AnimateBase;\n\n\t\t// animate transform element\n\t\tsvg.Element.animateTransform = function(node) {\n\t\t\tthis.base = svg.Element.AnimateBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.calcValue = function() {\n\t\t\t\tvar p = this.progress();\n\n\t\t\t\t// tween value linearly\n\t\t\t\tvar from = svg.ToNumberArray(p.from.value);\n\t\t\t\tvar to = svg.ToNumberArray(p.to.value);\n\t\t\t\tvar newValue = '';\n\t\t\t\tfor (var i=0; i<from.length; i++) {\n\t\t\t\t\tnewValue += from[i] + (to[i] - from[i]) * p.progress + ' ';\n\t\t\t\t}\n\t\t\t\treturn newValue;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.animateTransform.prototype = new svg.Element.animate;\n\n\t\t// font element\n\t\tsvg.Element.font = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\n\n\t\t\tthis.isRTL = false;\n\t\t\tthis.isArabic = false;\n\t\t\tthis.fontFace = null;\n\t\t\tthis.missingGlyph = null;\n\t\t\tthis.glyphs = [];\n\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\tvar child = this.children[i];\n\t\t\t\tif (child.type == 'font-face') {\n\t\t\t\t\tthis.fontFace = child;\n\t\t\t\t\tif (child.style('font-family').hasValue()) {\n\t\t\t\t\t\tsvg.Definitions[child.style('font-family').value] = this;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (child.type == 'missing-glyph') this.missingGlyph = child;\n\t\t\t\telse if (child.type == 'glyph') {\n\t\t\t\t\tif (child.arabicForm != '') {\n\t\t\t\t\t\tthis.isRTL = true;\n\t\t\t\t\t\tthis.isArabic = true;\n\t\t\t\t\t\tif (typeof(this.glyphs[child.unicode]) == 'undefined') this.glyphs[child.unicode] = [];\n\t\t\t\t\t\tthis.glyphs[child.unicode][child.arabicForm] = child;\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis.glyphs[child.unicode] = child;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.font.prototype = new svg.Element.ElementBase;\n\n\t\t// font-face element\n\t\tsvg.Element.fontface = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.ascent = this.attribute('ascent').value;\n\t\t\tthis.descent = this.attribute('descent').value;\n\t\t\tthis.unitsPerEm = this.attribute('units-per-em').numValue();\n\t\t}\n\t\tsvg.Element.fontface.prototype = new svg.Element.ElementBase;\n\n\t\t// missing-glyph element\n\t\tsvg.Element.missingglyph = function(node) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = 0;\n\t\t}\n\t\tsvg.Element.missingglyph.prototype = new svg.Element.path;\n\n\t\t// glyph element\n\t\tsvg.Element.glyph = function(node) {\n\t\t\tthis.base = svg.Element.path;\n\t\t\tthis.base(node);\n\n\t\t\tthis.horizAdvX = this.attribute('horiz-adv-x').numValue();\n\t\t\tthis.unicode = this.attribute('unicode').value;\n\t\t\tthis.arabicForm = this.attribute('arabic-form').value;\n\t\t}\n\t\tsvg.Element.glyph.prototype = new svg.Element.path;\n\n\t\t// text element\n\t\tsvg.Element.text = function(node) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\tthis.baseSetContext(ctx);\n\t\t\t\tif (this.style('dominant-baseline').hasValue()) ctx.textBaseline = this.style('dominant-baseline').value;\n\t\t\t\tif (this.style('alignment-baseline').hasValue()) ctx.textBaseline = this.style('alignment-baseline').value;\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function () {\n\t\t\t\t// TODO: implement\n\t\t\t\treturn new svg.BoundingBox(this.attribute('x').toPixels('x'), this.attribute('y').toPixels('y'), 0, 0);\n\t\t\t}\n\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tthis.x = this.attribute('x').toPixels('x');\n\t\t\t\tthis.y = this.attribute('y').toPixels('y');\n\t\t\t\tthis.x += this.getAnchorDelta(ctx, this, 0);\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tthis.renderChild(ctx, this, i);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.getAnchorDelta = function (ctx, parent, startI) {\n\t\t\t\tvar textAnchor = this.style('text-anchor').valueOrDefault('start');\n\t\t\t\tif (textAnchor != 'start') {\n\t\t\t\t\tvar width = 0;\n\t\t\t\t\tfor (var i=startI; i<parent.children.length; i++) {\n\t\t\t\t\t\tvar child = parent.children[i];\n\t\t\t\t\t\tif (i > startI && child.attribute('x').hasValue()) break; // new group\n\t\t\t\t\t\twidth += child.measureTextRecursive(ctx);\n\t\t\t\t\t}\n\t\t\t\t\treturn -1 * (textAnchor == 'end' ? width : width / 2.0);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t}\n\n\t\t\tthis.renderChild = function(ctx, parent, i) {\n\t\t\t\tvar child = parent.children[i];\n\t\t\t\tif (child.attribute('x').hasValue()) {\n\t\t\t\t\tchild.x = child.attribute('x').toPixels('x') + this.getAnchorDelta(ctx, parent, i);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.attribute('dx').hasValue()) this.x += this.attribute('dx').toPixels('x');\n\t\t\t\t\tif (child.attribute('dx').hasValue()) this.x += child.attribute('dx').toPixels('x');\n\t\t\t\t\tchild.x = this.x;\n\t\t\t\t}\n\t\t\t\tthis.x = child.x + child.measureText(ctx);\n\n\t\t\t\tif (child.attribute('y').hasValue()) {\n\t\t\t\t\tchild.y = child.attribute('y').toPixels('y');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (this.attribute('dy').hasValue()) this.y += this.attribute('dy').toPixels('y');\n\t\t\t\t\tif (child.attribute('dy').hasValue()) this.y += child.attribute('dy').toPixels('y');\n\t\t\t\t\tchild.y = this.y;\n\t\t\t\t}\n\t\t\t\tthis.y = child.y;\n\n\t\t\t\tchild.render(ctx);\n\n\t\t\t\tfor (var i=0; i<child.children.length; i++) {\n\t\t\t\t\tthis.renderChild(ctx, child, i);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.text.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// text base\n\t\tsvg.Element.TextElementBase = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getGlyph = function(font, text, i) {\n\t\t\t\tvar c = text[i];\n\t\t\t\tvar glyph = null;\n\t\t\t\tif (font.isArabic) {\n\t\t\t\t\tvar arabicForm = 'isolated';\n\t\t\t\t\tif ((i==0 || text[i-1]==' ') && i<text.length-2 && text[i+1]!=' ') arabicForm = 'terminal';\n\t\t\t\t\tif (i>0 && text[i-1]!=' ' && i<text.length-2 && text[i+1]!=' ') arabicForm = 'medial';\n\t\t\t\t\tif (i>0 && text[i-1]!=' ' && (i == text.length-1 || text[i+1]==' ')) arabicForm = 'initial';\n\t\t\t\t\tif (typeof(font.glyphs[c]) != 'undefined') {\n\t\t\t\t\t\tglyph = font.glyphs[c][arabicForm];\n\t\t\t\t\t\tif (glyph == null && font.glyphs[c].type == 'glyph') glyph = font.glyphs[c];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tglyph = font.glyphs[c];\n\t\t\t\t}\n\t\t\t\tif (glyph == null) glyph = font.missingGlyph;\n\t\t\t\treturn glyph;\n\t\t\t}\n\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\n\t\t\t\tif (customFont != null) {\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tvar fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\n\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\n\t\t\t\t\tfor (var i=0; i<text.length; i++) {\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\n\t\t\t\t\t\tvar scale = fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tctx.translate(this.x, this.y);\n\t\t\t\t\t\tctx.scale(scale, -scale);\n\t\t\t\t\t\tvar lw = ctx.lineWidth;\n\t\t\t\t\t\tctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, .4, 1, 0, 0);\n\t\t\t\t\t\tglyph.render(ctx);\n\t\t\t\t\t\tif (fontStyle == 'italic') ctx.transform(1, 0, -.4, 1, 0, 0);\n\t\t\t\t\t\tctx.lineWidth = lw;\n\t\t\t\t\t\tctx.scale(1/scale, -1/scale);\n\t\t\t\t\t\tctx.translate(-this.x, -this.y);\n\n\t\t\t\t\t\tthis.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {\n\t\t\t\t\t\t\tthis.x += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (ctx.fillStyle != '') ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y);\n\t\t\t\tif (ctx.strokeStyle != '') ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);\n\t\t\t}\n\n\t\t\tthis.getText = function() {\n\t\t\t\t// OVERRIDE ME\n\t\t\t}\n\n\t\t\tthis.measureTextRecursive = function(ctx) {\n\t\t\t\tvar width = this.measureText(ctx);\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\twidth += this.children[i].measureTextRecursive(ctx);\n\t\t\t\t}\n\t\t\t\treturn width;\n\t\t\t}\n\n\t\t\tthis.measureText = function(ctx) {\n\t\t\t\tvar customFont = this.parent.style('font-family').getDefinition();\n\t\t\t\tif (customFont != null) {\n\t\t\t\t\tvar fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tvar measure = 0;\n\t\t\t\t\tvar text = this.getText();\n\t\t\t\t\tif (customFont.isRTL) text = text.split(\"\").reverse().join(\"\");\n\t\t\t\t\tvar dx = svg.ToNumberArray(this.parent.attribute('dx').value);\n\t\t\t\t\tfor (var i=0; i<text.length; i++) {\n\t\t\t\t\t\tvar glyph = this.getGlyph(customFont, text, i);\n\t\t\t\t\t\tmeasure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;\n\t\t\t\t\t\tif (typeof(dx[i]) != 'undefined' && !isNaN(dx[i])) {\n\t\t\t\t\t\t\tmeasure += dx[i];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\treturn measure;\n\t\t\t\t}\n\n\t\t\t\tvar textToMeasure = svg.compressSpaces(this.getText());\n\t\t\t\tif (!ctx.measureText) return textToMeasure.length * 10;\n\n\t\t\t\tctx.save();\n\t\t\t\tthis.setContext(ctx);\n\t\t\t\tvar width = ctx.measureText(textToMeasure).width;\n\t\t\t\tctx.restore();\n\t\t\t\treturn width;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// tspan\n\t\tsvg.Element.tspan = function(node) {\n\t\t\tthis.captureTextNodes = true;\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.text = node.nodeValue || node.text || '';\n\t\t\tthis.getText = function() {\n\t\t\t\treturn this.text;\n\t\t\t}\n\t\t}\n\t\tsvg.Element.tspan.prototype = new svg.Element.TextElementBase;\n\n\t\t// tref\n\t\tsvg.Element.tref = function(node) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getText = function() {\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\t\t\t\tif (element != null) return element.children[0].getText();\n\t\t\t}\n\t\t}\n\t\tsvg.Element.tref.prototype = new svg.Element.TextElementBase;\n\n\t\t// a element\n\t\tsvg.Element.a = function(node) {\n\t\t\tthis.base = svg.Element.TextElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.hasText = true;\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\n\t\t\t\tif (node.childNodes[i].nodeType != 3) this.hasText = false;\n\t\t\t}\n\n\t\t\t// this might contain text\n\t\t\tthis.text = this.hasText ? node.childNodes[0].nodeValue : '';\n\t\t\tthis.getText = function() {\n\t\t\t\treturn this.text;\n\t\t\t}\n\n\t\t\tthis.baseRenderChildren = this.renderChildren;\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tif (this.hasText) {\n\t\t\t\t\t// render as text element\n\t\t\t\t\tthis.baseRenderChildren(ctx);\n\t\t\t\t\tvar fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);\n\t\t\t\t\tsvg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.toPixels('y'), this.x + this.measureText(ctx), this.y));\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// render as temporary group\n\t\t\t\t\tvar g = new svg.Element.g();\n\t\t\t\t\tg.children = this.children;\n\t\t\t\t\tg.parent = this;\n\t\t\t\t\tg.render(ctx);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.onclick = function() {\n\t\t\t\twindow.open(this.getHrefAttribute().value);\n\t\t\t}\n\n\t\t\tthis.onmousemove = function() {\n\t\t\t\tsvg.ctx.canvas.style.cursor = 'pointer';\n\t\t\t}\n\t\t}\n\t\tsvg.Element.a.prototype = new svg.Element.TextElementBase;\n\n\t\t// image element\n\t\tsvg.Element.image = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tvar href = this.getHrefAttribute().value;\n\t\t\tvar isSvg = href.match(/\\.svg$/)\n\n\t\t\tsvg.Images.push(this);\n\t\t\tthis.loaded = false;\n\t\t\tif (!isSvg) {\n\t\t\t\tthis.img = document.createElement('img');\n\t\t\t\tvar self = this;\n\t\t\t\tthis.img.onload = function() { self.loaded = true; }\n\t\t\t\tthis.img.onerror = function() { if (typeof(console) != 'undefined') { console.log('ERROR: image \"' + href + '\" not found'); self.loaded = true; } }\n\t\t\t\tthis.img.src = href;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.img = svg.ajax(href);\n\t\t\t\tthis.loaded = true;\n\t\t\t}\n\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\tif (width == 0 || height == 0) return;\n\n\t\t\t\tctx.save();\n\t\t\t\tif (isSvg) {\n\t\t\t\t\tctx.drawSvg(this.img, x, y, width, height);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tctx.translate(x, y);\n\t\t\t\t\tsvg.AspectRatio(ctx,\n\t\t\t\t\t\t\t\t\tthis.attribute('preserveAspectRatio').value,\n\t\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\t\tthis.img.width,\n\t\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\t\tthis.img.height,\n\t\t\t\t\t\t\t\t\t0,\n\t\t\t\t\t\t\t\t\t0);\n\t\t\t\t\tctx.drawImage(this.img, 0, 0);\n\t\t\t\t}\n\t\t\t\tctx.restore();\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\t\t\t\treturn new svg.BoundingBox(x, y, x + width, y + height);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.image.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// group element\n\t\tsvg.Element.g = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\n\t\t\t\t}\n\t\t\t\treturn bb;\n\t\t\t};\n\t\t}\n\t\tsvg.Element.g.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// symbol element\n\t\tsvg.Element.symbol = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\tthis.baseSetContext(ctx);\n\n\t\t\t\t// viewbox\n\t\t\t\tif (this.attribute('viewBox').hasValue()) {\n\t\t\t\t\tvar viewBox = svg.ToNumberArray(this.attribute('viewBox').value);\n\t\t\t\t\tvar minX = viewBox[0];\n\t\t\t\t\tvar minY = viewBox[1];\n\t\t\t\t\twidth = viewBox[2];\n\t\t\t\t\theight = viewBox[3];\n\n\t\t\t\t\tsvg.AspectRatio(ctx,\n\t\t\t\t\t\t\t\t\tthis.attribute('preserveAspectRatio').value,\n\t\t\t\t\t\t\t\t\tthis.attribute('width').toPixels('x'),\n\t\t\t\t\t\t\t\t\twidth,\n\t\t\t\t\t\t\t\t\tthis.attribute('height').toPixels('y'),\n\t\t\t\t\t\t\t\t\theight,\n\t\t\t\t\t\t\t\t\tminX,\n\t\t\t\t\t\t\t\t\tminY);\n\n\t\t\t\t\tsvg.ViewPort.SetCurrent(viewBox[2], viewBox[3]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.symbol.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// style element\n\t\tsvg.Element.style = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\t// text, or spaces then CDATA\n\t\t\tvar css = ''\n\t\t\tfor (var i=0; i<node.childNodes.length; i++) {\n\t\t\t  css += node.childNodes[i].nodeValue;\n\t\t\t}\n\t\t\tcss = css.replace(/(\\/\\*([^*]|[\\r\\n]|(\\*+([^*\\/]|[\\r\\n])))*\\*+\\/)|(^[\\s]*\\/\\/.*)/gm, ''); // remove comments\n\t\t\tcss = svg.compressSpaces(css); // replace whitespace\n\t\t\tvar cssDefs = css.split('}');\n\t\t\tfor (var i=0; i<cssDefs.length; i++) {\n\t\t\t\tif (svg.trim(cssDefs[i]) != '') {\n\t\t\t\t\tvar cssDef = cssDefs[i].split('{');\n\t\t\t\t\tvar cssClasses = cssDef[0].split(',');\n\t\t\t\t\tvar cssProps = cssDef[1].split(';');\n\t\t\t\t\tfor (var j=0; j<cssClasses.length; j++) {\n\t\t\t\t\t\tvar cssClass = svg.trim(cssClasses[j]);\n\t\t\t\t\t\tif (cssClass != '') {\n\t\t\t\t\t\t\tvar props = {};\n\t\t\t\t\t\t\tfor (var k=0; k<cssProps.length; k++) {\n\t\t\t\t\t\t\t\tvar prop = cssProps[k].indexOf(':');\n\t\t\t\t\t\t\t\tvar name = cssProps[k].substr(0, prop);\n\t\t\t\t\t\t\t\tvar value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);\n\t\t\t\t\t\t\t\tif (name != null && value != null) {\n\t\t\t\t\t\t\t\t\tprops[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value));\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tsvg.Styles[cssClass] = props;\n\t\t\t\t\t\t\tif (cssClass == '@font-face') {\n\t\t\t\t\t\t\t\tvar fontFamily = props['font-family'].value.replace(/\"/g,'');\n\t\t\t\t\t\t\t\tvar srcs = props['src'].value.split(',');\n\t\t\t\t\t\t\t\tfor (var s=0; s<srcs.length; s++) {\n\t\t\t\t\t\t\t\t\tif (srcs[s].indexOf('format(\"svg\")') > 0) {\n\t\t\t\t\t\t\t\t\t\tvar urlStart = srcs[s].indexOf('url');\n\t\t\t\t\t\t\t\t\t\tvar urlEnd = srcs[s].indexOf(')', urlStart);\n\t\t\t\t\t\t\t\t\t\tvar url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);\n\t\t\t\t\t\t\t\t\t\tvar doc = svg.parseXml(svg.ajax(url));\n\t\t\t\t\t\t\t\t\t\tvar fonts = doc.getElementsByTagName('font');\n\t\t\t\t\t\t\t\t\t\tfor (var f=0; f<fonts.length; f++) {\n\t\t\t\t\t\t\t\t\t\t\tvar font = svg.CreateElement(fonts[f]);\n\t\t\t\t\t\t\t\t\t\t\tsvg.Definitions[fontFamily] = font;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.style.prototype = new svg.Element.ElementBase;\n\n\t\t// use element\n\t\tsvg.Element.use = function(node) {\n\t\t\tthis.base = svg.Element.RenderedElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.baseSetContext = this.setContext;\n\t\t\tthis.setContext = function(ctx) {\n\t\t\t\tthis.baseSetContext(ctx);\n\t\t\t\tif (this.attribute('x').hasValue()) ctx.translate(this.attribute('x').toPixels('x'), 0);\n\t\t\t\tif (this.attribute('y').hasValue()) ctx.translate(0, this.attribute('y').toPixels('y'));\n\t\t\t}\n\n\t\t\tthis.getDefinition = function() {\n\t\t\t\tvar element = this.getHrefAttribute().getDefinition();\n\t\t\t\tif (this.attribute('width').hasValue()) element.attribute('width', true).value = this.attribute('width').value;\n\t\t\t\tif (this.attribute('height').hasValue()) element.attribute('height', true).value = this.attribute('height').value;\n\t\t\t\treturn element;\n\t\t\t}\n\n\t\t\tthis.path = function(ctx) {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif (element != null) element.path(ctx);\n\t\t\t}\n\n\t\t\tthis.getBoundingBox = function() {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif (element != null) return element.getBoundingBox();\n\t\t\t}\n\n\t\t\tthis.renderChildren = function(ctx) {\n\t\t\t\tvar element = this.getDefinition();\n\t\t\t\tif (element != null) {\n\t\t\t\t\t// temporarily detach from parent and render\n\t\t\t\t\tvar oldParent = element.parent;\n\t\t\t\t\telement.parent = null;\n\t\t\t\t\telement.render(ctx);\n\t\t\t\t\telement.parent = oldParent;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tsvg.Element.use.prototype = new svg.Element.RenderedElementBase;\n\n\t\t// mask element\n\t\tsvg.Element.mask = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function(ctx, element) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar x = this.attribute('x').toPixels('x');\n\t\t\t\tvar y = this.attribute('y').toPixels('y');\n\t\t\t\tvar width = this.attribute('width').toPixels('x');\n\t\t\t\tvar height = this.attribute('height').toPixels('y');\n\n\t\t\t\tif (width == 0 && height == 0) {\n\t\t\t\t\tvar bb = new svg.BoundingBox();\n\t\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\t\tbb.addBoundingBox(this.children[i].getBoundingBox());\n\t\t\t\t\t}\n\t\t\t\t\tvar x = Math.floor(bb.x1);\n\t\t\t\t\tvar y = Math.floor(bb.y1);\n\t\t\t\t\tvar width = Math.floor(bb.width());\n\t\t\t\t\tvar\theight = Math.floor(bb.height());\n\t\t\t\t}\n\n\t\t\t\t// temporarily remove mask to avoid recursion\n\t\t\t\tvar mask = element.attribute('mask').value;\n\t\t\t\telement.attribute('mask').value = '';\n\n\t\t\t\t\tvar cMask = document.createElement('canvas');\n\t\t\t\t\tcMask.width = x + width;\n\t\t\t\t\tcMask.height = y + height;\n\t\t\t\t\tvar maskCtx = cMask.getContext('2d');\n\t\t\t\t\tthis.renderChildren(maskCtx);\n\n\t\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\t\tc.width = x + width;\n\t\t\t\t\tc.height = y + height;\n\t\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\t\telement.render(tempCtx);\n\t\t\t\t\ttempCtx.globalCompositeOperation = 'destination-in';\n\t\t\t\t\ttempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');\n\t\t\t\t\ttempCtx.fillRect(0, 0, x + width, y + height);\n\n\t\t\t\t\tctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');\n\t\t\t\t\tctx.fillRect(0, 0, x + width, y + height);\n\n\t\t\t\t// reassign mask\n\t\t\t\telement.attribute('mask').value = mask;\n\t\t\t}\n\n\t\t\tthis.render = function(ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.mask.prototype = new svg.Element.ElementBase;\n\n\t\t// clip element\n\t\tsvg.Element.clipPath = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function(ctx) {\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tvar child = this.children[i];\n\t\t\t\t\tif (typeof(child.path) != 'undefined') {\n\t\t\t\t\t\tvar transform = null;\n\t\t\t\t\t\tif (child.attribute('transform').hasValue()) {\n\t\t\t\t\t\t\ttransform = new svg.Transform(child.attribute('transform').value);\n\t\t\t\t\t\t\ttransform.apply(ctx);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tchild.path(ctx);\n\t\t\t\t\t\tctx.clip();\n\t\t\t\t\t\tif (transform) { transform.unapply(ctx); }\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.render = function(ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.clipPath.prototype = new svg.Element.ElementBase;\n\n\t\t// filters\n\t\tsvg.Element.filter = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function(ctx, element) {\n\t\t\t\t// render as temp svg\n\t\t\t\tvar bb = element.getBoundingBox();\n\t\t\t\tvar x = Math.floor(bb.x1);\n\t\t\t\tvar y = Math.floor(bb.y1);\n\t\t\t\tvar width = Math.floor(bb.width());\n\t\t\t\tvar\theight = Math.floor(bb.height());\n\n\t\t\t\t// temporarily remove filter to avoid recursion\n\t\t\t\tvar filter = element.style('filter').value;\n\t\t\t\telement.style('filter').value = '';\n\n\t\t\t\tvar px = 0, py = 0;\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tvar efd = this.children[i].extraFilterDistance || 0;\n\t\t\t\t\tpx = Math.max(px, efd);\n\t\t\t\t\tpy = Math.max(py, efd);\n\t\t\t\t}\n\n\t\t\t\tvar c = document.createElement('canvas');\n\t\t\t\tc.width = width + 2*px;\n\t\t\t\tc.height = height + 2*py;\n\t\t\t\tvar tempCtx = c.getContext('2d');\n\t\t\t\ttempCtx.translate(-x + px, -y + py);\n\t\t\t\telement.render(tempCtx);\n\n\t\t\t\t// apply filters\n\t\t\t\tfor (var i=0; i<this.children.length; i++) {\n\t\t\t\t\tthis.children[i].apply(tempCtx, 0, 0, width + 2*px, height + 2*py);\n\t\t\t\t}\n\n\t\t\t\t// render on me\n\t\t\t\tctx.drawImage(c, 0, 0, width + 2*px, height + 2*py, x - px, y - py, width + 2*px, height + 2*py);\n\n\t\t\t\t// reassign filter\n\t\t\t\telement.style('filter', true).value = filter;\n\t\t\t}\n\n\t\t\tthis.render = function(ctx) {\n\t\t\t\t// NO RENDER\n\t\t\t}\n\t\t}\n\t\tsvg.Element.filter.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feMorphology = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\n\t\t\t\t// TODO: implement\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feMorphology.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feColorMatrix = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tfunction imGet(img, x, y, width, height, rgba) {\n\t\t\t\treturn img[y*width*4 + x*4 + rgba];\n\t\t\t}\n\n\t\t\tfunction imSet(img, x, y, width, height, rgba, val) {\n\t\t\t\timg[y*width*4 + x*4 + rgba] = val;\n\t\t\t}\n\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\n\t\t\t\t// only supporting grayscale for now per Issue 195, need to extend to all matrix\n\t\t\t\t// assuming x==0 && y==0 for now\n\t\t\t\tvar srcData = ctx.getImageData(0, 0, width, height);\n\t\t\t\tfor (var y = 0; y < height; y++) {\n\t\t\t\t\tfor (var x = 0; x < width; x++) {\n\t\t\t\t\t\tvar r = imGet(srcData.data, x, y, width, height, 0);\n\t\t\t\t\t\tvar g = imGet(srcData.data, x, y, width, height, 1);\n\t\t\t\t\t\tvar b = imGet(srcData.data, x, y, width, height, 2);\n\t\t\t\t\t\tvar gray = (r + g + b) / 3;\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 0, gray);\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 1, gray);\n\t\t\t\t\t\timSet(srcData.data, x, y, width, height, 2, gray);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tctx.clearRect(0, 0, width, height);\n\t\t\t\tctx.putImageData(srcData, 0, 0);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feColorMatrix.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.feGaussianBlur = function(node) {\n\t\t\tthis.base = svg.Element.ElementBase;\n\t\t\tthis.base(node);\n\n\t\t\tthis.blurRadius = Math.floor(this.attribute('stdDeviation').numValue());\n\t\t\tthis.extraFilterDistance = this.blurRadius;\n\n\t\t\tthis.apply = function(ctx, x, y, width, height) {\n\t\t\t\tif (typeof(stackBlurCanvasRGBA) == 'undefined') {\n\t\t\t\t\tif (typeof(console) != 'undefined') { console.log('ERROR: StackBlur.js must be included for blur to work'); }\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// StackBlur requires canvas be on document\n\t\t\t\tctx.canvas.id = svg.UniqueId();\n\t\t\t\tctx.canvas.style.display = 'none';\n\t\t\t\tdocument.body.appendChild(ctx.canvas);\n\t\t\t\tstackBlurCanvasRGBA(ctx.canvas.id, x, y, width, height, this.blurRadius);\n\t\t\t\tdocument.body.removeChild(ctx.canvas);\n\t\t\t}\n\t\t}\n\t\tsvg.Element.feGaussianBlur.prototype = new svg.Element.ElementBase;\n\n\t\t// title element, do nothing\n\t\tsvg.Element.title = function(node) {\n\t\t}\n\t\tsvg.Element.title.prototype = new svg.Element.ElementBase;\n\n\t\t// desc element, do nothing\n\t\tsvg.Element.desc = function(node) {\n\t\t}\n\t\tsvg.Element.desc.prototype = new svg.Element.ElementBase;\n\n\t\tsvg.Element.MISSING = function(node) {\n\t\t\tif (typeof(console) != 'undefined') { console.log('ERROR: Element \\'' + node.nodeName + '\\' not yet implemented.'); }\n\t\t}\n\t\tsvg.Element.MISSING.prototype = new svg.Element.ElementBase;\n\n\t\t// element factory\n\t\tsvg.CreateElement = function(node) {\n\t\t\tvar className = node.nodeName.replace(/^[^:]+:/,''); // remove namespace\n\t\t\tclassName = className.replace(/\\-/g,''); // remove dashes\n\t\t\tvar e = null;\n\t\t\tif (typeof(svg.Element[className]) != 'undefined') {\n\t\t\t\te = new svg.Element[className](node);\n\t\t\t}\n\t\t\telse {\n\t\t\t\te = new svg.Element.MISSING(node);\n\t\t\t}\n\n\t\t\te.type = node.nodeName;\n\t\t\treturn e;\n\t\t}\n\n\t\t// load from url\n\t\tsvg.load = function(ctx, url) {\n\t\t\tsvg.loadXml(ctx, svg.ajax(url));\n\t\t}\n\n\t\t// load from xml\n\t\tsvg.loadXml = function(ctx, xml) {\n\t\t\tsvg.loadXmlDoc(ctx, svg.parseXml(xml));\n\t\t}\n\n\t\tsvg.loadXmlDoc = function(ctx, dom) {\n\t\t\tsvg.init(ctx);\n\n\t\t\tvar mapXY = function(p) {\n\t\t\t\tvar e = ctx.canvas;\n\t\t\t\twhile (e) {\n\t\t\t\t\tp.x -= e.offsetLeft;\n\t\t\t\t\tp.y -= e.offsetTop;\n\t\t\t\t\te = e.offsetParent;\n\t\t\t\t}\n\t\t\t\tif (window.scrollX) p.x += window.scrollX;\n\t\t\t\tif (window.scrollY) p.y += window.scrollY;\n\t\t\t\treturn p;\n\t\t\t}\n\n\t\t\t// bind mouse\n\t\t\tif (svg.opts['ignoreMouse'] != true) {\n\t\t\t\tctx.canvas.onclick = function(e) {\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\n\t\t\t\t\tsvg.Mouse.onclick(p.x, p.y);\n\t\t\t\t};\n\t\t\t\tctx.canvas.onmousemove = function(e) {\n\t\t\t\t\tvar p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));\n\t\t\t\t\tsvg.Mouse.onmousemove(p.x, p.y);\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tvar e = svg.CreateElement(dom.documentElement);\n\t\t\te.root = true;\n\n\t\t\t// render loop\n\t\t\tvar isFirstRender = true;\n\t\t\tvar draw = function() {\n\t\t\t\tsvg.ViewPort.Clear();\n\t\t\t\tif (ctx.canvas.parentNode) svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);\n\n\t\t\t\tif (svg.opts['ignoreDimensions'] != true) {\n\t\t\t\t\t// set canvas size\n\t\t\t\t\tif (e.style('width').hasValue()) {\n\t\t\t\t\t\tctx.canvas.width = e.style('width').toPixels('x');\n\t\t\t\t\t\tctx.canvas.style.width = ctx.canvas.width + 'px';\n\t\t\t\t\t}\n\t\t\t\t\tif (e.style('height').hasValue()) {\n\t\t\t\t\t\tctx.canvas.height = e.style('height').toPixels('y');\n\t\t\t\t\t\tctx.canvas.style.height = ctx.canvas.height + 'px';\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar cWidth = ctx.canvas.clientWidth || ctx.canvas.width;\n\t\t\t\tvar cHeight = ctx.canvas.clientHeight || ctx.canvas.height;\n\t\t\t\tif (svg.opts['ignoreDimensions'] == true && e.style('width').hasValue() && e.style('height').hasValue()) {\n\t\t\t\t\tcWidth = e.style('width').toPixels('x');\n\t\t\t\t\tcHeight = e.style('height').toPixels('y');\n\t\t\t\t}\n\t\t\t\tsvg.ViewPort.SetCurrent(cWidth, cHeight);\n\n\t\t\t\tif (svg.opts['offsetX'] != null) e.attribute('x', true).value = svg.opts['offsetX'];\n\t\t\t\tif (svg.opts['offsetY'] != null) e.attribute('y', true).value = svg.opts['offsetY'];\n\t\t\t\tif (svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null) {\n\t\t\t\t\tvar xRatio = 1, yRatio = 1, viewBox = svg.ToNumberArray(e.attribute('viewBox').value);\n\t\t\t\t\tif (e.attribute('width').hasValue()) xRatio = e.attribute('width').toPixels('x') / svg.opts['scaleWidth'];\n\t\t\t\t\telse if (!isNaN(viewBox[2])) xRatio = viewBox[2] / svg.opts['scaleWidth'];\n\t\t\t\t\tif (e.attribute('height').hasValue()) yRatio = e.attribute('height').toPixels('y') / svg.opts['scaleHeight'];\n\t\t\t\t\telse if (!isNaN(viewBox[3])) yRatio = viewBox[3] / svg.opts['scaleHeight'];\n\n\t\t\t\t\te.attribute('width', true).value = svg.opts['scaleWidth'];\n\t\t\t\t\te.attribute('height', true).value = svg.opts['scaleHeight'];\n\t\t\t\t\te.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);\n\t\t\t\t\te.attribute('preserveAspectRatio', true).value = 'none';\n\t\t\t\t}\n\n\t\t\t\t// clear and render\n\t\t\t\tif (svg.opts['ignoreClear'] != true) {\n\t\t\t\t\tctx.clearRect(0, 0, cWidth, cHeight);\n\t\t\t\t}\n\t\t\t\te.render(ctx);\n\t\t\t\tif (isFirstRender) {\n\t\t\t\t\tisFirstRender = false;\n\t\t\t\t\tif (typeof(svg.opts['renderCallback']) == 'function') svg.opts['renderCallback'](dom);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tvar waitingForImages = true;\n\t\t\tif (svg.ImagesLoaded()) {\n\t\t\t\twaitingForImages = false;\n\t\t\t\tdraw();\n\t\t\t}\n\t\t\tsvg.intervalID = setInterval(function() {\n\t\t\t\tvar needUpdate = false;\n\n\t\t\t\tif (waitingForImages && svg.ImagesLoaded()) {\n\t\t\t\t\twaitingForImages = false;\n\t\t\t\t\tneedUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// need update from mouse events?\n\t\t\t\tif (svg.opts['ignoreMouse'] != true) {\n\t\t\t\t\tneedUpdate = needUpdate | svg.Mouse.hasEvents();\n\t\t\t\t}\n\n\t\t\t\t// need update from animations?\n\t\t\t\tif (svg.opts['ignoreAnimation'] != true) {\n\t\t\t\t\tfor (var i=0; i<svg.Animations.length; i++) {\n\t\t\t\t\t\tneedUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// need update from redraw?\n\t\t\t\tif (typeof(svg.opts['forceRedraw']) == 'function') {\n\t\t\t\t\tif (svg.opts['forceRedraw']() == true) needUpdate = true;\n\t\t\t\t}\n\n\t\t\t\t// render if needed\n\t\t\t\tif (needUpdate) {\n\t\t\t\t\tdraw();\n\t\t\t\t\tsvg.Mouse.runEvents(); // run and clear our events\n\t\t\t\t}\n\t\t\t}, 1000 / svg.FRAMERATE);\n\t\t}\n\n\t\tsvg.stop = function() {\n\t\t\tif (svg.intervalID) {\n\t\t\t\tclearInterval(svg.intervalID);\n\t\t\t}\n\t\t}\n\n\t\tsvg.Mouse = new (function() {\n\t\t\tthis.events = [];\n\t\t\tthis.hasEvents = function() { return this.events.length != 0; }\n\n\t\t\tthis.onclick = function(x, y) {\n\t\t\t\tthis.events.push({ type: 'onclick', x: x, y: y,\n\t\t\t\t\trun: function(e) { if (e.onclick) e.onclick(); }\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.onmousemove = function(x, y) {\n\t\t\t\tthis.events.push({ type: 'onmousemove', x: x, y: y,\n\t\t\t\t\trun: function(e) { if (e.onmousemove) e.onmousemove(); }\n\t\t\t\t});\n\t\t\t}\n\n\t\t\tthis.eventElements = [];\n\n\t\t\tthis.checkPath = function(element, ctx) {\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y)) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.checkBoundingBox = function(element, bb) {\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tif (bb.isPointInBox(e.x, e.y)) this.eventElements[i] = element;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.runEvents = function() {\n\t\t\t\tsvg.ctx.canvas.style.cursor = '';\n\n\t\t\t\tfor (var i=0; i<this.events.length; i++) {\n\t\t\t\t\tvar e = this.events[i];\n\t\t\t\t\tvar element = this.eventElements[i];\n\t\t\t\t\twhile (element) {\n\t\t\t\t\t\te.run(element);\n\t\t\t\t\t\telement = element.parent;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// done running, clear\n\t\t\t\tthis.events = [];\n\t\t\t\tthis.eventElements = [];\n\t\t\t}\n\t\t});\n\n\t\treturn svg;\n\t}\n})();\n\nif (typeof(CanvasRenderingContext2D) != 'undefined') {\n\tCanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh) {\n\t\tcanvg(this.canvas, s, {\n\t\t\tignoreMouse: true,\n\t\t\tignoreAnimation: true,\n\t\t\tignoreDimensions: true,\n\t\t\tignoreClear: true,\n\t\t\toffsetX: dx,\n\t\t\toffsetY: dy,\n\t\t\tscaleWidth: dw,\n\t\t\tscaleHeight: dh\n\t\t});\n\t}\n}\n","/* FileSaver.js\n * A saveAs() FileSaver implementation.\n * 2012-12-11\n * \n * By Eli Grey, http://eligrey.com\n * License: X11/MIT\n *   See LICENSE.md\n */\n\n/*global self */\n/*jslint bitwise: true, regexp: true, confusion: true, es5: true, vars: true, white: true,\n  plusplus: true */\n\n/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */\n\nvar saveAs = saveAs\n  || (navigator.msSaveOrOpenBlob && navigator.msSaveOrOpenBlob.bind(navigator))\n  || (function(view) {\n\t\"use strict\";\n\tvar\n\t\t  doc = view.document\n\t\t  // only get URL when necessary in case BlobBuilder.js hasn't overridden it yet\n\t\t, get_URL = function() {\n\t\t\treturn view.URL || view.webkitURL || view;\n\t\t}\n\t\t, URL = view.URL || view.webkitURL || view\n\t\t, save_link = doc.createElementNS(\"http://www.w3.org/1999/xhtml\", \"a\")\n\t\t, can_use_save_link = \"download\" in save_link\n\t\t, click = function(node) {\n\t\t\tvar event = doc.createEvent(\"MouseEvents\");\n\t\t\tevent.initMouseEvent(\n\t\t\t\t\"click\", true, false, view, 0, 0, 0, 0, 0\n\t\t\t\t, false, false, false, false, 0, null\n\t\t\t);\n\t\t\treturn node.dispatchEvent(event); // false if event was cancelled\n\t\t}\n\t\t, webkit_req_fs = view.webkitRequestFileSystem\n\t\t, req_fs = view.requestFileSystem || webkit_req_fs || view.mozRequestFileSystem\n\t\t, throw_outside = function (ex) {\n\t\t\t(view.setImmediate || view.setTimeout)(function() {\n\t\t\t\tthrow ex;\n\t\t\t}, 0);\n\t\t}\n\t\t, force_saveable_type = \"application/octet-stream\"\n\t\t, fs_min_size = 0\n\t\t, deletion_queue = []\n\t\t, process_deletion_queue = function() {\n\t\t\tvar i = deletion_queue.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar file = deletion_queue[i];\n\t\t\t\tif (typeof file === \"string\") { // file is an object URL\n\t\t\t\t\tURL.revokeObjectURL(file);\n\t\t\t\t} else { // file is a File\n\t\t\t\t\tfile.remove();\n\t\t\t\t}\n\t\t\t}\n\t\t\tdeletion_queue.length = 0; // clear queue\n\t\t}\n\t\t, dispatch = function(filesaver, event_types, event) {\n\t\t\tevent_types = [].concat(event_types);\n\t\t\tvar i = event_types.length;\n\t\t\twhile (i--) {\n\t\t\t\tvar listener = filesaver[\"on\" + event_types[i]];\n\t\t\t\tif (typeof listener === \"function\") {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tlistener.call(filesaver, event || filesaver);\n\t\t\t\t\t} catch (ex) {\n\t\t\t\t\t\tthrow_outside(ex);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t, FileSaver = function(blob, name) {\n\t\t\t// First try a.download, then web filesystem, then object URLs\n\t\t\tvar\n\t\t\t\t  filesaver = this\n\t\t\t\t, type = blob.type\n\t\t\t\t, blob_changed = false\n\t\t\t\t, object_url\n\t\t\t\t, target_view\n\t\t\t\t, get_object_url = function() {\n\t\t\t\t\tvar object_url = get_URL().createObjectURL(blob);\n\t\t\t\t\tdeletion_queue.push(object_url);\n\t\t\t\t\treturn object_url;\n\t\t\t\t}\n\t\t\t\t, dispatch_all = function() {\n\t\t\t\t\tdispatch(filesaver, \"writestart progress write writeend\".split(\" \"));\n\t\t\t\t}\n\t\t\t\t// on any filesys errors revert to saving with object URLs\n\t\t\t\t, fs_error = function() {\n\t\t\t\t\t// don't create more object URLs than needed\n\t\t\t\t\tif (blob_changed || !object_url) {\n\t\t\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\t\t}\n\t\t\t\t\ttarget_view.location.href = object_url;\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t}\n\t\t\t\t, abortable = function(func) {\n\t\t\t\t\treturn function() {\n\t\t\t\t\t\tif (filesaver.readyState !== filesaver.DONE) {\n\t\t\t\t\t\t\treturn func.apply(this, arguments);\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t\t, create_if_not_found = {create: true, exclusive: false}\n\t\t\t\t, slice\n\t\t\t;\n\t\t\tfilesaver.readyState = filesaver.INIT;\n\t\t\tif (!name) {\n\t\t\t\tname = \"download\";\n\t\t\t}\n\t\t\tif (can_use_save_link) {\n\t\t\t\tobject_url = get_object_url(blob);\n\t\t\t\tsave_link.href = object_url;\n\t\t\t\tsave_link.download = name;\n\t\t\t\tif (click(save_link)) {\n\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\tdispatch_all();\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Object and web filesystem URLs have a problem saving in Google Chrome when\n\t\t\t// viewed in a tab, so I force save with application/octet-stream\n\t\t\t// http://code.google.com/p/chromium/issues/detail?id=91158\n\t\t\tif (view.chrome && type && type !== force_saveable_type) {\n\t\t\t\tslice = blob.slice || blob.webkitSlice;\n\t\t\t\tblob = slice.call(blob, 0, blob.size, force_saveable_type);\n\t\t\t\tblob_changed = true;\n\t\t\t}\n\t\t\t// Since I can't be sure that the guessed media type will trigger a download\n\t\t\t// in WebKit, I append .download to the filename.\n\t\t\t// https://bugs.webkit.org/show_bug.cgi?id=65440\n\t\t\tif (webkit_req_fs && name !== \"download\") {\n\t\t\t\tname += \".download\";\n\t\t\t}\n\t\t\tif (type === force_saveable_type || webkit_req_fs) {\n\t\t\t\ttarget_view = view;\n\t\t\t} else {\n\t\t\t\ttarget_view = view.open();\n\t\t\t}\n\t\t\tif (!req_fs) {\n\t\t\t\tfs_error();\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfs_min_size += blob.size;\n\t\t\treq_fs(view.TEMPORARY, fs_min_size, abortable(function(fs) {\n\t\t\t\tfs.root.getDirectory(\"saved\", create_if_not_found, abortable(function(dir) {\n\t\t\t\t\tvar save = function() {\n\t\t\t\t\t\tdir.getFile(name, create_if_not_found, abortable(function(file) {\n\t\t\t\t\t\t\tfile.createWriter(abortable(function(writer) {\n\t\t\t\t\t\t\t\twriter.onwriteend = function(event) {\n\t\t\t\t\t\t\t\t\ttarget_view.location.href = file.toURL();\n\t\t\t\t\t\t\t\t\tdeletion_queue.push(file);\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t\tdispatch(filesaver, \"writeend\", event);\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\twriter.onerror = function() {\n\t\t\t\t\t\t\t\t\tvar error = writer.error;\n\t\t\t\t\t\t\t\t\tif (error.code !== error.ABORT_ERR) {\n\t\t\t\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\t\"writestart progress write abort\".split(\" \").forEach(function(event) {\n\t\t\t\t\t\t\t\t\twriter[\"on\" + event] = filesaver[\"on\" + event];\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\twriter.write(blob);\n\t\t\t\t\t\t\t\tfilesaver.abort = function() {\n\t\t\t\t\t\t\t\t\twriter.abort();\n\t\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.DONE;\n\t\t\t\t\t\t\t\t};\n\t\t\t\t\t\t\t\tfilesaver.readyState = filesaver.WRITING;\n\t\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t\t}), fs_error);\n\t\t\t\t\t};\n\t\t\t\t\tdir.getFile(name, {create: false}, abortable(function(file) {\n\t\t\t\t\t\t// delete file if it already exists\n\t\t\t\t\t\tfile.remove();\n\t\t\t\t\t\tsave();\n\t\t\t\t\t}), abortable(function(ex) {\n\t\t\t\t\t\tif (ex.code === ex.NOT_FOUND_ERR) {\n\t\t\t\t\t\t\tsave();\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tfs_error();\n\t\t\t\t\t\t}\n\t\t\t\t\t}));\n\t\t\t\t}), fs_error);\n\t\t\t}), fs_error);\n\t\t}\n\t\t, FS_proto = FileSaver.prototype\n\t\t, saveAs = function(blob, name) {\n\t\t\treturn new FileSaver(blob, name);\n\t\t}\n\t;\n\tFS_proto.abort = function() {\n\t\tvar filesaver = this;\n\t\tfilesaver.readyState = filesaver.DONE;\n\t\tdispatch(filesaver, \"abort\");\n\t};\n\tFS_proto.readyState = FS_proto.INIT = 0;\n\tFS_proto.WRITING = 1;\n\tFS_proto.DONE = 2;\n\t\n\tFS_proto.error =\n\tFS_proto.onwritestart =\n\tFS_proto.onprogress =\n\tFS_proto.onwrite =\n\tFS_proto.onabort =\n\tFS_proto.onerror =\n\tFS_proto.onwriteend =\n\t\tnull;\n\t\n\tview.addEventListener(\"unload\", process_deletion_queue, false);\n\treturn saveAs;\n}(self));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = (module) => {\n\tvar getter = module && module.__esModule ?\n\t\t() => (module['default']) :\n\t\t() => (module);\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable */\nimport 'script-loader!./dependencies/d3.js';\nimport 'script-loader!./dependencies/uvcharts.js';\nimport './dependencies/filesaver.js';\nimport './dependencies/canvg.js';\nimport './dependencies/canvas-toblob.js';\n"],"names":[],"sourceRoot":""}